{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport { findOptimalInsertionRange as engineFindOptimalInsertionRange } from '@ckeditor/ckeditor5-engine/src/model/utils/findoptimalinsertionrange';\nimport HighlightStack from './highlightstack';\nimport { getTypeAroundFakeCaretPosition } from './widgettypearound/utils';\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport dragHandleIcon from '../theme/icons/drag-handle.svg';\n\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\nexport function isWidget(node) {\n  if (!node.is('element')) {\n    return false;\n  }\n  return !!node.getCustomProperty('widget');\n}\n\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"false\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandle=false] If `true`, the widget will have a selection handle added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\nexport function toWidget(element, writer) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!element.is('containerElement')) {\n    /**\n     * The element passed to `toWidget()` must be a {@link module:engine/view/containerelement~ContainerElement}\n     * instance.\n     *\n     * @error widget-to-widget-wrong-element-type\n     * @param {String} element The view element passed to `toWidget()`.\n     */\n    throw new CKEditorError('widget-to-widget-wrong-element-type', null, {\n      element\n    });\n  }\n  writer.setAttribute('contenteditable', 'false', element);\n  writer.addClass(WIDGET_CLASS_NAME, element);\n  writer.setCustomProperty('widget', true, element);\n  element.getFillerOffset = getFillerOffset;\n  if (options.label) {\n    setLabel(element, options.label, writer);\n  }\n  if (options.hasSelectionHandle) {\n    addSelectionHandle(element, writer);\n  }\n  setHighlightHandling(element, writer);\n  return element;\n}\n\n// Default handler for adding a highlight on a widget.\n// It adds CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction addHighlight(element, descriptor, writer) {\n  if (descriptor.classes) {\n    writer.addClass(toArray(descriptor.classes), element);\n  }\n  if (descriptor.attributes) {\n    for (const key in descriptor.attributes) {\n      writer.setAttribute(key, descriptor.attributes[key], element);\n    }\n  }\n}\n\n// Default handler for removing a highlight from a widget.\n// It removes CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction removeHighlight(element, descriptor, writer) {\n  if (descriptor.classes) {\n    writer.removeClass(toArray(descriptor.classes), element);\n  }\n  if (descriptor.attributes) {\n    for (const key in descriptor.attributes) {\n      writer.removeAttribute(key, element);\n    }\n  }\n}\n\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} [add]\n * @param {Function} [remove]\n */\nexport function setHighlightHandling(element, writer) {\n  let add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : addHighlight;\n  let remove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : removeHighlight;\n  const stack = new HighlightStack();\n  stack.on('change:top', (evt, data) => {\n    if (data.oldDescriptor) {\n      remove(element, data.oldDescriptor, data.writer);\n    }\n    if (data.newDescriptor) {\n      add(element, data.newDescriptor, data.writer);\n    }\n  });\n  writer.setCustomProperty('addHighlight', (element, descriptor, writer) => stack.add(descriptor, writer), element);\n  writer.setCustomProperty('removeHighlight', (element, id, writer) => stack.remove(id, writer), element);\n}\n\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\nexport function setLabel(element, labelOrCreator, writer) {\n  writer.setCustomProperty('widgetLabel', labelOrCreator, element);\n}\n\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\nexport function getLabel(element) {\n  const labelCreator = element.getCustomProperty('widgetLabel');\n  if (!labelCreator) {\n    return '';\n  }\n  return typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n * * implements the {@link ~setHighlightHandling view highlight on widget's editable}.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `editingDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer, { label: 'label for editable' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options] Additional options.\n * @param {String} [options.label] Editable's label used by assistive technologies (e.g. screen readers).\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\nexport function toWidgetEditable(editable, writer) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable);\n  writer.setAttribute('role', 'textbox', editable);\n  if (options.label) {\n    writer.setAttribute('aria-label', options.label, editable);\n  }\n\n  // Set initial contenteditable value.\n  writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable);\n\n  // Bind the contenteditable property to element#isReadOnly.\n  editable.on('change:isReadOnly', (evt, property, is) => {\n    writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);\n  });\n  editable.on('change:isFocused', (evt, property, is) => {\n    if (is) {\n      writer.addClass('ck-editor__nested-editable_focused', editable);\n    } else {\n      writer.removeClass('ck-editor__nested-editable_focused', editable);\n    }\n  });\n  setHighlightHandling(editable, writer);\n  return editable;\n}\n\n/**\n * Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the collapsed range after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n * by the inserted widget block.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/range~Range} The optimal range.\n */\nexport function findOptimalInsertionRange(selection, model) {\n  const selectedElement = selection.getSelectedElement();\n  if (selectedElement) {\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection);\n\n    // If the WidgetTypeAround \"fake caret\" is displayed, use its position for the insertion\n    // to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).\n    if (typeAroundFakeCaretPosition) {\n      return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));\n    }\n  }\n  return engineFindOptimalInsertionRange(selection, model);\n}\n\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\nexport function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {\n  return (evt, data) => {\n    const {\n      mapper,\n      viewPosition\n    } = data;\n    const viewParent = mapper.findMappedViewAncestor(viewPosition);\n    if (!viewElementMatcher(viewParent)) {\n      return;\n    }\n    const modelParent = mapper.toModelElement(viewParent);\n    data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');\n  };\n}\n\n// Default filler offset function applied to all widget elements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n  return null;\n}\n\n// Adds a drag handle to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction addSelectionHandle(widgetElement, writer) {\n  const selectionHandle = writer.createUIElement('div', {\n    class: 'ck ck-widget__selection-handle'\n  }, function (domDocument) {\n    const domElement = this.toDomElement(domDocument);\n\n    // Use the IconView from the ui library.\n    const icon = new IconView();\n    icon.set('content', dragHandleIcon);\n\n    // Render the icon view right away to append its #element to the selectionHandle DOM element.\n    icon.render();\n    domElement.appendChild(icon.element);\n    return domElement;\n  });\n\n  // Append the selection handle into the widget wrapper.\n  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);\n  writer.addClass(['ck-widget_with-selection-handle'], widgetElement);\n}","map":{"version":3,"names":["CKEditorError","toArray","findOptimalInsertionRange","engineFindOptimalInsertionRange","HighlightStack","getTypeAroundFakeCaretPosition","IconView","dragHandleIcon","WIDGET_CLASS_NAME","WIDGET_SELECTED_CLASS_NAME","isWidget","node","is","getCustomProperty","toWidget","element","writer","options","setAttribute","addClass","setCustomProperty","getFillerOffset","label","setLabel","hasSelectionHandle","addSelectionHandle","setHighlightHandling","addHighlight","descriptor","classes","attributes","key","removeHighlight","removeClass","removeAttribute","add","remove","stack","on","evt","data","oldDescriptor","newDescriptor","id","labelOrCreator","getLabel","labelCreator","toWidgetEditable","editable","isReadOnly","property","selection","model","selectedElement","getSelectedElement","typeAroundFakeCaretPosition","createRange","createPositionAt","viewToModelPositionOutsideModelElement","viewElementMatcher","mapper","viewPosition","viewParent","findMappedViewAncestor","modelParent","toModelElement","modelPosition","isAtStart","widgetElement","selectionHandle","createUIElement","class","domDocument","domElement","toDomElement","icon","set","render","appendChild","insert"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-widget/src/utils.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport {\n\tfindOptimalInsertionRange as engineFindOptimalInsertionRange\n} from '@ckeditor/ckeditor5-engine/src/model/utils/findoptimalinsertionrange';\n\nimport HighlightStack from './highlightstack';\nimport { getTypeAroundFakeCaretPosition } from './widgettypearound/utils';\n\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport dragHandleIcon from '../theme/icons/drag-handle.svg';\n\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\nexport function isWidget( node ) {\n\tif ( !node.is( 'element' ) ) {\n\t\treturn false;\n\t}\n\n\treturn !!node.getCustomProperty( 'widget' );\n}\n\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"false\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandle=false] If `true`, the widget will have a selection handle added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\nexport function toWidget( element, writer, options = {} ) {\n\tif ( !element.is( 'containerElement' ) ) {\n\t\t/**\n\t\t * The element passed to `toWidget()` must be a {@link module:engine/view/containerelement~ContainerElement}\n\t\t * instance.\n\t\t *\n\t\t * @error widget-to-widget-wrong-element-type\n\t\t * @param {String} element The view element passed to `toWidget()`.\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'widget-to-widget-wrong-element-type',\n\t\t\tnull,\n\t\t\t{ element }\n\t\t);\n\t}\n\n\twriter.setAttribute( 'contenteditable', 'false', element );\n\n\twriter.addClass( WIDGET_CLASS_NAME, element );\n\twriter.setCustomProperty( 'widget', true, element );\n\telement.getFillerOffset = getFillerOffset;\n\n\tif ( options.label ) {\n\t\tsetLabel( element, options.label, writer );\n\t}\n\n\tif ( options.hasSelectionHandle ) {\n\t\taddSelectionHandle( element, writer );\n\t}\n\n\tsetHighlightHandling( element, writer );\n\n\treturn element;\n}\n\n// Default handler for adding a highlight on a widget.\n// It adds CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction addHighlight( element, descriptor, writer ) {\n\tif ( descriptor.classes ) {\n\t\twriter.addClass( toArray( descriptor.classes ), element );\n\t}\n\n\tif ( descriptor.attributes ) {\n\t\tfor ( const key in descriptor.attributes ) {\n\t\t\twriter.setAttribute( key, descriptor.attributes[ key ], element );\n\t\t}\n\t}\n}\n\n// Default handler for removing a highlight from a widget.\n// It removes CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction removeHighlight( element, descriptor, writer ) {\n\tif ( descriptor.classes ) {\n\t\twriter.removeClass( toArray( descriptor.classes ), element );\n\t}\n\n\tif ( descriptor.attributes ) {\n\t\tfor ( const key in descriptor.attributes ) {\n\t\t\twriter.removeAttribute( key, element );\n\t\t}\n\t}\n}\n\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} [add]\n * @param {Function} [remove]\n */\nexport function setHighlightHandling( element, writer, add = addHighlight, remove = removeHighlight ) {\n\tconst stack = new HighlightStack();\n\n\tstack.on( 'change:top', ( evt, data ) => {\n\t\tif ( data.oldDescriptor ) {\n\t\t\tremove( element, data.oldDescriptor, data.writer );\n\t\t}\n\n\t\tif ( data.newDescriptor ) {\n\t\t\tadd( element, data.newDescriptor, data.writer );\n\t\t}\n\t} );\n\n\twriter.setCustomProperty( 'addHighlight', ( element, descriptor, writer ) => stack.add( descriptor, writer ), element );\n\twriter.setCustomProperty( 'removeHighlight', ( element, id, writer ) => stack.remove( id, writer ), element );\n}\n\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\nexport function setLabel( element, labelOrCreator, writer ) {\n\twriter.setCustomProperty( 'widgetLabel', labelOrCreator, element );\n}\n\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\nexport function getLabel( element ) {\n\tconst labelCreator = element.getCustomProperty( 'widgetLabel' );\n\n\tif ( !labelCreator ) {\n\t\treturn '';\n\t}\n\n\treturn typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n * * implements the {@link ~setHighlightHandling view highlight on widget's editable}.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `editingDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer, { label: 'label for editable' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options] Additional options.\n * @param {String} [options.label] Editable's label used by assistive technologies (e.g. screen readers).\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\nexport function toWidgetEditable( editable, writer, options = {} ) {\n\twriter.addClass( [ 'ck-editor__editable', 'ck-editor__nested-editable' ], editable );\n\n\twriter.setAttribute( 'role', 'textbox', editable );\n\n\tif ( options.label ) {\n\t\twriter.setAttribute( 'aria-label', options.label, editable );\n\t}\n\n\t// Set initial contenteditable value.\n\twriter.setAttribute( 'contenteditable', editable.isReadOnly ? 'false' : 'true', editable );\n\n\t// Bind the contenteditable property to element#isReadOnly.\n\teditable.on( 'change:isReadOnly', ( evt, property, is ) => {\n\t\twriter.setAttribute( 'contenteditable', is ? 'false' : 'true', editable );\n\t} );\n\n\teditable.on( 'change:isFocused', ( evt, property, is ) => {\n\t\tif ( is ) {\n\t\t\twriter.addClass( 'ck-editor__nested-editable_focused', editable );\n\t\t} else {\n\t\t\twriter.removeClass( 'ck-editor__nested-editable_focused', editable );\n\t\t}\n\t} );\n\n\tsetHighlightHandling( editable, writer );\n\n\treturn editable;\n}\n\n/**\n * Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the collapsed range after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n * by the inserted widget block.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/range~Range} The optimal range.\n */\nexport function findOptimalInsertionRange( selection, model ) {\n\tconst selectedElement = selection.getSelectedElement();\n\n\tif ( selectedElement ) {\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( selection );\n\n\t\t// If the WidgetTypeAround \"fake caret\" is displayed, use its position for the insertion\n\t\t// to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).\n\t\tif ( typeAroundFakeCaretPosition ) {\n\t\t\treturn model.createRange( model.createPositionAt( selectedElement, typeAroundFakeCaretPosition ) );\n\t\t}\n\t}\n\n\treturn engineFindOptimalInsertionRange( selection, model );\n}\n\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\nexport function viewToModelPositionOutsideModelElement( model, viewElementMatcher ) {\n\treturn ( evt, data ) => {\n\t\tconst { mapper, viewPosition } = data;\n\n\t\tconst viewParent = mapper.findMappedViewAncestor( viewPosition );\n\n\t\tif ( !viewElementMatcher( viewParent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelParent = mapper.toModelElement( viewParent );\n\n\t\tdata.modelPosition = model.createPositionAt( modelParent, viewPosition.isAtStart ? 'before' : 'after' );\n\t};\n}\n\n// Default filler offset function applied to all widget elements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n\treturn null;\n}\n\n// Adds a drag handle to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction addSelectionHandle( widgetElement, writer ) {\n\tconst selectionHandle = writer.createUIElement( 'div', { class: 'ck ck-widget__selection-handle' }, function( domDocument ) {\n\t\tconst domElement = this.toDomElement( domDocument );\n\n\t\t// Use the IconView from the ui library.\n\t\tconst icon = new IconView();\n\t\ticon.set( 'content', dragHandleIcon );\n\n\t\t// Render the icon view right away to append its #element to the selectionHandle DOM element.\n\t\ticon.render();\n\n\t\tdomElement.appendChild( icon.element );\n\n\t\treturn domElement;\n\t} );\n\n\t// Append the selection handle into the widget wrapper.\n\twriter.insert( writer.createPositionAt( widgetElement, 0 ), selectionHandle );\n\twriter.addClass( [ 'ck-widget_with-selection-handle' ], widgetElement );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}