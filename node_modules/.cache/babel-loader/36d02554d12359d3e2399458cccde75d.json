{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/view/selection\n */\nimport TypeCheckable from './typecheckable';\nimport Range from './range';\nimport Position from './position';\nimport Node from './node';\nimport DocumentSelection from './documentselection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * Class representing an arbirtary selection in the view.\n * See also {@link module:engine/view/documentselection~DocumentSelection}.\n *\n * New selection instances can be created via the constructor or one these methods:\n *\n * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n *\n * A selection can consist of {@link module:engine/view/range~Range ranges} that can be set by using\n * the {@link module:engine/view/selection~Selection#setTo `Selection#setTo()`} method.\n */\nexport default class Selection extends EmitterMixin(TypeCheckable) {\n  /**\n   * Creates new selection instance.\n   *\n   * **Note**: The selection constructor is available as a factory method:\n   *\n   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n   *\n   * \t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the document selection.\n   *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n   *\n   * \t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} [selectable=null]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n  constructor() {\n    super();\n    /**\n     * Stores all ranges that are selected.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/range~Range>}\n     */\n    this._ranges = [];\n    /**\n     * Specifies whether the last added range was added as a backward or forward range.\n     *\n     * @protected\n     * @member {Boolean}\n     */\n    this._lastRangeBackward = false;\n    /**\n     * Specifies whether selection instance is fake.\n     *\n     * @private\n     * @member {Boolean}\n     */\n    this._isFake = false;\n    /**\n     * Fake selection's label.\n     *\n     * @private\n     * @member {String}\n     */\n    this._fakeSelectionLabel = '';\n    if (arguments.length) {\n      this.setTo(...arguments);\n    }\n  }\n  /**\n   * Returns true if selection instance is marked as `fake`.\n   *\n   * @see #setTo\n   * @type {Boolean}\n   */\n  get isFake() {\n    return this._isFake;\n  }\n  /**\n   * Returns fake selection label.\n   *\n   * @see #setTo\n   * @type {String}\n   */\n  get fakeSelectionLabel() {\n    return this._fakeSelectionLabel;\n  }\n  /**\n   * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n   * {@link #focus focus} they define the direction of selection, which is important\n   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n   * It may be a bit unintuitive when there are multiple ranges in selection.\n   *\n   * @see #focus\n   * @type {module:engine/view/position~Position}\n   */\n  get anchor() {\n    if (!this._ranges.length) {\n      return null;\n    }\n    const range = this._ranges[this._ranges.length - 1];\n    const anchor = this._lastRangeBackward ? range.end : range.start;\n    return anchor.clone();\n  }\n  /**\n   * Selection focus. Focus is a position where the selection ends.\n   *\n   * @see #anchor\n   * @type {module:engine/view/position~Position}\n   */\n  get focus() {\n    if (!this._ranges.length) {\n      return null;\n    }\n    const range = this._ranges[this._ranges.length - 1];\n    const focus = this._lastRangeBackward ? range.start : range.end;\n    return focus.clone();\n  }\n  /**\n   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n   * collapsed.\n   *\n   * @type {Boolean}\n   */\n  get isCollapsed() {\n    return this.rangeCount === 1 && this._ranges[0].isCollapsed;\n  }\n  /**\n   * Returns number of ranges in selection.\n   *\n   * @type {Number}\n   */\n  get rangeCount() {\n    return this._ranges.length;\n  }\n  /**\n   * Specifies whether the {@link #focus} precedes {@link #anchor}.\n   *\n   * @type {Boolean}\n   */\n  get isBackward() {\n    return !this.isCollapsed && this._lastRangeBackward;\n  }\n  /**\n   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n   * if the selection is not inside an editable element.\n   *\n   * @type {module:engine/view/editableelement~EditableElement|null}\n   */\n  get editableElement() {\n    if (this.anchor) {\n      return this.anchor.editableElement;\n    }\n    return null;\n  }\n  /**\n   * Returns an iterable that contains copies of all ranges added to the selection.\n   *\n   * @returns {Iterable.<module:engine/view/range~Range>}\n   */\n  *getRanges() {\n    for (const range of this._ranges) {\n      yield range.clone();\n    }\n  }\n  /**\n   * Returns copy of the first range in the selection. First range is the one which\n   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n   * position of all other ranges (not to confuse with the first range added to the selection).\n   * Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/range~Range|null}\n   */\n  getFirstRange() {\n    let first = null;\n    for (const range of this._ranges) {\n      if (!first || range.start.isBefore(first.start)) {\n        first = range;\n      }\n    }\n    return first ? first.clone() : null;\n  }\n  /**\n   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n   * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/range~Range|null}\n   */\n  getLastRange() {\n    let last = null;\n    for (const range of this._ranges) {\n      if (!last || range.end.isAfter(last.end)) {\n        last = range;\n      }\n    }\n    return last ? last.clone() : null;\n  }\n  /**\n   * Returns copy of the first position in the selection. First position is the position that\n   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n   * Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/position~Position|null}\n   */\n  getFirstPosition() {\n    const firstRange = this.getFirstRange();\n    return firstRange ? firstRange.start.clone() : null;\n  }\n  /**\n   * Returns copy of the last position in the selection. Last position is the position that\n   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n   * Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/position~Position|null}\n   */\n  getLastPosition() {\n    const lastRange = this.getLastRange();\n    return lastRange ? lastRange.end.clone() : null;\n  }\n  /**\n   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n   * same number of ranges and all ranges from one selection equal to a range from other selection.\n   *\n   * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n   * Selection to compare with.\n   * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n   */\n  isEqual(otherSelection) {\n    if (this.isFake != otherSelection.isFake) {\n      return false;\n    }\n    if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {\n      return false;\n    }\n    if (this.rangeCount != otherSelection.rangeCount) {\n      return false;\n    } else if (this.rangeCount === 0) {\n      return true;\n    }\n    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n      return false;\n    }\n    for (const thisRange of this._ranges) {\n      let found = false;\n      for (const otherRange of otherSelection._ranges) {\n        if (thisRange.isEqual(otherRange)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n   * equal to any trimmed range from other selection.\n   *\n   * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n   * Selection to compare with.\n   * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n   */\n  isSimilar(otherSelection) {\n    if (this.isBackward != otherSelection.isBackward) {\n      return false;\n    }\n    const numOfRangesA = count(this.getRanges());\n    const numOfRangesB = count(otherSelection.getRanges());\n    // If selections have different number of ranges, they cannot be similar.\n    if (numOfRangesA != numOfRangesB) {\n      return false;\n    }\n    // If both selections have no ranges, they are similar.\n    if (numOfRangesA == 0) {\n      return true;\n    }\n    // Check if each range in one selection has a similar range in other selection.\n    for (let rangeA of this.getRanges()) {\n      rangeA = rangeA.getTrimmed();\n      let found = false;\n      for (let rangeB of otherSelection.getRanges()) {\n        rangeB = rangeB.getTrimmed();\n        if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {\n          found = true;\n          break;\n        }\n      }\n      // For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.\n      if (!found) {\n        return false;\n      }\n    }\n    // There were no ranges that weren't matched. Selections are similar.\n    return true;\n  }\n  /**\n   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n   * one range in the selection, and that range contains exactly one element.\n   * Returns `null` if there is no selected element.\n   *\n   * @returns {module:engine/view/element~Element|null}\n   */\n  getSelectedElement() {\n    if (this.rangeCount !== 1) {\n      return null;\n    }\n    return this.getFirstRange().getContainedElement();\n  }\n  /**\n   * Sets this selection's ranges and direction to the specified location based on the given\n   * {@link module:engine/view/selection~Selectable selectable}.\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tselection.setTo( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tselection.setTo( range );\n   *\n   *\t\t// Sets selection to the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tselection.setTo( otherSelection );\n   *\n   *\t \t// Sets selection to contents of DocumentSelection.\n   *\t\tselection.setTo( editor.editing.view.document.selection );\n   *\n   * \t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionAt( root, path );\n   *\t\tselection.setTo( position );\n   *\n   * \t\t// Sets collapsed selection at the position of given item and offset.\n   *\t\tselection.setTo( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   *\t\tselection.setTo( paragraph, 'in' );\n   *\n   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\tselection.setTo( paragraph, 'on' );\n   *\n   * \t\t// Clears selection. Removes all ranges.\n   *\t\tselection.setTo( null );\n   *\n   * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\tselection.setTo( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tselection.setTo( range, { fake: true, label: 'foo' } );\n   *\n   * @fires change\n   * @param {module:engine/view/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n  setTo() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    let [selectable, placeOrOffset, options] = args;\n    if (typeof placeOrOffset == 'object') {\n      options = placeOrOffset;\n      placeOrOffset = undefined;\n    }\n    if (selectable === null) {\n      this._setRanges([]);\n      this._setFakeOptions(options);\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      this._setRanges(selectable.getRanges(), selectable.isBackward);\n      this._setFakeOptions({\n        fake: selectable.isFake,\n        label: selectable.fakeSelectionLabel\n      });\n    } else if (selectable instanceof Range) {\n      this._setRanges([selectable], options && options.backward);\n      this._setFakeOptions(options);\n    } else if (selectable instanceof Position) {\n      this._setRanges([new Range(selectable)]);\n      this._setFakeOptions(options);\n    } else if (selectable instanceof Node) {\n      const backward = !!options && !!options.backward;\n      let range;\n      if (placeOrOffset === undefined) {\n        /**\n         * selection.setTo requires the second parameter when the first parameter is a node.\n         *\n         * @error view-selection-setto-required-second-parameter\n         */\n        throw new CKEditorError('view-selection-setto-required-second-parameter', this);\n      } else if (placeOrOffset == 'in') {\n        range = Range._createIn(selectable);\n      } else if (placeOrOffset == 'on') {\n        range = Range._createOn(selectable);\n      } else {\n        range = new Range(Position._createAt(selectable, placeOrOffset));\n      }\n      this._setRanges([range], backward);\n      this._setFakeOptions(options);\n    } else if (isIterable(selectable)) {\n      // We assume that the selectable is an iterable of ranges.\n      // Array.from() is used to prevent setting ranges to the old iterable\n      this._setRanges(selectable, options && options.backward);\n      this._setFakeOptions(options);\n    } else {\n      /**\n       * Cannot set selection to given place.\n       *\n       * @error view-selection-setto-not-selectable\n       */\n      throw new CKEditorError('view-selection-setto-not-selectable', this);\n    }\n    this.fire('change');\n  }\n  /**\n   * Moves {@link #focus} to the specified location.\n   *\n   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n   * parameters.\n   *\n   * @fires change\n   * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n  setFocus(itemOrPosition, offset) {\n    if (this.anchor === null) {\n      /**\n       * Cannot set selection focus if there are no ranges in selection.\n       *\n       * @error view-selection-setfocus-no-ranges\n       */\n      throw new CKEditorError('view-selection-setfocus-no-ranges', this);\n    }\n    const newFocus = Position._createAt(itemOrPosition, offset);\n    if (newFocus.compareWith(this.focus) == 'same') {\n      return;\n    }\n    const anchor = this.anchor;\n    this._ranges.pop();\n    if (newFocus.compareWith(anchor) == 'before') {\n      this._addRange(new Range(newFocus, anchor), true);\n    } else {\n      this._addRange(new Range(anchor, newFocus));\n    }\n    this.fire('change');\n  }\n  /**\n   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n   * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.\n   * Accepts a flag describing in which way the selection is made.\n   *\n   * @private\n   * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.\n   * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end\n   * (`false`) or backward - from end to start (`true`). Defaults to `false`.\n   */\n  _setRanges(newRanges) {\n    let isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // New ranges should be copied to prevent removing them by setting them to `[]` first.\n    // Only applies to situations when selection is set to the same selection or same selection's ranges.\n    newRanges = Array.from(newRanges);\n    this._ranges = [];\n    for (const range of newRanges) {\n      this._addRange(range);\n    }\n    this._lastRangeBackward = !!isLastBackward;\n  }\n  /**\n   * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection\n   * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to\n   * the user and selection over elements can be represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be\n   * properly handled by screen readers).\n   *\n   * @private\n   * @param {Object} [options] Options.\n   * @param {Boolean} [options.fake] If set to true selection will be marked as `fake`.\n   * @param {String} [options.label=''] Fake selection label.\n   */\n  _setFakeOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._isFake = !!options.fake;\n    this._fakeSelectionLabel = options.fake ? options.label || '' : '';\n  }\n  /**\n   * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the\n   * selection instance and you can safely operate on it.\n   *\n   * Accepts a flag describing in which way the selection is made - passed range might be selected from\n   * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}\n   * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.\n   * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n   * with ranges already stored in Selection instance.\n   *\n   * @private\n   * @fires change\n   * @param {module:engine/view/range~Range} range\n   * @param {Boolean} [isBackward]\n   */\n  _addRange(range) {\n    let isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!(range instanceof Range)) {\n      /**\n       * Selection range set to an object that is not an instance of {@link module:engine/view/range~Range}.\n       *\n       * @error view-selection-add-range-not-range\n       */\n      throw new CKEditorError('view-selection-add-range-not-range', this);\n    }\n    this._pushRange(range);\n    this._lastRangeBackward = !!isBackward;\n  }\n  /**\n   * Adds range to selection - creates copy of given range so it can be safely used and modified.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n   * with ranges already stored in selection instance.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range\n   */\n  _pushRange(range) {\n    for (const storedRange of this._ranges) {\n      if (range.isIntersecting(storedRange)) {\n        /**\n         * Trying to add a range that intersects with another range from selection.\n         *\n         * @error view-selection-range-intersects\n         * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.\n         * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.\n         */\n        throw new CKEditorError('view-selection-range-intersects', this, {\n          addedRange: range,\n          intersectingRange: storedRange\n        });\n      }\n    }\n    this._ranges.push(new Range(range.start, range.end));\n  }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tselection.is( 'selection' ); // -> true\n *\t\tselection.is( 'view:selection' ); // -> true\n *\n *\t\tselection.is( 'model:selection' ); // -> false\n *\t\tselection.is( 'element' ); // -> false\n *\t\tselection.is( 'range' ); // -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nSelection.prototype.is = function (type) {\n  return type === 'selection' || type === 'view:selection';\n};","map":{"version":3,"names":["TypeCheckable","Range","Position","Node","DocumentSelection","CKEditorError","count","isIterable","EmitterMixin","Selection","constructor","_ranges","_lastRangeBackward","_isFake","_fakeSelectionLabel","length","setTo","isFake","fakeSelectionLabel","anchor","range","end","start","clone","focus","isCollapsed","rangeCount","isBackward","editableElement","getRanges","getFirstRange","first","isBefore","getLastRange","last","isAfter","getFirstPosition","firstRange","getLastPosition","lastRange","isEqual","otherSelection","thisRange","found","otherRange","isSimilar","numOfRangesA","numOfRangesB","rangeA","getTrimmed","rangeB","getSelectedElement","getContainedElement","args","selectable","placeOrOffset","options","undefined","_setRanges","_setFakeOptions","fake","label","backward","_createIn","_createOn","_createAt","fire","setFocus","itemOrPosition","offset","newFocus","compareWith","pop","_addRange","newRanges","isLastBackward","Array","from","_pushRange","storedRange","isIntersecting","addedRange","intersectingRange","push","prototype","is","type"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/selection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/view/selection\n */\nimport TypeCheckable from './typecheckable';\nimport Range from './range';\nimport Position from './position';\nimport Node from './node';\nimport DocumentSelection from './documentselection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * Class representing an arbirtary selection in the view.\n * See also {@link module:engine/view/documentselection~DocumentSelection}.\n *\n * New selection instances can be created via the constructor or one these methods:\n *\n * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n *\n * A selection can consist of {@link module:engine/view/range~Range ranges} that can be set by using\n * the {@link module:engine/view/selection~Selection#setTo `Selection#setTo()`} method.\n */\nexport default class Selection extends EmitterMixin(TypeCheckable) {\n    /**\n     * Creates new selection instance.\n     *\n     * **Note**: The selection constructor is available as a factory method:\n     *\n     * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n     * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n     *\n     * \t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the document selection.\n     *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n     *\n     * \t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates collapsed selection at the position of given item and offset.\n     *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n     *\n     * @param {module:engine/view/selection~Selectable} [selectable=null]\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Stores all ranges that are selected.\n         *\n         * @protected\n         * @member {Array.<module:engine/view/range~Range>}\n         */\n        this._ranges = [];\n        /**\n         * Specifies whether the last added range was added as a backward or forward range.\n         *\n         * @protected\n         * @member {Boolean}\n         */\n        this._lastRangeBackward = false;\n        /**\n         * Specifies whether selection instance is fake.\n         *\n         * @private\n         * @member {Boolean}\n         */\n        this._isFake = false;\n        /**\n         * Fake selection's label.\n         *\n         * @private\n         * @member {String}\n         */\n        this._fakeSelectionLabel = '';\n        if (args.length) {\n            this.setTo(...args);\n        }\n    }\n    /**\n     * Returns true if selection instance is marked as `fake`.\n     *\n     * @see #setTo\n     * @type {Boolean}\n     */\n    get isFake() {\n        return this._isFake;\n    }\n    /**\n     * Returns fake selection label.\n     *\n     * @see #setTo\n     * @type {String}\n     */\n    get fakeSelectionLabel() {\n        return this._fakeSelectionLabel;\n    }\n    /**\n     * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n     * {@link #focus focus} they define the direction of selection, which is important\n     * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n     * It may be a bit unintuitive when there are multiple ranges in selection.\n     *\n     * @see #focus\n     * @type {module:engine/view/position~Position}\n     */\n    get anchor() {\n        if (!this._ranges.length) {\n            return null;\n        }\n        const range = this._ranges[this._ranges.length - 1];\n        const anchor = this._lastRangeBackward ? range.end : range.start;\n        return anchor.clone();\n    }\n    /**\n     * Selection focus. Focus is a position where the selection ends.\n     *\n     * @see #anchor\n     * @type {module:engine/view/position~Position}\n     */\n    get focus() {\n        if (!this._ranges.length) {\n            return null;\n        }\n        const range = this._ranges[this._ranges.length - 1];\n        const focus = this._lastRangeBackward ? range.start : range.end;\n        return focus.clone();\n    }\n    /**\n     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n     * collapsed.\n     *\n     * @type {Boolean}\n     */\n    get isCollapsed() {\n        return this.rangeCount === 1 && this._ranges[0].isCollapsed;\n    }\n    /**\n     * Returns number of ranges in selection.\n     *\n     * @type {Number}\n     */\n    get rangeCount() {\n        return this._ranges.length;\n    }\n    /**\n     * Specifies whether the {@link #focus} precedes {@link #anchor}.\n     *\n     * @type {Boolean}\n     */\n    get isBackward() {\n        return !this.isCollapsed && this._lastRangeBackward;\n    }\n    /**\n     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n     * if the selection is not inside an editable element.\n     *\n     * @type {module:engine/view/editableelement~EditableElement|null}\n     */\n    get editableElement() {\n        if (this.anchor) {\n            return this.anchor.editableElement;\n        }\n        return null;\n    }\n    /**\n     * Returns an iterable that contains copies of all ranges added to the selection.\n     *\n     * @returns {Iterable.<module:engine/view/range~Range>}\n     */\n    *getRanges() {\n        for (const range of this._ranges) {\n            yield range.clone();\n        }\n    }\n    /**\n     * Returns copy of the first range in the selection. First range is the one which\n     * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n     * position of all other ranges (not to confuse with the first range added to the selection).\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/range~Range|null}\n     */\n    getFirstRange() {\n        let first = null;\n        for (const range of this._ranges) {\n            if (!first || range.start.isBefore(first.start)) {\n                first = range;\n            }\n        }\n        return first ? first.clone() : null;\n    }\n    /**\n     * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n     * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n     * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/range~Range|null}\n     */\n    getLastRange() {\n        let last = null;\n        for (const range of this._ranges) {\n            if (!last || range.end.isAfter(last.end)) {\n                last = range;\n            }\n        }\n        return last ? last.clone() : null;\n    }\n    /**\n     * Returns copy of the first position in the selection. First position is the position that\n     * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/position~Position|null}\n     */\n    getFirstPosition() {\n        const firstRange = this.getFirstRange();\n        return firstRange ? firstRange.start.clone() : null;\n    }\n    /**\n     * Returns copy of the last position in the selection. Last position is the position that\n     * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/position~Position|null}\n     */\n    getLastPosition() {\n        const lastRange = this.getLastRange();\n        return lastRange ? lastRange.end.clone() : null;\n    }\n    /**\n     * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n     * same number of ranges and all ranges from one selection equal to a range from other selection.\n     *\n     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n     */\n    isEqual(otherSelection) {\n        if (this.isFake != otherSelection.isFake) {\n            return false;\n        }\n        if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {\n            return false;\n        }\n        if (this.rangeCount != otherSelection.rangeCount) {\n            return false;\n        }\n        else if (this.rangeCount === 0) {\n            return true;\n        }\n        if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n            return false;\n        }\n        for (const thisRange of this._ranges) {\n            let found = false;\n            for (const otherRange of otherSelection._ranges) {\n                if (thisRange.isEqual(otherRange)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n     * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n     * equal to any trimmed range from other selection.\n     *\n     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n     */\n    isSimilar(otherSelection) {\n        if (this.isBackward != otherSelection.isBackward) {\n            return false;\n        }\n        const numOfRangesA = count(this.getRanges());\n        const numOfRangesB = count(otherSelection.getRanges());\n        // If selections have different number of ranges, they cannot be similar.\n        if (numOfRangesA != numOfRangesB) {\n            return false;\n        }\n        // If both selections have no ranges, they are similar.\n        if (numOfRangesA == 0) {\n            return true;\n        }\n        // Check if each range in one selection has a similar range in other selection.\n        for (let rangeA of this.getRanges()) {\n            rangeA = rangeA.getTrimmed();\n            let found = false;\n            for (let rangeB of otherSelection.getRanges()) {\n                rangeB = rangeB.getTrimmed();\n                if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {\n                    found = true;\n                    break;\n                }\n            }\n            // For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.\n            if (!found) {\n                return false;\n            }\n        }\n        // There were no ranges that weren't matched. Selections are similar.\n        return true;\n    }\n    /**\n     * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n     * one range in the selection, and that range contains exactly one element.\n     * Returns `null` if there is no selected element.\n     *\n     * @returns {module:engine/view/element~Element|null}\n     */\n    getSelectedElement() {\n        if (this.rangeCount !== 1) {\n            return null;\n        }\n        return this.getFirstRange().getContainedElement();\n    }\n    /**\n     * Sets this selection's ranges and direction to the specified location based on the given\n     * {@link module:engine/view/selection~Selectable selectable}.\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tselection.setTo( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tselection.setTo( range );\n     *\n     *\t\t// Sets selection to the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tselection.setTo( otherSelection );\n     *\n     *\t \t// Sets selection to contents of DocumentSelection.\n     *\t\tselection.setTo( editor.editing.view.document.selection );\n     *\n     * \t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPositionAt( root, path );\n     *\t\tselection.setTo( position );\n     *\n     * \t\t// Sets collapsed selection at the position of given item and offset.\n     *\t\tselection.setTo( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     *\t\tselection.setTo( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\tselection.setTo( paragraph, 'on' );\n     *\n     * \t\t// Clears selection. Removes all ranges.\n     *\t\tselection.setTo( null );\n     *\n     * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Sets selection as backward.\n     *\t\tselection.setTo( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tselection.setTo( range, { fake: true, label: 'foo' } );\n     *\n     * @fires change\n     * @param {module:engine/view/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     */\n    setTo(...args) {\n        let [selectable, placeOrOffset, options] = args;\n        if (typeof placeOrOffset == 'object') {\n            options = placeOrOffset;\n            placeOrOffset = undefined;\n        }\n        if (selectable === null) {\n            this._setRanges([]);\n            this._setFakeOptions(options);\n        }\n        else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n            this._setRanges(selectable.getRanges(), selectable.isBackward);\n            this._setFakeOptions({ fake: selectable.isFake, label: selectable.fakeSelectionLabel });\n        }\n        else if (selectable instanceof Range) {\n            this._setRanges([selectable], options && options.backward);\n            this._setFakeOptions(options);\n        }\n        else if (selectable instanceof Position) {\n            this._setRanges([new Range(selectable)]);\n            this._setFakeOptions(options);\n        }\n        else if (selectable instanceof Node) {\n            const backward = !!options && !!options.backward;\n            let range;\n            if (placeOrOffset === undefined) {\n                /**\n                 * selection.setTo requires the second parameter when the first parameter is a node.\n                 *\n                 * @error view-selection-setto-required-second-parameter\n                 */\n                throw new CKEditorError('view-selection-setto-required-second-parameter', this);\n            }\n            else if (placeOrOffset == 'in') {\n                range = Range._createIn(selectable);\n            }\n            else if (placeOrOffset == 'on') {\n                range = Range._createOn(selectable);\n            }\n            else {\n                range = new Range(Position._createAt(selectable, placeOrOffset));\n            }\n            this._setRanges([range], backward);\n            this._setFakeOptions(options);\n        }\n        else if (isIterable(selectable)) {\n            // We assume that the selectable is an iterable of ranges.\n            // Array.from() is used to prevent setting ranges to the old iterable\n            this._setRanges(selectable, options && options.backward);\n            this._setFakeOptions(options);\n        }\n        else {\n            /**\n             * Cannot set selection to given place.\n             *\n             * @error view-selection-setto-not-selectable\n             */\n            throw new CKEditorError('view-selection-setto-not-selectable', this);\n        }\n        this.fire('change');\n    }\n    /**\n     * Moves {@link #focus} to the specified location.\n     *\n     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n     * parameters.\n     *\n     * @fires change\n     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n    setFocus(itemOrPosition, offset) {\n        if (this.anchor === null) {\n            /**\n             * Cannot set selection focus if there are no ranges in selection.\n             *\n             * @error view-selection-setfocus-no-ranges\n             */\n            throw new CKEditorError('view-selection-setfocus-no-ranges', this);\n        }\n        const newFocus = Position._createAt(itemOrPosition, offset);\n        if (newFocus.compareWith(this.focus) == 'same') {\n            return;\n        }\n        const anchor = this.anchor;\n        this._ranges.pop();\n        if (newFocus.compareWith(anchor) == 'before') {\n            this._addRange(new Range(newFocus, anchor), true);\n        }\n        else {\n            this._addRange(new Range(anchor, newFocus));\n        }\n        this.fire('change');\n    }\n    /**\n     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n     * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.\n     * Accepts a flag describing in which way the selection is made.\n     *\n     * @private\n     * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.\n     * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end\n     * (`false`) or backward - from end to start (`true`). Defaults to `false`.\n     */\n    _setRanges(newRanges, isLastBackward = false) {\n        // New ranges should be copied to prevent removing them by setting them to `[]` first.\n        // Only applies to situations when selection is set to the same selection or same selection's ranges.\n        newRanges = Array.from(newRanges);\n        this._ranges = [];\n        for (const range of newRanges) {\n            this._addRange(range);\n        }\n        this._lastRangeBackward = !!isLastBackward;\n    }\n    /**\n     * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection\n     * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to\n     * the user and selection over elements can be represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be\n     * properly handled by screen readers).\n     *\n     * @private\n     * @param {Object} [options] Options.\n     * @param {Boolean} [options.fake] If set to true selection will be marked as `fake`.\n     * @param {String} [options.label=''] Fake selection label.\n     */\n    _setFakeOptions(options = {}) {\n        this._isFake = !!options.fake;\n        this._fakeSelectionLabel = options.fake ? options.label || '' : '';\n    }\n    /**\n     * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the\n     * selection instance and you can safely operate on it.\n     *\n     * Accepts a flag describing in which way the selection is made - passed range might be selected from\n     * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}\n     * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.\n     * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n     * with ranges already stored in Selection instance.\n     *\n     * @private\n     * @fires change\n     * @param {module:engine/view/range~Range} range\n     * @param {Boolean} [isBackward]\n     */\n    _addRange(range, isBackward = false) {\n        if (!(range instanceof Range)) {\n            /**\n             * Selection range set to an object that is not an instance of {@link module:engine/view/range~Range}.\n             *\n             * @error view-selection-add-range-not-range\n             */\n            throw new CKEditorError('view-selection-add-range-not-range', this);\n        }\n        this._pushRange(range);\n        this._lastRangeBackward = !!isBackward;\n    }\n    /**\n     * Adds range to selection - creates copy of given range so it can be safely used and modified.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n     * with ranges already stored in selection instance.\n     *\n     * @private\n     * @param {module:engine/view/range~Range} range\n     */\n    _pushRange(range) {\n        for (const storedRange of this._ranges) {\n            if (range.isIntersecting(storedRange)) {\n                /**\n                 * Trying to add a range that intersects with another range from selection.\n                 *\n                 * @error view-selection-range-intersects\n                 * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.\n                 * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.\n                 */\n                throw new CKEditorError('view-selection-range-intersects', this, { addedRange: range, intersectingRange: storedRange });\n            }\n        }\n        this._ranges.push(new Range(range.start, range.end));\n    }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tselection.is( 'selection' ); // -> true\n *\t\tselection.is( 'view:selection' ); // -> true\n *\n *\t\tselection.is( 'model:selection' ); // -> false\n *\t\tselection.is( 'element' ); // -> false\n *\t\tselection.is( 'range' ); // -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nSelection.prototype.is = function (type) {\n    return type === 'selection' || type === 'view:selection';\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,iBAAiB,MAAM,qBAAqB;AACnD,OAAOC,aAAa,MAAM,6CAA6C;AACvE,OAAOC,KAAK,MAAM,qCAAqC;AACvD,OAAOC,UAAU,MAAM,0CAA0C;AACjE,OAAOC,YAAY,MAAM,4CAA4C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,SAAS,SAASD,YAAY,CAACR,aAAa,CAAC,CAAC;EAC/D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIU,WAAW,GAAU;IACjB,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,mBAAmB,GAAG,EAAE;IAC7B,IAAI,UAAKC,MAAM,EAAE;MACb,IAAI,CAACC,KAAK,CAAC,YAAO,CAAC;IACvB;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,MAAM,GAAG;IACT,OAAO,IAAI,CAACJ,OAAO;EACvB;EACA;AACJ;AACA;AACA;AACA;AACA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"},"metadata":{},"sourceType":"module"}