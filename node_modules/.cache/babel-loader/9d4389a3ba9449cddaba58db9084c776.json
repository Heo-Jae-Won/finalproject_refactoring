{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/position\n */\nimport TypeCheckable from './typecheckable';\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position extends TypeCheckable {\n  /**\n   * Creates a position.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   */\n  constructor(root, path) {\n    let stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';\n    super();\n    if (!root.is('element') && !root.is('documentFragment')) {\n      /**\n       * Position root is invalid.\n       *\n       * Positions can only be anchored in elements or document fragments.\n       *\n       * @error model-position-root-invalid\n       */\n      throw new CKEditorError('model-position-root-invalid', root);\n    }\n    if (!(path instanceof Array) || path.length === 0) {\n      /**\n       * Position path must be an array with at least one item.\n       *\n       * @error model-position-path-incorrect-format\n       * @param path\n       */\n      throw new CKEditorError('model-position-path-incorrect-format', root, {\n        path\n      });\n    }\n    // Normalize the root and path when element (not root) is passed.\n    if (root.is('rootElement')) {\n      path = path.slice();\n    } else {\n      path = [...root.getPath(), ...path];\n      root = root.root;\n    }\n    /**\n     * Root of the position path.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     * module:engine/model/position~Position#root\n     */\n    this.root = root;\n    /**\n     * Position of the node in the tree. **Path contains offsets, not indexes.**\n     *\n     * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n     * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n     * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n     * down to the position offset in it's parent.\n     *\n     *\t\t ROOT\n     *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n     *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n     *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n     *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n     *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n     *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n     *\n     * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n     * greater than `1` you can place position offset between their start and end:\n     *\n     *\t\t ROOT\n     *\t\t  |- P\n     *\t\t  |- UL\n     *\t\t     |- LI\n     *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n     *\t\t     |- LI\n     *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n     *\n     * @readonly\n     * @member {Array.<Number>} module:engine/model/position~Position#path\n     */\n    this.path = path;\n    /**\n     * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n     *\n     * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n     */\n    this.stickiness = stickiness;\n  }\n  /**\n   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n   * to the last item in position {@link module:engine/model/position~Position#path path}.\n   *\n   * @type {Number}\n   */\n  get offset() {\n    return this.path[this.path.length - 1];\n  }\n  set offset(newOffset) {\n    this.path[this.path.length - 1] = newOffset;\n  }\n  /**\n   * Parent element of this position.\n   *\n   * Keep in mind that `parent` value is calculated when the property is accessed.\n   * If {@link module:engine/model/position~Position#path position path}\n   * leads to a non-existing element, `parent` property will throw error.\n   *\n   * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n   *\n   * @readonly\n   * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n   */\n  get parent() {\n    let parent = this.root;\n    for (let i = 0; i < this.path.length - 1; i++) {\n      parent = parent.getChild(parent.offsetToIndex(this.path[i]));\n      if (!parent) {\n        /**\n         * The position's path is incorrect. This means that a position does not point to\n         * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n         *\n         * **Note**: Unlike DOM and view positions, in the model, the\n         * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n         * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element\n         * where this position points.\n         *\n         * Read more about model positions and offsets in\n         * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n         *\n         * @error model-position-path-incorrect\n         * @param {module:engine/model/position~Position} position The incorrect position.\n         */\n        throw new CKEditorError('model-position-path-incorrect', this, {\n          position: this\n        });\n      }\n    }\n    if (parent.is('$text')) {\n      throw new CKEditorError('model-position-path-incorrect', this, {\n        position: this\n      });\n    }\n    return parent;\n  }\n  /**\n   * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n   * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n   * in text node, position index is equal to the index of that text node.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get index() {\n    return this.parent.offsetToIndex(this.offset);\n  }\n  /**\n   * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n   * position is not in a text node.\n   *\n   * @readonly\n   * @type {module:engine/model/text~Text|null}\n   */\n  get textNode() {\n    return getTextNodeAtPosition(this, this.parent);\n  }\n  /**\n   * Node directly after this position or `null` if this position is in text node.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|null}\n   */\n  get nodeAfter() {\n    // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n    const parent = this.parent;\n    return getNodeAfterPosition(this, parent, getTextNodeAtPosition(this, parent));\n  }\n  /**\n   * Node directly before this position or `null` if this position is in text node.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|null}\n   */\n  get nodeBefore() {\n    // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n    const parent = this.parent;\n    return getNodeBeforePosition(this, parent, getTextNodeAtPosition(this, parent));\n  }\n  /**\n   * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isAtStart() {\n    return this.offset === 0;\n  }\n  /**\n   * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isAtEnd() {\n    return this.offset == this.parent.maxOffset;\n  }\n  /**\n   * Checks whether this position is before or after given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {module:engine/model/position~PositionRelation}\n   */\n  compareWith(otherPosition) {\n    if (this.root != otherPosition.root) {\n      return 'different';\n    }\n    const result = compareArrays(this.path, otherPosition.path);\n    switch (result) {\n      case 'same':\n        return 'same';\n      case 'prefix':\n        return 'before';\n      case 'extension':\n        return 'after';\n      default:\n        return this.path[result] < otherPosition.path[result] ? 'before' : 'after';\n    }\n  }\n  /**\n   * Gets the farthest position which matches the callback using\n   * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n   *\n   * For example:\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n   * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n   * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n   *\n   * \t\tgetLastMatchingPosition( value => false );\n   * \t\t// Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   *\n   * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n   */\n  getLastMatchingPosition(skip) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.startPosition = this;\n    const treeWalker = new TreeWalker(options);\n    treeWalker.skip(skip);\n    return treeWalker.position;\n  }\n  /**\n   * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n   * but without the last item.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @returns {Array.<Number>} Path to the parent.\n   */\n  getParentPath() {\n    return this.path.slice(0, -1);\n  }\n  /**\n   * Returns ancestors array of this position, that is this position's parent and its ancestors.\n   *\n   * @returns {Array.<module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment>} Array with ancestors.\n   */\n  getAncestors() {\n    const parent = this.parent;\n    if (parent.is('documentFragment')) {\n      return [parent];\n    } else {\n      return parent.getAncestors({\n        includeSelf: true\n      });\n    }\n  }\n  /**\n   * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.\n   *\n   * @param {String} parentName The name of the parent element to find.\n   * @returns {module:engine/model/element~Element|null}\n   */\n  findAncestor(parentName) {\n    const parent = this.parent;\n    if (parent.is('element')) {\n      return parent.findAncestor(parentName, {\n        includeSelf: true\n      });\n    }\n    return null;\n  }\n  /**\n   * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n   * of these two paths must be identical.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} position The second position.\n   * @returns {Array.<Number>} The common path.\n   */\n  getCommonPath(position) {\n    if (this.root != position.root) {\n      return [];\n    }\n    // We find on which tree-level start and end have the lowest common ancestor\n    const cmp = compareArrays(this.path, position.path);\n    // If comparison returned string it means that arrays are same.\n    const diffAt = typeof cmp == 'string' ? Math.min(this.path.length, position.path.length) : cmp;\n    return this.path.slice(0, diffAt);\n  }\n  /**\n   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n   * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n   *\n   * @param {module:engine/model/position~Position} position The second position.\n   * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n  getCommonAncestor(position) {\n    const ancestorsA = this.getAncestors();\n    const ancestorsB = position.getAncestors();\n    let i = 0;\n    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n      i++;\n    }\n    return i === 0 ? null : ancestorsA[i - 1];\n  }\n  /**\n   * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n   * is shifted by `shift` value (can be a negative value).\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {Number} shift Offset shift. Can be a negative value.\n   * @returns {module:engine/model/position~Position} Shifted position.\n   */\n  getShiftedBy(shift) {\n    const shifted = this.clone();\n    const offset = shifted.offset + shift;\n    shifted.offset = offset < 0 ? 0 : offset;\n    return shifted;\n  }\n  /**\n   * Checks whether this position is after given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @see module:engine/model/position~Position#isBefore\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if this position is after given position.\n   */\n  isAfter(otherPosition) {\n    return this.compareWith(otherPosition) == 'after';\n  }\n  /**\n   * Checks whether this position is before given position.\n   *\n   * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n   * be `true` if positions are in different roots and you might not expect this. You should probably use\n   * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n   * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n   *\n   *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n   *\t\t\t// do A.\n   *\t\t} else {\n   *\t\t\t// do B.\n   *\t\t}\n   *\n   * or, if you have only one if-branch:\n   *\n   *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n   *\t\t\t// do B.\n   *\t\t}\n   *\n   * rather than:\n   *\n   *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n   *\t\t\t// do B.\n   *\t\t} else {\n   *\t\t\t// do A.\n   *\t\t}\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if this position is before given position.\n   */\n  isBefore(otherPosition) {\n    return this.compareWith(otherPosition) == 'before';\n  }\n  /**\n   * Checks whether this position is equal to given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions are same.\n   */\n  isEqual(otherPosition) {\n    return this.compareWith(otherPosition) == 'same';\n  }\n  /**\n   * Checks whether this position is touching given position. Positions touch when there are no text nodes\n   * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n   * they are very similar or even indistinguishable.\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions touch.\n   */\n  isTouching(otherPosition) {\n    if (this.root !== otherPosition.root) {\n      return false;\n    }\n    const commonLevel = Math.min(this.path.length, otherPosition.path.length);\n    for (let level = 0; level < commonLevel; level++) {\n      const diff = this.path[level] - otherPosition.path[level];\n      // Positions are spread by a node, so they are not touching.\n      if (diff < -1 || diff > 1) {\n        return false;\n      } else if (diff === 1) {\n        // `otherPosition` is on the left.\n        // `this` is on the right.\n        return checkTouchingBranch(otherPosition, this, level);\n      } else if (diff === -1) {\n        // `this` is on the left.\n        // `otherPosition` is on the right.\n        return checkTouchingBranch(this, otherPosition, level);\n      }\n      // `diff === 0`.\n      // Positions are inside the same element on this level, compare deeper.\n    }\n    // If we ended up here, it means that positions paths have the same beginning.\n    // If the paths have the same length, then it means that they are identical, so the positions are same.\n    if (this.path.length === otherPosition.path.length) {\n      return true;\n    }\n    // If positions have different length of paths, then the common part is the same.\n    // In this case, the \"shorter\" position is on the left, the \"longer\" position is on the right.\n    //\n    // If the positions are touching, the \"longer\" position must have only zeroes. For example:\n    // [ 1, 2 ] vs [ 1, 2, 0 ]\n    // [ 1, 2 ] vs [ 1, 2, 0, 0, 0 ]\n    else if (this.path.length > otherPosition.path.length) {\n      return checkOnlyZeroes(this.path, commonLevel);\n    } else {\n      return checkOnlyZeroes(otherPosition.path, commonLevel);\n    }\n  }\n  /**\n   * Checks if two positions are in the same parent.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} position Position to compare with.\n   * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n   */\n  hasSameParentAs(position) {\n    if (this.root !== position.root) {\n      return false;\n    }\n    const thisParentPath = this.getParentPath();\n    const posParentPath = position.getParentPath();\n    return compareArrays(thisParentPath, posParentPath) == 'same';\n  }\n  /**\n   * Returns a copy of this position that is transformed by given `operation`.\n   *\n   * The new position's parameters are updated accordingly to the effect of the `operation`.\n   *\n   * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n   * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n  getTransformedByOperation(operation) {\n    let result;\n    switch (operation.type) {\n      case 'insert':\n        result = this._getTransformedByInsertOperation(operation);\n        break;\n      case 'move':\n      case 'remove':\n      case 'reinsert':\n        result = this._getTransformedByMoveOperation(operation);\n        break;\n      case 'split':\n        result = this._getTransformedBySplitOperation(operation);\n        break;\n      case 'merge':\n        result = this._getTransformedByMergeOperation(operation);\n        break;\n      default:\n        result = Position._createAt(this);\n        break;\n    }\n    return result;\n  }\n  /**\n   * Returns a copy of this position transformed by an insert operation.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n  _getTransformedByInsertOperation(operation) {\n    return this._getTransformedByInsertion(operation.position, operation.howMany);\n  }\n  /**\n   * Returns a copy of this position transformed by a move operation.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n  _getTransformedByMoveOperation(operation) {\n    return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);\n  }\n  /**\n   * Returns a copy of this position transformed by a split operation.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n  _getTransformedBySplitOperation(operation) {\n    const movedRange = operation.movedRange;\n    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == 'toNext';\n    if (isContained) {\n      return this._getCombined(operation.splitPosition, operation.moveTargetPosition);\n    } else {\n      if (operation.graveyardPosition) {\n        return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);\n      } else {\n        return this._getTransformedByInsertion(operation.insertionPosition, 1);\n      }\n    }\n  }\n  /**\n   * Returns a copy of this position transformed by merge operation.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n  _getTransformedByMergeOperation(operation) {\n    const movedRange = operation.movedRange;\n    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);\n    let pos;\n    if (isContained) {\n      pos = this._getCombined(operation.sourcePosition, operation.targetPosition);\n      if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n        // Above happens during OT when the merged element is moved before the merged-to element.\n        pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);\n      }\n    } else if (this.isEqual(operation.deletionPosition)) {\n      pos = Position._createAt(operation.deletionPosition);\n    } else {\n      pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);\n    }\n    return pos;\n  }\n  /**\n   * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n   * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n   * @param {Number} howMany How many nodes are removed.\n   * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n   */\n  _getTransformedByDeletion(deletePosition, howMany) {\n    const transformed = Position._createAt(this);\n    // This position can't be affected if deletion was in a different root.\n    if (this.root != deletePosition.root) {\n      return transformed;\n    }\n    if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'same') {\n      // If nodes are removed from the node that is pointed by this position...\n      if (deletePosition.offset < this.offset) {\n        // And are removed from before an offset of that position...\n        if (deletePosition.offset + howMany > this.offset) {\n          // Position is in removed range, it's no longer in the tree.\n          return null;\n        } else {\n          // Decrement the offset accordingly.\n          transformed.offset -= howMany;\n        }\n      }\n    } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'prefix') {\n      // If nodes are removed from a node that is on a path to this position...\n      const i = deletePosition.path.length - 1;\n      if (deletePosition.offset <= this.path[i]) {\n        // And are removed from before next node of that path...\n        if (deletePosition.offset + howMany > this.path[i]) {\n          // If the next node of that path is removed return null\n          // because the node containing this position got removed.\n          return null;\n        } else {\n          // Otherwise, decrement index on that path.\n          transformed.path[i] -= howMany;\n        }\n      }\n    }\n    return transformed;\n  }\n  /**\n   * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n   * @param {Number} howMany How many nodes are inserted.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n  _getTransformedByInsertion(insertPosition, howMany) {\n    const transformed = Position._createAt(this);\n    // This position can't be affected if insertion was in a different root.\n    if (this.root != insertPosition.root) {\n      return transformed;\n    }\n    if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'same') {\n      // If nodes are inserted in the node that is pointed by this position...\n      if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != 'toPrevious') {\n        // And are inserted before an offset of that position...\n        // \"Push\" this positions offset.\n        transformed.offset += howMany;\n      }\n    } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'prefix') {\n      // If nodes are inserted in a node that is on a path to this position...\n      const i = insertPosition.path.length - 1;\n      if (insertPosition.offset <= this.path[i]) {\n        // And are inserted before next node of that path...\n        // \"Push\" the index on that path.\n        transformed.path[i] += howMany;\n      }\n    }\n    return transformed;\n  }\n  /**\n   * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n   * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n   * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n  _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n    // Update target position, as it could be affected by nodes removal.\n    targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n    if (sourcePosition.isEqual(targetPosition)) {\n      // If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n      return Position._createAt(this);\n    }\n    // Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n    const transformed = this._getTransformedByDeletion(sourcePosition, howMany);\n    const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == 'toNext' || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == 'toPrevious';\n    if (isMoved) {\n      // This position is inside moved range (or sticks to it).\n      // In this case, we calculate a combination of this position, move source position and target position.\n      return this._getCombined(sourcePosition, targetPosition);\n    } else {\n      // This position is not inside a removed range.\n      //\n      // In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n      return transformed._getTransformedByInsertion(targetPosition, howMany);\n    }\n  }\n  /**\n   * Returns a new position that is a combination of this position and given positions.\n   *\n   * The combined position is a copy of this position transformed by moving a range starting at `source` position\n   * to the `target` position. It is expected that this position is inside the moved range.\n   *\n   * Example:\n   *\n   *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n   *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n   *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n   *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n   *\n   * Explanation:\n   *\n   * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n   * was inside moved nodes and now should point to the new place. The moved nodes will be after\n   * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n   * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n   * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n   * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} source Beginning of the moved range.\n   * @param {module:engine/model/position~Position} target Position where the range is moved.\n   * @returns {module:engine/model/position~Position} Combined position.\n   */\n  _getCombined(source, target) {\n    const i = source.path.length - 1;\n    // The first part of a path to combined position is a path to the place where nodes were moved.\n    const combined = Position._createAt(target);\n    combined.stickiness = this.stickiness;\n    // Then we have to update the rest of the path.\n    // Fix the offset because this position might be after `from` position and we have to reflect that.\n    combined.offset = combined.offset + this.path[i] - source.offset;\n    // Then, add the rest of the path.\n    // If this position is at the same level as `from` position nothing will get added.\n    combined.path = [...combined.path, ...this.path.slice(i + 1)];\n    return combined;\n  }\n  /**\n   * @inheritDoc\n   */\n  toJSON() {\n    return {\n      root: this.root.toJSON(),\n      path: Array.from(this.path),\n      stickiness: this.stickiness\n    };\n  }\n  /**\n   * Returns a new position that is equal to current position.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n  clone() {\n    return new this.constructor(this.root, this.path, this.stickiness);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/model/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n   *\n   * This method is a shortcut to other factory methods such as:\n   *\n   * * {@link module:engine/model/position~Position._createBefore},\n   * * {@link module:engine/model/position~Position._createAfter}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @protected\n   * @internal\n   */\n  static _createAt(itemOrPosition, offset) {\n    let stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';\n    if (itemOrPosition instanceof Position) {\n      return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);\n    } else {\n      const node = itemOrPosition;\n      if (offset == 'end') {\n        offset = node.maxOffset;\n      } else if (offset == 'before') {\n        return this._createBefore(node, stickiness);\n      } else if (offset == 'after') {\n        return this._createAfter(node, stickiness);\n      } else if (offset !== 0 && !offset) {\n        /**\n         * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n         * requires the offset to be specified when the first parameter is a model item.\n         *\n         * @error model-createpositionat-offset-required\n         */\n        throw new CKEditorError('model-createpositionat-offset-required', [this, itemOrPosition]);\n      }\n      if (!node.is('element') && !node.is('documentFragment')) {\n        /**\n         * Position parent have to be a model element or model document fragment.\n         *\n         * @error model-position-parent-incorrect\n         */\n        throw new CKEditorError('model-position-parent-incorrect', [this, itemOrPosition]);\n      }\n      const path = node.getPath();\n      path.push(offset);\n      return new this(node.root, path, stickiness);\n    }\n  }\n  /**\n   * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * @returns {module:engine/model/position~Position}\n   * @protected\n   * @internal\n   */\n  static _createAfter(item, stickiness) {\n    if (!item.parent) {\n      /**\n       * You can not make a position after a root element.\n       *\n       * @error model-position-after-root\n       * @param {module:engine/model/item~Item} root\n       */\n      throw new CKEditorError('model-position-after-root', [this, item], {\n        root: item\n      });\n    }\n    return this._createAt(item.parent, item.endOffset, stickiness);\n  }\n  /**\n   * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n   *\n   * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * @returns {module:engine/model/position~Position}\n   * @protected\n   * @internal\n   */\n  static _createBefore(item, stickiness) {\n    if (!item.parent) {\n      /**\n       * You can not make a position before a root element.\n       *\n       * @error model-position-before-root\n       * @param {module:engine/model/item~Item} root\n       */\n      throw new CKEditorError('model-position-before-root', item, {\n        root: item\n      });\n    }\n    return this._createAt(item.parent, item.startOffset, stickiness);\n  }\n  /**\n   * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n   *\n   * @param {Object} json Plain object to be converted to `Position`.\n   * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n   * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n   */\n  static fromJSON(json, doc) {\n    if (json.root === '$graveyard') {\n      const pos = new Position(doc.graveyard, json.path);\n      pos.stickiness = json.stickiness;\n      return pos;\n    }\n    if (!doc.getRoot(json.root)) {\n      /**\n       * Cannot create position for document. Root with specified name does not exist.\n       *\n       * @error model-position-fromjson-no-root\n       * @param {String} rootName\n       */\n      throw new CKEditorError('model-position-fromjson-no-root', doc, {\n        rootName: json.root\n      });\n    }\n    return new Position(doc.getRoot(json.root), json.path, json.stickiness);\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tposition.is( 'position' ); // -> true\n *\t\tposition.is( 'model:position' ); // -> true\n *\n *\t\tposition.is( 'view:position' ); // -> false\n *\t\tposition.is( 'documentSelection' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nPosition.prototype.is = function (type) {\n  return type === 'position' || type === 'model:position';\n};\n/**\n * Returns a text node at the given position.\n *\n * This is a helper function optimized to reuse the position parent instance for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#textNode `Position#textNode`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`}\n * check if your algorithm does not access it multiple times (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getNodeAfterPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @returns {module:engine/model/text~Text|null}\n */\nexport function getTextNodeAtPosition(position, positionParent) {\n  const node = positionParent.getChild(positionParent.offsetToIndex(position.offset));\n  if (node && node.is('$text') && node.startOffset < position.offset) {\n    return node;\n  }\n  return null;\n}\n/**\n * Returns the node after the given position.\n *\n * This is a helper function optimized to reuse the position parent instance and the calculation of the text node at the\n * specific position for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#nodeAfter `Position#nodeAfter`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`} and/or\n * {@link module:engine/model/position~Position#textNode `Position#textNode`}\n * check if your algorithm does not access those properties multiple times\n * (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579 and https://github.com/ckeditor/ckeditor5/issues/6582.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeAfterPosition(position, positionParent, textNode) {\n  if (textNode !== null) {\n    return null;\n  }\n  return positionParent.getChild(positionParent.offsetToIndex(position.offset));\n}\n/**\n * Returns the node before the given position.\n *\n * Refer to {@link module:engine/model/position~getNodeBeforePosition} for documentation on when to use this util method.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeAfterPosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeBeforePosition(position, positionParent, textNode) {\n  if (textNode !== null) {\n    return null;\n  }\n  return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);\n}\n// This is a helper function for `Position#isTouching()`.\n//\n// It checks whether to given positions are touching, considering that they have the same root and paths\n// until given level, and at given level they differ by 1 (so they are branching at `level` point).\n//\n// The exact requirements for touching positions are described in `Position#isTouching()` and also\n// in the body of this function.\n//\n// @param {module:engine/model/position~Position} left Position \"on the left\" (it is before `right`).\n// @param {module:engine/model/position~Position} right Position \"on the right\" (it is after `left`).\n// @param {Number} level Level on which the positions are different.\n// @returns {Boolean}\nfunction checkTouchingBranch(left, right, level) {\n  if (level + 1 === left.path.length) {\n    // Left position does not have any more entries after the point where the positions differ.\n    // [ 2 ] vs [ 3 ]\n    // [ 2 ] vs [ 3, 0, 0 ]\n    // The positions are spread by node at [ 2 ].\n    return false;\n  }\n  if (!checkOnlyZeroes(right.path, level + 1)) {\n    // Right position does not have only zeroes, so we have situation like:\n    // [ 2, maxOffset ] vs [ 3, 1 ]\n    // [ 2, maxOffset ] vs [ 3, 1, 0, 0 ]\n    // The positions are spread by node at [ 3, 0 ].\n    return false;\n  }\n  if (!checkOnlyMaxOffset(left, level + 1)) {\n    // Left position does not have only max offsets, so we have situation like:\n    // [ 2, 4 ] vs [ 3 ]\n    // [ 2, 4 ] vs [ 3, 0, 0 ]\n    // The positions are spread by node at [ 2, 5 ].\n    return false;\n  }\n  // Left position has only max offsets and right position has only zeroes or nothing.\n  // [ 2, maxOffset ] vs [ 3 ]\n  // [ 2, maxOffset, maxOffset ] vs [ 3, 0 ]\n  // There are not elements between positions. The positions are touching.\n  return true;\n}\n// Checks whether for given array, starting from given index until the end of the array, all items are `0`s.\n//\n// This is a helper function for `Position#isTouching()`.\n//\n// @private\n// @param {Array.<Number>} arr Array to check.\n// @param {Number} idx Index to start checking from.\n// @returns {Boolean}\nfunction checkOnlyZeroes(arr, idx) {\n  while (idx < arr.length) {\n    if (arr[idx] !== 0) {\n      return false;\n    }\n    idx++;\n  }\n  return true;\n}\n// Checks whether for given position, starting from given path level, whether the position is at the end of\n// its parent and whether each element on the path to the position is also at at the end of its parent.\n//\n// This is a helper function for `Position#isTouching()`.\n//\n// @private\n// @param {module:engine/model/position~Position} pos Position to check.\n// @param {Number} level Level to start checking from.\n// @returns {Boolean}\nfunction checkOnlyMaxOffset(pos, level) {\n  let parent = pos.parent;\n  let idx = pos.path.length - 1;\n  let add = 0;\n  while (idx >= level) {\n    if (pos.path[idx] + add !== parent.maxOffset) {\n      return false;\n    }\n    // After the first check, we \"go up\", and check whether the position's parent-parent is the last element.\n    // However, we need to add 1 to the value in the path to \"simulate\" moving the path after the parent.\n    // It happens just once.\n    add = 1;\n    idx--;\n    parent = parent.parent;\n  }\n  return true;\n}","map":{"version":3,"names":["TypeCheckable","TreeWalker","compareArrays","CKEditorError","Position","constructor","root","path","stickiness","is","Array","length","slice","getPath","offset","newOffset","parent","i","getChild","offsetToIndex","position","index","textNode","getTextNodeAtPosition","nodeAfter","getNodeAfterPosition","nodeBefore","getNodeBeforePosition","isAtStart","isAtEnd","maxOffset","compareWith","otherPosition","result","getLastMatchingPosition","skip","options","startPosition","treeWalker","getParentPath","getAncestors","includeSelf","findAncestor","parentName","getCommonPath","cmp","diffAt","Math","min","getCommonAncestor","ancestorsA","ancestorsB","getShiftedBy","shift","shifted","clone","isAfter","isBefore","isEqual","isTouching","commonLevel","level","diff","checkTouchingBranch","checkOnlyZeroes","hasSameParentAs","thisParentPath","posParentPath","getTransformedByOperation","operation","type","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","_createAt","_getTransformedByInsertion","howMany","_getTransformedByMove","sourcePosition","targetPosition","movedRange","isContained","containsPosition","start","_getCombined","splitPosition","moveTargetPosition","graveyardPosition","insertionPosition","pos","_getTransformedByDeletion","deletionPosition","deletePosition","transformed","insertPosition","isMoved","source","target","combined","toJSON","from","itemOrPosition","node","_createBefore","_createAfter","push","item","endOffset","startOffset","fromJSON","json","doc","graveyard","getRoot","rootName","prototype","positionParent","left","right","checkOnlyMaxOffset","arr","idx","add"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/position\n */\nimport TypeCheckable from './typecheckable';\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position extends TypeCheckable {\n    /**\n     * Creates a position.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * See {@link module:engine/model/position~PositionStickiness}.\n     */\n    constructor(root, path, stickiness = 'toNone') {\n        super();\n        if (!root.is('element') && !root.is('documentFragment')) {\n            /**\n             * Position root is invalid.\n             *\n             * Positions can only be anchored in elements or document fragments.\n             *\n             * @error model-position-root-invalid\n             */\n            throw new CKEditorError('model-position-root-invalid', root);\n        }\n        if (!(path instanceof Array) || path.length === 0) {\n            /**\n             * Position path must be an array with at least one item.\n             *\n             * @error model-position-path-incorrect-format\n             * @param path\n             */\n            throw new CKEditorError('model-position-path-incorrect-format', root, { path });\n        }\n        // Normalize the root and path when element (not root) is passed.\n        if (root.is('rootElement')) {\n            path = path.slice();\n        }\n        else {\n            path = [...root.getPath(), ...path];\n            root = root.root;\n        }\n        /**\n         * Root of the position path.\n         *\n         * @readonly\n         * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n         * module:engine/model/position~Position#root\n         */\n        this.root = root;\n        /**\n         * Position of the node in the tree. **Path contains offsets, not indexes.**\n         *\n         * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n         * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n         * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n         * down to the position offset in it's parent.\n         *\n         *\t\t ROOT\n         *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n         *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n         *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n         *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n         *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n         *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n         *\n         * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n         * greater than `1` you can place position offset between their start and end:\n         *\n         *\t\t ROOT\n         *\t\t  |- P\n         *\t\t  |- UL\n         *\t\t     |- LI\n         *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n         *\t\t     |- LI\n         *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n         *\n         * @readonly\n         * @member {Array.<Number>} module:engine/model/position~Position#path\n         */\n        this.path = path;\n        /**\n         * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n         *\n         * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n         */\n        this.stickiness = stickiness;\n    }\n    /**\n     * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n     * to the last item in position {@link module:engine/model/position~Position#path path}.\n     *\n     * @type {Number}\n     */\n    get offset() {\n        return this.path[this.path.length - 1];\n    }\n    set offset(newOffset) {\n        this.path[this.path.length - 1] = newOffset;\n    }\n    /**\n     * Parent element of this position.\n     *\n     * Keep in mind that `parent` value is calculated when the property is accessed.\n     * If {@link module:engine/model/position~Position#path position path}\n     * leads to a non-existing element, `parent` property will throw error.\n     *\n     * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n     *\n     * @readonly\n     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     */\n    get parent() {\n        let parent = this.root;\n        for (let i = 0; i < this.path.length - 1; i++) {\n            parent = parent.getChild(parent.offsetToIndex(this.path[i]));\n            if (!parent) {\n                /**\n                 * The position's path is incorrect. This means that a position does not point to\n                 * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n                 *\n                 * **Note**: Unlike DOM and view positions, in the model, the\n                 * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n                 * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element\n                 * where this position points.\n                 *\n                 * Read more about model positions and offsets in\n                 * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n                 *\n                 * @error model-position-path-incorrect\n                 * @param {module:engine/model/position~Position} position The incorrect position.\n                 */\n                throw new CKEditorError('model-position-path-incorrect', this, { position: this });\n            }\n        }\n        if (parent.is('$text')) {\n            throw new CKEditorError('model-position-path-incorrect', this, { position: this });\n        }\n        return parent;\n    }\n    /**\n     * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n     * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n     * in text node, position index is equal to the index of that text node.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get index() {\n        return this.parent.offsetToIndex(this.offset);\n    }\n    /**\n     * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n     * position is not in a text node.\n     *\n     * @readonly\n     * @type {module:engine/model/text~Text|null}\n     */\n    get textNode() {\n        return getTextNodeAtPosition(this, this.parent);\n    }\n    /**\n     * Node directly after this position or `null` if this position is in text node.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|null}\n     */\n    get nodeAfter() {\n        // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n        const parent = this.parent;\n        return getNodeAfterPosition(this, parent, getTextNodeAtPosition(this, parent));\n    }\n    /**\n     * Node directly before this position or `null` if this position is in text node.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|null}\n     */\n    get nodeBefore() {\n        // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n        const parent = this.parent;\n        return getNodeBeforePosition(this, parent, getTextNodeAtPosition(this, parent));\n    }\n    /**\n     * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isAtStart() {\n        return this.offset === 0;\n    }\n    /**\n     * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isAtEnd() {\n        return this.offset == this.parent.maxOffset;\n    }\n    /**\n     * Checks whether this position is before or after given position.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {module:engine/model/position~PositionRelation}\n     */\n    compareWith(otherPosition) {\n        if (this.root != otherPosition.root) {\n            return 'different';\n        }\n        const result = compareArrays(this.path, otherPosition.path);\n        switch (result) {\n            case 'same':\n                return 'same';\n            case 'prefix':\n                return 'before';\n            case 'extension':\n                return 'after';\n            default:\n                return this.path[result] < otherPosition.path[result] ? 'before' : 'after';\n        }\n    }\n    /**\n     * Gets the farthest position which matches the callback using\n     * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n     *\n     * For example:\n     *\n     * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n     * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n     *\n     * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n     * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n     *\n     * \t\tgetLastMatchingPosition( value => false );\n     * \t\t// Do not move the position.\n     *\n     * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n     * return `true` if the value should be skipped or `false` if not.\n     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     *\n     * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n     */\n    getLastMatchingPosition(skip, options = {}) {\n        options.startPosition = this;\n        const treeWalker = new TreeWalker(options);\n        treeWalker.skip(skip);\n        return treeWalker.position;\n    }\n    /**\n     * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n     * but without the last item.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @returns {Array.<Number>} Path to the parent.\n     */\n    getParentPath() {\n        return this.path.slice(0, -1);\n    }\n    /**\n     * Returns ancestors array of this position, that is this position's parent and its ancestors.\n     *\n     * @returns {Array.<module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment>} Array with ancestors.\n     */\n    getAncestors() {\n        const parent = this.parent;\n        if (parent.is('documentFragment')) {\n            return [parent];\n        }\n        else {\n            return parent.getAncestors({ includeSelf: true });\n        }\n    }\n    /**\n     * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.\n     *\n     * @param {String} parentName The name of the parent element to find.\n     * @returns {module:engine/model/element~Element|null}\n     */\n    findAncestor(parentName) {\n        const parent = this.parent;\n        if (parent.is('element')) {\n            return parent.findAncestor(parentName, { includeSelf: true });\n        }\n        return null;\n    }\n    /**\n     * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n     * of these two paths must be identical.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} position The second position.\n     * @returns {Array.<Number>} The common path.\n     */\n    getCommonPath(position) {\n        if (this.root != position.root) {\n            return [];\n        }\n        // We find on which tree-level start and end have the lowest common ancestor\n        const cmp = compareArrays(this.path, position.path);\n        // If comparison returned string it means that arrays are same.\n        const diffAt = (typeof cmp == 'string') ? Math.min(this.path.length, position.path.length) : cmp;\n        return this.path.slice(0, diffAt);\n    }\n    /**\n     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n     * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n     *\n     * @param {module:engine/model/position~Position} position The second position.\n     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n    getCommonAncestor(position) {\n        const ancestorsA = this.getAncestors();\n        const ancestorsB = position.getAncestors();\n        let i = 0;\n        while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n            i++;\n        }\n        return i === 0 ? null : ancestorsA[i - 1];\n    }\n    /**\n     * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n     * is shifted by `shift` value (can be a negative value).\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {Number} shift Offset shift. Can be a negative value.\n     * @returns {module:engine/model/position~Position} Shifted position.\n     */\n    getShiftedBy(shift) {\n        const shifted = this.clone();\n        const offset = shifted.offset + shift;\n        shifted.offset = offset < 0 ? 0 : offset;\n        return shifted;\n    }\n    /**\n     * Checks whether this position is after given position.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @see module:engine/model/position~Position#isBefore\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if this position is after given position.\n     */\n    isAfter(otherPosition) {\n        return this.compareWith(otherPosition) == 'after';\n    }\n    /**\n     * Checks whether this position is before given position.\n     *\n     * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n     * be `true` if positions are in different roots and you might not expect this. You should probably use\n     * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n     * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n     *\n     *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n     *\t\t\t// do A.\n     *\t\t} else {\n     *\t\t\t// do B.\n     *\t\t}\n     *\n     * or, if you have only one if-branch:\n     *\n     *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n     *\t\t\t// do B.\n     *\t\t}\n     *\n     * rather than:\n     *\n     *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n     *\t\t\t// do B.\n     *\t\t} else {\n     *\t\t\t// do A.\n     *\t\t}\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if this position is before given position.\n     */\n    isBefore(otherPosition) {\n        return this.compareWith(otherPosition) == 'before';\n    }\n    /**\n     * Checks whether this position is equal to given position.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if positions are same.\n     */\n    isEqual(otherPosition) {\n        return this.compareWith(otherPosition) == 'same';\n    }\n    /**\n     * Checks whether this position is touching given position. Positions touch when there are no text nodes\n     * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n     * they are very similar or even indistinguishable.\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if positions touch.\n     */\n    isTouching(otherPosition) {\n        if (this.root !== otherPosition.root) {\n            return false;\n        }\n        const commonLevel = Math.min(this.path.length, otherPosition.path.length);\n        for (let level = 0; level < commonLevel; level++) {\n            const diff = this.path[level] - otherPosition.path[level];\n            // Positions are spread by a node, so they are not touching.\n            if (diff < -1 || diff > 1) {\n                return false;\n            }\n            else if (diff === 1) {\n                // `otherPosition` is on the left.\n                // `this` is on the right.\n                return checkTouchingBranch(otherPosition, this, level);\n            }\n            else if (diff === -1) {\n                // `this` is on the left.\n                // `otherPosition` is on the right.\n                return checkTouchingBranch(this, otherPosition, level);\n            }\n            // `diff === 0`.\n            // Positions are inside the same element on this level, compare deeper.\n        }\n        // If we ended up here, it means that positions paths have the same beginning.\n        // If the paths have the same length, then it means that they are identical, so the positions are same.\n        if (this.path.length === otherPosition.path.length) {\n            return true;\n        }\n        // If positions have different length of paths, then the common part is the same.\n        // In this case, the \"shorter\" position is on the left, the \"longer\" position is on the right.\n        //\n        // If the positions are touching, the \"longer\" position must have only zeroes. For example:\n        // [ 1, 2 ] vs [ 1, 2, 0 ]\n        // [ 1, 2 ] vs [ 1, 2, 0, 0, 0 ]\n        else if (this.path.length > otherPosition.path.length) {\n            return checkOnlyZeroes(this.path, commonLevel);\n        }\n        else {\n            return checkOnlyZeroes(otherPosition.path, commonLevel);\n        }\n    }\n    /**\n     * Checks if two positions are in the same parent.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} position Position to compare with.\n     * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n     */\n    hasSameParentAs(position) {\n        if (this.root !== position.root) {\n            return false;\n        }\n        const thisParentPath = this.getParentPath();\n        const posParentPath = position.getParentPath();\n        return compareArrays(thisParentPath, posParentPath) == 'same';\n    }\n    /**\n     * Returns a copy of this position that is transformed by given `operation`.\n     *\n     * The new position's parameters are updated accordingly to the effect of the `operation`.\n     *\n     * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n     * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n     * @returns {module:engine/model/position~Position} Transformed position.\n     */\n    getTransformedByOperation(operation) {\n        let result;\n        switch (operation.type) {\n            case 'insert':\n                result = this._getTransformedByInsertOperation(operation);\n                break;\n            case 'move':\n            case 'remove':\n            case 'reinsert':\n                result = this._getTransformedByMoveOperation(operation);\n                break;\n            case 'split':\n                result = this._getTransformedBySplitOperation(operation);\n                break;\n            case 'merge':\n                result = this._getTransformedByMergeOperation(operation);\n                break;\n            default:\n                result = Position._createAt(this);\n                break;\n        }\n        return result;\n    }\n    /**\n     * Returns a copy of this position transformed by an insert operation.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n    _getTransformedByInsertOperation(operation) {\n        return this._getTransformedByInsertion(operation.position, operation.howMany);\n    }\n    /**\n     * Returns a copy of this position transformed by a move operation.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n    _getTransformedByMoveOperation(operation) {\n        return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);\n    }\n    /**\n     * Returns a copy of this position transformed by a split operation.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n    _getTransformedBySplitOperation(operation) {\n        const movedRange = operation.movedRange;\n        const isContained = movedRange.containsPosition(this) ||\n            (movedRange.start.isEqual(this) && this.stickiness == 'toNext');\n        if (isContained) {\n            return this._getCombined(operation.splitPosition, operation.moveTargetPosition);\n        }\n        else {\n            if (operation.graveyardPosition) {\n                return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);\n            }\n            else {\n                return this._getTransformedByInsertion(operation.insertionPosition, 1);\n            }\n        }\n    }\n    /**\n     * Returns a copy of this position transformed by merge operation.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n    _getTransformedByMergeOperation(operation) {\n        const movedRange = operation.movedRange;\n        const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);\n        let pos;\n        if (isContained) {\n            pos = this._getCombined(operation.sourcePosition, operation.targetPosition);\n            if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n                // Above happens during OT when the merged element is moved before the merged-to element.\n                pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);\n            }\n        }\n        else if (this.isEqual(operation.deletionPosition)) {\n            pos = Position._createAt(operation.deletionPosition);\n        }\n        else {\n            pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);\n        }\n        return pos;\n    }\n    /**\n     * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n     * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n     * @param {Number} howMany How many nodes are removed.\n     * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n     */\n    _getTransformedByDeletion(deletePosition, howMany) {\n        const transformed = Position._createAt(this);\n        // This position can't be affected if deletion was in a different root.\n        if (this.root != deletePosition.root) {\n            return transformed;\n        }\n        if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'same') {\n            // If nodes are removed from the node that is pointed by this position...\n            if (deletePosition.offset < this.offset) {\n                // And are removed from before an offset of that position...\n                if (deletePosition.offset + howMany > this.offset) {\n                    // Position is in removed range, it's no longer in the tree.\n                    return null;\n                }\n                else {\n                    // Decrement the offset accordingly.\n                    transformed.offset -= howMany;\n                }\n            }\n        }\n        else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'prefix') {\n            // If nodes are removed from a node that is on a path to this position...\n            const i = deletePosition.path.length - 1;\n            if (deletePosition.offset <= this.path[i]) {\n                // And are removed from before next node of that path...\n                if (deletePosition.offset + howMany > this.path[i]) {\n                    // If the next node of that path is removed return null\n                    // because the node containing this position got removed.\n                    return null;\n                }\n                else {\n                    // Otherwise, decrement index on that path.\n                    transformed.path[i] -= howMany;\n                }\n            }\n        }\n        return transformed;\n    }\n    /**\n     * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n     * @param {Number} howMany How many nodes are inserted.\n     * @returns {module:engine/model/position~Position} Transformed position.\n     */\n    _getTransformedByInsertion(insertPosition, howMany) {\n        const transformed = Position._createAt(this);\n        // This position can't be affected if insertion was in a different root.\n        if (this.root != insertPosition.root) {\n            return transformed;\n        }\n        if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'same') {\n            // If nodes are inserted in the node that is pointed by this position...\n            if (insertPosition.offset < this.offset || (insertPosition.offset == this.offset && this.stickiness != 'toPrevious')) {\n                // And are inserted before an offset of that position...\n                // \"Push\" this positions offset.\n                transformed.offset += howMany;\n            }\n        }\n        else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'prefix') {\n            // If nodes are inserted in a node that is on a path to this position...\n            const i = insertPosition.path.length - 1;\n            if (insertPosition.offset <= this.path[i]) {\n                // And are inserted before next node of that path...\n                // \"Push\" the index on that path.\n                transformed.path[i] += howMany;\n            }\n        }\n        return transformed;\n    }\n    /**\n     * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n     * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n     * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n     * @returns {module:engine/model/position~Position} Transformed position.\n     */\n    _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n        // Update target position, as it could be affected by nodes removal.\n        targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n        if (sourcePosition.isEqual(targetPosition)) {\n            // If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n            return Position._createAt(this);\n        }\n        // Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n        const transformed = this._getTransformedByDeletion(sourcePosition, howMany);\n        const isMoved = transformed === null ||\n            (sourcePosition.isEqual(this) && this.stickiness == 'toNext') ||\n            (sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == 'toPrevious');\n        if (isMoved) {\n            // This position is inside moved range (or sticks to it).\n            // In this case, we calculate a combination of this position, move source position and target position.\n            return this._getCombined(sourcePosition, targetPosition);\n        }\n        else {\n            // This position is not inside a removed range.\n            //\n            // In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n            return transformed._getTransformedByInsertion(targetPosition, howMany);\n        }\n    }\n    /**\n     * Returns a new position that is a combination of this position and given positions.\n     *\n     * The combined position is a copy of this position transformed by moving a range starting at `source` position\n     * to the `target` position. It is expected that this position is inside the moved range.\n     *\n     * Example:\n     *\n     *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n     *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n     *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n     *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n     *\n     * Explanation:\n     *\n     * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n     * was inside moved nodes and now should point to the new place. The moved nodes will be after\n     * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n     * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n     * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n     * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} source Beginning of the moved range.\n     * @param {module:engine/model/position~Position} target Position where the range is moved.\n     * @returns {module:engine/model/position~Position} Combined position.\n     */\n    _getCombined(source, target) {\n        const i = source.path.length - 1;\n        // The first part of a path to combined position is a path to the place where nodes were moved.\n        const combined = Position._createAt(target);\n        combined.stickiness = this.stickiness;\n        // Then we have to update the rest of the path.\n        // Fix the offset because this position might be after `from` position and we have to reflect that.\n        combined.offset = combined.offset + this.path[i] - source.offset;\n        // Then, add the rest of the path.\n        // If this position is at the same level as `from` position nothing will get added.\n        combined.path = [...combined.path, ...this.path.slice(i + 1)];\n        return combined;\n    }\n    /**\n     * @inheritDoc\n     */\n    toJSON() {\n        return {\n            root: this.root.toJSON(),\n            path: Array.from(this.path),\n            stickiness: this.stickiness\n        };\n    }\n    /**\n     * Returns a new position that is equal to current position.\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n    clone() {\n        return new this.constructor(this.root, this.path, this.stickiness);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/model/position~Position position},\n     * * parent element and offset (offset defaults to `0`),\n     * * parent element and `'end'` (sets position at the end of that element),\n     * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n     *\n     * This method is a shortcut to other factory methods such as:\n     *\n     * * {@link module:engine/model/position~Position._createBefore},\n     * * {@link module:engine/model/position~Position._createAfter}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     * @protected\n     * @internal\n     */\n    static _createAt(itemOrPosition, offset, stickiness = 'toNone') {\n        if (itemOrPosition instanceof Position) {\n            return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);\n        }\n        else {\n            const node = itemOrPosition;\n            if (offset == 'end') {\n                offset = node.maxOffset;\n            }\n            else if (offset == 'before') {\n                return this._createBefore(node, stickiness);\n            }\n            else if (offset == 'after') {\n                return this._createAfter(node, stickiness);\n            }\n            else if (offset !== 0 && !offset) {\n                /**\n                 * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n                 * requires the offset to be specified when the first parameter is a model item.\n                 *\n                 * @error model-createpositionat-offset-required\n                 */\n                throw new CKEditorError('model-createpositionat-offset-required', [this, itemOrPosition]);\n            }\n            if (!node.is('element') && !node.is('documentFragment')) {\n                /**\n                 * Position parent have to be a model element or model document fragment.\n                 *\n                 * @error model-position-parent-incorrect\n                 */\n                throw new CKEditorError('model-position-parent-incorrect', [this, itemOrPosition]);\n            }\n            const path = node.getPath();\n            path.push(offset);\n            return new this(node.root, path, stickiness);\n        }\n    }\n    /**\n     * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * @returns {module:engine/model/position~Position}\n     * @protected\n     * @internal\n     */\n    static _createAfter(item, stickiness) {\n        if (!item.parent) {\n            /**\n             * You can not make a position after a root element.\n             *\n             * @error model-position-after-root\n             * @param {module:engine/model/item~Item} root\n             */\n            throw new CKEditorError('model-position-after-root', [this, item], { root: item });\n        }\n        return this._createAt(item.parent, item.endOffset, stickiness);\n    }\n    /**\n     * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n     *\n     * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * @returns {module:engine/model/position~Position}\n     * @protected\n     * @internal\n     */\n    static _createBefore(item, stickiness) {\n        if (!item.parent) {\n            /**\n             * You can not make a position before a root element.\n             *\n             * @error model-position-before-root\n             * @param {module:engine/model/item~Item} root\n             */\n            throw new CKEditorError('model-position-before-root', item, { root: item });\n        }\n        return this._createAt(item.parent, item.startOffset, stickiness);\n    }\n    /**\n     * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n     *\n     * @param {Object} json Plain object to be converted to `Position`.\n     * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n     * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n     */\n    static fromJSON(json, doc) {\n        if (json.root === '$graveyard') {\n            const pos = new Position(doc.graveyard, json.path);\n            pos.stickiness = json.stickiness;\n            return pos;\n        }\n        if (!doc.getRoot(json.root)) {\n            /**\n             * Cannot create position for document. Root with specified name does not exist.\n             *\n             * @error model-position-fromjson-no-root\n             * @param {String} rootName\n             */\n            throw new CKEditorError('model-position-fromjson-no-root', doc, { rootName: json.root });\n        }\n        return new Position(doc.getRoot(json.root), json.path, json.stickiness);\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tposition.is( 'position' ); // -> true\n *\t\tposition.is( 'model:position' ); // -> true\n *\n *\t\tposition.is( 'view:position' ); // -> false\n *\t\tposition.is( 'documentSelection' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nPosition.prototype.is = function (type) {\n    return type === 'position' || type === 'model:position';\n};\n/**\n * Returns a text node at the given position.\n *\n * This is a helper function optimized to reuse the position parent instance for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#textNode `Position#textNode`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`}\n * check if your algorithm does not access it multiple times (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getNodeAfterPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @returns {module:engine/model/text~Text|null}\n */\nexport function getTextNodeAtPosition(position, positionParent) {\n    const node = positionParent.getChild(positionParent.offsetToIndex(position.offset));\n    if (node && node.is('$text') && node.startOffset < position.offset) {\n        return node;\n    }\n    return null;\n}\n/**\n * Returns the node after the given position.\n *\n * This is a helper function optimized to reuse the position parent instance and the calculation of the text node at the\n * specific position for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#nodeAfter `Position#nodeAfter`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`} and/or\n * {@link module:engine/model/position~Position#textNode `Position#textNode`}\n * check if your algorithm does not access those properties multiple times\n * (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579 and https://github.com/ckeditor/ckeditor5/issues/6582.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeAfterPosition(position, positionParent, textNode) {\n    if (textNode !== null) {\n        return null;\n    }\n    return positionParent.getChild(positionParent.offsetToIndex(position.offset));\n}\n/**\n * Returns the node before the given position.\n *\n * Refer to {@link module:engine/model/position~getNodeBeforePosition} for documentation on when to use this util method.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeAfterPosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeBeforePosition(position, positionParent, textNode) {\n    if (textNode !== null) {\n        return null;\n    }\n    return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);\n}\n// This is a helper function for `Position#isTouching()`.\n//\n// It checks whether to given positions are touching, considering that they have the same root and paths\n// until given level, and at given level they differ by 1 (so they are branching at `level` point).\n//\n// The exact requirements for touching positions are described in `Position#isTouching()` and also\n// in the body of this function.\n//\n// @param {module:engine/model/position~Position} left Position \"on the left\" (it is before `right`).\n// @param {module:engine/model/position~Position} right Position \"on the right\" (it is after `left`).\n// @param {Number} level Level on which the positions are different.\n// @returns {Boolean}\nfunction checkTouchingBranch(left, right, level) {\n    if (level + 1 === left.path.length) {\n        // Left position does not have any more entries after the point where the positions differ.\n        // [ 2 ] vs [ 3 ]\n        // [ 2 ] vs [ 3, 0, 0 ]\n        // The positions are spread by node at [ 2 ].\n        return false;\n    }\n    if (!checkOnlyZeroes(right.path, level + 1)) {\n        // Right position does not have only zeroes, so we have situation like:\n        // [ 2, maxOffset ] vs [ 3, 1 ]\n        // [ 2, maxOffset ] vs [ 3, 1, 0, 0 ]\n        // The positions are spread by node at [ 3, 0 ].\n        return false;\n    }\n    if (!checkOnlyMaxOffset(left, level + 1)) {\n        // Left position does not have only max offsets, so we have situation like:\n        // [ 2, 4 ] vs [ 3 ]\n        // [ 2, 4 ] vs [ 3, 0, 0 ]\n        // The positions are spread by node at [ 2, 5 ].\n        return false;\n    }\n    // Left position has only max offsets and right position has only zeroes or nothing.\n    // [ 2, maxOffset ] vs [ 3 ]\n    // [ 2, maxOffset, maxOffset ] vs [ 3, 0 ]\n    // There are not elements between positions. The positions are touching.\n    return true;\n}\n// Checks whether for given array, starting from given index until the end of the array, all items are `0`s.\n//\n// This is a helper function for `Position#isTouching()`.\n//\n// @private\n// @param {Array.<Number>} arr Array to check.\n// @param {Number} idx Index to start checking from.\n// @returns {Boolean}\nfunction checkOnlyZeroes(arr, idx) {\n    while (idx < arr.length) {\n        if (arr[idx] !== 0) {\n            return false;\n        }\n        idx++;\n    }\n    return true;\n}\n// Checks whether for given position, starting from given path level, whether the position is at the end of\n// its parent and whether each element on the path to the position is also at at the end of its parent.\n//\n// This is a helper function for `Position#isTouching()`.\n//\n// @private\n// @param {module:engine/model/position~Position} pos Position to check.\n// @param {Number} level Level to start checking from.\n// @returns {Boolean}\nfunction checkOnlyMaxOffset(pos, level) {\n    let parent = pos.parent;\n    let idx = pos.path.length - 1;\n    let add = 0;\n    while (idx >= level) {\n        if (pos.path[idx] + add !== parent.maxOffset) {\n            return false;\n        }\n        // After the first check, we \"go up\", and check whether the position's parent-parent is the last element.\n        // However, we need to add 1 to the value in the path to \"simulate\" moving the path after the parent.\n        // It happens just once.\n        add = 1;\n        idx--;\n        parent = parent.parent;\n    }\n    return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}