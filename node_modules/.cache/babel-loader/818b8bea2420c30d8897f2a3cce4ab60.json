{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/position\n */\nimport TypeCheckable from './typecheckable';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EditableElement from './editableelement';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\nimport { default as TreeWalker } from './treewalker';\n/**\n * Position in the view tree. Position is represented by its parent node and an offset in this parent.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Position extends TypeCheckable {\n  /**\n   * Creates a position.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} parent Position parent.\n   * @param {Number} offset Position offset.\n   */\n  constructor(parent, offset) {\n    super();\n    /**\n     * Position parent.\n     *\n     * @readonly\n     * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n     * module:engine/view/position~Position#parent\n     */\n    this.parent = parent;\n    /**\n     * Position offset.\n     *\n     * @readonly\n     * @member {Number} module:engine/view/position~Position#offset\n     */\n    this.offset = offset;\n  }\n  /**\n   * Node directly after the position. Equals `null` when there is no node after position or position is located\n   * inside text node.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|null}\n   */\n  get nodeAfter() {\n    if (this.parent.is('$text')) {\n      return null;\n    }\n    return this.parent.getChild(this.offset) || null;\n  }\n  /**\n   * Node directly before the position. Equals `null` when there is no node before position or position is located\n   * inside text node.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|null}\n   */\n  get nodeBefore() {\n    if (this.parent.is('$text')) {\n      return null;\n    }\n    return this.parent.getChild(this.offset - 1) || null;\n  }\n  /**\n   * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isAtStart() {\n    return this.offset === 0;\n  }\n  /**\n   * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isAtEnd() {\n    const endOffset = this.parent.is('$text') ? this.parent.data.length : this.parent.childCount;\n    return this.offset === endOffset;\n  }\n  /**\n   * Position's root, that is the root of the position's parent element.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n   */\n  get root() {\n    return this.parent.root;\n  }\n  /**\n   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if\n   * position is not inside an editable element.\n   *\n   * @type {module:engine/view/editableelement~EditableElement|null}\n   */\n  get editableElement() {\n    let editable = this.parent;\n    while (!(editable instanceof EditableElement)) {\n      if (editable.parent) {\n        editable = editable.parent;\n      } else {\n        return null;\n      }\n    }\n    return editable;\n  }\n  /**\n   * Returns a new instance of Position with offset incremented by `shift` value.\n   *\n   * @param {Number} shift How position offset should get changed. Accepts negative values.\n   * @returns {module:engine/view/position~Position} Shifted position.\n   */\n  getShiftedBy(shift) {\n    const shifted = Position._createAt(this);\n    const offset = shifted.offset + shift;\n    shifted.offset = offset < 0 ? 0 : offset;\n    return shifted;\n  }\n  /**\n   * Gets the farthest position which matches the callback using\n   * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.\n   *\n   * For example:\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n   * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>\n   * \t\tgetLastMatchingPosition( value => false ); // Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~type TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   *\n   * @returns {module:engine/view/position~Position} The position after the last item which matches the `skip` callback test.\n   */\n  getLastMatchingPosition(skip) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.startPosition = this;\n    const treeWalker = new TreeWalker(options);\n    treeWalker.skip(skip);\n    return treeWalker.position;\n  }\n  /**\n   * Returns ancestors array of this position, that is this position's parent and it's ancestors.\n   *\n   * @returns {Array} Array with ancestors.\n   */\n  getAncestors() {\n    if (this.parent.is('documentFragment')) {\n      return [this.parent];\n    } else {\n      return this.parent.getAncestors({\n        includeSelf: true\n      });\n    }\n  }\n  /**\n   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n   * which is a common ancestor of both positions.\n   *\n   * @param {module:engine/view/position~Position} position\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n   */\n  getCommonAncestor(position) {\n    const ancestorsA = this.getAncestors();\n    const ancestorsB = position.getAncestors();\n    let i = 0;\n    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n      i++;\n    }\n    return i === 0 ? null : ancestorsA[i - 1];\n  }\n  /**\n   * Checks whether this position equals given position.\n   *\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions are same.\n   */\n  isEqual(otherPosition) {\n    return this.parent == otherPosition.parent && this.offset == otherPosition.offset;\n  }\n  /**\n   * Checks whether this position is located before given position. When method returns `false` it does not mean that\n   * this position is after give one. Two positions may be located inside separate roots and in that situation this\n   * method will still return `false`.\n   *\n   * @see module:engine/view/position~Position#isAfter\n   * @see module:engine/view/position~Position#compareWith\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} Returns `true` if this position is before given position.\n   */\n  isBefore(otherPosition) {\n    return this.compareWith(otherPosition) == 'before';\n  }\n  /**\n   * Checks whether this position is located after given position. When method returns `false` it does not mean that\n   * this position is before give one. Two positions may be located inside separate roots and in that situation this\n   * method will still return `false`.\n   *\n   * @see module:engine/view/position~Position#isBefore\n   * @see module:engine/view/position~Position#compareWith\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} Returns `true` if this position is after given position.\n   */\n  isAfter(otherPosition) {\n    return this.compareWith(otherPosition) == 'after';\n  }\n  /**\n   * Checks whether this position is before, after or in same position that other position. Two positions may be also\n   * different when they are located in separate roots.\n   *\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {module:engine/view/position~PositionRelation}\n   */\n  compareWith(otherPosition) {\n    if (this.root !== otherPosition.root) {\n      return 'different';\n    }\n    if (this.isEqual(otherPosition)) {\n      return 'same';\n    }\n    // Get path from root to position's parent element.\n    const thisPath = this.parent.is('node') ? this.parent.getPath() : [];\n    const otherPath = otherPosition.parent.is('node') ? otherPosition.parent.getPath() : [];\n    // Add the positions' offsets to the parents offsets.\n    thisPath.push(this.offset);\n    otherPath.push(otherPosition.offset);\n    // Compare both path arrays to find common ancestor.\n    const result = compareArrays(thisPath, otherPath);\n    switch (result) {\n      case 'prefix':\n        return 'before';\n      case 'extension':\n        return 'after';\n      default:\n        return thisPath[result] < otherPath[result] ? 'before' : 'after';\n    }\n  }\n  /**\n   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}\n   * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n   * @param {Boolean} [options.singleCharacters=false]\n   * @param {Boolean} [options.shallow=false]\n   * @param {Boolean} [options.ignoreElementEnd=false]\n   */\n  getWalker() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.startPosition = this;\n    return new TreeWalker(options);\n  }\n  clone() {\n    return new Position(this.parent, this.offset);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/view/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n   *\n   * This method is a shortcut to other constructors such as:\n   *\n   * * {@link module:engine/view/position~Position._createBefore},\n   * * {@link module:engine/view/position~Position._createAfter}.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n  static _createAt(itemOrPosition, offset) {\n    if (itemOrPosition instanceof Position) {\n      return new this(itemOrPosition.parent, itemOrPosition.offset);\n    } else {\n      const node = itemOrPosition;\n      if (offset == 'end') {\n        offset = node.is('$text') ? node.data.length : node.childCount;\n      } else if (offset == 'before') {\n        return this._createBefore(node);\n      } else if (offset == 'after') {\n        return this._createAfter(node);\n      } else if (offset !== 0 && !offset) {\n        /**\n         * {@link module:engine/view/view~View#createPositionAt `View#createPositionAt()`}\n         * requires the offset to be specified when the first parameter is a view item.\n         *\n         * @error view-createpositionat-offset-required\n         */\n        throw new CKEditorError('view-createpositionat-offset-required', node);\n      }\n      return new Position(node, offset);\n    }\n  }\n  /**\n   * Creates a new position after given view item.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item} item View item after which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n  static _createAfter(item) {\n    // TextProxy is not a instance of Node so we need do handle it in specific way.\n    if (item.is('$textProxy')) {\n      return new Position(item.textNode, item.offsetInText + item.data.length);\n    }\n    if (!item.parent) {\n      /**\n       * You can not make a position after a root.\n       *\n       * @error view-position-after-root\n       * @param {module:engine/view/node~Node} root\n       */\n      throw new CKEditorError('view-position-after-root', item, {\n        root: item\n      });\n    }\n    return new Position(item.parent, item.index + 1);\n  }\n  /**\n   * Creates a new position before given view item.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item} item View item before which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n  static _createBefore(item) {\n    // TextProxy is not a instance of Node so we need do handle it in specific way.\n    if (item.is('$textProxy')) {\n      return new Position(item.textNode, item.offsetInText);\n    }\n    if (!item.parent) {\n      /**\n       * You cannot make a position before a root.\n       *\n       * @error view-position-before-root\n       * @param {module:engine/view/node~Node} root\n       */\n      throw new CKEditorError('view-position-before-root', item, {\n        root: item\n      });\n    }\n    return new Position(item.parent, item.index);\n  }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tposition.is( 'position' ); // -> true\n *\t\tposition.is( 'view:position' ); // -> true\n *\n *\t\tposition.is( 'model:position' ); // -> false\n *\t\tposition.is( 'element' ); // -> false\n *\t\tposition.is( 'range' ); // -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nPosition.prototype.is = function (type) {\n  return type === 'position' || type === 'view:position';\n};","map":{"version":3,"names":["TypeCheckable","compareArrays","CKEditorError","EditableElement","default","TreeWalker","Position","constructor","parent","offset","nodeAfter","is","getChild","nodeBefore","isAtStart","isAtEnd","endOffset","data","length","childCount","root","editableElement","editable","getShiftedBy","shift","shifted","_createAt","getLastMatchingPosition","skip","options","startPosition","treeWalker","position","getAncestors","includeSelf","getCommonAncestor","ancestorsA","ancestorsB","i","isEqual","otherPosition","isBefore","compareWith","isAfter","thisPath","getPath","otherPath","push","result","getWalker","clone","itemOrPosition","node","_createBefore","_createAfter","item","textNode","offsetInText","index","prototype","type"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/position.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/position\n */\nimport TypeCheckable from './typecheckable';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EditableElement from './editableelement';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\nimport { default as TreeWalker } from './treewalker';\n/**\n * Position in the view tree. Position is represented by its parent node and an offset in this parent.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Position extends TypeCheckable {\n    /**\n     * Creates a position.\n     *\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} parent Position parent.\n     * @param {Number} offset Position offset.\n     */\n    constructor(parent, offset) {\n        super();\n        /**\n         * Position parent.\n         *\n         * @readonly\n         * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n         * module:engine/view/position~Position#parent\n         */\n        this.parent = parent;\n        /**\n         * Position offset.\n         *\n         * @readonly\n         * @member {Number} module:engine/view/position~Position#offset\n         */\n        this.offset = offset;\n    }\n    /**\n     * Node directly after the position. Equals `null` when there is no node after position or position is located\n     * inside text node.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|null}\n     */\n    get nodeAfter() {\n        if (this.parent.is('$text')) {\n            return null;\n        }\n        return this.parent.getChild(this.offset) || null;\n    }\n    /**\n     * Node directly before the position. Equals `null` when there is no node before position or position is located\n     * inside text node.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|null}\n     */\n    get nodeBefore() {\n        if (this.parent.is('$text')) {\n            return null;\n        }\n        return this.parent.getChild(this.offset - 1) || null;\n    }\n    /**\n     * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isAtStart() {\n        return this.offset === 0;\n    }\n    /**\n     * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isAtEnd() {\n        const endOffset = this.parent.is('$text') ? this.parent.data.length : this.parent.childCount;\n        return this.offset === endOffset;\n    }\n    /**\n     * Position's root, that is the root of the position's parent element.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n     */\n    get root() {\n        return this.parent.root;\n    }\n    /**\n     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if\n     * position is not inside an editable element.\n     *\n     * @type {module:engine/view/editableelement~EditableElement|null}\n     */\n    get editableElement() {\n        let editable = this.parent;\n        while (!(editable instanceof EditableElement)) {\n            if (editable.parent) {\n                editable = editable.parent;\n            }\n            else {\n                return null;\n            }\n        }\n        return editable;\n    }\n    /**\n     * Returns a new instance of Position with offset incremented by `shift` value.\n     *\n     * @param {Number} shift How position offset should get changed. Accepts negative values.\n     * @returns {module:engine/view/position~Position} Shifted position.\n     */\n    getShiftedBy(shift) {\n        const shifted = Position._createAt(this);\n        const offset = shifted.offset + shift;\n        shifted.offset = offset < 0 ? 0 : offset;\n        return shifted;\n    }\n    /**\n     * Gets the farthest position which matches the callback using\n     * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.\n     *\n     * For example:\n     *\n     * \t\tgetLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n     * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>\n     * \t\tgetLastMatchingPosition( value => false ); // Do not move the position.\n     *\n     * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~type TreeWalkerValue} and should\n     * return `true` if the value should be skipped or `false` if not.\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n     *\n     * @returns {module:engine/view/position~Position} The position after the last item which matches the `skip` callback test.\n     */\n    getLastMatchingPosition(skip, options = {}) {\n        options.startPosition = this;\n        const treeWalker = new TreeWalker(options);\n        treeWalker.skip(skip);\n        return treeWalker.position;\n    }\n    /**\n     * Returns ancestors array of this position, that is this position's parent and it's ancestors.\n     *\n     * @returns {Array} Array with ancestors.\n     */\n    getAncestors() {\n        if (this.parent.is('documentFragment')) {\n            return [this.parent];\n        }\n        else {\n            return this.parent.getAncestors({ includeSelf: true });\n        }\n    }\n    /**\n     * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n     * which is a common ancestor of both positions.\n     *\n     * @param {module:engine/view/position~Position} position\n     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n     */\n    getCommonAncestor(position) {\n        const ancestorsA = this.getAncestors();\n        const ancestorsB = position.getAncestors();\n        let i = 0;\n        while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n            i++;\n        }\n        return i === 0 ? null : ancestorsA[i - 1];\n    }\n    /**\n     * Checks whether this position equals given position.\n     *\n     * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if positions are same.\n     */\n    isEqual(otherPosition) {\n        return (this.parent == otherPosition.parent && this.offset == otherPosition.offset);\n    }\n    /**\n     * Checks whether this position is located before given position. When method returns `false` it does not mean that\n     * this position is after give one. Two positions may be located inside separate roots and in that situation this\n     * method will still return `false`.\n     *\n     * @see module:engine/view/position~Position#isAfter\n     * @see module:engine/view/position~Position#compareWith\n     * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} Returns `true` if this position is before given position.\n     */\n    isBefore(otherPosition) {\n        return this.compareWith(otherPosition) == 'before';\n    }\n    /**\n     * Checks whether this position is located after given position. When method returns `false` it does not mean that\n     * this position is before give one. Two positions may be located inside separate roots and in that situation this\n     * method will still return `false`.\n     *\n     * @see module:engine/view/position~Position#isBefore\n     * @see module:engine/view/position~Position#compareWith\n     * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} Returns `true` if this position is after given position.\n     */\n    isAfter(otherPosition) {\n        return this.compareWith(otherPosition) == 'after';\n    }\n    /**\n     * Checks whether this position is before, after or in same position that other position. Two positions may be also\n     * different when they are located in separate roots.\n     *\n     * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n     * @returns {module:engine/view/position~PositionRelation}\n     */\n    compareWith(otherPosition) {\n        if (this.root !== otherPosition.root) {\n            return 'different';\n        }\n        if (this.isEqual(otherPosition)) {\n            return 'same';\n        }\n        // Get path from root to position's parent element.\n        const thisPath = this.parent.is('node') ? this.parent.getPath() : [];\n        const otherPath = otherPosition.parent.is('node') ? otherPosition.parent.getPath() : [];\n        // Add the positions' offsets to the parents offsets.\n        thisPath.push(this.offset);\n        otherPath.push(otherPosition.offset);\n        // Compare both path arrays to find common ancestor.\n        const result = compareArrays(thisPath, otherPath);\n        switch (result) {\n            case 'prefix':\n                return 'before';\n            case 'extension':\n                return 'after';\n            default:\n                return thisPath[result] < otherPath[result] ? 'before' : 'after';\n        }\n    }\n    /**\n     * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}\n     * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n     * @param {Boolean} [options.singleCharacters=false]\n     * @param {Boolean} [options.shallow=false]\n     * @param {Boolean} [options.ignoreElementEnd=false]\n     */\n    getWalker(options = {}) {\n        options.startPosition = this;\n        return new TreeWalker(options);\n    }\n    clone() {\n        return new Position(this.parent, this.offset);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/view/position~Position position},\n     * * parent element and offset (offset defaults to `0`),\n     * * parent element and `'end'` (sets position at the end of that element),\n     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n     *\n     * This method is a shortcut to other constructors such as:\n     *\n     * * {@link module:engine/view/position~Position._createBefore},\n     * * {@link module:engine/view/position~Position._createAfter}.\n     *\n     * @protected\n     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n    static _createAt(itemOrPosition, offset) {\n        if (itemOrPosition instanceof Position) {\n            return new this(itemOrPosition.parent, itemOrPosition.offset);\n        }\n        else {\n            const node = itemOrPosition;\n            if (offset == 'end') {\n                offset = node.is('$text') ? node.data.length : node.childCount;\n            }\n            else if (offset == 'before') {\n                return this._createBefore(node);\n            }\n            else if (offset == 'after') {\n                return this._createAfter(node);\n            }\n            else if (offset !== 0 && !offset) {\n                /**\n                 * {@link module:engine/view/view~View#createPositionAt `View#createPositionAt()`}\n                 * requires the offset to be specified when the first parameter is a view item.\n                 *\n                 * @error view-createpositionat-offset-required\n                 */\n                throw new CKEditorError('view-createpositionat-offset-required', node);\n            }\n            return new Position(node, offset);\n        }\n    }\n    /**\n     * Creates a new position after given view item.\n     *\n     * @protected\n     * @param {module:engine/view/item~Item} item View item after which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n    static _createAfter(item) {\n        // TextProxy is not a instance of Node so we need do handle it in specific way.\n        if (item.is('$textProxy')) {\n            return new Position(item.textNode, item.offsetInText + item.data.length);\n        }\n        if (!item.parent) {\n            /**\n             * You can not make a position after a root.\n             *\n             * @error view-position-after-root\n             * @param {module:engine/view/node~Node} root\n             */\n            throw new CKEditorError('view-position-after-root', item, { root: item });\n        }\n        return new Position(item.parent, item.index + 1);\n    }\n    /**\n     * Creates a new position before given view item.\n     *\n     * @protected\n     * @param {module:engine/view/item~Item} item View item before which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n    static _createBefore(item) {\n        // TextProxy is not a instance of Node so we need do handle it in specific way.\n        if (item.is('$textProxy')) {\n            return new Position(item.textNode, item.offsetInText);\n        }\n        if (!item.parent) {\n            /**\n             * You cannot make a position before a root.\n             *\n             * @error view-position-before-root\n             * @param {module:engine/view/node~Node} root\n             */\n            throw new CKEditorError('view-position-before-root', item, { root: item });\n        }\n        return new Position(item.parent, item.index);\n    }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tposition.is( 'position' ); // -> true\n *\t\tposition.is( 'view:position' ); // -> true\n *\n *\t\tposition.is( 'model:position' ); // -> false\n *\t\tposition.is( 'element' ); // -> false\n *\t\tposition.is( 'range' ); // -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nPosition.prototype.is = function (type) {\n    return type === 'position' || type === 'view:position';\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}