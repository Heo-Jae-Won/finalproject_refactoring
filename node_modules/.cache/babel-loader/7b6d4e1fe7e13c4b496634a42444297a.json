{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/getselectedcontent\n */\n/**\n * Gets a clone of the selected content.\n *\n * For example, for the following selection:\n *\n * ```html\n * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n * ```\n *\n * It will return a document fragment with such a content:\n *\n * ```html\n * <quote><h>st</h></quote><p>se</p>\n * ```\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection of which content will be returned.\n * @returns {module:engine/model/documentfragment~DocumentFragment}\n */\nexport default function getSelectedContent(model, selection) {\n  return model.change(writer => {\n    const frag = writer.createDocumentFragment();\n    const range = selection.getFirstRange();\n    if (!range || range.isCollapsed) {\n      return frag;\n    }\n    const root = range.start.root;\n    const commonPath = range.start.getCommonPath(range.end);\n    const commonParent = root.getNodeByPath(commonPath);\n    // ## 1st step\n    //\n    // First, we'll clone a fragment represented by a minimal flat range\n    // containing the original range to be cloned.\n    // E.g. let's consider such a range:\n    //\n    // <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n    //\n    // A minimal flat range containing this one is:\n    //\n    // <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>\n    //\n    // We can easily clone this structure, preserving e.g. the <quote> element.\n    let flatSubtreeRange;\n    if (range.start.parent == range.end.parent) {\n      // The original range is flat, so take it.\n      flatSubtreeRange = range;\n    } else {\n      flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));\n    }\n    const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;\n    // Clone the whole contents.\n    for (const item of flatSubtreeRange.getItems({\n      shallow: true\n    })) {\n      if (item.is('$textProxy')) {\n        writer.appendText(item.data, item.getAttributes(), frag);\n      } else {\n        writer.append(writer.cloneElement(item, true), frag);\n      }\n    }\n    // ## 2nd step\n    //\n    // If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.\n    //\n    // For example, for the range shown in the 1st step comment, we need to remove these pieces:\n    //\n    // <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>\n    //\n    // So this will be the final copied content:\n    //\n    // <quote><h>st</h></quote><p>se</p>\n    //\n    // In order to do that, we remove content from these two ranges:\n    //\n    // [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]\n    if (flatSubtreeRange != range) {\n      // Find the position of the original range in the cloned fragment.\n      const newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];\n      const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);\n      const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, 'end'));\n      removeRangeContent(rightExcessRange, writer);\n      removeRangeContent(leftExcessRange, writer);\n    }\n    return frag;\n  });\n}\n// After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,\n// this function will, most likely, be able to rewritten using getMinimalFlatRanges().\nfunction removeRangeContent(range, writer) {\n  const parentsToCheck = [];\n  Array.from(range.getItems({\n    direction: 'backward'\n  }))\n  // We should better store ranges because text proxies will lose integrity\n  // with the text nodes when we'll start removing content.\n  .map(item => writer.createRangeOn(item))\n  // Filter only these items which are fully contained in the passed range.\n  //\n  // E.g. for the following range: [<quote><p>y</p><h>fir]st</h>\n  // the walker will return the entire <h> element, when only the \"fir\" item inside it is fully contained.\n  .filter(itemRange => {\n    // We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.\n    const contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) && (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));\n    return contained;\n  }).forEach(itemRange => {\n    parentsToCheck.push(itemRange.start.parent);\n    writer.remove(itemRange);\n  });\n  // Remove ancestors of the removed items if they turned to be empty now\n  // (their whole content was contained in the range).\n  parentsToCheck.forEach(parentToCheck => {\n    let parent = parentToCheck;\n    while (parent.parent && parent.isEmpty) {\n      const removeRange = writer.createRangeOn(parent);\n      parent = parent.parent;\n      writer.remove(removeRange);\n    }\n  });\n}","map":{"version":3,"names":["getSelectedContent","model","selection","change","writer","frag","createDocumentFragment","range","getFirstRange","isCollapsed","root","start","commonPath","getCommonPath","end","commonParent","getNodeByPath","flatSubtreeRange","parent","createRange","createPositionAt","path","length","howMany","offset","item","getItems","shallow","is","appendText","data","getAttributes","append","cloneElement","newRange","_getTransformedByMove","leftExcessRange","rightExcessRange","removeRangeContent","parentsToCheck","Array","from","direction","map","createRangeOn","filter","itemRange","contained","isAfter","isEqual","isBefore","forEach","push","remove","parentToCheck","isEmpty","removeRange"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/getselectedcontent.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/getselectedcontent\n */\n/**\n * Gets a clone of the selected content.\n *\n * For example, for the following selection:\n *\n * ```html\n * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n * ```\n *\n * It will return a document fragment with such a content:\n *\n * ```html\n * <quote><h>st</h></quote><p>se</p>\n * ```\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection of which content will be returned.\n * @returns {module:engine/model/documentfragment~DocumentFragment}\n */\nexport default function getSelectedContent(model, selection) {\n    return model.change(writer => {\n        const frag = writer.createDocumentFragment();\n        const range = selection.getFirstRange();\n        if (!range || range.isCollapsed) {\n            return frag;\n        }\n        const root = range.start.root;\n        const commonPath = range.start.getCommonPath(range.end);\n        const commonParent = root.getNodeByPath(commonPath);\n        // ## 1st step\n        //\n        // First, we'll clone a fragment represented by a minimal flat range\n        // containing the original range to be cloned.\n        // E.g. let's consider such a range:\n        //\n        // <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n        //\n        // A minimal flat range containing this one is:\n        //\n        // <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>\n        //\n        // We can easily clone this structure, preserving e.g. the <quote> element.\n        let flatSubtreeRange;\n        if (range.start.parent == range.end.parent) {\n            // The original range is flat, so take it.\n            flatSubtreeRange = range;\n        }\n        else {\n            flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));\n        }\n        const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;\n        // Clone the whole contents.\n        for (const item of flatSubtreeRange.getItems({ shallow: true })) {\n            if (item.is('$textProxy')) {\n                writer.appendText(item.data, item.getAttributes(), frag);\n            }\n            else {\n                writer.append(writer.cloneElement(item, true), frag);\n            }\n        }\n        // ## 2nd step\n        //\n        // If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.\n        //\n        // For example, for the range shown in the 1st step comment, we need to remove these pieces:\n        //\n        // <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>\n        //\n        // So this will be the final copied content:\n        //\n        // <quote><h>st</h></quote><p>se</p>\n        //\n        // In order to do that, we remove content from these two ranges:\n        //\n        // [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]\n        if (flatSubtreeRange != range) {\n            // Find the position of the original range in the cloned fragment.\n            const newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];\n            const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);\n            const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, 'end'));\n            removeRangeContent(rightExcessRange, writer);\n            removeRangeContent(leftExcessRange, writer);\n        }\n        return frag;\n    });\n}\n// After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,\n// this function will, most likely, be able to rewritten using getMinimalFlatRanges().\nfunction removeRangeContent(range, writer) {\n    const parentsToCheck = [];\n    Array.from(range.getItems({ direction: 'backward' }))\n        // We should better store ranges because text proxies will lose integrity\n        // with the text nodes when we'll start removing content.\n        .map(item => writer.createRangeOn(item))\n        // Filter only these items which are fully contained in the passed range.\n        //\n        // E.g. for the following range: [<quote><p>y</p><h>fir]st</h>\n        // the walker will return the entire <h> element, when only the \"fir\" item inside it is fully contained.\n        .filter(itemRange => {\n        // We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.\n        const contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) &&\n            (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));\n        return contained;\n    })\n        .forEach(itemRange => {\n        parentsToCheck.push(itemRange.start.parent);\n        writer.remove(itemRange);\n    });\n    // Remove ancestors of the removed items if they turned to be empty now\n    // (their whole content was contained in the range).\n    parentsToCheck.forEach(parentToCheck => {\n        let parent = parentToCheck;\n        while (parent.parent && parent.isEmpty) {\n            const removeRange = writer.createRangeOn(parent);\n            parent = parent.parent;\n            writer.remove(removeRange);\n        }\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,kBAAkB,CAACC,KAAK,EAAEC,SAAS,EAAE;EACzD,OAAOD,KAAK,CAACE,MAAM,CAACC,MAAM,IAAI;IAC1B,MAAMC,IAAI,GAAGD,MAAM,CAACE,sBAAsB,EAAE;IAC5C,MAAMC,KAAK,GAAGL,SAAS,CAACM,aAAa,EAAE;IACvC,IAAI,CAACD,KAAK,IAAIA,KAAK,CAACE,WAAW,EAAE;MAC7B,OAAOJ,IAAI;IACf;IACA,MAAMK,IAAI,GAAGH,KAAK,CAACI,KAAK,CAACD,IAAI;IAC7B,MAAME,UAAU,GAAGL,KAAK,CAACI,KAAK,CAACE,aAAa,CAACN,KAAK,CAACO,GAAG,CAAC;IACvD,MAAMC,YAAY,GAAGL,IAAI,CAACM,aAAa,CAACJ,UAAU,CAAC;IACnD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIK,gBAAgB;IACpB,IAAIV,KAAK,CAACI,KAAK,CAACO,MAAM,IAAIX,KAAK,CAACO,GAAG,CAACI,MAAM,EAAE;MACxC;MACAD,gBAAgB,GAAGV,KAAK;IAC5B,CAAC,MACI;MACDU,gBAAgB,GAAGb,MAAM,CAACe,WAAW,CAACf,MAAM,CAACgB,gBAAgB,CAACL,YAAY,EAAER,KAAK,CAACI,KAAK,CAACU,IAAI,CAACT,UAAU,CAACU,MAAM,CAAC,CAAC,EAAElB,MAAM,CAACgB,gBAAgB,CAACL,YAAY,EAAER,KAAK,CAACO,GAAG,CAACO,IAAI,CAACT,UAAU,CAACU,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;IACnM;IACA,MAAMC,OAAO,GAAGN,gBAAgB,CAACH,GAAG,CAACU,MAAM,GAAGP,gBAAgB,CAACN,KAAK,CAACa,MAAM;IAC3E;IACA,KAAK,MAAMC,IAAI,IAAIR,gBAAgB,CAACS,QAAQ,CAAC;MAAEC,OAAO,EAAE;IAAK,CAAC,CAAC,EAAE;MAC7D,IAAIF,IAAI,CAACG,EAAE,CAAC,YAAY,CAAC,EAAE;QACvBxB,MAAM,CAACyB,UAAU,CAACJ,IAAI,CAACK,IAAI,EAAEL,IAAI,CAACM,aAAa,EAAE,EAAE1B,IAAI,CAAC;MAC5D,CAAC,MACI;QACDD,MAAM,CAAC4B,MAAM,CAAC5B,MAAM,CAAC6B,YAAY,CAACR,IAAI,EAAE,IAAI,CAAC,EAAEpB,IAAI,CAAC;MACxD;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIY,gBAAgB,IAAIV,KAAK,EAAE;MAC3B;MACA,MAAM2B,QAAQ,GAAG3B,KAAK,CAAC4B,qBAAqB,CAAClB,gBAAgB,CAACN,KAAK,EAAEP,MAAM,CAACgB,gBAAgB,CAACf,IAAI,EAAE,CAAC,CAAC,EAAEkB,OAAO,CAAC,CAAC,CAAC,CAAC;MAClH,MAAMa,eAAe,GAAGhC,MAAM,CAACe,WAAW,CAACf,MAAM,CAACgB,gBAAgB,CAACf,IAAI,EAAE,CAAC,CAAC,EAAE6B,QAAQ,CAACvB,KAAK,CAAC;MAC5F,MAAM0B,gBAAgB,GAAGjC,MAAM,CAACe,WAAW,CAACe,QAAQ,CAACpB,GAAG,EAAEV,MAAM,CAACgB,gBAAgB,CAACf,IAAI,EAAE,KAAK,CAAC,CAAC;MAC/FiC,kBAAkB,CAACD,gBAAgB,EAAEjC,MAAM,CAAC;MAC5CkC,kBAAkB,CAACF,eAAe,EAAEhC,MAAM,CAAC;IAC/C;IACA,OAAOC,IAAI;EACf,CAAC,CAAC;AACN;AACA;AACA;AACA,SAASiC,kBAAkB,CAAC/B,KAAK,EAAEH,MAAM,EAAE;EACvC,MAAMmC,cAAc,GAAG,EAAE;EACzBC,KAAK,CAACC,IAAI,CAAClC,KAAK,CAACmB,QAAQ,CAAC;IAAEgB,SAAS,EAAE;EAAW,CAAC,CAAC;EAChD;EACA;EAAA,CACCC,GAAG,CAAClB,IAAI,IAAIrB,MAAM,CAACwC,aAAa,CAACnB,IAAI,CAAC;EACvC;EACA;EACA;EACA;EAAA,CACCoB,MAAM,CAACC,SAAS,IAAI;IACrB;IACA,MAAMC,SAAS,GAAG,CAACD,SAAS,CAACnC,KAAK,CAACqC,OAAO,CAACzC,KAAK,CAACI,KAAK,CAAC,IAAImC,SAAS,CAACnC,KAAK,CAACsC,OAAO,CAAC1C,KAAK,CAACI,KAAK,CAAC,MAC1FmC,SAAS,CAAChC,GAAG,CAACoC,QAAQ,CAAC3C,KAAK,CAACO,GAAG,CAAC,IAAIgC,SAAS,CAAChC,GAAG,CAACmC,OAAO,CAAC1C,KAAK,CAACO,GAAG,CAAC,CAAC;IAC3E,OAAOiC,SAAS;EACpB,CAAC,CAAC,CACGI,OAAO,CAACL,SAAS,IAAI;IACtBP,cAAc,CAACa,IAAI,CAACN,SAAS,CAACnC,KAAK,CAACO,MAAM,CAAC;IAC3Cd,MAAM,CAACiD,MAAM,CAACP,SAAS,CAAC;EAC5B,CAAC,CAAC;EACF;EACA;EACAP,cAAc,CAACY,OAAO,CAACG,aAAa,IAAI;IACpC,IAAIpC,MAAM,GAAGoC,aAAa;IAC1B,OAAOpC,MAAM,CAACA,MAAM,IAAIA,MAAM,CAACqC,OAAO,EAAE;MACpC,MAAMC,WAAW,GAAGpD,MAAM,CAACwC,aAAa,CAAC1B,MAAM,CAAC;MAChDA,MAAM,GAAGA,MAAM,CAACA,MAAM;MACtBd,MAAM,CAACiD,MAAM,CAACG,WAAW,CAAC;IAC9B;EACJ,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"module"}