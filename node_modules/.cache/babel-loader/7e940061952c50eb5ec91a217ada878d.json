{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/panel/sticky/stickypanelview\n */\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport View from '../../view';\nimport Template from '../../template';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\nimport '../../../theme/components/panel/stickypanel.css';\nconst toPx = toUnit('px');\n\n/**\n * The sticky panel view class.\n */\nexport default class StickyPanelView extends View {\n  /**\n   * @inheritDoc\n   */\n  constructor(locale) {\n    super(locale);\n    const bind = this.bindTemplate;\n\n    /**\n     * Controls whether the sticky panel should be active.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isActive\n     */\n    this.set('isActive', false);\n\n    /**\n     * Controls whether the sticky panel is in the \"sticky\" state.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isSticky\n     */\n    this.set('isSticky', false);\n\n    /**\n     * The limiter element for the sticky panel instance. Its bounding rect limits\n     * the \"stickyness\" of the panel, i.e. when the panel reaches the bottom\n     * edge of the limiter, it becomes sticky to that edge and does not float\n     * off the limiter. It is mandatory for the panel to work properly and once\n     * set, it cannot be changed.\n     *\n     * @readonly\n     * @observable\n     * @member {HTMLElement} #limiterElement\n     */\n    this.set('limiterElement', null);\n\n    /**\n     * The offset from the bottom edge of {@link #limiterElement}\n     * which stops the panel from stickying any further to prevent limiter's content\n     * from being completely covered.\n     *\n     * @readonly\n     * @observable\n     * @default 50\n     * @member {Number} #limiterBottomOffset\n     */\n    this.set('limiterBottomOffset', 50);\n\n    /**\n     * The offset from the top edge of the web browser's viewport which makes the\n     * panel become sticky. The default value is `0`, which means the panel becomes\n     * sticky when it's upper edge touches the top of the page viewport.\n     *\n     * This attribute is useful when the web page has UI elements positioned to the top\n     * either using `position: fixed` or `position: sticky`, which would cover the\n     * sticky panel or vice–versa (depending on the `z-index` hierarchy).\n     *\n     * Bound to {@link module:core/editor/editorui~EditorUI#viewportOffset `EditorUI#viewportOffset`}.\n     *\n     * If {@link module:core/editor/editorconfig~EditorConfig#ui `EditorConfig#ui.viewportOffset.top`} is defined, then\n     * it will override the default value.\n     *\n     * @observable\n     * @default 0\n     * @member {Number} #viewportTopOffset\n     */\n    this.set('viewportTopOffset', 0);\n\n    /**\n     * Controls the `margin-left` CSS style of the panel.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {String} #_marginLeft\n     */\n    this.set('_marginLeft', null);\n\n    /**\n     * Set `true` if the sticky panel reached the bottom edge of the\n     * {@link #limiterElement}.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_isStickyToTheLimiter\n     */\n    this.set('_isStickyToTheLimiter', false);\n\n    /**\n     * Set `true` if the sticky panel uses the {@link #viewportTopOffset},\n     * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}\n     * is not `0`.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_hasViewportTopOffset\n     */\n    this.set('_hasViewportTopOffset', false);\n\n    /**\n     * Collection of the child views which creates balloon panel contents.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n    this.content = this.createCollection();\n\n    /**\n     * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.\n     *\n     * @protected\n     * @member {Object} #_panelRect\n     */\n\n    /**\n     * The DOM bounding client rect of the {@link #limiterElement}\n     * of the panel.\n     *\n     * @protected\n     * @member {Object} #_limiterRect\n     */\n\n    /**\n     * A dummy element which visually fills the space as long as the\n     * actual panel is sticky. It prevents flickering of the UI.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n    this._contentPanelPlaceholder = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__placeholder'],\n        style: {\n          display: bind.to('isSticky', isSticky => isSticky ? 'block' : 'none'),\n          height: bind.to('isSticky', isSticky => {\n            return isSticky ? toPx(this._panelRect.height) : null;\n          })\n        }\n      }\n    }).render();\n\n    /**\n     * The panel which accepts children into {@link #content} collection.\n     * Also an element which is positioned when {@link #isSticky}.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n    this._contentPanel = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__content',\n        // Toggle class of the panel when \"sticky\" state changes in the view.\n        bind.if('isSticky', 'ck-sticky-panel__content_sticky'), bind.if('_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit')],\n        style: {\n          width: bind.to('isSticky', isSticky => {\n            return isSticky ? toPx(this._contentPanelPlaceholder.getBoundingClientRect().width) : null;\n          }),\n          top: bind.to('_hasViewportTopOffset', _hasViewportTopOffset => {\n            return _hasViewportTopOffset ? toPx(this.viewportTopOffset) : null;\n          }),\n          bottom: bind.to('_isStickyToTheLimiter', _isStickyToTheLimiter => {\n            return _isStickyToTheLimiter ? toPx(this.limiterBottomOffset) : null;\n          }),\n          marginLeft: bind.to('_marginLeft')\n        }\n      },\n      children: this.content\n    }).render();\n    this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel']\n      },\n      children: [this._contentPanelPlaceholder, this._contentPanel]\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  render() {\n    super.render();\n\n    // Check if the panel should go into the sticky state immediately.\n    this._checkIfShouldBeSticky();\n\n    // Update sticky state of the panel as the window is being scrolled.\n    this.listenTo(global.window, 'scroll', () => {\n      this._checkIfShouldBeSticky();\n    });\n\n    // Synchronize with `model.isActive` because sticking an inactive panel is pointless.\n    this.listenTo(this, 'change:isActive', () => {\n      this._checkIfShouldBeSticky();\n    });\n  }\n\n  /**\n   * Analyzes the environment to decide whether the panel should\n   * be sticky or not.\n   *\n   * @protected\n   */\n  _checkIfShouldBeSticky() {\n    const panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();\n    let limiterRect;\n    if (!this.limiterElement) {\n      this.isSticky = false;\n    } else {\n      limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect();\n\n      // The panel must be active to become sticky.\n      this.isSticky = this.isActive &&\n      // The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).\n      limiterRect.top < this.viewportTopOffset &&\n      // The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.\n      // There's no point in entering the sticky mode if the model#limiterElement is very, very small, because\n      // it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel\n      // would be positioned before the model#limiterElement.\n      this._panelRect.height + this.limiterBottomOffset < limiterRect.height;\n    }\n\n    // Stick the panel to the top edge of the viewport simulating CSS position:sticky.\n    // TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky\n    if (this.isSticky) {\n      this._isStickyToTheLimiter = limiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;\n      this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;\n      this._marginLeft = this._isStickyToTheLimiter ? null : toPx(-global.window.scrollX);\n    }\n    // Detach the panel from the top edge of the viewport.\n    else {\n      this._isStickyToTheLimiter = false;\n      this._hasViewportTopOffset = false;\n      this._marginLeft = null;\n    }\n  }\n}","map":{"version":3,"names":["global","View","Template","toUnit","toPx","StickyPanelView","constructor","locale","bind","bindTemplate","set","content","createCollection","_contentPanelPlaceholder","tag","attributes","class","style","display","to","isSticky","height","_panelRect","render","_contentPanel","if","width","getBoundingClientRect","top","_hasViewportTopOffset","viewportTopOffset","bottom","_isStickyToTheLimiter","limiterBottomOffset","marginLeft","children","setTemplate","_checkIfShouldBeSticky","listenTo","window","panelRect","limiterRect","limiterElement","_limiterRect","isActive","_marginLeft","scrollX"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/panel/sticky/stickypanelview\n */\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport View from '../../view';\nimport Template from '../../template';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\n\nimport '../../../theme/components/panel/stickypanel.css';\n\nconst toPx = toUnit( 'px' );\n\n/**\n * The sticky panel view class.\n */\nexport default class StickyPanelView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\t/**\n\t\t * Controls whether the sticky panel should be active.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #isActive\n\t\t */\n\t\tthis.set( 'isActive', false );\n\n\t\t/**\n\t\t * Controls whether the sticky panel is in the \"sticky\" state.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #isSticky\n\t\t */\n\t\tthis.set( 'isSticky', false );\n\n\t\t/**\n\t\t * The limiter element for the sticky panel instance. Its bounding rect limits\n\t\t * the \"stickyness\" of the panel, i.e. when the panel reaches the bottom\n\t\t * edge of the limiter, it becomes sticky to that edge and does not float\n\t\t * off the limiter. It is mandatory for the panel to work properly and once\n\t\t * set, it cannot be changed.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {HTMLElement} #limiterElement\n\t\t */\n\t\tthis.set( 'limiterElement', null );\n\n\t\t/**\n\t\t * The offset from the bottom edge of {@link #limiterElement}\n\t\t * which stops the panel from stickying any further to prevent limiter's content\n\t\t * from being completely covered.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @default 50\n\t\t * @member {Number} #limiterBottomOffset\n\t\t */\n\t\tthis.set( 'limiterBottomOffset', 50 );\n\n\t\t/**\n\t\t * The offset from the top edge of the web browser's viewport which makes the\n\t\t * panel become sticky. The default value is `0`, which means the panel becomes\n\t\t * sticky when it's upper edge touches the top of the page viewport.\n\t\t *\n\t\t * This attribute is useful when the web page has UI elements positioned to the top\n\t\t * either using `position: fixed` or `position: sticky`, which would cover the\n\t\t * sticky panel or vice–versa (depending on the `z-index` hierarchy).\n\t\t *\n\t\t * Bound to {@link module:core/editor/editorui~EditorUI#viewportOffset `EditorUI#viewportOffset`}.\n\t\t *\n\t\t * If {@link module:core/editor/editorconfig~EditorConfig#ui `EditorConfig#ui.viewportOffset.top`} is defined, then\n\t\t * it will override the default value.\n\t\t *\n\t\t * @observable\n\t\t * @default 0\n\t\t * @member {Number} #viewportTopOffset\n\t\t */\n\t\tthis.set( 'viewportTopOffset', 0 );\n\n\t\t/**\n\t\t * Controls the `margin-left` CSS style of the panel.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {String} #_marginLeft\n\t\t */\n\t\tthis.set( '_marginLeft', null );\n\n\t\t/**\n\t\t * Set `true` if the sticky panel reached the bottom edge of the\n\t\t * {@link #limiterElement}.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #_isStickyToTheLimiter\n\t\t */\n\t\tthis.set( '_isStickyToTheLimiter', false );\n\n\t\t/**\n\t\t * Set `true` if the sticky panel uses the {@link #viewportTopOffset},\n\t\t * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}\n\t\t * is not `0`.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #_hasViewportTopOffset\n\t\t */\n\t\tthis.set( '_hasViewportTopOffset', false );\n\n\t\t/**\n\t\t * Collection of the child views which creates balloon panel contents.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/viewcollection~ViewCollection}\n\t\t */\n\t\tthis.content = this.createCollection();\n\n\t\t/**\n\t\t * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.\n\t\t *\n\t\t * @protected\n\t\t * @member {Object} #_panelRect\n\t\t */\n\n\t\t/**\n\t\t * The DOM bounding client rect of the {@link #limiterElement}\n\t\t * of the panel.\n\t\t *\n\t\t * @protected\n\t\t * @member {Object} #_limiterRect\n\t\t */\n\n\t\t/**\n\t\t * A dummy element which visually fills the space as long as the\n\t\t * actual panel is sticky. It prevents flickering of the UI.\n\t\t *\n\t\t * @protected\n\t\t * @property {HTMLElement}\n\t\t */\n\t\tthis._contentPanelPlaceholder = new Template( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-sticky-panel__placeholder'\n\t\t\t\t],\n\t\t\t\tstyle: {\n\t\t\t\t\tdisplay: bind.to( 'isSticky', isSticky => isSticky ? 'block' : 'none' ),\n\t\t\t\t\theight: bind.to( 'isSticky', isSticky => {\n\t\t\t\t\t\treturn isSticky ? toPx( this._panelRect.height ) : null;\n\t\t\t\t\t} )\n\t\t\t\t}\n\t\t\t}\n\t\t} ).render();\n\n\t\t/**\n\t\t * The panel which accepts children into {@link #content} collection.\n\t\t * Also an element which is positioned when {@link #isSticky}.\n\t\t *\n\t\t * @protected\n\t\t * @property {HTMLElement}\n\t\t */\n\t\tthis._contentPanel = new Template( {\n\t\t\ttag: 'div',\n\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-sticky-panel__content',\n\t\t\t\t\t// Toggle class of the panel when \"sticky\" state changes in the view.\n\t\t\t\t\tbind.if( 'isSticky', 'ck-sticky-panel__content_sticky' ),\n\t\t\t\t\tbind.if( '_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit' )\n\t\t\t\t],\n\t\t\t\tstyle: {\n\t\t\t\t\twidth: bind.to( 'isSticky', isSticky => {\n\t\t\t\t\t\treturn isSticky ? toPx( this._contentPanelPlaceholder.getBoundingClientRect().width ) : null;\n\t\t\t\t\t} ),\n\n\t\t\t\t\ttop: bind.to( '_hasViewportTopOffset', _hasViewportTopOffset => {\n\t\t\t\t\t\treturn _hasViewportTopOffset ? toPx( this.viewportTopOffset ) : null;\n\t\t\t\t\t} ),\n\n\t\t\t\t\tbottom: bind.to( '_isStickyToTheLimiter', _isStickyToTheLimiter => {\n\t\t\t\t\t\treturn _isStickyToTheLimiter ? toPx( this.limiterBottomOffset ) : null;\n\t\t\t\t\t} ),\n\n\t\t\t\t\tmarginLeft: bind.to( '_marginLeft' )\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tchildren: this.content\n\t\t} ).render();\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-sticky-panel'\n\t\t\t\t]\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\tthis._contentPanelPlaceholder,\n\t\t\t\tthis._contentPanel\n\t\t\t]\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trender() {\n\t\tsuper.render();\n\n\t\t// Check if the panel should go into the sticky state immediately.\n\t\tthis._checkIfShouldBeSticky();\n\n\t\t// Update sticky state of the panel as the window is being scrolled.\n\t\tthis.listenTo( global.window, 'scroll', () => {\n\t\t\tthis._checkIfShouldBeSticky();\n\t\t} );\n\n\t\t// Synchronize with `model.isActive` because sticking an inactive panel is pointless.\n\t\tthis.listenTo( this, 'change:isActive', () => {\n\t\t\tthis._checkIfShouldBeSticky();\n\t\t} );\n\t}\n\n\t/**\n\t * Analyzes the environment to decide whether the panel should\n\t * be sticky or not.\n\t *\n\t * @protected\n\t */\n\t_checkIfShouldBeSticky() {\n\t\tconst panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();\n\t\tlet limiterRect;\n\n\t\tif ( !this.limiterElement ) {\n\t\t\tthis.isSticky = false;\n\t\t} else {\n\t\t\tlimiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect();\n\n\t\t\t// The panel must be active to become sticky.\n\t\t\tthis.isSticky = this.isActive &&\n\t\t\t\t// The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).\n\t\t\t\tlimiterRect.top < this.viewportTopOffset &&\n\t\t\t\t// The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.\n\t\t\t\t// There's no point in entering the sticky mode if the model#limiterElement is very, very small, because\n\t\t\t\t// it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel\n\t\t\t\t// would be positioned before the model#limiterElement.\n\t\t\t\tthis._panelRect.height + this.limiterBottomOffset < limiterRect.height;\n\t\t}\n\n\t\t// Stick the panel to the top edge of the viewport simulating CSS position:sticky.\n\t\t// TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky\n\t\tif ( this.isSticky ) {\n\t\t\tthis._isStickyToTheLimiter =\n\t\t\t\tlimiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;\n\t\t\tthis._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;\n\t\t\tthis._marginLeft = this._isStickyToTheLimiter ? null : toPx( -global.window.scrollX );\n\t\t}\n\t\t// Detach the panel from the top edge of the viewport.\n\t\telse {\n\t\t\tthis._isStickyToTheLimiter = false;\n\t\t\tthis._hasViewportTopOffset = false;\n\t\t\tthis._marginLeft = null;\n\t\t}\n\t}\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAOA,MAAM,MAAM,0CAA0C;AAC7D,OAAOC,IAAI,MAAM,YAAY;AAC7B,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,OAAOC,MAAM,MAAM,0CAA0C;AAE7D,OAAO,iDAAiD;AAExD,MAAMC,IAAI,GAAGD,MAAM,CAAE,IAAI,CAAE;;AAE3B;AACA;AACA;AACA,eAAe,MAAME,eAAe,SAASJ,IAAI,CAAC;EACjD;AACD;AACA;EACCK,WAAW,CAAEC,MAAM,EAAG;IACrB,KAAK,CAAEA,MAAM,CAAE;IAEf,MAAMC,IAAI,GAAG,IAAI,CAACC,YAAY;;IAE9B;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,GAAG,CAAE,UAAU,EAAE,KAAK,CAAE;;IAE7B;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,GAAG,CAAE,UAAU,EAAE,KAAK,CAAE;;IAE7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,GAAG,CAAE,gBAAgB,EAAE,IAAI,CAAE;;IAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,GAAG,CAAE,qBAAqB,EAAE,EAAE,CAAE;;IAErC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,GAAG,CAAE,mBAAmB,EAAE,CAAC,CAAE;;IAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,GAAG,CAAE,aAAa,EAAE,IAAI,CAAE;;IAE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,GAAG,CAAE,uBAAuB,EAAE,KAAK,CAAE;;IAE1C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,GAAG,CAAE,uBAAuB,EAAE,KAAK,CAAE;;IAE1C;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,OAAO,GAAG,IAAI,CAACC,gBAAgB,EAAE;;IAEtC;AACF;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,wBAAwB,GAAG,IAAIX,QAAQ,CAAE;MAC7CY,GAAG,EAAE,KAAK;MACVC,UAAU,EAAE;QACXC,KAAK,EAAE,CACN,IAAI,EACJ,8BAA8B,CAC9B;QACDC,KAAK,EAAE;UACNC,OAAO,EAAEV,IAAI,CAACW,EAAE,CAAE,UAAU,EAAEC,QAAQ,IAAIA,QAAQ,GAAG,OAAO,GAAG,MAAM,CAAE;UACvEC,MAAM,EAAEb,IAAI,CAACW,EAAE,CAAE,UAAU,EAAEC,QAAQ,IAAI;YACxC,OAAOA,QAAQ,GAAGhB,IAAI,CAAE,IAAI,CAACkB,UAAU,CAACD,MAAM,CAAE,GAAG,IAAI;UACxD,CAAC;QACF;MACD;IACD,CAAC,CAAE,CAACE,MAAM,EAAE;;IAEZ;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,aAAa,GAAG,IAAItB,QAAQ,CAAE;MAClCY,GAAG,EAAE,KAAK;MAEVC,UAAU,EAAE;QACXC,KAAK,EAAE,CACN,IAAI,EACJ,0BAA0B;QAC1B;QACAR,IAAI,CAACiB,EAAE,CAAE,UAAU,EAAE,iCAAiC,CAAE,EACxDjB,IAAI,CAACiB,EAAE,CAAE,uBAAuB,EAAE,8CAA8C,CAAE,CAClF;QACDR,KAAK,EAAE;UACNS,KAAK,EAAElB,IAAI,CAACW,EAAE,CAAE,UAAU,EAAEC,QAAQ,IAAI;YACvC,OAAOA,QAAQ,GAAGhB,IAAI,CAAE,IAAI,CAACS,wBAAwB,CAACc,qBAAqB,EAAE,CAACD,KAAK,CAAE,GAAG,IAAI;UAC7F,CAAC,CAAE;UAEHE,GAAG,EAAEpB,IAAI,CAACW,EAAE,CAAE,uBAAuB,EAAEU,qBAAqB,IAAI;YAC/D,OAAOA,qBAAqB,GAAGzB,IAAI,CAAE,IAAI,CAAC0B,iBAAiB,CAAE,GAAG,IAAI;UACrE,CAAC,CAAE;UAEHC,MAAM,EAAEvB,IAAI,CAACW,EAAE,CAAE,uBAAuB,EAAEa,qBAAqB,IAAI;YAClE,OAAOA,qBAAqB,GAAG5B,IAAI,CAAE,IAAI,CAAC6B,mBAAmB,CAAE,GAAG,IAAI;UACvE,CAAC,CAAE;UAEHC,UAAU,EAAE1B,IAAI,CAACW,EAAE,CAAE,aAAa;QACnC;MACD,CAAC;MAEDgB,QAAQ,EAAE,IAAI,CAACxB;IAChB,CAAC,CAAE,CAACY,MAAM,EAAE;IAEZ,IAAI,CAACa,WAAW,CAAE;MACjBtB,GAAG,EAAE,KAAK;MACVC,UAAU,EAAE;QACXC,KAAK,EAAE,CACN,IAAI,EACJ,iBAAiB;MAEnB,CAAC;MACDmB,QAAQ,EAAE,CACT,IAAI,CAACtB,wBAAwB,EAC7B,IAAI,CAACW,aAAa;IAEpB,CAAC,CAAE;EACJ;;EAEA;AACD;AACA;EACCD,MAAM,GAAG;IACR,KAAK,CAACA,MAAM,EAAE;;IAEd;IACA,IAAI,CAACc,sBAAsB,EAAE;;IAE7B;IACA,IAAI,CAACC,QAAQ,CAAEtC,MAAM,CAACuC,MAAM,EAAE,QAAQ,EAAE,MAAM;MAC7C,IAAI,CAACF,sBAAsB,EAAE;IAC9B,CAAC,CAAE;;IAEH;IACA,IAAI,CAACC,QAAQ,CAAE,IAAI,EAAE,iBAAiB,EAAE,MAAM;MAC7C,IAAI,CAACD,sBAAsB,EAAE;IAC9B,CAAC,CAAE;EACJ;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCA,sBAAsB,GAAG;IACxB,MAAMG,SAAS,GAAG,IAAI,CAAClB,UAAU,GAAG,IAAI,CAACE,aAAa,CAACG,qBAAqB,EAAE;IAC9E,IAAIc,WAAW;IAEf,IAAK,CAAC,IAAI,CAACC,cAAc,EAAG;MAC3B,IAAI,CAACtB,QAAQ,GAAG,KAAK;IACtB,CAAC,MAAM;MACNqB,WAAW,GAAG,IAAI,CAACE,YAAY,GAAG,IAAI,CAACD,cAAc,CAACf,qBAAqB,EAAE;;MAE7E;MACA,IAAI,CAACP,QAAQ,GAAG,IAAI,CAACwB,QAAQ;MAC5B;MACAH,WAAW,CAACb,GAAG,GAAG,IAAI,CAACE,iBAAiB;MACxC;MACA;MACA;MACA;MACA,IAAI,CAACR,UAAU,CAACD,MAAM,GAAG,IAAI,CAACY,mBAAmB,GAAGQ,WAAW,CAACpB,MAAM;IACxE;;IAEA;IACA;IACA,IAAK,IAAI,CAACD,QAAQ,EAAG;MACpB,IAAI,CAACY,qBAAqB,GACzBS,WAAW,CAACV,MAAM,GAAGS,SAAS,CAACnB,MAAM,GAAG,IAAI,CAACY,mBAAmB,GAAG,IAAI,CAACH,iBAAiB;MAC1F,IAAI,CAACD,qBAAqB,GAAG,CAAC,IAAI,CAACG,qBAAqB,IAAI,CAAC,CAAC,IAAI,CAACF,iBAAiB;MACpF,IAAI,CAACe,WAAW,GAAG,IAAI,CAACb,qBAAqB,GAAG,IAAI,GAAG5B,IAAI,CAAE,CAACJ,MAAM,CAACuC,MAAM,CAACO,OAAO,CAAE;IACtF;IACA;IAAA,KACK;MACJ,IAAI,CAACd,qBAAqB,GAAG,KAAK;MAClC,IAAI,CAACH,qBAAqB,GAAG,KAAK;MAClC,IAAI,CAACgB,WAAW,GAAG,IAAI;IACxB;EACD;AACD"},"metadata":{},"sourceType":"module"}