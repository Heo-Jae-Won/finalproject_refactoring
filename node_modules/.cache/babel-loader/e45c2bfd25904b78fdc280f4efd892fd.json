{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/insertobject\n */\nimport { findOptimalInsertionRange } from './findoptimalinsertionrange';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Inserts an {@glink framework/guides/deep-dive/schema#object-elements object element} at a specific position in the editor content.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertObject} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertObject}\n * method's behavior.\n *\n * **Note**: For more documentation and examples, see {@link module:engine/model/model~Model#insertObject}.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/element~Element} object An object to be inserted into the model document.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * A selectable where the content should be inserted. If not specified, the current\n * {@link module:engine/model/document~Document#selection document selection} will be used instead.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} placeOrOffset Specifies the exact place or offset for the insertion to take place,\n * relative to `selectable`.\n * @param {Object} [options] Additional options.\n * @param {'auto'|'before'|'after'} [options.findOptimalPosition] An option that, when set, adjusts the insertion position (relative to\n * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).\n * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.\n * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.\n * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.\n *\n * Note that this option works only for block objects. Inline objects are inserted into text and do not split blocks.\n * @param {'on'|'after'} [options.setSelection] An option that, when set, moves the\n * {@link module:engine/model/document~Document#selection document selection} after inserting the object.\n * * When `'on'`, the document selection will be set on the inserted object.\n * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no\n * such text node, a paragraph will be created and the document selection will be moved inside it.\n * @returns {module:engine/model/range~Range} A range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertObject()`, returns a range collapsed\n * at the insertion position.\n */\nexport default function insertObject(model, object, selectable, placeOrOffset) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  if (!model.schema.isObject(object)) {\n    /**\n     * Tried to insert an element with {@link module:engine/model/utils/insertobject insertObject()} function\n     * that is not defined as an object in schema.\n     * See {@link module:engine/model/schema~SchemaItemDefinition#isObject `SchemaItemDefinition`}.\n     * If you want to insert content that is not an object you might want to use\n     * {@link module:engine/model/utils/insertcontent insertContent()} function.\n     * @error insertobject-element-not-an-object\n     */\n    throw new CKEditorError('insertobject-element-not-an-object', model, {\n      object\n    });\n  }\n  // Normalize selectable to a selection instance.\n  let originalSelection;\n  if (!selectable) {\n    originalSelection = model.document.selection;\n  } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n    originalSelection = selectable;\n  } else {\n    originalSelection = model.createSelection(selectable, placeOrOffset);\n  }\n  // Adjust the insertion selection.\n  let insertionSelection = originalSelection;\n  if (options.findOptimalPosition && model.schema.isBlock(object)) {\n    insertionSelection = model.createSelection(findOptimalInsertionRange(originalSelection, model, options.findOptimalPosition));\n  }\n  // Collect attributes to be copied on the inserted object.\n  const firstSelectedBlock = first(originalSelection.getSelectedBlocks());\n  const attributesToCopy = {};\n  if (firstSelectedBlock) {\n    Object.assign(attributesToCopy, model.schema.getAttributesWithProperty(firstSelectedBlock, 'copyOnReplace', true));\n  }\n  return model.change(writer => {\n    // Remove the selected content to find out what the parent of the inserted object would be.\n    // It would be removed inside model.insertContent() anyway.\n    if (!insertionSelection.isCollapsed) {\n      model.deleteContent(insertionSelection, {\n        doNotAutoparagraph: true\n      });\n    }\n    let elementToInsert = object;\n    const insertionPositionParent = insertionSelection.anchor.parent;\n    // Autoparagraphing of an inline objects.\n    if (!model.schema.checkChild(insertionPositionParent, object) && model.schema.checkChild(insertionPositionParent, 'paragraph') && model.schema.checkChild('paragraph', object)) {\n      elementToInsert = writer.createElement('paragraph');\n      writer.insert(object, elementToInsert);\n    }\n    // Apply attributes that are allowed on the inserted object (or paragraph if autoparagraphed).\n    model.schema.setAllowedAttributes(elementToInsert, attributesToCopy, writer);\n    // Insert the prepared content at the optionally adjusted selection.\n    const affectedRange = model.insertContent(elementToInsert, insertionSelection);\n    // Nothing got inserted.\n    if (affectedRange.isCollapsed) {\n      return affectedRange;\n    }\n    if (options.setSelection) {\n      updateSelection(writer, object, options.setSelection, attributesToCopy);\n    }\n    return affectedRange;\n  });\n}\n// Updates document selection based on given `place` parameter in relation to `contextElement` element.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n// @param {module:engine/model/element~Element} contextElement An element to set the attributes on.\n// @param {'on'|'after'} place The place where selection should be set in relation to the `contextElement` element.\n// Value `on` will set selection on the passed `contextElement`. Value `after` will set selection after `contextElement`.\n// @param {Object} attributes Attributes keys and values to set on a paragraph that this function can create when\n// `place` parameter is equal to `after` but there is no element with `$text` node to set selection in.\nfunction updateSelection(writer, contextElement, place, paragraphAttributes) {\n  const model = writer.model;\n  if (place == 'after') {\n    let nextElement = contextElement.nextSibling;\n    // Check whether an element next to the inserted element is defined and can contain a text.\n    const canSetSelection = nextElement && model.schema.checkChild(nextElement, '$text');\n    // If the element is missing, but a paragraph could be inserted next to the element, let's add it.\n    if (!canSetSelection && model.schema.checkChild(contextElement.parent, 'paragraph')) {\n      nextElement = writer.createElement('paragraph');\n      model.schema.setAllowedAttributes(nextElement, paragraphAttributes, writer);\n      model.insertContent(nextElement, writer.createPositionAfter(contextElement));\n    }\n    // Put the selection inside the element, at the beginning.\n    if (nextElement) {\n      writer.setSelection(nextElement, 0);\n    }\n  } else if (place == 'on') {\n    writer.setSelection(contextElement, 'on');\n  } else {\n    /**\n     * The unsupported `options.setSelection` parameter was passed\n     * to the {@link module:engine/model/utils/insertobject insertObject()} function.\n     * Check the {@link module:engine/model/utils/insertobject insertObject()} API documentation for allowed\n     * `options.setSelection` parameter values.\n     *\n     * @error insertobject-invalid-place-parameter-value\n     */\n    throw new CKEditorError('insertobject-invalid-place-parameter-value', model);\n  }\n}","map":{"version":3,"names":["findOptimalInsertionRange","DocumentSelection","Selection","first","CKEditorError","insertObject","model","object","selectable","placeOrOffset","options","schema","isObject","originalSelection","document","selection","createSelection","insertionSelection","findOptimalPosition","isBlock","firstSelectedBlock","getSelectedBlocks","attributesToCopy","Object","assign","getAttributesWithProperty","change","writer","isCollapsed","deleteContent","doNotAutoparagraph","elementToInsert","insertionPositionParent","anchor","parent","checkChild","createElement","insert","setAllowedAttributes","affectedRange","insertContent","setSelection","updateSelection","contextElement","place","paragraphAttributes","nextElement","nextSibling","canSetSelection","createPositionAfter"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertobject.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/insertobject\n */\nimport { findOptimalInsertionRange } from './findoptimalinsertionrange';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Inserts an {@glink framework/guides/deep-dive/schema#object-elements object element} at a specific position in the editor content.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertObject} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertObject}\n * method's behavior.\n *\n * **Note**: For more documentation and examples, see {@link module:engine/model/model~Model#insertObject}.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/element~Element} object An object to be inserted into the model document.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * A selectable where the content should be inserted. If not specified, the current\n * {@link module:engine/model/document~Document#selection document selection} will be used instead.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} placeOrOffset Specifies the exact place or offset for the insertion to take place,\n * relative to `selectable`.\n * @param {Object} [options] Additional options.\n * @param {'auto'|'before'|'after'} [options.findOptimalPosition] An option that, when set, adjusts the insertion position (relative to\n * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).\n * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.\n * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.\n * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.\n *\n * Note that this option works only for block objects. Inline objects are inserted into text and do not split blocks.\n * @param {'on'|'after'} [options.setSelection] An option that, when set, moves the\n * {@link module:engine/model/document~Document#selection document selection} after inserting the object.\n * * When `'on'`, the document selection will be set on the inserted object.\n * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no\n * such text node, a paragraph will be created and the document selection will be moved inside it.\n * @returns {module:engine/model/range~Range} A range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertObject()`, returns a range collapsed\n * at the insertion position.\n */\nexport default function insertObject(model, object, selectable, placeOrOffset, options = {}) {\n    if (!model.schema.isObject(object)) {\n        /**\n         * Tried to insert an element with {@link module:engine/model/utils/insertobject insertObject()} function\n         * that is not defined as an object in schema.\n         * See {@link module:engine/model/schema~SchemaItemDefinition#isObject `SchemaItemDefinition`}.\n         * If you want to insert content that is not an object you might want to use\n         * {@link module:engine/model/utils/insertcontent insertContent()} function.\n         * @error insertobject-element-not-an-object\n         */\n        throw new CKEditorError('insertobject-element-not-an-object', model, { object });\n    }\n    // Normalize selectable to a selection instance.\n    let originalSelection;\n    if (!selectable) {\n        originalSelection = model.document.selection;\n    }\n    else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n        originalSelection = selectable;\n    }\n    else {\n        originalSelection = model.createSelection(selectable, placeOrOffset);\n    }\n    // Adjust the insertion selection.\n    let insertionSelection = originalSelection;\n    if (options.findOptimalPosition && model.schema.isBlock(object)) {\n        insertionSelection = model.createSelection(findOptimalInsertionRange(originalSelection, model, options.findOptimalPosition));\n    }\n    // Collect attributes to be copied on the inserted object.\n    const firstSelectedBlock = first(originalSelection.getSelectedBlocks());\n    const attributesToCopy = {};\n    if (firstSelectedBlock) {\n        Object.assign(attributesToCopy, model.schema.getAttributesWithProperty(firstSelectedBlock, 'copyOnReplace', true));\n    }\n    return model.change(writer => {\n        // Remove the selected content to find out what the parent of the inserted object would be.\n        // It would be removed inside model.insertContent() anyway.\n        if (!insertionSelection.isCollapsed) {\n            model.deleteContent(insertionSelection, { doNotAutoparagraph: true });\n        }\n        let elementToInsert = object;\n        const insertionPositionParent = insertionSelection.anchor.parent;\n        // Autoparagraphing of an inline objects.\n        if (!model.schema.checkChild(insertionPositionParent, object) &&\n            model.schema.checkChild(insertionPositionParent, 'paragraph') &&\n            model.schema.checkChild('paragraph', object)) {\n            elementToInsert = writer.createElement('paragraph');\n            writer.insert(object, elementToInsert);\n        }\n        // Apply attributes that are allowed on the inserted object (or paragraph if autoparagraphed).\n        model.schema.setAllowedAttributes(elementToInsert, attributesToCopy, writer);\n        // Insert the prepared content at the optionally adjusted selection.\n        const affectedRange = model.insertContent(elementToInsert, insertionSelection);\n        // Nothing got inserted.\n        if (affectedRange.isCollapsed) {\n            return affectedRange;\n        }\n        if (options.setSelection) {\n            updateSelection(writer, object, options.setSelection, attributesToCopy);\n        }\n        return affectedRange;\n    });\n}\n// Updates document selection based on given `place` parameter in relation to `contextElement` element.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n// @param {module:engine/model/element~Element} contextElement An element to set the attributes on.\n// @param {'on'|'after'} place The place where selection should be set in relation to the `contextElement` element.\n// Value `on` will set selection on the passed `contextElement`. Value `after` will set selection after `contextElement`.\n// @param {Object} attributes Attributes keys and values to set on a paragraph that this function can create when\n// `place` parameter is equal to `after` but there is no element with `$text` node to set selection in.\nfunction updateSelection(writer, contextElement, place, paragraphAttributes) {\n    const model = writer.model;\n    if (place == 'after') {\n        let nextElement = contextElement.nextSibling;\n        // Check whether an element next to the inserted element is defined and can contain a text.\n        const canSetSelection = nextElement && model.schema.checkChild(nextElement, '$text');\n        // If the element is missing, but a paragraph could be inserted next to the element, let's add it.\n        if (!canSetSelection && model.schema.checkChild(contextElement.parent, 'paragraph')) {\n            nextElement = writer.createElement('paragraph');\n            model.schema.setAllowedAttributes(nextElement, paragraphAttributes, writer);\n            model.insertContent(nextElement, writer.createPositionAfter(contextElement));\n        }\n        // Put the selection inside the element, at the beginning.\n        if (nextElement) {\n            writer.setSelection(nextElement, 0);\n        }\n    }\n    else if (place == 'on') {\n        writer.setSelection(contextElement, 'on');\n    }\n    else {\n        /**\n         * The unsupported `options.setSelection` parameter was passed\n         * to the {@link module:engine/model/utils/insertobject insertObject()} function.\n         * Check the {@link module:engine/model/utils/insertobject insertObject()} API documentation for allowed\n         * `options.setSelection` parameter values.\n         *\n         * @error insertobject-invalid-place-parameter-value\n         */\n        throw new CKEditorError('insertobject-invalid-place-parameter-value', model);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}