{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/model/documentselection\n */\nimport TypeCheckable from './typecheckable';\nimport LiveRange from './liverange';\nimport Selection from './selection';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nconst storePrefix = 'selection:';\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class DocumentSelection extends EmitterMixin(TypeCheckable) {\n  /**\n   * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n   *\n   * @param {module:engine/model/document~Document} doc Document which owns this selection.\n   */\n  constructor(doc) {\n    super();\n    /**\n     * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n     *\n     * @protected\n     */\n    this._selection = new LiveSelection(doc);\n    this._selection.delegate('change:range').to(this);\n    this._selection.delegate('change:attribute').to(this);\n    this._selection.delegate('change:marker').to(this);\n  }\n  /**\n   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n   * collapsed.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isCollapsed() {\n    return this._selection.isCollapsed;\n  }\n  /**\n   * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n   * Together with {@link #focus} they define the direction of selection, which is important\n   * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n   * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n   *\n   * Is set to `null` if there are no ranges in selection.\n   *\n   * @see #focus\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n  get anchor() {\n    return this._selection.anchor;\n  }\n  /**\n   * Selection focus. Focus is a position where the selection ends.\n   *\n   * Is set to `null` if there are no ranges in selection.\n   *\n   * @see #anchor\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n  get focus() {\n    return this._selection.focus;\n  }\n  /**\n   * Returns number of ranges in selection.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get rangeCount() {\n    return this._selection.rangeCount;\n  }\n  /**\n   * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get hasOwnRange() {\n    return this._selection.hasOwnRange;\n  }\n  /**\n   * Specifies whether the {@link #focus}\n   * precedes {@link #anchor}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isBackward() {\n    return this._selection.isBackward;\n  }\n  /**\n   * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n   *\n   * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n   *\n   * @readonly\n   * @returns {Boolean}\n   */\n  get isGravityOverridden() {\n    return this._selection.isGravityOverridden;\n  }\n  /**\n   * A collection of selection {@link module:engine/model/markercollection~Marker markers}.\n   * Marker is a selection marker when selection range is inside the marker range.\n   *\n   * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.\n   *\n   * @readonly\n   * @type {module:utils/collection~Collection}\n   */\n  get markers() {\n    return this._selection.markers;\n  }\n  /**\n   * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n   *\n   * @internal\n   * @protected\n   */\n  get _ranges() {\n    return this._selection._ranges;\n  }\n  /**\n   * Returns an iterable that iterates over copies of selection ranges.\n   *\n   * @returns {Iterable.<module:engine/model/range~Range>}\n   */\n  getRanges() {\n    return this._selection.getRanges();\n  }\n  /**\n   * Returns the first position in the selection.\n   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n  getFirstPosition() {\n    return this._selection.getFirstPosition();\n  }\n  /**\n   * Returns the last position in the selection.\n   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n  getLastPosition() {\n    return this._selection.getLastPosition();\n  }\n  /**\n   * Returns a copy of the first range in the selection.\n   * First range is the one which {@link module:engine/model/range~Range#start start} position\n   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n   * (not to confuse with the first range added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n  getFirstRange() {\n    return this._selection.getFirstRange();\n  }\n  /**\n   * Returns a copy of the last range in the selection.\n   * Last range is the one which {@link module:engine/model/range~Range#end end} position\n   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n   * recently added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n  getLastRange() {\n    return this._selection.getLastRange();\n  }\n  /**\n   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n   *\n   * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n   *\n   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n   * but will not return blocks nested in other blocks.\n   *\n   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<blockQuote>\n   *\t\t\t<paragraph>b</paragraph>\n   *\t\t</blockQuote>\n   *\t\t<paragraph>c]d</paragraph>\n   *\n   * In this case the paragraph will also be returned, despite the collapsed selection:\n   *\n   *\t\t<paragraph>[]a</paragraph>\n   *\n   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n   *\n   *\t\t[<blockA></blockA>\n   *\t\t<blockB>\n   *\t\t\t<blockC></blockC>\n   *\t\t\t<blockD></blockD>\n   *\t\t</blockB>\n   *\t\t<blockE></blockE>]\n   *\n   * If the selection is inside a block all the inner blocks (A & B) are returned:\n   *\n   * \t\t<block>\n   *\t\t\t<blockA>[a</blockA>\n   * \t\t\t<blockB>b]</blockB>\n   * \t\t</block>\n   *\n   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<paragraph>b</paragraph>\n   *\t\t<paragraph>]c</paragraph> // this block will not be returned\n   *\n   * @returns {Iterable.<module:engine/model/element~Element>}\n   */\n  getSelectedBlocks() {\n    return this._selection.getSelectedBlocks();\n  }\n  /**\n   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n   * one range in the selection, and that range contains exactly one element.\n   * Returns `null` if there is no selected element.\n   *\n   * @returns {module:engine/model/element~Element|null}\n   */\n  getSelectedElement() {\n    return this._selection.getSelectedElement();\n  }\n  /**\n   * Checks whether the selection contains the entire content of the given element. This means that selection must start\n   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n   * touching the element's end.\n   *\n   * By default, this method will check whether the entire content of the selection's current root is selected.\n   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n   *\n   * @param {module:engine/model/element~Element} [element=this.anchor.root]\n   * @returns {Boolean}\n   */\n  containsEntireContent(element) {\n    return this._selection.containsEntireContent(element);\n  }\n  /**\n   * Unbinds all events previously bound by document selection.\n   */\n  destroy() {\n    this._selection.destroy();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n  getAttributeKeys() {\n    return this._selection.getAttributeKeys();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n  getAttributes() {\n    return this._selection.getAttributes();\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n  getAttribute(key) {\n    return this._selection.getAttribute(key);\n  }\n  /**\n   * Checks if the selection has an attribute for given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n   */\n  hasAttribute(key) {\n    return this._selection.hasAttribute(key);\n  }\n  /**\n   * Refreshes selection attributes and markers according to the current position in the model.\n   */\n  refresh() {\n    this._selection.updateMarkers();\n    this._selection._updateAttributes(false);\n  }\n  /**\n   * Registers a marker group prefix or a marker name to be collected in the\n   * {@link ~DocumentSelection#markers selection markers collection}.\n   *\n   * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.\n   *\n   * @param {String} prefixOrName The marker group prefix or marker name.\n   */\n  observeMarkers(prefixOrName) {\n    this._selection.observeMarkers(prefixOrName);\n  }\n  /**\n   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n   *\n   * The location can be specified in the same form as\n   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n   *\n   * @see module:engine/model/writer~Writer#setSelectionFocus\n   * @internal\n   * @protected\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  _setFocus(itemOrPosition, offset) {\n    this._selection.setFocus(itemOrPosition, offset);\n  }\n  /**\n   * Sets this selection's ranges and direction to the specified location based on the given\n   * {@link module:engine/model/selection~Selectable selectable}.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n   *\n   * @see module:engine/model/writer~Writer#setSelection\n   * @internal\n   * @protected\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n  _setTo() {\n    this._selection.setTo(...arguments);\n  }\n  /**\n   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n   *\n   * @see module:engine/model/writer~Writer#setSelectionAttribute\n   * @internal\n   * @protected\n   * @param {String} key Key of the attribute to set.\n   * @param {*} value Attribute value.\n   */\n  _setAttribute(key, value) {\n    this._selection.setAttribute(key, value);\n  }\n  /**\n   * Removes an attribute with given key from the selection.\n   * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n   * event with removed attribute key.\n   * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n   *\n   * @see module:engine/model/writer~Writer#removeSelectionAttribute\n   * @internal\n   * @protected\n   * @param {String} key Key of the attribute to remove.\n   */\n  _removeAttribute(key) {\n    this._selection.removeAttribute(key);\n  }\n  /**\n   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n   *\n   * @protected\n   * @returns {Iterable.<*>}\n   */\n  _getStoredAttributes() {\n    return this._selection.getStoredAttributes();\n  }\n  /**\n   * Temporarily changes the gravity of the selection from the left to the right.\n   *\n   * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n   * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n   * This method allows to temporarily override this behavior by forcing the gravity to the right.\n   *\n   * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n   * of the process.\n   *\n   * @see module:engine/model/writer~Writer#overrideSelectionGravity\n   * @internal\n   * @protected\n   * @returns {String} The unique id which allows restoring the gravity.\n   */\n  _overrideGravity() {\n    return this._selection.overrideGravity();\n  }\n  /**\n   * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n   *\n   * Restoring the gravity is only possible using the unique identifier returned by\n   * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n   * the same number of times it was overridden.\n   *\n   * @see module:engine/model/writer~Writer#restoreSelectionGravity\n   * @internal\n   * @protected\n   * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n   */\n  _restoreGravity(uid) {\n    this._selection.restoreGravity(uid);\n  }\n  /**\n   * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n   *\n   * @internal\n   * @protected\n   * @param {String} key Attribute key to convert.\n   * @returns {String} Converted attribute key, applicable for selection store.\n   */\n  static _getStoreAttributeKey(key) {\n    return storePrefix + key;\n  }\n  /**\n   * Checks whether the given attribute key is an attribute stored on an element.\n   *\n   * @protected\n   * @param {String} key\n   * @returns {Boolean}\n   */\n  static _isStoreAttributeKey(key) {\n    return key.startsWith(storePrefix);\n  }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tselection.is( 'selection' ); // -> true\n *\t\tselection.is( 'documentSelection' ); // -> true\n *\t\tselection.is( 'model:selection' ); // -> true\n *\t\tselection.is( 'model:documentSelection' ); // -> true\n *\n *\t\tselection.is( 'view:selection' ); // -> false\n *\t\tselection.is( 'element' ); // -> false\n *\t\tselection.is( 'node' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nDocumentSelection.prototype.is = function (type) {\n  return type === 'selection' || type == 'model:selection' || type == 'documentSelection' || type == 'model:documentSelection';\n};\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\nclass LiveSelection extends Selection {\n  // Creates an empty live selection for given {@link module:engine/model/document~Document}.\n  // @param {module:engine/model/document~Document} doc Document which owns this selection.\n  constructor(doc) {\n    super();\n    // List of selection markers.\n    // Marker is a selection marker when selection range is inside the marker range.\n    //\n    // @type {module:utils/collection~Collection}\n    this.markers = new Collection({\n      idProperty: 'name'\n    });\n    // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/model~Model}\n    this._model = doc.model;\n    // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/document~Document}\n    this._document = doc;\n    // Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n    // last time. Possible values of priority are: `'low'` and `'normal'`.\n    //\n    // Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n    // attributes API are set with `'normal'` priority.\n    //\n    // @private\n    // @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n    this._attributePriority = new Map();\n    // Position to which the selection should be set if the last selection range was moved to the graveyard.\n    // @private\n    // @member {module:engine/model/position~Position} module:engine/model/liveselection~LiveSelection#_selectionRestorePosition\n    this._selectionRestorePosition = null;\n    // Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n    // @private\n    // @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n    this._hasChangedRange = false;\n    // Each overriding gravity adds an UID to the set and each removal removes it.\n    // Gravity is overridden when there's at least one UID in the set.\n    // Gravity is restored when the set is empty.\n    // This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n    // @private\n    // @type {Set}\n    this._overriddenGravityRegister = new Set();\n    // Prefixes of marker names that should affect `LiveSelection#markers` collection.\n    // @private\n    // @type {Set}\n    this._observedMarkers = new Set();\n    // Ensure selection is correct after each operation.\n    this.listenTo(this._model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n      if (!operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop') {\n        return;\n      }\n      // Fix selection if the last range was removed from it and we have a position to which we can restore the selection.\n      if (this._ranges.length == 0 && this._selectionRestorePosition) {\n        this._fixGraveyardSelection(this._selectionRestorePosition);\n      }\n      // \"Forget\" the restore position even if it was not \"used\".\n      this._selectionRestorePosition = null;\n      if (this._hasChangedRange) {\n        this._hasChangedRange = false;\n        this.fire('change:range', {\n          directChange: false\n        });\n      }\n    }, {\n      priority: 'lowest'\n    });\n    // Ensure selection is correct and up to date after each range change.\n    this.on('change:range', () => {\n      this._validateSelectionRanges(this.getRanges());\n    });\n    // Update markers data stored by the selection after each marker change.\n    // This handles only marker changes done through marker operations (not model tree changes).\n    this.listenTo(this._model.markers, 'update', (evt, marker, oldRange, newRange) => {\n      this._updateMarker(marker, newRange);\n    });\n    // Ensure selection is up to date after each change block.\n    this.listenTo(this._document, 'change', (evt, batch) => {\n      clearAttributesStoredInElement(this._model, batch);\n    });\n  }\n  get isCollapsed() {\n    const length = this._ranges.length;\n    return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;\n  }\n  get anchor() {\n    return super.anchor || this._document._getDefaultRange().start;\n  }\n  get focus() {\n    return super.focus || this._document._getDefaultRange().end;\n  }\n  get rangeCount() {\n    return this._ranges.length ? this._ranges.length : 1;\n  }\n  // Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n  // {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n  //\n  // @readonly\n  // @type {Boolean}\n  get hasOwnRange() {\n    return this._ranges.length > 0;\n  }\n  // When set to `true` then selection attributes on node before the caret won't be taken\n  // into consideration while updating selection attributes.\n  //\n  // @protected\n  // @type {Boolean}\n  get isGravityOverridden() {\n    return !!this._overriddenGravityRegister.size;\n  }\n  // Unbinds all events previously bound by live selection.\n  destroy() {\n    for (let i = 0; i < this._ranges.length; i++) {\n      this._ranges[i].detach();\n    }\n    this.stopListening();\n  }\n  *getRanges() {\n    if (this._ranges.length) {\n      yield* super.getRanges();\n    } else {\n      yield this._document._getDefaultRange();\n    }\n  }\n  getFirstRange() {\n    return super.getFirstRange() || this._document._getDefaultRange();\n  }\n  getLastRange() {\n    return super.getLastRange() || this._document._getDefaultRange();\n  }\n  setTo() {\n    super.setTo(...arguments);\n    this._updateAttributes(true);\n    this.updateMarkers();\n  }\n  setFocus(itemOrPosition, offset) {\n    super.setFocus(itemOrPosition, offset);\n    this._updateAttributes(true);\n    this.updateMarkers();\n  }\n  setAttribute(key, value) {\n    if (this._setAttribute(key, value)) {\n      // Fire event with exact data.\n      const attributeKeys = [key];\n      this.fire('change:attribute', {\n        attributeKeys,\n        directChange: true\n      });\n    }\n  }\n  removeAttribute(key) {\n    if (this._removeAttribute(key)) {\n      // Fire event with exact data.\n      const attributeKeys = [key];\n      this.fire('change:attribute', {\n        attributeKeys,\n        directChange: true\n      });\n    }\n  }\n  overrideGravity() {\n    const overrideUid = uid();\n    // Remember that another overriding has been requested. It will need to be removed\n    // before the gravity is to be restored.\n    this._overriddenGravityRegister.add(overrideUid);\n    if (this._overriddenGravityRegister.size === 1) {\n      this._updateAttributes(true);\n    }\n    return overrideUid;\n  }\n  restoreGravity(uid) {\n    if (!this._overriddenGravityRegister.has(uid)) {\n      /**\n       * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n       * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n       *\n       * @error document-selection-gravity-wrong-restore\n       * @param {String} uid The unique identifier returned by\n       * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.\n       */\n      throw new CKEditorError('document-selection-gravity-wrong-restore', this, {\n        uid\n      });\n    }\n    this._overriddenGravityRegister.delete(uid);\n    // Restore gravity only when all overriding have been restored.\n    if (!this.isGravityOverridden) {\n      this._updateAttributes(true);\n    }\n  }\n  observeMarkers(prefixOrName) {\n    this._observedMarkers.add(prefixOrName);\n    this.updateMarkers();\n  }\n  _replaceAllRanges(ranges) {\n    this._validateSelectionRanges(ranges);\n    super._replaceAllRanges(ranges);\n  }\n  _popRange() {\n    this._ranges.pop().detach();\n  }\n  _pushRange(range) {\n    const liveRange = this._prepareRange(range);\n    // `undefined` is returned when given `range` is in graveyard root.\n    if (liveRange) {\n      this._ranges.push(liveRange);\n    }\n  }\n  _validateSelectionRanges(ranges) {\n    for (const range of ranges) {\n      if (!this._document._validateSelectionRange(range)) {\n        /**\n         * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n         * starts or ends at incorrect position.\n         *\n         * @error document-selection-wrong-position\n         * @param {module:engine/model/range~Range} range\n         */\n        throw new CKEditorError('document-selection-wrong-position', this, {\n          range\n        });\n      }\n    }\n  }\n  // Prepares given range to be added to selection. Checks if it is correct,\n  // converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n  // and sets listeners listening to the range's change event.\n  //\n  // @private\n  // @param {module:engine/model/range~Range} range\n  _prepareRange(range) {\n    this._checkRange(range);\n    if (range.root == this._document.graveyard) {\n      // @if CK_DEBUG // console.warn( 'Trying to add a Range that is in the graveyard root. Range rejected.' );\n      return;\n    }\n    const liveRange = LiveRange.fromRange(range);\n    // If selection range is moved to the graveyard remove it from the selection object.\n    // Also, save some data that can be used to restore selection later, on `Model#applyOperation` event.\n    liveRange.on('change:range', (evt, oldRange, data) => {\n      this._hasChangedRange = true;\n      if (liveRange.root == this._document.graveyard) {\n        this._selectionRestorePosition = data.deletionPosition;\n        const index = this._ranges.indexOf(liveRange);\n        this._ranges.splice(index, 1);\n        liveRange.detach();\n      }\n    });\n    return liveRange;\n  }\n  updateMarkers() {\n    if (!this._observedMarkers.size) {\n      return;\n    }\n    const markers = [];\n    let changed = false;\n    for (const marker of this._model.markers) {\n      const markerGroup = marker.name.split(':', 1)[0];\n      if (!this._observedMarkers.has(markerGroup)) {\n        continue;\n      }\n      const markerRange = marker.getRange();\n      for (const selectionRange of this.getRanges()) {\n        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n          markers.push(marker);\n        }\n      }\n    }\n    const oldMarkers = Array.from(this.markers);\n    for (const marker of markers) {\n      if (!this.markers.has(marker)) {\n        this.markers.add(marker);\n        changed = true;\n      }\n    }\n    for (const marker of Array.from(this.markers)) {\n      if (!markers.includes(marker)) {\n        this.markers.remove(marker);\n        changed = true;\n      }\n    }\n    if (changed) {\n      this.fire('change:marker', {\n        oldMarkers,\n        directChange: false\n      });\n    }\n  }\n  _updateMarker(marker, markerRange) {\n    const markerGroup = marker.name.split(':', 1)[0];\n    if (!this._observedMarkers.has(markerGroup)) {\n      return;\n    }\n    let changed = false;\n    const oldMarkers = Array.from(this.markers);\n    const hasMarker = this.markers.has(marker);\n    if (!markerRange) {\n      if (hasMarker) {\n        this.markers.remove(marker);\n        changed = true;\n      }\n    } else {\n      let contained = false;\n      for (const selectionRange of this.getRanges()) {\n        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n          contained = true;\n          break;\n        }\n      }\n      if (contained && !hasMarker) {\n        this.markers.add(marker);\n        changed = true;\n      } else if (!contained && hasMarker) {\n        this.markers.remove(marker);\n        changed = true;\n      }\n    }\n    if (changed) {\n      this.fire('change:marker', {\n        oldMarkers,\n        directChange: false\n      });\n    }\n  }\n  // Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n  //\n  // @protected\n  // @param {Boolean} clearAll\n  // @fires change:attribute\n  _updateAttributes(clearAll) {\n    const newAttributes = toMap(this._getSurroundingAttributes());\n    const oldAttributes = toMap(this.getAttributes());\n    if (clearAll) {\n      // If `clearAll` remove all attributes and reset priorities.\n      this._attributePriority = new Map();\n      this._attrs = new Map();\n    } else {\n      // If not, remove only attributes added with `low` priority.\n      for (const [key, priority] of this._attributePriority) {\n        if (priority == 'low') {\n          this._attrs.delete(key);\n          this._attributePriority.delete(key);\n        }\n      }\n    }\n    this._setAttributesTo(newAttributes);\n    // Let's evaluate which attributes really changed.\n    const changed = [];\n    // First, loop through all attributes that are set on selection right now.\n    // Check which of them are different than old attributes.\n    for (const [newKey, newValue] of this.getAttributes()) {\n      if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {\n        changed.push(newKey);\n      }\n    }\n    // Then, check which of old attributes got removed.\n    for (const [oldKey] of oldAttributes) {\n      if (!this.hasAttribute(oldKey)) {\n        changed.push(oldKey);\n      }\n    }\n    // Fire event with exact data (fire only if anything changed).\n    if (changed.length > 0) {\n      this.fire('change:attribute', {\n        attributeKeys: changed,\n        directChange: false\n      });\n    }\n  }\n  // Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n  // parameter).\n  //\n  // @private\n  // @param {String} key Attribute key.\n  // @param {*} value Attribute value.\n  // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n  // is caused by `Batch` API.\n  // @returns {Boolean} Whether value has changed.\n  _setAttribute(key, value) {\n    let directChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const priority = directChange ? 'normal' : 'low';\n    if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n      // Priority too low.\n      return false;\n    }\n    const oldValue = super.getAttribute(key);\n    // Don't do anything if value has not changed.\n    if (oldValue === value) {\n      return false;\n    }\n    this._attrs.set(key, value);\n    // Update priorities map.\n    this._attributePriority.set(key, priority);\n    return true;\n  }\n  // Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n  // parameter).\n  //\n  // NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n  // be changed according to `directChange` parameter.\n  //\n  // @private\n  // @param {String} key Attribute key.\n  // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n  // is caused by `Batch` API.\n  // @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n  // existing attribute had higher priority.\n  _removeAttribute(key) {\n    let directChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const priority = directChange ? 'normal' : 'low';\n    if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n      // Priority too low.\n      return false;\n    }\n    // Update priorities map.\n    this._attributePriority.set(key, priority);\n    // Don't do anything if value has not changed.\n    if (!super.hasAttribute(key)) {\n      return false;\n    }\n    this._attrs.delete(key);\n    return true;\n  }\n  // Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n  // `directChange` parameter).\n  //\n  // @private\n  // @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n  // @returns {Set.<String>} Changed attribute keys.\n  _setAttributesTo(attrs) {\n    const changed = new Set();\n    for (const [oldKey, oldValue] of this.getAttributes()) {\n      // Do not remove attribute if attribute with same key and value is about to be set.\n      if (attrs.get(oldKey) === oldValue) {\n        continue;\n      }\n      // All rest attributes will be removed so changed attributes won't change .\n      this._removeAttribute(oldKey, false);\n    }\n    for (const [key, value] of attrs) {\n      // Attribute may not be set because of attributes or because same key/value is already added.\n      const gotAdded = this._setAttribute(key, value, false);\n      if (gotAdded) {\n        changed.add(key);\n      }\n    }\n    return changed;\n  }\n  // Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n  //\n  // @public\n  // @returns {Iterable.<*>}\n  *getStoredAttributes() {\n    const selectionParent = this.getFirstPosition().parent;\n    if (this.isCollapsed && selectionParent.isEmpty) {\n      for (const key of selectionParent.getAttributeKeys()) {\n        if (key.startsWith(storePrefix)) {\n          const realKey = key.substr(storePrefix.length);\n          yield [realKey, selectionParent.getAttribute(key)];\n        }\n      }\n    }\n  }\n  // Checks model text nodes that are closest to the selection's first position and returns attributes of first\n  // found element. If there are no text nodes in selection's first position parent, it returns selection\n  // attributes stored in that parent.\n  //\n  // @private\n  // @returns {Iterable.<*>} Collection of attributes.\n  _getSurroundingAttributes() {\n    const position = this.getFirstPosition();\n    const schema = this._model.schema;\n    let attrs = null;\n    if (!this.isCollapsed) {\n      // 1. If selection is a range...\n      const range = this.getFirstRange();\n      // ...look for a first character node in that range and take attributes from it.\n      for (const value of range) {\n        // If the item is an object, we don't want to get attributes from its children.\n        if (value.item.is('element') && schema.isObject(value.item)) {\n          break;\n        }\n        if (value.type == 'text') {\n          attrs = value.item.getAttributes();\n          break;\n        }\n      }\n    } else {\n      // 2. If the selection is a caret or the range does not contain a character node...\n      const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n      const nodeAfter = position.textNode ? position.textNode : position.nodeAfter;\n      // When gravity is overridden then don't take node before into consideration.\n      if (!this.isGravityOverridden) {\n        // ...look at the node before caret and take attributes from it if it is a character node.\n        attrs = getAttrsIfCharacter(nodeBefore);\n      }\n      // 3. If not, look at the node after caret...\n      if (!attrs) {\n        attrs = getAttrsIfCharacter(nodeAfter);\n      }\n      // 4. If not, try to find the first character on the left, that is in the same node.\n      // When gravity is overridden then don't take node before into consideration.\n      if (!this.isGravityOverridden && !attrs) {\n        let node = nodeBefore;\n        while (node && !schema.isInline(node) && !attrs) {\n          node = node.previousSibling;\n          attrs = getAttrsIfCharacter(node);\n        }\n      }\n      // 5. If not found, try to find the first character on the right, that is in the same node.\n      if (!attrs) {\n        let node = nodeAfter;\n        while (node && !schema.isInline(node) && !attrs) {\n          node = node.nextSibling;\n          attrs = getAttrsIfCharacter(node);\n        }\n      }\n      // 6. If not found, selection should retrieve attributes from parent.\n      if (!attrs) {\n        attrs = this.getStoredAttributes();\n      }\n    }\n    return attrs;\n  }\n  // Fixes the selection after all its ranges got removed.\n  //\n  // @private\n  // @param {module:engine/model/position~Position} deletionPosition Position where the deletion happened.\n  _fixGraveyardSelection(deletionPosition) {\n    // Find a range that is a correct selection range and is closest to the position where the deletion happened.\n    const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition);\n    // If nearest valid selection range has been found - add it in the place of old range.\n    if (selectionRange) {\n      // Check the range, convert it to live range, bind events, etc.\n      this._pushRange(selectionRange);\n    }\n    // If nearest valid selection range cannot be found don't add any range. Selection will be set to the default range.\n  }\n}\n// Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\nfunction getAttrsIfCharacter(node) {\n  if (node instanceof TextProxy || node instanceof Text) {\n    return node.getAttributes();\n  }\n  return null;\n}\n// Removes selection attributes from element which is not empty anymore.\n//\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\nfunction clearAttributesStoredInElement(model, batch) {\n  const differ = model.document.differ;\n  for (const entry of differ.getChanges()) {\n    if (entry.type != 'insert') {\n      continue;\n    }\n    const changeParent = entry.position.parent;\n    const isNoLongerEmpty = entry.length === changeParent.maxOffset;\n    if (isNoLongerEmpty) {\n      model.enqueueChange(batch, writer => {\n        const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter(key => key.startsWith(storePrefix));\n        for (const key of storedAttributes) {\n          writer.removeAttribute(key, changeParent);\n        }\n      });\n    }\n  }\n}","map":{"version":3,"names":["TypeCheckable","LiveRange","Selection","Text","TextProxy","CKEditorError","Collection","EmitterMixin","toMap","uid","storePrefix","DocumentSelection","constructor","doc","_selection","LiveSelection","delegate","to","isCollapsed","anchor","focus","rangeCount","hasOwnRange","isBackward","isGravityOverridden","markers","_ranges","getRanges","getFirstPosition","getLastPosition","getFirstRange","getLastRange","getSelectedBlocks","getSelectedElement","containsEntireContent","element","destroy","getAttributeKeys","getAttributes","getAttribute","key","hasAttribute","refresh","updateMarkers","_updateAttributes","observeMarkers","prefixOrName","_setFocus","itemOrPosition","offset","setFocus","_setTo","setTo","_setAttribute","value","setAttribute","_removeAttribute","removeAttribute","_getStoredAttributes","getStoredAttributes","_overrideGravity","overrideGravity","_restoreGravity","restoreGravity","_getStoreAttributeKey","_isStoreAttributeKey","startsWith","prototype","is","type","idProperty","_model","model","_document","_attributePriority","Map","_selectionRestorePosition","_hasChangedRange","_overriddenGravityRegister","Set","_observedMarkers","listenTo","evt","args","operation","isDocumentOperation","length","_fixGraveyardSelection","fire","directChange","priority","on","_validateSelectionRanges","marker","oldRange","newRange","_updateMarker","batch","clearAttributesStoredInElement","_getDefaultRange","start","end","size","i","detach","stopListening","attributeKeys","overrideUid","add","has","delete","_replaceAllRanges","ranges","_popRange","pop","_pushRange","range","liveRange","_prepareRange","push","_validateSelectionRange","_checkRange","root","graveyard","fromRange","data","deletionPosition","index","indexOf","splice","changed","markerGroup","name","split","markerRange","getRange","selectionRange","containsRange","oldMarkers","Array","from","includes","remove","hasMarker","contained","clearAll","newAttributes","_getSurroundingAttributes","oldAttributes","_attrs","_setAttributesTo","newKey","newValue","get","oldKey","oldValue","set","attrs","gotAdded","selectionParent","parent","isEmpty","realKey","substr","position","schema","item","isObject","nodeBefore","textNode","nodeAfter","getAttrsIfCharacter","node","isInline","previousSibling","nextSibling","getNearestSelectionRange","differ","document","entry","getChanges","changeParent","isNoLongerEmpty","maxOffset","enqueueChange","writer","storedAttributes","filter"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/documentselection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/model/documentselection\n */\nimport TypeCheckable from './typecheckable';\nimport LiveRange from './liverange';\nimport Selection from './selection';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nconst storePrefix = 'selection:';\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class DocumentSelection extends EmitterMixin(TypeCheckable) {\n    /**\n     * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n     *\n     * @param {module:engine/model/document~Document} doc Document which owns this selection.\n     */\n    constructor(doc) {\n        super();\n        /**\n         * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n         *\n         * @protected\n         */\n        this._selection = new LiveSelection(doc);\n        this._selection.delegate('change:range').to(this);\n        this._selection.delegate('change:attribute').to(this);\n        this._selection.delegate('change:marker').to(this);\n    }\n    /**\n     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n     * collapsed.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isCollapsed() {\n        return this._selection.isCollapsed;\n    }\n    /**\n     * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n     * Together with {@link #focus} they define the direction of selection, which is important\n     * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n     * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n     *\n     * Is set to `null` if there are no ranges in selection.\n     *\n     * @see #focus\n     * @readonly\n     * @type {module:engine/model/position~Position|null}\n     */\n    get anchor() {\n        return this._selection.anchor;\n    }\n    /**\n     * Selection focus. Focus is a position where the selection ends.\n     *\n     * Is set to `null` if there are no ranges in selection.\n     *\n     * @see #anchor\n     * @readonly\n     * @type {module:engine/model/position~Position|null}\n     */\n    get focus() {\n        return this._selection.focus;\n    }\n    /**\n     * Returns number of ranges in selection.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get rangeCount() {\n        return this._selection.rangeCount;\n    }\n    /**\n     * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n     * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get hasOwnRange() {\n        return this._selection.hasOwnRange;\n    }\n    /**\n     * Specifies whether the {@link #focus}\n     * precedes {@link #anchor}.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isBackward() {\n        return this._selection.isBackward;\n    }\n    /**\n     * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n     *\n     * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n     *\n     * @readonly\n     * @returns {Boolean}\n     */\n    get isGravityOverridden() {\n        return this._selection.isGravityOverridden;\n    }\n    /**\n     * A collection of selection {@link module:engine/model/markercollection~Marker markers}.\n     * Marker is a selection marker when selection range is inside the marker range.\n     *\n     * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n    get markers() {\n        return this._selection.markers;\n    }\n    /**\n     * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n     *\n     * @internal\n     * @protected\n     */\n    get _ranges() {\n        return this._selection._ranges;\n    }\n    /**\n     * Returns an iterable that iterates over copies of selection ranges.\n     *\n     * @returns {Iterable.<module:engine/model/range~Range>}\n     */\n    getRanges() {\n        return this._selection.getRanges();\n    }\n    /**\n     * Returns the first position in the selection.\n     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n    getFirstPosition() {\n        return this._selection.getFirstPosition();\n    }\n    /**\n     * Returns the last position in the selection.\n     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n    getLastPosition() {\n        return this._selection.getLastPosition();\n    }\n    /**\n     * Returns a copy of the first range in the selection.\n     * First range is the one which {@link module:engine/model/range~Range#start start} position\n     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n     * (not to confuse with the first range added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n    getFirstRange() {\n        return this._selection.getFirstRange();\n    }\n    /**\n     * Returns a copy of the last range in the selection.\n     * Last range is the one which {@link module:engine/model/range~Range#end end} position\n     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n     * recently added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n    getLastRange() {\n        return this._selection.getLastRange();\n    }\n    /**\n     * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n     *\n     * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n     *\n     * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n     * but will not return blocks nested in other blocks.\n     *\n     * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<blockQuote>\n     *\t\t\t<paragraph>b</paragraph>\n     *\t\t</blockQuote>\n     *\t\t<paragraph>c]d</paragraph>\n     *\n     * In this case the paragraph will also be returned, despite the collapsed selection:\n     *\n     *\t\t<paragraph>[]a</paragraph>\n     *\n     * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n     *\n     *\t\t[<blockA></blockA>\n     *\t\t<blockB>\n     *\t\t\t<blockC></blockC>\n     *\t\t\t<blockD></blockD>\n     *\t\t</blockB>\n     *\t\t<blockE></blockE>]\n     *\n     * If the selection is inside a block all the inner blocks (A & B) are returned:\n     *\n     * \t\t<block>\n     *\t\t\t<blockA>[a</blockA>\n     * \t\t\t<blockB>b]</blockB>\n     * \t\t</block>\n     *\n     * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n     * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<paragraph>b</paragraph>\n     *\t\t<paragraph>]c</paragraph> // this block will not be returned\n     *\n     * @returns {Iterable.<module:engine/model/element~Element>}\n     */\n    getSelectedBlocks() {\n        return this._selection.getSelectedBlocks();\n    }\n    /**\n     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n     * one range in the selection, and that range contains exactly one element.\n     * Returns `null` if there is no selected element.\n     *\n     * @returns {module:engine/model/element~Element|null}\n     */\n    getSelectedElement() {\n        return this._selection.getSelectedElement();\n    }\n    /**\n     * Checks whether the selection contains the entire content of the given element. This means that selection must start\n     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n     * touching the element's end.\n     *\n     * By default, this method will check whether the entire content of the selection's current root is selected.\n     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n     *\n     * @param {module:engine/model/element~Element} [element=this.anchor.root]\n     * @returns {Boolean}\n     */\n    containsEntireContent(element) {\n        return this._selection.containsEntireContent(element);\n    }\n    /**\n     * Unbinds all events previously bound by document selection.\n     */\n    destroy() {\n        this._selection.destroy();\n    }\n    /**\n     * Returns iterable that iterates over this selection's attribute keys.\n     *\n     * @returns {Iterable.<String>}\n     */\n    getAttributeKeys() {\n        return this._selection.getAttributeKeys();\n    }\n    /**\n     * Returns iterable that iterates over this selection's attributes.\n     *\n     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n    getAttributes() {\n        return this._selection.getAttributes();\n    }\n    /**\n     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n     *\n     * @param {String} key Key of attribute to look for.\n     * @returns {*} Attribute value or `undefined`.\n     */\n    getAttribute(key) {\n        return this._selection.getAttribute(key);\n    }\n    /**\n     * Checks if the selection has an attribute for given key.\n     *\n     * @param {String} key Key of attribute to check.\n     * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n     */\n    hasAttribute(key) {\n        return this._selection.hasAttribute(key);\n    }\n    /**\n     * Refreshes selection attributes and markers according to the current position in the model.\n     */\n    refresh() {\n        this._selection.updateMarkers();\n        this._selection._updateAttributes(false);\n    }\n    /**\n     * Registers a marker group prefix or a marker name to be collected in the\n     * {@link ~DocumentSelection#markers selection markers collection}.\n     *\n     * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.\n     *\n     * @param {String} prefixOrName The marker group prefix or marker name.\n     */\n    observeMarkers(prefixOrName) {\n        this._selection.observeMarkers(prefixOrName);\n    }\n    /**\n     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n     *\n     * The location can be specified in the same form as\n     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n     *\n     * @see module:engine/model/writer~Writer#setSelectionFocus\n     * @internal\n     * @protected\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    _setFocus(itemOrPosition, offset) {\n        this._selection.setFocus(itemOrPosition, offset);\n    }\n    /**\n     * Sets this selection's ranges and direction to the specified location based on the given\n     * {@link module:engine/model/selection~Selectable selectable}.\n     * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n     *\n     * @see module:engine/model/writer~Writer#setSelection\n     * @internal\n     * @protected\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n    _setTo(...args) {\n        this._selection.setTo(...args);\n    }\n    /**\n     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n     *\n     * @see module:engine/model/writer~Writer#setSelectionAttribute\n     * @internal\n     * @protected\n     * @param {String} key Key of the attribute to set.\n     * @param {*} value Attribute value.\n     */\n    _setAttribute(key, value) {\n        this._selection.setAttribute(key, value);\n    }\n    /**\n     * Removes an attribute with given key from the selection.\n     * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n     * event with removed attribute key.\n     * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n     *\n     * @see module:engine/model/writer~Writer#removeSelectionAttribute\n     * @internal\n     * @protected\n     * @param {String} key Key of the attribute to remove.\n     */\n    _removeAttribute(key) {\n        this._selection.removeAttribute(key);\n    }\n    /**\n     * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n     *\n     * @protected\n     * @returns {Iterable.<*>}\n     */\n    _getStoredAttributes() {\n        return this._selection.getStoredAttributes();\n    }\n    /**\n     * Temporarily changes the gravity of the selection from the left to the right.\n     *\n     * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n     * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n     * This method allows to temporarily override this behavior by forcing the gravity to the right.\n     *\n     * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n     * of the process.\n     *\n     * @see module:engine/model/writer~Writer#overrideSelectionGravity\n     * @internal\n     * @protected\n     * @returns {String} The unique id which allows restoring the gravity.\n     */\n    _overrideGravity() {\n        return this._selection.overrideGravity();\n    }\n    /**\n     * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n     *\n     * Restoring the gravity is only possible using the unique identifier returned by\n     * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n     * the same number of times it was overridden.\n     *\n     * @see module:engine/model/writer~Writer#restoreSelectionGravity\n     * @internal\n     * @protected\n     * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n     */\n    _restoreGravity(uid) {\n        this._selection.restoreGravity(uid);\n    }\n    /**\n     * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n     *\n     * @internal\n     * @protected\n     * @param {String} key Attribute key to convert.\n     * @returns {String} Converted attribute key, applicable for selection store.\n     */\n    static _getStoreAttributeKey(key) {\n        return storePrefix + key;\n    }\n    /**\n     * Checks whether the given attribute key is an attribute stored on an element.\n     *\n     * @protected\n     * @param {String} key\n     * @returns {Boolean}\n     */\n    static _isStoreAttributeKey(key) {\n        return key.startsWith(storePrefix);\n    }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tselection.is( 'selection' ); // -> true\n *\t\tselection.is( 'documentSelection' ); // -> true\n *\t\tselection.is( 'model:selection' ); // -> true\n *\t\tselection.is( 'model:documentSelection' ); // -> true\n *\n *\t\tselection.is( 'view:selection' ); // -> false\n *\t\tselection.is( 'element' ); // -> false\n *\t\tselection.is( 'node' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nDocumentSelection.prototype.is = function (type) {\n    return type === 'selection' ||\n        type == 'model:selection' ||\n        type == 'documentSelection' ||\n        type == 'model:documentSelection';\n};\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\nclass LiveSelection extends Selection {\n    // Creates an empty live selection for given {@link module:engine/model/document~Document}.\n    // @param {module:engine/model/document~Document} doc Document which owns this selection.\n    constructor(doc) {\n        super();\n        // List of selection markers.\n        // Marker is a selection marker when selection range is inside the marker range.\n        //\n        // @type {module:utils/collection~Collection}\n        this.markers = new Collection({ idProperty: 'name' });\n        // Document which owns this selection.\n        //\n        // @protected\n        // @member {module:engine/model/model~Model}\n        this._model = doc.model;\n        // Document which owns this selection.\n        //\n        // @protected\n        // @member {module:engine/model/document~Document}\n        this._document = doc;\n        // Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n        // last time. Possible values of priority are: `'low'` and `'normal'`.\n        //\n        // Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n        // attributes API are set with `'normal'` priority.\n        //\n        // @private\n        // @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n        this._attributePriority = new Map();\n        // Position to which the selection should be set if the last selection range was moved to the graveyard.\n        // @private\n        // @member {module:engine/model/position~Position} module:engine/model/liveselection~LiveSelection#_selectionRestorePosition\n        this._selectionRestorePosition = null;\n        // Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n        // @private\n        // @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n        this._hasChangedRange = false;\n        // Each overriding gravity adds an UID to the set and each removal removes it.\n        // Gravity is overridden when there's at least one UID in the set.\n        // Gravity is restored when the set is empty.\n        // This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n        // @private\n        // @type {Set}\n        this._overriddenGravityRegister = new Set();\n        // Prefixes of marker names that should affect `LiveSelection#markers` collection.\n        // @private\n        // @type {Set}\n        this._observedMarkers = new Set();\n        // Ensure selection is correct after each operation.\n        this.listenTo(this._model, 'applyOperation', (evt, args) => {\n            const operation = args[0];\n            if (!operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop') {\n                return;\n            }\n            // Fix selection if the last range was removed from it and we have a position to which we can restore the selection.\n            if (this._ranges.length == 0 && this._selectionRestorePosition) {\n                this._fixGraveyardSelection(this._selectionRestorePosition);\n            }\n            // \"Forget\" the restore position even if it was not \"used\".\n            this._selectionRestorePosition = null;\n            if (this._hasChangedRange) {\n                this._hasChangedRange = false;\n                this.fire('change:range', { directChange: false });\n            }\n        }, { priority: 'lowest' });\n        // Ensure selection is correct and up to date after each range change.\n        this.on('change:range', () => {\n            this._validateSelectionRanges(this.getRanges());\n        });\n        // Update markers data stored by the selection after each marker change.\n        // This handles only marker changes done through marker operations (not model tree changes).\n        this.listenTo(this._model.markers, 'update', (evt, marker, oldRange, newRange) => {\n            this._updateMarker(marker, newRange);\n        });\n        // Ensure selection is up to date after each change block.\n        this.listenTo(this._document, 'change', (evt, batch) => {\n            clearAttributesStoredInElement(this._model, batch);\n        });\n    }\n    get isCollapsed() {\n        const length = this._ranges.length;\n        return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;\n    }\n    get anchor() {\n        return super.anchor || this._document._getDefaultRange().start;\n    }\n    get focus() {\n        return super.focus || this._document._getDefaultRange().end;\n    }\n    get rangeCount() {\n        return this._ranges.length ? this._ranges.length : 1;\n    }\n    // Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n    // {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n    //\n    // @readonly\n    // @type {Boolean}\n    get hasOwnRange() {\n        return this._ranges.length > 0;\n    }\n    // When set to `true` then selection attributes on node before the caret won't be taken\n    // into consideration while updating selection attributes.\n    //\n    // @protected\n    // @type {Boolean}\n    get isGravityOverridden() {\n        return !!this._overriddenGravityRegister.size;\n    }\n    // Unbinds all events previously bound by live selection.\n    destroy() {\n        for (let i = 0; i < this._ranges.length; i++) {\n            this._ranges[i].detach();\n        }\n        this.stopListening();\n    }\n    *getRanges() {\n        if (this._ranges.length) {\n            yield* super.getRanges();\n        }\n        else {\n            yield this._document._getDefaultRange();\n        }\n    }\n    getFirstRange() {\n        return super.getFirstRange() || this._document._getDefaultRange();\n    }\n    getLastRange() {\n        return super.getLastRange() || this._document._getDefaultRange();\n    }\n    setTo(...args) {\n        super.setTo(...args);\n        this._updateAttributes(true);\n        this.updateMarkers();\n    }\n    setFocus(itemOrPosition, offset) {\n        super.setFocus(itemOrPosition, offset);\n        this._updateAttributes(true);\n        this.updateMarkers();\n    }\n    setAttribute(key, value) {\n        if (this._setAttribute(key, value)) {\n            // Fire event with exact data.\n            const attributeKeys = [key];\n            this.fire('change:attribute', { attributeKeys, directChange: true });\n        }\n    }\n    removeAttribute(key) {\n        if (this._removeAttribute(key)) {\n            // Fire event with exact data.\n            const attributeKeys = [key];\n            this.fire('change:attribute', { attributeKeys, directChange: true });\n        }\n    }\n    overrideGravity() {\n        const overrideUid = uid();\n        // Remember that another overriding has been requested. It will need to be removed\n        // before the gravity is to be restored.\n        this._overriddenGravityRegister.add(overrideUid);\n        if (this._overriddenGravityRegister.size === 1) {\n            this._updateAttributes(true);\n        }\n        return overrideUid;\n    }\n    restoreGravity(uid) {\n        if (!this._overriddenGravityRegister.has(uid)) {\n            /**\n             * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n             * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n             *\n             * @error document-selection-gravity-wrong-restore\n             * @param {String} uid The unique identifier returned by\n             * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.\n             */\n            throw new CKEditorError('document-selection-gravity-wrong-restore', this, { uid });\n        }\n        this._overriddenGravityRegister.delete(uid);\n        // Restore gravity only when all overriding have been restored.\n        if (!this.isGravityOverridden) {\n            this._updateAttributes(true);\n        }\n    }\n    observeMarkers(prefixOrName) {\n        this._observedMarkers.add(prefixOrName);\n        this.updateMarkers();\n    }\n    _replaceAllRanges(ranges) {\n        this._validateSelectionRanges(ranges);\n        super._replaceAllRanges(ranges);\n    }\n    _popRange() {\n        this._ranges.pop().detach();\n    }\n    _pushRange(range) {\n        const liveRange = this._prepareRange(range);\n        // `undefined` is returned when given `range` is in graveyard root.\n        if (liveRange) {\n            this._ranges.push(liveRange);\n        }\n    }\n    _validateSelectionRanges(ranges) {\n        for (const range of ranges) {\n            if (!this._document._validateSelectionRange(range)) {\n                /**\n                 * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n                 * starts or ends at incorrect position.\n                 *\n                 * @error document-selection-wrong-position\n                 * @param {module:engine/model/range~Range} range\n                 */\n                throw new CKEditorError('document-selection-wrong-position', this, { range });\n            }\n        }\n    }\n    // Prepares given range to be added to selection. Checks if it is correct,\n    // converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n    // and sets listeners listening to the range's change event.\n    //\n    // @private\n    // @param {module:engine/model/range~Range} range\n    _prepareRange(range) {\n        this._checkRange(range);\n        if (range.root == this._document.graveyard) {\n            // @if CK_DEBUG // console.warn( 'Trying to add a Range that is in the graveyard root. Range rejected.' );\n            return;\n        }\n        const liveRange = LiveRange.fromRange(range);\n        // If selection range is moved to the graveyard remove it from the selection object.\n        // Also, save some data that can be used to restore selection later, on `Model#applyOperation` event.\n        liveRange.on('change:range', (evt, oldRange, data) => {\n            this._hasChangedRange = true;\n            if (liveRange.root == this._document.graveyard) {\n                this._selectionRestorePosition = data.deletionPosition;\n                const index = this._ranges.indexOf(liveRange);\n                this._ranges.splice(index, 1);\n                liveRange.detach();\n            }\n        });\n        return liveRange;\n    }\n    updateMarkers() {\n        if (!this._observedMarkers.size) {\n            return;\n        }\n        const markers = [];\n        let changed = false;\n        for (const marker of this._model.markers) {\n            const markerGroup = marker.name.split(':', 1)[0];\n            if (!this._observedMarkers.has(markerGroup)) {\n                continue;\n            }\n            const markerRange = marker.getRange();\n            for (const selectionRange of this.getRanges()) {\n                if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n                    markers.push(marker);\n                }\n            }\n        }\n        const oldMarkers = Array.from(this.markers);\n        for (const marker of markers) {\n            if (!this.markers.has(marker)) {\n                this.markers.add(marker);\n                changed = true;\n            }\n        }\n        for (const marker of Array.from(this.markers)) {\n            if (!markers.includes(marker)) {\n                this.markers.remove(marker);\n                changed = true;\n            }\n        }\n        if (changed) {\n            this.fire('change:marker', { oldMarkers, directChange: false });\n        }\n    }\n    _updateMarker(marker, markerRange) {\n        const markerGroup = marker.name.split(':', 1)[0];\n        if (!this._observedMarkers.has(markerGroup)) {\n            return;\n        }\n        let changed = false;\n        const oldMarkers = Array.from(this.markers);\n        const hasMarker = this.markers.has(marker);\n        if (!markerRange) {\n            if (hasMarker) {\n                this.markers.remove(marker);\n                changed = true;\n            }\n        }\n        else {\n            let contained = false;\n            for (const selectionRange of this.getRanges()) {\n                if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (contained && !hasMarker) {\n                this.markers.add(marker);\n                changed = true;\n            }\n            else if (!contained && hasMarker) {\n                this.markers.remove(marker);\n                changed = true;\n            }\n        }\n        if (changed) {\n            this.fire('change:marker', { oldMarkers, directChange: false });\n        }\n    }\n    // Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n    //\n    // @protected\n    // @param {Boolean} clearAll\n    // @fires change:attribute\n    _updateAttributes(clearAll) {\n        const newAttributes = toMap(this._getSurroundingAttributes());\n        const oldAttributes = toMap(this.getAttributes());\n        if (clearAll) {\n            // If `clearAll` remove all attributes and reset priorities.\n            this._attributePriority = new Map();\n            this._attrs = new Map();\n        }\n        else {\n            // If not, remove only attributes added with `low` priority.\n            for (const [key, priority] of this._attributePriority) {\n                if (priority == 'low') {\n                    this._attrs.delete(key);\n                    this._attributePriority.delete(key);\n                }\n            }\n        }\n        this._setAttributesTo(newAttributes);\n        // Let's evaluate which attributes really changed.\n        const changed = [];\n        // First, loop through all attributes that are set on selection right now.\n        // Check which of them are different than old attributes.\n        for (const [newKey, newValue] of this.getAttributes()) {\n            if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {\n                changed.push(newKey);\n            }\n        }\n        // Then, check which of old attributes got removed.\n        for (const [oldKey] of oldAttributes) {\n            if (!this.hasAttribute(oldKey)) {\n                changed.push(oldKey);\n            }\n        }\n        // Fire event with exact data (fire only if anything changed).\n        if (changed.length > 0) {\n            this.fire('change:attribute', { attributeKeys: changed, directChange: false });\n        }\n    }\n    // Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n    // parameter).\n    //\n    // @private\n    // @param {String} key Attribute key.\n    // @param {*} value Attribute value.\n    // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n    // is caused by `Batch` API.\n    // @returns {Boolean} Whether value has changed.\n    _setAttribute(key, value, directChange = true) {\n        const priority = directChange ? 'normal' : 'low';\n        if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n            // Priority too low.\n            return false;\n        }\n        const oldValue = super.getAttribute(key);\n        // Don't do anything if value has not changed.\n        if (oldValue === value) {\n            return false;\n        }\n        this._attrs.set(key, value);\n        // Update priorities map.\n        this._attributePriority.set(key, priority);\n        return true;\n    }\n    // Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n    // parameter).\n    //\n    // NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n    // be changed according to `directChange` parameter.\n    //\n    // @private\n    // @param {String} key Attribute key.\n    // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n    // is caused by `Batch` API.\n    // @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n    // existing attribute had higher priority.\n    _removeAttribute(key, directChange = true) {\n        const priority = directChange ? 'normal' : 'low';\n        if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n            // Priority too low.\n            return false;\n        }\n        // Update priorities map.\n        this._attributePriority.set(key, priority);\n        // Don't do anything if value has not changed.\n        if (!super.hasAttribute(key)) {\n            return false;\n        }\n        this._attrs.delete(key);\n        return true;\n    }\n    // Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n    // `directChange` parameter).\n    //\n    // @private\n    // @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n    // @returns {Set.<String>} Changed attribute keys.\n    _setAttributesTo(attrs) {\n        const changed = new Set();\n        for (const [oldKey, oldValue] of this.getAttributes()) {\n            // Do not remove attribute if attribute with same key and value is about to be set.\n            if (attrs.get(oldKey) === oldValue) {\n                continue;\n            }\n            // All rest attributes will be removed so changed attributes won't change .\n            this._removeAttribute(oldKey, false);\n        }\n        for (const [key, value] of attrs) {\n            // Attribute may not be set because of attributes or because same key/value is already added.\n            const gotAdded = this._setAttribute(key, value, false);\n            if (gotAdded) {\n                changed.add(key);\n            }\n        }\n        return changed;\n    }\n    // Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n    //\n    // @public\n    // @returns {Iterable.<*>}\n    *getStoredAttributes() {\n        const selectionParent = this.getFirstPosition().parent;\n        if (this.isCollapsed && selectionParent.isEmpty) {\n            for (const key of selectionParent.getAttributeKeys()) {\n                if (key.startsWith(storePrefix)) {\n                    const realKey = key.substr(storePrefix.length);\n                    yield [realKey, selectionParent.getAttribute(key)];\n                }\n            }\n        }\n    }\n    // Checks model text nodes that are closest to the selection's first position and returns attributes of first\n    // found element. If there are no text nodes in selection's first position parent, it returns selection\n    // attributes stored in that parent.\n    //\n    // @private\n    // @returns {Iterable.<*>} Collection of attributes.\n    _getSurroundingAttributes() {\n        const position = this.getFirstPosition();\n        const schema = this._model.schema;\n        let attrs = null;\n        if (!this.isCollapsed) {\n            // 1. If selection is a range...\n            const range = this.getFirstRange();\n            // ...look for a first character node in that range and take attributes from it.\n            for (const value of range) {\n                // If the item is an object, we don't want to get attributes from its children.\n                if (value.item.is('element') && schema.isObject(value.item)) {\n                    break;\n                }\n                if (value.type == 'text') {\n                    attrs = value.item.getAttributes();\n                    break;\n                }\n            }\n        }\n        else {\n            // 2. If the selection is a caret or the range does not contain a character node...\n            const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n            const nodeAfter = position.textNode ? position.textNode : position.nodeAfter;\n            // When gravity is overridden then don't take node before into consideration.\n            if (!this.isGravityOverridden) {\n                // ...look at the node before caret and take attributes from it if it is a character node.\n                attrs = getAttrsIfCharacter(nodeBefore);\n            }\n            // 3. If not, look at the node after caret...\n            if (!attrs) {\n                attrs = getAttrsIfCharacter(nodeAfter);\n            }\n            // 4. If not, try to find the first character on the left, that is in the same node.\n            // When gravity is overridden then don't take node before into consideration.\n            if (!this.isGravityOverridden && !attrs) {\n                let node = nodeBefore;\n                while (node && !schema.isInline(node) && !attrs) {\n                    node = node.previousSibling;\n                    attrs = getAttrsIfCharacter(node);\n                }\n            }\n            // 5. If not found, try to find the first character on the right, that is in the same node.\n            if (!attrs) {\n                let node = nodeAfter;\n                while (node && !schema.isInline(node) && !attrs) {\n                    node = node.nextSibling;\n                    attrs = getAttrsIfCharacter(node);\n                }\n            }\n            // 6. If not found, selection should retrieve attributes from parent.\n            if (!attrs) {\n                attrs = this.getStoredAttributes();\n            }\n        }\n        return attrs;\n    }\n    // Fixes the selection after all its ranges got removed.\n    //\n    // @private\n    // @param {module:engine/model/position~Position} deletionPosition Position where the deletion happened.\n    _fixGraveyardSelection(deletionPosition) {\n        // Find a range that is a correct selection range and is closest to the position where the deletion happened.\n        const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition);\n        // If nearest valid selection range has been found - add it in the place of old range.\n        if (selectionRange) {\n            // Check the range, convert it to live range, bind events, etc.\n            this._pushRange(selectionRange);\n        }\n        // If nearest valid selection range cannot be found don't add any range. Selection will be set to the default range.\n    }\n}\n// Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\nfunction getAttrsIfCharacter(node) {\n    if (node instanceof TextProxy || node instanceof Text) {\n        return node.getAttributes();\n    }\n    return null;\n}\n// Removes selection attributes from element which is not empty anymore.\n//\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\nfunction clearAttributesStoredInElement(model, batch) {\n    const differ = model.document.differ;\n    for (const entry of differ.getChanges()) {\n        if (entry.type != 'insert') {\n            continue;\n        }\n        const changeParent = entry.position.parent;\n        const isNoLongerEmpty = entry.length === changeParent.maxOffset;\n        if (isNoLongerEmpty) {\n            model.enqueueChange(batch, writer => {\n                const storedAttributes = Array.from(changeParent.getAttributeKeys())\n                    .filter(key => key.startsWith(storePrefix));\n                for (const key of storedAttributes) {\n                    writer.removeAttribute(key, changeParent);\n                }\n            });\n        }\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,aAAa,MAAM,6CAA6C;AACvE,OAAOC,UAAU,MAAM,0CAA0C;AACjE,OAAOC,YAAY,MAAM,4CAA4C;AACrE,OAAOC,KAAK,MAAM,qCAAqC;AACvD,OAAOC,GAAG,MAAM,mCAAmC;AACnD,MAAMC,WAAW,GAAG,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,iBAAiB,SAASJ,YAAY,CAACP,aAAa,CAAC,CAAC;EACvE;AACJ;AACA;AACA;AACA;EACIY,WAAW,CAACC,GAAG,EAAE;IACb,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAIC,aAAa,CAACF,GAAG,CAAC;IACxC,IAAI,CAACC,UAAU,CAACE,QAAQ,CAAC,cAAc,CAAC,CAACC,EAAE,CAAC,IAAI,CAAC;IACjD,IAAI,CAACH,UAAU,CAACE,QAAQ,CAAC,kBAAkB,CAAC,CAACC,EAAE,CAAC,IAAI,CAAC;IACrD,IAAI,CAACH,UAAU,CAACE,QAAQ,CAAC,eAAe,CAAC,CAACC,EAAE,CAAC,IAAI,CAAC;EACtD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,WAAW,GAAG;IACd,OAAO,IAAI,CAACJ,UAAU,CAACI,WAAW;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,MAAM,GAAG;IACT,OAAO,IAAI,CAACL,UAAU,CAACK,MAAM;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,KAAK,GAAG;IACR,OAAO,IAAI,CAACN,UAAU,CAACM,KAAK;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAG;IACb,OAAO,IAAI,CAACP,UAAU,CAACO,UAAU;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,WAAW,GAAG;IACd,OAAO,IAAI,CAACR,UAAU,CAACQ,WAAW;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAG;IACb,OAAO,IAAI,CAACT,UAAU,CAACS,UAAU;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,mBAAmB,GAAG;IACtB,OAAO,IAAI,CAACV,UAAU,CAACU,mBAAmB;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,OAAO,GAAG;IACV,OAAO,IAAI,CAACX,UAAU,CAACW,OAAO;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,OAAO,GAAG;IACV,OAAO,IAAI,CAACZ,UAAU,CAACY,OAAO;EAClC;EACA;AACJ;AACA;AACA;AACA;EACIC,SAAS,GAAG;IACR,OAAO,IAAI,CAACb,UAAU,CAACa,SAAS,EAAE;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgB,GAAG;IACf,OAAO,IAAI,CAACd,UAAU,CAACc,gBAAgB,EAAE;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,eAAe,GAAG;IACd,OAAO,IAAI,CAACf,UAAU,CAACe,eAAe,EAAE;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,GAAG;IACZ,OAAO,IAAI,CAAChB,UAAU,CAACgB,aAAa,EAAE;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,GAAG;IACX,OAAO,IAAI,CAACjB,UAAU,CAACiB,YAAY,EAAE;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,iBAAiB,GAAG;IAChB,OAAO,IAAI,CAAClB,UAAU,CAACkB,iBAAiB,EAAE;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,kBAAkB,GAAG;IACjB,OAAO,IAAI,CAACnB,UAAU,CAACmB,kBAAkB,EAAE;EAC/C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,qBAAqB,CAACC,OAAO,EAAE;IAC3B,OAAO,IAAI,CAACrB,UAAU,CAACoB,qBAAqB,CAACC,OAAO,CAAC;EACzD;EACA;AACJ;AACA;EACIC,OAAO,GAAG;IACN,IAAI,CAACtB,UAAU,CAACsB,OAAO,EAAE;EAC7B;EACA;AACJ;AACA;AACA;AACA;EACIC,gBAAgB,GAAG;IACf,OAAO,IAAI,CAACvB,UAAU,CAACuB,gBAAgB,EAAE;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,GAAG;IACZ,OAAO,IAAI,CAACxB,UAAU,CAACwB,aAAa,EAAE;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACC,GAAG,EAAE;IACd,OAAO,IAAI,CAAC1B,UAAU,CAACyB,YAAY,CAACC,GAAG,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACD,GAAG,EAAE;IACd,OAAO,IAAI,CAAC1B,UAAU,CAAC2B,YAAY,CAACD,GAAG,CAAC;EAC5C;EACA;AACJ;AACA;EACIE,OAAO,GAAG;IACN,IAAI,CAAC5B,UAAU,CAAC6B,aAAa,EAAE;IAC/B,IAAI,CAAC7B,UAAU,CAAC8B,iBAAiB,CAAC,KAAK,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,cAAc,CAACC,YAAY,EAAE;IACzB,IAAI,CAAChC,UAAU,CAAC+B,cAAc,CAACC,YAAY,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,SAAS,CAACC,cAAc,EAAEC,MAAM,EAAE;IAC9B,IAAI,CAACnC,UAAU,CAACoC,QAAQ,CAACF,cAAc,EAAEC,MAAM,CAAC;EACpD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,MAAM,GAAU;IACZ,IAAI,CAACrC,UAAU,CAACsC,KAAK,CAAC,YAAO,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,CAACb,GAAG,EAAEc,KAAK,EAAE;IACtB,IAAI,CAACxC,UAAU,CAACyC,YAAY,CAACf,GAAG,EAAEc,KAAK,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,gBAAgB,CAAChB,GAAG,EAAE;IAClB,IAAI,CAAC1B,UAAU,CAAC2C,eAAe,CAACjB,GAAG,CAAC;EACxC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIkB,oBAAoB,GAAG;IACnB,OAAO,IAAI,CAAC5C,UAAU,CAAC6C,mBAAmB,EAAE;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgB,GAAG;IACf,OAAO,IAAI,CAAC9C,UAAU,CAAC+C,eAAe,EAAE;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,eAAe,CAACrD,GAAG,EAAE;IACjB,IAAI,CAACK,UAAU,CAACiD,cAAc,CAACtD,GAAG,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOuD,qBAAqB,CAACxB,GAAG,EAAE;IAC9B,OAAO9B,WAAW,G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"},"metadata":{},"sourceType":"module"}