{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/autoparagraphing\n */\n/**\n * Fixes all empty roots.\n *\n * @protected\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\nexport function autoParagraphEmptyRoots(writer) {\n  const {\n    schema,\n    document\n  } = writer.model;\n  for (const rootName of document.getRootNames()) {\n    const root = document.getRoot(rootName);\n    if (root.isEmpty && !schema.checkChild(root, '$text')) {\n      // If paragraph element is allowed in the root, create paragraph element.\n      if (schema.checkChild(root, 'paragraph')) {\n        writer.insertElement('paragraph', root);\n        // Other roots will get fixed in the next post-fixer round. Those will be triggered\n        // in the same batch no matter if this method was triggered by the post-fixing or not\n        // (the above insertElement call will trigger the post-fixers).\n        return true;\n      }\n    }\n  }\n  return false;\n}\n/**\n * Checks if the given node wrapped with a paragraph would be accepted by the schema in the given position.\n *\n * @internal\n * @protected\n * @param {module:engine/model/position~Position} position The position at which to check.\n * @param {module:engine/model/node~Node|String} nodeOrType The child node or child type to check.\n * @param {module:engine/model/schema~Schema} schema A schema instance used for element validation.\n */\nexport function isParagraphable(position, nodeOrType, schema) {\n  const context = schema.createContext(position);\n  // When paragraph is allowed in this context...\n  if (!schema.checkChild(context, 'paragraph')) {\n    return false;\n  }\n  // And a node would be allowed in this paragraph...\n  if (!schema.checkChild(context.push('paragraph'), nodeOrType)) {\n    return false;\n  }\n  return true;\n}\n/**\n * Inserts a new paragraph at the given position and returns a position inside that paragraph.\n *\n * @protected\n * @param {module:engine/model/position~Position} position The position where a paragraph should be inserted.\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {module:engine/model/position~Position} Position inside the created paragraph.\n */\nexport function wrapInParagraph(position, writer) {\n  const paragraph = writer.createElement('paragraph');\n  writer.insert(paragraph, position);\n  return writer.createPositionAt(paragraph, 0);\n}","map":{"version":3,"names":["autoParagraphEmptyRoots","writer","schema","document","model","rootName","getRootNames","root","getRoot","isEmpty","checkChild","insertElement","isParagraphable","position","nodeOrType","context","createContext","push","wrapInParagraph","paragraph","createElement","insert","createPositionAt"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/autoparagraphing.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/autoparagraphing\n */\n/**\n * Fixes all empty roots.\n *\n * @protected\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\nexport function autoParagraphEmptyRoots(writer) {\n    const { schema, document } = writer.model;\n    for (const rootName of document.getRootNames()) {\n        const root = document.getRoot(rootName);\n        if (root.isEmpty && !schema.checkChild(root, '$text')) {\n            // If paragraph element is allowed in the root, create paragraph element.\n            if (schema.checkChild(root, 'paragraph')) {\n                writer.insertElement('paragraph', root);\n                // Other roots will get fixed in the next post-fixer round. Those will be triggered\n                // in the same batch no matter if this method was triggered by the post-fixing or not\n                // (the above insertElement call will trigger the post-fixers).\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * Checks if the given node wrapped with a paragraph would be accepted by the schema in the given position.\n *\n * @internal\n * @protected\n * @param {module:engine/model/position~Position} position The position at which to check.\n * @param {module:engine/model/node~Node|String} nodeOrType The child node or child type to check.\n * @param {module:engine/model/schema~Schema} schema A schema instance used for element validation.\n */\nexport function isParagraphable(position, nodeOrType, schema) {\n    const context = schema.createContext(position);\n    // When paragraph is allowed in this context...\n    if (!schema.checkChild(context, 'paragraph')) {\n        return false;\n    }\n    // And a node would be allowed in this paragraph...\n    if (!schema.checkChild(context.push('paragraph'), nodeOrType)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Inserts a new paragraph at the given position and returns a position inside that paragraph.\n *\n * @protected\n * @param {module:engine/model/position~Position} position The position where a paragraph should be inserted.\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {module:engine/model/position~Position} Position inside the created paragraph.\n */\nexport function wrapInParagraph(position, writer) {\n    const paragraph = writer.createElement('paragraph');\n    writer.insert(paragraph, position);\n    return writer.createPositionAt(paragraph, 0);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,uBAAuB,CAACC,MAAM,EAAE;EAC5C,MAAM;IAAEC,MAAM;IAAEC;EAAS,CAAC,GAAGF,MAAM,CAACG,KAAK;EACzC,KAAK,MAAMC,QAAQ,IAAIF,QAAQ,CAACG,YAAY,EAAE,EAAE;IAC5C,MAAMC,IAAI,GAAGJ,QAAQ,CAACK,OAAO,CAACH,QAAQ,CAAC;IACvC,IAAIE,IAAI,CAACE,OAAO,IAAI,CAACP,MAAM,CAACQ,UAAU,CAACH,IAAI,EAAE,OAAO,CAAC,EAAE;MACnD;MACA,IAAIL,MAAM,CAACQ,UAAU,CAACH,IAAI,EAAE,WAAW,CAAC,EAAE;QACtCN,MAAM,CAACU,aAAa,CAAC,WAAW,EAAEJ,IAAI,CAAC;QACvC;QACA;QACA;QACA,OAAO,IAAI;MACf;IACJ;EACJ;EACA,OAAO,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,eAAe,CAACC,QAAQ,EAAEC,UAAU,EAAEZ,MAAM,EAAE;EAC1D,MAAMa,OAAO,GAAGb,MAAM,CAACc,aAAa,CAACH,QAAQ,CAAC;EAC9C;EACA,IAAI,CAACX,MAAM,CAACQ,UAAU,CAACK,OAAO,EAAE,WAAW,CAAC,EAAE;IAC1C,OAAO,KAAK;EAChB;EACA;EACA,IAAI,CAACb,MAAM,CAACQ,UAAU,CAACK,OAAO,CAACE,IAAI,CAAC,WAAW,CAAC,EAAEH,UAAU,CAAC,EAAE;IAC3D,OAAO,KAAK;EAChB;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,eAAe,CAACL,QAAQ,EAAEZ,MAAM,EAAE;EAC9C,MAAMkB,SAAS,GAAGlB,MAAM,CAACmB,aAAa,CAAC,WAAW,CAAC;EACnDnB,MAAM,CAACoB,MAAM,CAACF,SAAS,EAAEN,QAAQ,CAAC;EAClC,OAAOZ,MAAM,CAACqB,gBAAgB,CAACH,SAAS,EAAE,CAAC,CAAC;AAChD"},"metadata":{},"sourceType":"module"}