{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/downcastdispatcher\n */\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * The downcast dispatcher is a central point of downcasting (conversion from the model to the view), which is a process of reacting\n * to changes in the model and firing a set of events. The callbacks listening to these events are called converters. The\n * converters' role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During the conversion process, downcast dispatcher fires events basing on the state of the model and prepares\n * data for these events. It is important to understand that the events are connected with the changes done on the model,\n * for example: \"a node has been inserted\" or \"an attribute has changed\". This is in contrary to upcasting (a view-to-model conversion)\n * where you convert the view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by the {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to the downcast dispatcher as a diff between the old model state and the new model state.\n *\n * Note that because the changes are converted, there is a need to have a mapping between the model structure and the view structure.\n * To map positions and elements during the downcast (a model-to-view conversion), use {@link module:engine/conversion/mapper~Mapper}.\n *\n * Downcast dispatcher fires the following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} &ndash;\n * If a range of nodes was inserted to the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove `remove`} &ndash;\n * If a range of nodes was removed from the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} &ndash;\n * If an attribute was added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`},\n * the downcast dispatcher generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have control over which changes have already been consumed. It is useful when some converters\n * overwrite others or convert multiple changes (for example, it converts an insertion of an element and also converts that\n * element's attributes during the insertion).\n *\n * Additionally, downcast dispatcher fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`} &ndash; If a marker was added.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker `removeMarker`} &ndash; If a marker was\n * removed.\n *\n * Note that changing a marker is done through removing the marker from the old range and adding it to the new range,\n * so both of these events are fired.\n *\n * Finally, a downcast dispatcher also handles firing events for the {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection `selection`}\n * &ndash; Converts the selection from the model to the view.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`}\n * &ndash; Fired for every selection attribute.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`}\n * &ndash; Fired for every marker that contains a selection.\n *\n * Unlike the model tree and the markers, the events for selection are not fired for changes but for a selection state.\n *\n * When providing custom listeners for a downcast dispatcher, remember to check whether a given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for a downcast dispatcher, keep in mind that you **should not** stop the event. If you stop it,\n * then the default converter at the `lowest` priority will not trigger the conversion of this node's attributes and child nodes.\n *\n * When providing custom listeners for a downcast dispatcher, remember to use the provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * You can read more about conversion in the following guide:\n *\n * * {@glink framework/guides/deep-dive/conversion/downcast Downcast conversion}\n *\n * An example of a custom converter for the downcast dispatcher:\n *\n *\t\t// You will convert inserting a \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate the position in the model to a position in the view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create a <p> element that will be inserted into the view at the `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to the model element so positions will map accordingly in the future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\t\t} );\n */\nexport default class DowncastDispatcher extends Emitter {\n  /**\n   * Creates a downcast dispatcher instance.\n   *\n   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n   * @param {Object} conversionApi Additional properties for an interface that will be passed to events fired\n   * by the downcast dispatcher.\n   */\n  constructor(conversionApi) {\n    super();\n    /**\n     * A template for an interface passed by the dispatcher to the event callbacks.\n     *\n     * @protected\n     * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n     */\n    this._conversionApi = {\n      dispatcher: this,\n      ...conversionApi\n    };\n    /**\n     * A map of already fired events for a given `ModelConsumable`.\n     *\n     * @private\n     * @member {WeakMap.<module:engine/conversion/downcastdispatcher~DowncastConversionApi,Map>}\n     */\n    this._firedEventsMap = new WeakMap();\n  }\n  /**\n   * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}\n   * and fires conversion events based on it.\n   *\n   * @fires insert\n   * @fires remove\n   * @fires attribute\n   * @fires addMarker\n   * @fires removeMarker\n   * @fires reduceChanges\n   * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers related to the model fragment to convert.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   */\n  convertChanges(differ, markers, writer) {\n    const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems());\n    // Before the view is updated, remove markers which have changed.\n    for (const change of differ.getMarkersToRemove()) {\n      this._convertMarkerRemove(change.name, change.range, conversionApi);\n    }\n    // Let features modify the change list (for example to allow reconversion).\n    const changes = this._reduceChanges(differ.getChanges());\n    // Convert changes that happened on model tree.\n    for (const entry of changes) {\n      if (entry.type === 'insert') {\n        this._convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n      } else if (entry.type === 'reinsert') {\n        this._convertReinsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n      } else if (entry.type === 'remove') {\n        this._convertRemove(entry.position, entry.length, entry.name, conversionApi);\n      } else {\n        // Defaults to 'attribute' change.\n        this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);\n      }\n    }\n    for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {\n      const markerRange = markers.get(markerName).getRange();\n      this._convertMarkerRemove(markerName, markerRange, conversionApi);\n      this._convertMarkerAdd(markerName, markerRange, conversionApi);\n    }\n    // After the view is updated, convert markers which have changed.\n    for (const change of differ.getMarkersToAdd()) {\n      this._convertMarkerAdd(change.name, change.range, conversionApi);\n    }\n    // Remove mappings for all removed view elements.\n    conversionApi.mapper.flushDeferredBindings();\n    // Verify if all insert consumables were consumed.\n    conversionApi.consumable.verifyAllConsumed('insert');\n  }\n  /**\n   * Starts a conversion of a model range and the provided markers.\n   *\n   * @fires insert\n   * @fires attribute\n   * @fires addMarker\n   * @param {module:engine/model/range~Range} range The inserted range.\n   * @param {Map<String,module:engine/model/range~Range>} markers The map of markers that should be down-casted.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   * @param {Object} [options] Optional options object passed to `convertionApi.options`.\n   */\n  convert(range, markers, writer) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const conversionApi = this._createConversionApi(writer, undefined, options);\n    this._convertInsert(range, conversionApi);\n    for (const [name, range] of markers) {\n      this._convertMarkerAdd(name, range, conversionApi);\n    }\n    // Verify if all insert consumables were consumed.\n    conversionApi.consumable.verifyAllConsumed('insert');\n  }\n  /**\n   * Starts the model selection conversion.\n   *\n   * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.\n   *\n   * @fires selection\n   * @fires addMarker\n   * @fires attribute\n   * @param {module:engine/model/selection~Selection} selection The selection to convert.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n   */\n  convertSelection(selection, markers, writer) {\n    const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));\n    const conversionApi = this._createConversionApi(writer);\n    this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);\n    this.fire('selection', {\n      selection\n    }, conversionApi);\n    if (!selection.isCollapsed) {\n      return;\n    }\n    for (const marker of markersAtSelection) {\n      const markerRange = marker.getRange();\n      if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {\n        continue;\n      }\n      const data = {\n        item: selection,\n        markerName: marker.name,\n        markerRange\n      };\n      if (conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {\n        this.fire(`addMarker:${marker.name}`, data, conversionApi);\n      }\n    }\n    for (const key of selection.getAttributeKeys()) {\n      const data = {\n        item: selection,\n        range: selection.getFirstRange(),\n        attributeKey: key,\n        attributeOldValue: null,\n        attributeNewValue: selection.getAttribute(key)\n      };\n      // Do not fire event if the attribute has been consumed.\n      if (conversionApi.consumable.test(selection, 'attribute:' + data.attributeKey)) {\n        this.fire(`attribute:${data.attributeKey}:$text`, data, conversionApi);\n      }\n    }\n  }\n  /**\n   * Fires insertion conversion of a range of nodes.\n   *\n   * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,\n   * {@link #event:attribute `attribute` event is fired}.\n   *\n   * @protected\n   * @fires insert\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range The inserted range.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   * @param {Object} [options]\n   * @param {Boolean} [options.doNotAddConsumables=false] Whether the ModelConsumable should not get populated\n   * for items in the provided range.\n   */\n  _convertInsert(range, conversionApi) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!options.doNotAddConsumables) {\n      // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n      this._addConsumablesForInsert(conversionApi.consumable, Array.from(range));\n    }\n    // Fire a separate insert event for each node and text fragment contained in the range.\n    for (const data of Array.from(range.getWalker({\n      shallow: true\n    })).map(walkerValueToEventData)) {\n      this._testAndFire('insert', data, conversionApi);\n    }\n  }\n  /**\n   * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} position Position from which node was removed.\n   * @param {Number} length Offset size of removed node.\n   * @param {String} name Name of removed node.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n  _convertRemove(position, length, name, conversionApi) {\n    this.fire(`remove:${name}`, {\n      position,\n      length\n    }, conversionApi);\n  }\n  /**\n   * Starts a conversion of an attribute change on a given `range`.\n   *\n   * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n   *\n   * @protected\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range Changed range.\n   * @param {String} key Key of the attribute that has changed.\n   * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n   * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n  _convertAttribute(range, key, oldValue, newValue, conversionApi) {\n    // Create a list with attributes to consume.\n    this._addConsumablesForRange(conversionApi.consumable, range, `attribute:${key}`);\n    // Create a separate attribute event for each node in the range.\n    for (const value of range) {\n      const data = {\n        item: value.item,\n        range: Range._createFromPositionAndShift(value.previousPosition, value.length),\n        attributeKey: key,\n        attributeOldValue: oldValue,\n        attributeNewValue: newValue\n      };\n      this._testAndFire(`attribute:${key}`, data, conversionApi);\n    }\n  }\n  /**\n   * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)\n   * of a range of elements (only elements on the range depth, without children).\n   *\n   * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.\n   * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.\n   *\n   * @protected\n   * @fires insert\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range The range to reinsert.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n  _convertReinsert(range, conversionApi) {\n    // Convert the elements - without converting children.\n    const walkerValues = Array.from(range.getWalker({\n      shallow: true\n    }));\n    // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n    this._addConsumablesForInsert(conversionApi.consumable, walkerValues);\n    // Fire a separate insert event for each node and text fragment contained shallowly in the range.\n    for (const data of walkerValues.map(walkerValueToEventData)) {\n      this._testAndFire('insert', {\n        ...data,\n        reconversion: true\n      }, conversionApi);\n    }\n  }\n  /**\n   * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item\n   * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.\n   *\n   * @protected\n   * @fires addMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange The marker range.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n  _convertMarkerAdd(markerName, markerRange, conversionApi) {\n    // Do not convert if range is in graveyard.\n    if (markerRange.root.rootName == '$graveyard') {\n      return;\n    }\n    // In markers' case, event name == consumable name.\n    const eventName = `addMarker:${markerName}`;\n    //\n    // First, fire an event for the whole marker.\n    //\n    conversionApi.consumable.add(markerRange, eventName);\n    this.fire(eventName, {\n      markerName,\n      markerRange\n    }, conversionApi);\n    //\n    // Do not fire events for each item inside the range if the range got consumed.\n    // Also consume the whole marker consumable if it wasn't consumed.\n    //\n    if (!conversionApi.consumable.consume(markerRange, eventName)) {\n      return;\n    }\n    //\n    // Then, fire an event for each item inside the marker range.\n    //\n    this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);\n    for (const item of markerRange.getItems()) {\n      // Do not fire event for already consumed items.\n      if (!conversionApi.consumable.test(item, eventName)) {\n        continue;\n      }\n      const data = {\n        item,\n        range: Range._createOn(item),\n        markerName,\n        markerRange\n      };\n      this.fire(eventName, data, conversionApi);\n    }\n  }\n  /**\n   * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.\n   *\n   * @protected\n   * @fires removeMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange The marker range.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n  _convertMarkerRemove(markerName, markerRange, conversionApi) {\n    // Do not convert if range is in graveyard.\n    if (markerRange.root.rootName == '$graveyard') {\n      return;\n    }\n    this.fire(`removeMarker:${markerName}`, {\n      markerName,\n      markerRange\n    }, conversionApi);\n  }\n  /**\n   * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.\n   *\n   * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger\n   * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n   * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.\n   *\n   * @private\n   * @fires reduceChanges\n   * @param {Iterable.<module:engine/model/differ~DiffItem>} changes\n   * @returns {Iterable.<module:engine/model/differ~DiffItem>}\n   */\n  _reduceChanges(changes) {\n    const data = {\n      changes\n    };\n    this.fire('reduceChanges', data);\n    return data.changes;\n  }\n  /**\n   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,\n   * assuming that the range has just been inserted to the model.\n   *\n   * @private\n   * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n   * @param {Iterable.<module:engine/model/treewalker~TreeWalkerValue>} walkerValues The walker values for the inserted range.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n  _addConsumablesForInsert(consumable, walkerValues) {\n    for (const value of walkerValues) {\n      const item = value.item;\n      // Add consumable if it wasn't there yet.\n      if (consumable.test(item, 'insert') === null) {\n        consumable.add(item, 'insert');\n        for (const key of item.getAttributeKeys()) {\n          consumable.add(item, 'attribute:' + key);\n        }\n      }\n    }\n    return consumable;\n  }\n  /**\n   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.\n   *\n   * @private\n   * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n   * @param {module:engine/model/range~Range} range The affected range.\n   * @param {String} type Consumable type.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n  _addConsumablesForRange(consumable, range, type) {\n    for (const item of range.getItems()) {\n      consumable.add(item, type);\n    }\n    return consumable;\n  }\n  /**\n   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n   *\n   * @private\n   * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n   * @param {module:engine/model/selection~Selection} selection The selection to create the consumable from.\n   * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers that contain the selection.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n  _addConsumablesForSelection(consumable, selection, markers) {\n    consumable.add(selection, 'selection');\n    for (const marker of markers) {\n      consumable.add(selection, 'addMarker:' + marker.name);\n    }\n    for (const key of selection.getAttributeKeys()) {\n      consumable.add(selection, 'attribute:' + key);\n    }\n    return consumable;\n  }\n  /**\n   * Tests whether given event wasn't already fired and if so, fires it.\n   *\n   * @private\n   * @fires insert\n   * @fires attribute\n   * @param {String} type Event type.\n   * @param {Object} data Event data.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n  _testAndFire(type, data, conversionApi) {\n    const eventName = getEventName(type, data);\n    const itemKey = data.item.is('$textProxy') ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;\n    const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);\n    const eventsFiredForItem = eventsFiredForConversion.get(itemKey);\n    if (!eventsFiredForItem) {\n      eventsFiredForConversion.set(itemKey, new Set([eventName]));\n    } else if (!eventsFiredForItem.has(eventName)) {\n      eventsFiredForItem.add(eventName);\n    } else {\n      return;\n    }\n    this.fire(eventName, data, conversionApi);\n  }\n  /**\n   * Fires not already fired events for setting attributes on just inserted item.\n   *\n   * @private\n   * @param {module:engine/model/item~Item} item The model item to convert attributes for.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n  _testAndFireAddAttributes(item, conversionApi) {\n    const data = {\n      item,\n      range: Range._createOn(item)\n    };\n    for (const key of data.item.getAttributeKeys()) {\n      data.attributeKey = key;\n      data.attributeOldValue = null;\n      data.attributeNewValue = data.item.getAttribute(key);\n      this._testAndFire(`attribute:${key}`, data, conversionApi);\n    }\n  }\n  /**\n   * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given\n   * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.\n   *\n   * @private\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n   * @param {Set.<module:engine/model/element~Element>} [refreshedItems] A set of model elements that should not reuse their\n   * previous view representations.\n   * @param {Object} [options] Optional options passed to `convertionApi.options`.\n   * @return {module:engine/conversion/downcastdispatcher~DowncastConversionApi} The conversion API object.\n   */\n  _createConversionApi(writer) {\n    let refreshedItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const conversionApi = {\n      ...this._conversionApi,\n      consumable: new Consumable(),\n      writer,\n      options,\n      convertItem: item => this._convertInsert(Range._createOn(item), conversionApi),\n      convertChildren: element => this._convertInsert(Range._createIn(element), conversionApi, {\n        doNotAddConsumables: true\n      }),\n      convertAttributes: item => this._testAndFireAddAttributes(item, conversionApi),\n      canReuseView: viewElement => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))\n    };\n    this._firedEventsMap.set(conversionApi, new Map());\n    return conversionApi;\n  }\n}\n// Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\nfunction shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {\n  const range = marker.getRange();\n  const ancestors = Array.from(modelPosition.getAncestors());\n  ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n  ancestors.reverse();\n  const hasCustomHandling = ancestors.some(element => {\n    if (range.containsItem(element)) {\n      const viewElement = mapper.toViewElement(element);\n      return !!viewElement.getCustomProperty('addHighlight');\n    }\n  });\n  return !hasCustomHandling;\n}\nfunction getEventName(type, data) {\n  const name = data.item.is('element') ? data.item.name : '$text';\n  return `${type}:${name}`;\n}\nfunction walkerValueToEventData(value) {\n  const item = value.item;\n  const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n  return {\n    item,\n    range: itemRange\n  };\n}\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n/**\n * Stores the information about what parts of a processed model item are still waiting to be handled. After a piece of a model item was\n * converted, an appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n/**\n * The {@link module:engine/model/schema~Schema} instance set for the model that is downcast.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n/**\n * Triggers conversion of a specified item.\n * This conversion is triggered within (as a separate process of) the parent conversion.\n *\n * @method #convertItem\n * @param {module:engine/model/item~Item} item The model item to trigger nested insert conversion on.\n */\n/**\n * Triggers conversion of children of a specified element.\n *\n * @method #convertChildren\n * @param {module:engine/model/element~Element} element The model element to trigger children insert conversion on.\n */\n/**\n * Triggers conversion of attributes of a specified item.\n *\n * @method #convertAttributes\n * @param {module:engine/model/item~Item} item The model item to trigger attribute conversion on.\n */\n/**\n * An object with an additional configuration which can be used during the conversion process. Available only for data downcast conversion.\n *\n * @member {Object} #options\n */","map":{"version":3,"names":["Consumable","Range","Emitter","DowncastDispatcher","constructor","conversionApi","_conversionApi","dispatcher","_firedEventsMap","WeakMap","convertChanges","differ","markers","writer","_createConversionApi","getRefreshedItems","change","getMarkersToRemove","_convertMarkerRemove","name","range","changes","_reduceChanges","getChanges","entry","type","_convertInsert","_createFromPositionAndShift","position","length","_convertReinsert","_convertRemove","_convertAttribute","attributeKey","attributeOldValue","attributeNewValue","markerName","mapper","flushUnboundMarkerNames","markerRange","get","getRange","_convertMarkerAdd","getMarkersToAdd","flushDeferredBindings","consumable","verifyAllConsumed","convert","options","undefined","convertSelection","selection","markersAtSelection","Array","from","getMarkersAtPosition","getFirstPosition","_addConsumablesForSelection","fire","isCollapsed","marker","shouldMarkerChangeBeConverted","data","item","test","key","getAttributeKeys","getFirstRange","getAttribute","doNotAddConsumables","_addConsumablesForInsert","getWalker","shallow","map","walkerValueToEventData","_testAndFire","oldValue","newValue","_addConsumablesForRange","value","previousPosition","walkerValues","reconversion","root","rootName","eventName","add","consume","getItems","_createOn","getEventName","itemKey","is","_getSymbolForTextProxy","eventsFiredForConversion","eventsFiredForItem","set","Set","has","_testAndFireAddAttributes","refreshedItems","convertItem","convertChildren","element","_createIn","convertAttributes","canReuseView","viewElement","toModelElement","Map","modelPosition","ancestors","getAncestors","shift","reverse","hasCustomHandling","some","containsItem","toViewElement","getCustomProperty","itemRange"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/downcastdispatcher\n */\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * The downcast dispatcher is a central point of downcasting (conversion from the model to the view), which is a process of reacting\n * to changes in the model and firing a set of events. The callbacks listening to these events are called converters. The\n * converters' role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During the conversion process, downcast dispatcher fires events basing on the state of the model and prepares\n * data for these events. It is important to understand that the events are connected with the changes done on the model,\n * for example: \"a node has been inserted\" or \"an attribute has changed\". This is in contrary to upcasting (a view-to-model conversion)\n * where you convert the view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by the {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to the downcast dispatcher as a diff between the old model state and the new model state.\n *\n * Note that because the changes are converted, there is a need to have a mapping between the model structure and the view structure.\n * To map positions and elements during the downcast (a model-to-view conversion), use {@link module:engine/conversion/mapper~Mapper}.\n *\n * Downcast dispatcher fires the following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} &ndash;\n * If a range of nodes was inserted to the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove `remove`} &ndash;\n * If a range of nodes was removed from the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} &ndash;\n * If an attribute was added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`},\n * the downcast dispatcher generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have control over which changes have already been consumed. It is useful when some converters\n * overwrite others or convert multiple changes (for example, it converts an insertion of an element and also converts that\n * element's attributes during the insertion).\n *\n * Additionally, downcast dispatcher fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`} &ndash; If a marker was added.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker `removeMarker`} &ndash; If a marker was\n * removed.\n *\n * Note that changing a marker is done through removing the marker from the old range and adding it to the new range,\n * so both of these events are fired.\n *\n * Finally, a downcast dispatcher also handles firing events for the {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection `selection`}\n * &ndash; Converts the selection from the model to the view.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`}\n * &ndash; Fired for every selection attribute.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`}\n * &ndash; Fired for every marker that contains a selection.\n *\n * Unlike the model tree and the markers, the events for selection are not fired for changes but for a selection state.\n *\n * When providing custom listeners for a downcast dispatcher, remember to check whether a given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for a downcast dispatcher, keep in mind that you **should not** stop the event. If you stop it,\n * then the default converter at the `lowest` priority will not trigger the conversion of this node's attributes and child nodes.\n *\n * When providing custom listeners for a downcast dispatcher, remember to use the provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * You can read more about conversion in the following guide:\n *\n * * {@glink framework/guides/deep-dive/conversion/downcast Downcast conversion}\n *\n * An example of a custom converter for the downcast dispatcher:\n *\n *\t\t// You will convert inserting a \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate the position in the model to a position in the view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create a <p> element that will be inserted into the view at the `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to the model element so positions will map accordingly in the future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\t\t} );\n */\nexport default class DowncastDispatcher extends Emitter {\n    /**\n     * Creates a downcast dispatcher instance.\n     *\n     * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n     * @param {Object} conversionApi Additional properties for an interface that will be passed to events fired\n     * by the downcast dispatcher.\n     */\n    constructor(conversionApi) {\n        super();\n        /**\n         * A template for an interface passed by the dispatcher to the event callbacks.\n         *\n         * @protected\n         * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n         */\n        this._conversionApi = { dispatcher: this, ...conversionApi };\n        /**\n         * A map of already fired events for a given `ModelConsumable`.\n         *\n         * @private\n         * @member {WeakMap.<module:engine/conversion/downcastdispatcher~DowncastConversionApi,Map>}\n         */\n        this._firedEventsMap = new WeakMap();\n    }\n    /**\n     * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}\n     * and fires conversion events based on it.\n     *\n     * @fires insert\n     * @fires remove\n     * @fires attribute\n     * @fires addMarker\n     * @fires removeMarker\n     * @fires reduceChanges\n     * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n     * @param {module:engine/model/markercollection~MarkerCollection} markers Markers related to the model fragment to convert.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n     */\n    convertChanges(differ, markers, writer) {\n        const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems());\n        // Before the view is updated, remove markers which have changed.\n        for (const change of differ.getMarkersToRemove()) {\n            this._convertMarkerRemove(change.name, change.range, conversionApi);\n        }\n        // Let features modify the change list (for example to allow reconversion).\n        const changes = this._reduceChanges(differ.getChanges());\n        // Convert changes that happened on model tree.\n        for (const entry of changes) {\n            if (entry.type === 'insert') {\n                this._convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n            }\n            else if (entry.type === 'reinsert') {\n                this._convertReinsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n            }\n            else if (entry.type === 'remove') {\n                this._convertRemove(entry.position, entry.length, entry.name, conversionApi);\n            }\n            else {\n                // Defaults to 'attribute' change.\n                this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);\n            }\n        }\n        for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {\n            const markerRange = markers.get(markerName).getRange();\n            this._convertMarkerRemove(markerName, markerRange, conversionApi);\n            this._convertMarkerAdd(markerName, markerRange, conversionApi);\n        }\n        // After the view is updated, convert markers which have changed.\n        for (const change of differ.getMarkersToAdd()) {\n            this._convertMarkerAdd(change.name, change.range, conversionApi);\n        }\n        // Remove mappings for all removed view elements.\n        conversionApi.mapper.flushDeferredBindings();\n        // Verify if all insert consumables were consumed.\n        conversionApi.consumable.verifyAllConsumed('insert');\n    }\n    /**\n     * Starts a conversion of a model range and the provided markers.\n     *\n     * @fires insert\n     * @fires attribute\n     * @fires addMarker\n     * @param {module:engine/model/range~Range} range The inserted range.\n     * @param {Map<String,module:engine/model/range~Range>} markers The map of markers that should be down-casted.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n     * @param {Object} [options] Optional options object passed to `convertionApi.options`.\n     */\n    convert(range, markers, writer, options = {}) {\n        const conversionApi = this._createConversionApi(writer, undefined, options);\n        this._convertInsert(range, conversionApi);\n        for (const [name, range] of markers) {\n            this._convertMarkerAdd(name, range, conversionApi);\n        }\n        // Verify if all insert consumables were consumed.\n        conversionApi.consumable.verifyAllConsumed('insert');\n    }\n    /**\n     * Starts the model selection conversion.\n     *\n     * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.\n     *\n     * @fires selection\n     * @fires addMarker\n     * @fires attribute\n     * @param {module:engine/model/selection~Selection} selection The selection to convert.\n     * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n     */\n    convertSelection(selection, markers, writer) {\n        const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));\n        const conversionApi = this._createConversionApi(writer);\n        this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);\n        this.fire('selection', { selection }, conversionApi);\n        if (!selection.isCollapsed) {\n            return;\n        }\n        for (const marker of markersAtSelection) {\n            const markerRange = marker.getRange();\n            if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {\n                continue;\n            }\n            const data = {\n                item: selection,\n                markerName: marker.name,\n                markerRange\n            };\n            if (conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {\n                this.fire(`addMarker:${marker.name}`, data, conversionApi);\n            }\n        }\n        for (const key of selection.getAttributeKeys()) {\n            const data = {\n                item: selection,\n                range: selection.getFirstRange(),\n                attributeKey: key,\n                attributeOldValue: null,\n                attributeNewValue: selection.getAttribute(key)\n            };\n            // Do not fire event if the attribute has been consumed.\n            if (conversionApi.consumable.test(selection, 'attribute:' + data.attributeKey)) {\n                this.fire(`attribute:${data.attributeKey}:$text`, data, conversionApi);\n            }\n        }\n    }\n    /**\n     * Fires insertion conversion of a range of nodes.\n     *\n     * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,\n     * {@link #event:attribute `attribute` event is fired}.\n     *\n     * @protected\n     * @fires insert\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range The inserted range.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     * @param {Object} [options]\n     * @param {Boolean} [options.doNotAddConsumables=false] Whether the ModelConsumable should not get populated\n     * for items in the provided range.\n     */\n    _convertInsert(range, conversionApi, options = {}) {\n        if (!options.doNotAddConsumables) {\n            // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n            this._addConsumablesForInsert(conversionApi.consumable, Array.from(range));\n        }\n        // Fire a separate insert event for each node and text fragment contained in the range.\n        for (const data of Array.from(range.getWalker({ shallow: true })).map(walkerValueToEventData)) {\n            this._testAndFire('insert', data, conversionApi);\n        }\n    }\n    /**\n     * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} position Position from which node was removed.\n     * @param {Number} length Offset size of removed node.\n     * @param {String} name Name of removed node.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n    _convertRemove(position, length, name, conversionApi) {\n        this.fire(`remove:${name}`, { position, length }, conversionApi);\n    }\n    /**\n     * Starts a conversion of an attribute change on a given `range`.\n     *\n     * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n     *\n     * @protected\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range Changed range.\n     * @param {String} key Key of the attribute that has changed.\n     * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n     * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n    _convertAttribute(range, key, oldValue, newValue, conversionApi) {\n        // Create a list with attributes to consume.\n        this._addConsumablesForRange(conversionApi.consumable, range, `attribute:${key}`);\n        // Create a separate attribute event for each node in the range.\n        for (const value of range) {\n            const data = {\n                item: value.item,\n                range: Range._createFromPositionAndShift(value.previousPosition, value.length),\n                attributeKey: key,\n                attributeOldValue: oldValue,\n                attributeNewValue: newValue\n            };\n            this._testAndFire(`attribute:${key}`, data, conversionApi);\n        }\n    }\n    /**\n     * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)\n     * of a range of elements (only elements on the range depth, without children).\n     *\n     * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.\n     * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.\n     *\n     * @protected\n     * @fires insert\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range The range to reinsert.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n    _convertReinsert(range, conversionApi) {\n        // Convert the elements - without converting children.\n        const walkerValues = Array.from(range.getWalker({ shallow: true }));\n        // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n        this._addConsumablesForInsert(conversionApi.consumable, walkerValues);\n        // Fire a separate insert event for each node and text fragment contained shallowly in the range.\n        for (const data of walkerValues.map(walkerValueToEventData)) {\n            this._testAndFire('insert', { ...data, reconversion: true }, conversionApi);\n        }\n    }\n    /**\n     * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item\n     * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.\n     *\n     * @protected\n     * @fires addMarker\n     * @param {String} markerName Marker name.\n     * @param {module:engine/model/range~Range} markerRange The marker range.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n    _convertMarkerAdd(markerName, markerRange, conversionApi) {\n        // Do not convert if range is in graveyard.\n        if (markerRange.root.rootName == '$graveyard') {\n            return;\n        }\n        // In markers' case, event name == consumable name.\n        const eventName = `addMarker:${markerName}`;\n        //\n        // First, fire an event for the whole marker.\n        //\n        conversionApi.consumable.add(markerRange, eventName);\n        this.fire(eventName, { markerName, markerRange }, conversionApi);\n        //\n        // Do not fire events for each item inside the range if the range got consumed.\n        // Also consume the whole marker consumable if it wasn't consumed.\n        //\n        if (!conversionApi.consumable.consume(markerRange, eventName)) {\n            return;\n        }\n        //\n        // Then, fire an event for each item inside the marker range.\n        //\n        this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);\n        for (const item of markerRange.getItems()) {\n            // Do not fire event for already consumed items.\n            if (!conversionApi.consumable.test(item, eventName)) {\n                continue;\n            }\n            const data = { item, range: Range._createOn(item), markerName, markerRange };\n            this.fire(eventName, data, conversionApi);\n        }\n    }\n    /**\n     * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.\n     *\n     * @protected\n     * @fires removeMarker\n     * @param {String} markerName Marker name.\n     * @param {module:engine/model/range~Range} markerRange The marker range.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n    _convertMarkerRemove(markerName, markerRange, conversionApi) {\n        // Do not convert if range is in graveyard.\n        if (markerRange.root.rootName == '$graveyard') {\n            return;\n        }\n        this.fire(`removeMarker:${markerName}`, { markerName, markerRange }, conversionApi);\n    }\n    /**\n     * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.\n     *\n     * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger\n     * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n     * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.\n     *\n     * @private\n     * @fires reduceChanges\n     * @param {Iterable.<module:engine/model/differ~DiffItem>} changes\n     * @returns {Iterable.<module:engine/model/differ~DiffItem>}\n     */\n    _reduceChanges(changes) {\n        const data = { changes };\n        this.fire('reduceChanges', data);\n        return data.changes;\n    }\n    /**\n     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,\n     * assuming that the range has just been inserted to the model.\n     *\n     * @private\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n     * @param {Iterable.<module:engine/model/treewalker~TreeWalkerValue>} walkerValues The walker values for the inserted range.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n     */\n    _addConsumablesForInsert(consumable, walkerValues) {\n        for (const value of walkerValues) {\n            const item = value.item;\n            // Add consumable if it wasn't there yet.\n            if (consumable.test(item, 'insert') === null) {\n                consumable.add(item, 'insert');\n                for (const key of item.getAttributeKeys()) {\n                    consumable.add(item, 'attribute:' + key);\n                }\n            }\n        }\n        return consumable;\n    }\n    /**\n     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.\n     *\n     * @private\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n     * @param {module:engine/model/range~Range} range The affected range.\n     * @param {String} type Consumable type.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n     */\n    _addConsumablesForRange(consumable, range, type) {\n        for (const item of range.getItems()) {\n            consumable.add(item, type);\n        }\n        return consumable;\n    }\n    /**\n     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n     *\n     * @private\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n     * @param {module:engine/model/selection~Selection} selection The selection to create the consumable from.\n     * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers that contain the selection.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n     */\n    _addConsumablesForSelection(consumable, selection, markers) {\n        consumable.add(selection, 'selection');\n        for (const marker of markers) {\n            consumable.add(selection, 'addMarker:' + marker.name);\n        }\n        for (const key of selection.getAttributeKeys()) {\n            consumable.add(selection, 'attribute:' + key);\n        }\n        return consumable;\n    }\n    /**\n     * Tests whether given event wasn't already fired and if so, fires it.\n     *\n     * @private\n     * @fires insert\n     * @fires attribute\n     * @param {String} type Event type.\n     * @param {Object} data Event data.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n    _testAndFire(type, data, conversionApi) {\n        const eventName = getEventName(type, data);\n        const itemKey = data.item.is('$textProxy') ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;\n        const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);\n        const eventsFiredForItem = eventsFiredForConversion.get(itemKey);\n        if (!eventsFiredForItem) {\n            eventsFiredForConversion.set(itemKey, new Set([eventName]));\n        }\n        else if (!eventsFiredForItem.has(eventName)) {\n            eventsFiredForItem.add(eventName);\n        }\n        else {\n            return;\n        }\n        this.fire(eventName, data, conversionApi);\n    }\n    /**\n     * Fires not already fired events for setting attributes on just inserted item.\n     *\n     * @private\n     * @param {module:engine/model/item~Item} item The model item to convert attributes for.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n    _testAndFireAddAttributes(item, conversionApi) {\n        const data = {\n            item,\n            range: Range._createOn(item)\n        };\n        for (const key of data.item.getAttributeKeys()) {\n            data.attributeKey = key;\n            data.attributeOldValue = null;\n            data.attributeNewValue = data.item.getAttribute(key);\n            this._testAndFire(`attribute:${key}`, data, conversionApi);\n        }\n    }\n    /**\n     * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given\n     * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.\n     *\n     * @private\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n     * @param {Set.<module:engine/model/element~Element>} [refreshedItems] A set of model elements that should not reuse their\n     * previous view representations.\n     * @param {Object} [options] Optional options passed to `convertionApi.options`.\n     * @return {module:engine/conversion/downcastdispatcher~DowncastConversionApi} The conversion API object.\n     */\n    _createConversionApi(writer, refreshedItems = new Set(), options = {}) {\n        const conversionApi = {\n            ...this._conversionApi,\n            consumable: new Consumable(),\n            writer,\n            options,\n            convertItem: item => this._convertInsert(Range._createOn(item), conversionApi),\n            convertChildren: element => this._convertInsert(Range._createIn(element), conversionApi, { doNotAddConsumables: true }),\n            convertAttributes: item => this._testAndFireAddAttributes(item, conversionApi),\n            canReuseView: viewElement => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))\n        };\n        this._firedEventsMap.set(conversionApi, new Map());\n        return conversionApi;\n    }\n}\n// Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\nfunction shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {\n    const range = marker.getRange();\n    const ancestors = Array.from(modelPosition.getAncestors());\n    ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n    ancestors.reverse();\n    const hasCustomHandling = ancestors.some(element => {\n        if (range.containsItem(element)) {\n            const viewElement = mapper.toViewElement(element);\n            return !!viewElement.getCustomProperty('addHighlight');\n        }\n    });\n    return !hasCustomHandling;\n}\nfunction getEventName(type, data) {\n    const name = data.item.is('element') ? data.item.name : '$text';\n    return `${type}:${name}`;\n}\nfunction walkerValueToEventData(value) {\n    const item = value.item;\n    const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n    return {\n        item,\n        range: itemRange\n    };\n}\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n/**\n * Stores the information about what parts of a processed model item are still waiting to be handled. After a piece of a model item was\n * converted, an appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n/**\n * The {@link module:engine/model/schema~Schema} instance set for the model that is downcast.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n/**\n * Triggers conversion of a specified item.\n * This conversion is triggered within (as a separate process of) the parent conversion.\n *\n * @method #convertItem\n * @param {module:engine/model/item~Item} item The model item to trigger nested insert conversion on.\n */\n/**\n * Triggers conversion of children of a specified element.\n *\n * @method #convertChildren\n * @param {module:engine/model/element~Element} element The model element to trigger children insert conversion on.\n */\n/**\n * Triggers conversion of attributes of a specified item.\n *\n * @method #convertAttributes\n * @param {module:engine/model/item~Item} item The model item to trigger attribute conversion on.\n */\n/**\n * An object with an additional configuration which can be used during the conversion process. Available only for data downcast conversion.\n *\n * @member {Object} #options\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,UAAU,MAAM,mBAAmB;AAC1C,OAAOC,KAAK,MAAM,gBAAgB;AAClC,SAASC,OAAO,QAAQ,4CAA4C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,kBAAkB,SAASD,OAAO,CAAC;EACpD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,WAAW,CAACC,aAAa,EAAE;IACvB,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG;MAAEC,UAAU,EAAE,IAAI;MAAE,GAAGF;IAAc,CAAC;IAC5D;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACG,eAAe,GAAG,IAAIC,OAAO,EAAE;EACxC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,cAAc,CAACC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAE;IACpC,MAAMR,aAAa,GAAG,IAAI,CAACS,oBAAoB,CAACD,MAAM,EAAEF,MAAM,CAACI,iBAAiB,EAAE,CAAC;IACnF;IACA,KAAK,MAAMC,MAAM,IAAIL,MAAM,CAACM,kBAAkB,EAAE,EAAE;MAC9C,IAAI,CAACC,oBAAoB,CAACF,MAAM,CAACG,IAAI,EAAEH,MAAM,CAACI,KAAK,EAAEf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"},"metadata":{},"sourceType":"module"}