{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/differ\n */\nimport Position from './position';\nimport Range from './range';\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n  /**\n   * Creates a `Differ` instance.\n   *\n   * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n   */\n  constructor(markerCollection) {\n    /**\n     * Reference to the model's marker collection.\n     *\n     * @private\n     * @type {module:engine/model/markercollection~MarkerCollection}\n     */\n    this._markerCollection = markerCollection;\n    /**\n     * A map that stores changes that happened in a given element.\n     *\n     * The keys of the map are references to the model elements.\n     * The values of the map are arrays with changes that were done on this element.\n     *\n     * @private\n     * @type {Map}\n     */\n    this._changesInElement = new Map();\n    /**\n     * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n     * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n     * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n     *\n     * @private\n     * @type {Map}\n     */\n    this._elementSnapshots = new Map();\n    /**\n     * A map that stores all changed markers.\n     *\n     * The keys of the map are marker names.\n     * The values of the map are objects with the following properties:\n     * - `oldMarkerData`,\n     * - `newMarkerData`.\n     *\n     * @private\n     * @type {Map.<String, Object>}\n     */\n    this._changedMarkers = new Map();\n    /**\n     * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n     * when changes are sorted.\n     *\n     * @private\n     * @type {Number}\n     */\n    this._changeCount = 0;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n     * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores those changes that did not take place in graveyard root.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n    this._cachedChanges = null;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n     * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n    this._cachedChangesWithGraveyard = null;\n    /**\n     * Set of model items that were marked to get refreshed in {@link #_refreshItem}.\n     *\n     * @private\n     * @type {Set.<module:engine/model/item~Item>}\n     */\n    this._refreshedItems = new Set();\n  }\n  /**\n   * Informs whether there are any changes buffered in `Differ`.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isEmpty() {\n    return this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n  }\n  /**\n   * Buffers the given operation. An operation has to be buffered before it is executed.\n   *\n   * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n   * in the state before the operation is executed.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operationToBuffer An operation to buffer.\n   */\n  bufferOperation(operationToBuffer) {\n    // Below we take an operation, check its type, then use its parameters in marking (private) methods.\n    // The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n    // Marking changes in them would cause a \"double\" changing then.\n    //\n    const operation = operationToBuffer;\n    switch (operation.type) {\n      case 'insert':\n        {\n          if (this._isInInsertedElement(operation.position.parent)) {\n            return;\n          }\n          this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);\n          break;\n        }\n      case 'addAttribute':\n      case 'removeAttribute':\n      case 'changeAttribute':\n        {\n          for (const item of operation.range.getItems({\n            shallow: true\n          })) {\n            if (this._isInInsertedElement(item.parent)) {\n              continue;\n            }\n            this._markAttribute(item);\n          }\n          break;\n        }\n      case 'remove':\n      case 'move':\n      case 'reinsert':\n        {\n          // When range is moved to the same position then not mark it as a change.\n          // See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n          if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {\n            return;\n          }\n          const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);\n          const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);\n          if (!sourceParentInserted) {\n            this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);\n          }\n          if (!targetParentInserted) {\n            this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);\n          }\n          break;\n        }\n      case 'rename':\n        {\n          if (this._isInInsertedElement(operation.position.parent)) {\n            return;\n          }\n          this._markRemove(operation.position.parent, operation.position.offset, 1);\n          this._markInsert(operation.position.parent, operation.position.offset, 1);\n          const range = Range._createFromPositionAndShift(operation.position, 1);\n          for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n            const markerData = marker.getData();\n            this.bufferMarkerChange(marker.name, markerData, markerData);\n          }\n          break;\n        }\n      case 'split':\n        {\n          const splitElement = operation.splitPosition.parent;\n          // Mark that children of the split element were removed.\n          if (!this._isInInsertedElement(splitElement)) {\n            this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);\n          }\n          // Mark that the new element (split copy) was inserted.\n          if (!this._isInInsertedElement(operation.insertionPosition.parent)) {\n            this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);\n          }\n          // If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n          if (operation.graveyardPosition) {\n            this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);\n          }\n          break;\n        }\n      case 'merge':\n        {\n          // Mark that the merged element was removed.\n          const mergedElement = operation.sourcePosition.parent;\n          if (!this._isInInsertedElement(mergedElement.parent)) {\n            this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);\n          }\n          // Mark that the merged element was inserted into graveyard.\n          const graveyardParent = operation.graveyardPosition.parent;\n          this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1);\n          // Mark that children of merged element were inserted at new parent.\n          const mergedIntoElement = operation.targetPosition.parent;\n          if (!this._isInInsertedElement(mergedIntoElement)) {\n            this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);\n          }\n          break;\n        }\n    }\n    // Clear cache after each buffered operation as it is no longer valid.\n    this._cachedChanges = null;\n  }\n  /**\n   * Buffers a marker change.\n   *\n   * @param {String} markerName The name of the marker that changed.\n   * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Marker data before the change.\n   * @param {module:engine/model/markercollection~MarkerData} newMarkerData Marker data after the change.\n   */\n  bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {\n    const buffered = this._changedMarkers.get(markerName);\n    if (!buffered) {\n      this._changedMarkers.set(markerName, {\n        newMarkerData,\n        oldMarkerData\n      });\n    } else {\n      buffered.newMarkerData = newMarkerData;\n      if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {\n        // The marker is going to be removed (`newMarkerData.range == null`) but it did not exist before the first buffered change\n        // (`buffered.oldMarkerData.range == null`). In this case, do not keep the marker in buffer at all.\n        this._changedMarkers.delete(markerName);\n      }\n    }\n  }\n  /**\n   * Returns all markers that should be removed as a result of buffered changes.\n   *\n   * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n   */\n  getMarkersToRemove() {\n    const result = [];\n    for (const [name, change] of this._changedMarkers) {\n      if (change.oldMarkerData.range != null) {\n        result.push({\n          name,\n          range: change.oldMarkerData.range\n        });\n      }\n    }\n    return result;\n  }\n  /**\n   * Returns all markers which should be added as a result of buffered changes.\n   *\n   * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n   */\n  getMarkersToAdd() {\n    const result = [];\n    for (const [name, change] of this._changedMarkers) {\n      if (change.newMarkerData.range != null) {\n        result.push({\n          name,\n          range: change.newMarkerData.range\n        });\n      }\n    }\n    return result;\n  }\n  /**\n   * Returns all markers which changed.\n   *\n   * @returns {Array.<Object>}\n   */\n  getChangedMarkers() {\n    return Array.from(this._changedMarkers).map(_ref => {\n      let [name, change] = _ref;\n      return {\n        name,\n        data: {\n          oldRange: change.oldMarkerData.range,\n          newRange: change.newMarkerData.range\n        }\n      };\n    });\n  }\n  /**\n   * Checks whether some of the buffered changes affect the editor data.\n   *\n   * Types of changes which affect the editor data:\n   *\n   * * model structure changes,\n   * * attribute changes,\n   * * changes of markers which were defined as `affectsData`,\n   * * changes of markers' `affectsData` property.\n   *\n   * @returns {Boolean}\n   */\n  hasDataChanges() {\n    if (this._changesInElement.size > 0) {\n      return true;\n    }\n    for (const {\n      newMarkerData,\n      oldMarkerData\n    } of this._changedMarkers.values()) {\n      if (newMarkerData.affectsData !== oldMarkerData.affectsData) {\n        return true;\n      }\n      if (newMarkerData.affectsData) {\n        const markerAdded = newMarkerData.range && !oldMarkerData.range;\n        const markerRemoved = !newMarkerData.range && oldMarkerData.range;\n        const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);\n        if (markerAdded || markerRemoved || markerChanged) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n   * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n   *\n   * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n   * on the model. The items are sorted by the position on which the change happened. If a position\n   * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n   *\n   * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n   *\n   * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n   * previous {@link #getChanges} call, the next call will return the cached value.\n   *\n   * @param {Object} options Additional options.\n   * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n   * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n   * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n   */\n  getChanges() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // If there are cached changes, just return them instead of calculating changes again.\n    if (this._cachedChanges) {\n      if (options.includeChangesInGraveyard) {\n        return this._cachedChangesWithGraveyard.slice();\n      } else {\n        return this._cachedChanges.slice();\n      }\n    }\n    // Will contain returned results.\n    let diffSet = [];\n    // Check all changed elements.\n    for (const element of this._changesInElement.keys()) {\n      // Get changes for this element and sort them.\n      const changes = this._changesInElement.get(element).sort((a, b) => {\n        if (a.offset === b.offset) {\n          if (a.type != b.type) {\n            // If there are multiple changes at the same position, \"remove\" change should be first.\n            // If the order is different, for example, we would first add some nodes and then removed them\n            // (instead of the nodes that we should remove).\n            return a.type == 'remove' ? -1 : 1;\n          }\n          return 0;\n        }\n        return a.offset < b.offset ? -1 : 1;\n      });\n      // Get children of this element before any change was applied on it.\n      const snapshotChildren = this._elementSnapshots.get(element);\n      // Get snapshot of current element's children.\n      const elementChildren = _getChildrenSnapshot(element.getChildren());\n      // Generate actions basing on changes done on element.\n      const actions = _generateActionsFromChanges(snapshotChildren.length, changes);\n      let i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n      let j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n      // Process every action.\n      for (const action of actions) {\n        if (action === 'i') {\n          // Generate diff item for this element and insert it into the diff set.\n          diffSet.push(this._getInsertDiff(element, i, elementChildren[i]));\n          i++;\n        } else if (action === 'r') {\n          // Generate diff item for this element and insert it into the diff set.\n          diffSet.push(this._getRemoveDiff(element, i, snapshotChildren[j]));\n          j++;\n        } else if (action === 'a') {\n          // Take attributes from saved and current children.\n          const elementAttributes = elementChildren[i].attributes;\n          const snapshotAttributes = snapshotChildren[j].attributes;\n          let range;\n          if (elementChildren[i].name == '$text') {\n            range = new Range(Position._createAt(element, i), Position._createAt(element, i + 1));\n          } else {\n            const index = element.offsetToIndex(i);\n            range = new Range(Position._createAt(element, i), Position._createAt(element.getChild(index), 0));\n          }\n          // Generate diff items for this change (there might be multiple attributes changed and\n          // there is a single diff for each of them) and insert them into the diff set.\n          diffSet.push(...this._getAttributesDiff(range, snapshotAttributes, elementAttributes));\n          i++;\n          j++;\n        } else {\n          // `action` is 'equal'. Child not changed.\n          i++;\n          j++;\n        }\n      }\n    }\n    // Then, sort the changes by the position (change at position before other changes is first).\n    diffSet.sort((a, b) => {\n      // If the change is in different root, we don't care much, but we'd like to have all changes in given\n      // root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n      // will be processed first.\n      if (a.position.root != b.position.root) {\n        return a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n      }\n      // If change happens at the same position...\n      if (a.position.isEqual(b.position)) {\n        // Keep chronological order of operations.\n        return a.changeCount - b.changeCount;\n      }\n      // If positions differ, position \"on the left\" should be earlier in the result.\n      return a.position.isBefore(b.position) ? -1 : 1;\n    });\n    // Glue together multiple changes (mostly on text nodes).\n    for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {\n      const prevDiff = diffSet[prevIndex];\n      const thisDiff = diffSet[i];\n      // Glue remove changes if they happen on text on same position.\n      const isConsecutiveTextRemove = prevDiff.type == 'remove' && thisDiff.type == 'remove' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.isEqual(thisDiff.position);\n      // Glue insert changes if they happen on text on consecutive fragments.\n      const isConsecutiveTextAdd = prevDiff.type == 'insert' && thisDiff.type == 'insert' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n      // Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n      const isConsecutiveAttributeChange = prevDiff.type == 'attribute' && thisDiff.type == 'attribute' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;\n      if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {\n        prevDiff.length++;\n        if (isConsecutiveAttributeChange) {\n          prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);\n        }\n        diffSet[i] = null;\n      } else {\n        prevIndex = i;\n      }\n    }\n    diffSet = diffSet.filter(v => v);\n    // Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n    for (const item of diffSet) {\n      delete item.changeCount;\n      if (item.type == 'attribute') {\n        delete item.position;\n        delete item.length;\n      }\n    }\n    this._changeCount = 0;\n    // Cache changes.\n    this._cachedChangesWithGraveyard = diffSet;\n    this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);\n    if (options.includeChangesInGraveyard) {\n      return this._cachedChangesWithGraveyard.slice();\n    } else {\n      return this._cachedChanges.slice();\n    }\n  }\n  /**\n   * Returns a set of model items that were marked to get refreshed.\n   *\n   * @return {Set.<module:engine/model/item~Item>}\n   */\n  getRefreshedItems() {\n    return new Set(this._refreshedItems);\n  }\n  /**\n   * Resets `Differ`. Removes all buffered changes.\n   */\n  reset() {\n    this._changesInElement.clear();\n    this._elementSnapshots.clear();\n    this._changedMarkers.clear();\n    this._refreshedItems = new Set();\n    this._cachedChanges = null;\n  }\n  /**\n   * Marks the given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted\n   * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.\n   *\n   * @protected\n   * @internal\n   * @param {module:engine/model/item~Item} item Item to refresh.\n   */\n  _refreshItem(item) {\n    if (this._isInInsertedElement(item.parent)) {\n      return;\n    }\n    this._markRemove(item.parent, item.startOffset, item.offsetSize);\n    this._markInsert(item.parent, item.startOffset, item.offsetSize);\n    this._refreshedItems.add(item);\n    const range = Range._createOn(item);\n    for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n      const markerData = marker.getData();\n      this.bufferMarkerChange(marker.name, markerData, markerData);\n    }\n    // Clear cache after each buffered operation as it is no longer valid.\n    this._cachedChanges = null;\n  }\n  /**\n   * Saves and handles an insert change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n  _markInsert(parent, offset, howMany) {\n    const changeItem = {\n      type: 'insert',\n      offset,\n      howMany,\n      count: this._changeCount++\n    };\n    this._markChange(parent, changeItem);\n  }\n  /**\n   * Saves and handles a remove change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n  _markRemove(parent, offset, howMany) {\n    const changeItem = {\n      type: 'remove',\n      offset,\n      howMany,\n      count: this._changeCount++\n    };\n    this._markChange(parent, changeItem);\n    this._removeAllNestedChanges(parent, offset, howMany);\n  }\n  /**\n   * Saves and handles an attribute change.\n   *\n   * @private\n   * @param {module:engine/model/item~Item} item\n   */\n  _markAttribute(item) {\n    const changeItem = {\n      type: 'attribute',\n      offset: item.startOffset,\n      howMany: item.offsetSize,\n      count: this._changeCount++\n    };\n    this._markChange(item.parent, changeItem);\n  }\n  /**\n   * Saves and handles a model change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Object} changeItem\n   */\n  _markChange(parent, changeItem) {\n    // First, make a snapshot of this parent's children (it will be made only if it was not made before).\n    this._makeSnapshot(parent);\n    // Then, get all changes that already were done on the element (empty array if this is the first change).\n    const changes = this._getChangesForElement(parent);\n    // Then, look through all the changes, and transform them or the new change.\n    this._handleChange(changeItem, changes);\n    // Add the new change.\n    changes.push(changeItem);\n    // Remove incorrect changes. During transformation some change might be, for example, included in another.\n    // In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n    for (let i = 0; i < changes.length; i++) {\n      if (changes[i].howMany < 1) {\n        changes.splice(i, 1);\n        i--;\n      }\n    }\n  }\n  /**\n   * Gets an array of changes that have already been saved for a given element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element\n   * @returns {Array.<Object>}\n   */\n  _getChangesForElement(element) {\n    let changes;\n    if (this._changesInElement.has(element)) {\n      changes = this._changesInElement.get(element);\n    } else {\n      changes = [];\n      this._changesInElement.set(element, changes);\n    }\n    return changes;\n  }\n  /**\n   * Saves a children snapshot for a given element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element\n   */\n  _makeSnapshot(element) {\n    if (!this._elementSnapshots.has(element)) {\n      this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));\n    }\n  }\n  /**\n   * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n   * change and/or the old change.\n   *\n   * @private\n   * @param {Object} inc Incoming (new) change.\n   * @param {Array.<Object>} changes An array containing all the changes done on that element.\n   */\n  _handleChange(inc, changes) {\n    // We need a helper variable that will store how many nodes are to be still handled for this change item.\n    // `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n    // needs to be differentiated.\n    //\n    // This comes up when there are multiple changes that are affected by `inc` change item.\n    //\n    // For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n    // Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n    //\n    // Then, we:\n    // - \"forget\" about first insert change (it is \"eaten\" by remove),\n    // - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n    // - but still we have to change offset of the second insert change from `5` to `3`!\n    //\n    // So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n    // while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n    inc.nodesToHandle = inc.howMany;\n    for (const old of changes) {\n      const incEnd = inc.offset + inc.howMany;\n      const oldEnd = old.offset + old.howMany;\n      if (inc.type == 'insert') {\n        if (old.type == 'insert') {\n          if (inc.offset <= old.offset) {\n            old.offset += inc.howMany;\n          } else if (inc.offset < oldEnd) {\n            old.howMany += inc.nodesToHandle;\n            inc.nodesToHandle = 0;\n          }\n        }\n        if (old.type == 'remove') {\n          if (inc.offset < old.offset) {\n            old.offset += inc.howMany;\n          }\n        }\n        if (old.type == 'attribute') {\n          if (inc.offset <= old.offset) {\n            old.offset += inc.howMany;\n          } else if (inc.offset < oldEnd) {\n            // This case is more complicated, because attribute change has to be split into two.\n            // Example (assume that uppercase and lowercase letters mean different attributes):\n            //\n            // initial state:\t\tabcxyz\n            // attribute change:\taBCXYz\n            // incoming insert:\t\taBCfooXYz\n            //\n            // Change ranges cannot intersect because each item has to be described exactly (it was either\n            // not changed, inserted, removed, or its attribute was changed). That's why old attribute\n            // change has to be split and both parts has to be handled separately from now on.\n            const howMany = old.howMany;\n            old.howMany = inc.offset - old.offset;\n            // Add the second part of attribute change to the beginning of processed array so it won't\n            // be processed again in this loop.\n            changes.unshift({\n              type: 'attribute',\n              offset: incEnd,\n              howMany: howMany - old.howMany,\n              count: this._changeCount++\n            });\n          }\n        }\n      }\n      if (inc.type == 'remove') {\n        if (old.type == 'insert') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (incEnd <= oldEnd) {\n            if (inc.offset < old.offset) {\n              const intersectionLength = incEnd - old.offset;\n              old.offset = inc.offset;\n              old.howMany -= intersectionLength;\n              inc.nodesToHandle -= intersectionLength;\n            } else {\n              old.howMany -= inc.nodesToHandle;\n              inc.nodesToHandle = 0;\n            }\n          } else {\n            if (inc.offset <= old.offset) {\n              inc.nodesToHandle -= old.howMany;\n              old.howMany = 0;\n            } else if (inc.offset < oldEnd) {\n              const intersectionLength = oldEnd - inc.offset;\n              old.howMany -= intersectionLength;\n              inc.nodesToHandle -= intersectionLength;\n            }\n          }\n        }\n        if (old.type == 'remove') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (inc.offset < old.offset) {\n            inc.nodesToHandle += old.howMany;\n            old.howMany = 0;\n          }\n        }\n        if (old.type == 'attribute') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (inc.offset < old.offset) {\n            const intersectionLength = incEnd - old.offset;\n            old.offset = inc.offset;\n            old.howMany -= intersectionLength;\n          } else if (inc.offset < oldEnd) {\n            if (incEnd <= oldEnd) {\n              // On first sight in this case we don't need to split attribute operation into two.\n              // However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n              // For that reason, no two changes may intersect.\n              // So we cannot have an attribute change that \"contains\" remove change.\n              // Attribute change needs to be split.\n              const howMany = old.howMany;\n              old.howMany = inc.offset - old.offset;\n              const howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n              // Add the second part of attribute change to the beginning of processed array so it won't\n              // be processed again in this loop.\n              changes.unshift({\n                type: 'attribute',\n                offset: inc.offset,\n                howMany: howManyAfter,\n                count: this._changeCount++\n              });\n            } else {\n              old.howMany -= oldEnd - inc.offset;\n            }\n          }\n        }\n      }\n      if (inc.type == 'attribute') {\n        // In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n        if (old.type == 'insert') {\n          if (inc.offset < old.offset && incEnd > old.offset) {\n            if (incEnd > oldEnd) {\n              // This case is similar to a case described when incoming change was insert and old change was attribute.\n              // See comment above.\n              //\n              // This time incoming change is attribute. We need to split incoming change in this case too.\n              // However this time, the second part of the attribute change needs to be processed further\n              // because there might be other changes that it collides with.\n              const attributePart = {\n                type: 'attribute',\n                offset: oldEnd,\n                howMany: incEnd - oldEnd,\n                count: this._changeCount++\n              };\n              this._handleChange(attributePart, changes);\n              changes.push(attributePart);\n            }\n            inc.nodesToHandle = old.offset - inc.offset;\n            inc.howMany = inc.nodesToHandle;\n          } else if (inc.offset >= old.offset && inc.offset < oldEnd) {\n            if (incEnd > oldEnd) {\n              inc.nodesToHandle = incEnd - oldEnd;\n              inc.offset = oldEnd;\n            } else {\n              inc.nodesToHandle = 0;\n            }\n          }\n        }\n        if (old.type == 'remove') {\n          // This is a case when attribute change \"contains\" remove change.\n          // The attribute change needs to be split into two because changes cannot intersect.\n          if (inc.offset < old.offset && incEnd > old.offset) {\n            const attributePart = {\n              type: 'attribute',\n              offset: old.offset,\n              howMany: incEnd - old.offset,\n              count: this._changeCount++\n            };\n            this._handleChange(attributePart, changes);\n            changes.push(attributePart);\n            inc.nodesToHandle = old.offset - inc.offset;\n            inc.howMany = inc.nodesToHandle;\n          }\n        }\n        if (old.type == 'attribute') {\n          // There are only two conflicting scenarios possible here:\n          if (inc.offset >= old.offset && incEnd <= oldEnd) {\n            // `old` change includes `inc` change, or they are the same.\n            inc.nodesToHandle = 0;\n            inc.howMany = 0;\n            inc.offset = 0;\n          } else if (inc.offset <= old.offset && incEnd >= oldEnd) {\n            // `inc` change includes `old` change.\n            old.howMany = 0;\n          }\n        }\n      }\n    }\n    inc.howMany = inc.nodesToHandle;\n    delete inc.nodesToHandle;\n  }\n  /**\n   * Returns an object with a single insert change description.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent The element in which the change happened.\n   * @param {Number} offset The offset at which change happened.\n   * @param {Object} elementSnapshot The snapshot of the removed element a character.\n   * @returns {Object} The diff item.\n   */\n  _getInsertDiff(parent, offset, elementSnapshot) {\n    return {\n      type: 'insert',\n      position: Position._createAt(parent, offset),\n      name: elementSnapshot.name,\n      attributes: new Map(elementSnapshot.attributes),\n      length: 1,\n      changeCount: this._changeCount++\n    };\n  }\n  /**\n   * Returns an object with a single remove change description.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent The element in which change happened.\n   * @param {Number} offset The offset at which change happened.\n   * @param {Object} elementSnapshot The snapshot of the removed element a character.\n   * @returns {Object} The diff item.\n   */\n  _getRemoveDiff(parent, offset, elementSnapshot) {\n    return {\n      type: 'remove',\n      position: Position._createAt(parent, offset),\n      name: elementSnapshot.name,\n      attributes: new Map(elementSnapshot.attributes),\n      length: 1,\n      changeCount: this._changeCount++\n    };\n  }\n  /**\n   * Returns an array of objects where each one is a single attribute change description.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The range where the change happened.\n   * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n   * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n   * @returns {Array.<Object>} An array containing one or more diff items.\n   */\n  _getAttributesDiff(range, oldAttributes, newAttributes) {\n    // Results holder.\n    const diffs = [];\n    // Clone new attributes as we will be performing changes on this object.\n    newAttributes = new Map(newAttributes);\n    // Look through old attributes.\n    for (const [key, oldValue] of oldAttributes) {\n      // Check what is the new value of the attribute (or if it was removed).\n      const newValue = newAttributes.has(key) ? newAttributes.get(key) : null;\n      // If values are different (or attribute was removed)...\n      if (newValue !== oldValue) {\n        // Add diff item.\n        diffs.push({\n          type: 'attribute',\n          position: range.start,\n          range: range.clone(),\n          length: 1,\n          attributeKey: key,\n          attributeOldValue: oldValue,\n          attributeNewValue: newValue,\n          changeCount: this._changeCount++\n        });\n      }\n      // Prevent returning two diff items for the same change.\n      newAttributes.delete(key);\n    }\n    // Look through new attributes that weren't handled above.\n    for (const [key, newValue] of newAttributes) {\n      // Each of them is a new attribute. Add diff item.\n      diffs.push({\n        type: 'attribute',\n        position: range.start,\n        range: range.clone(),\n        length: 1,\n        attributeKey: key,\n        attributeOldValue: null,\n        attributeNewValue: newValue,\n        changeCount: this._changeCount++\n      });\n    }\n    return diffs;\n  }\n  /**\n   * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element Element to check.\n   * @returns {Boolean}\n   */\n  _isInInsertedElement(element) {\n    const parent = element.parent;\n    if (!parent) {\n      return false;\n    }\n    const changes = this._changesInElement.get(parent);\n    const offset = element.startOffset;\n    if (changes) {\n      for (const change of changes) {\n        if (change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany) {\n          return true;\n        }\n      }\n    }\n    return this._isInInsertedElement(parent);\n  }\n  /**\n   * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n   * and `howMany`.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n  _removeAllNestedChanges(parent, offset, howMany) {\n    const range = new Range(Position._createAt(parent, offset), Position._createAt(parent, offset + howMany));\n    for (const item of range.getItems({\n      shallow: true\n    })) {\n      if (item.is('element')) {\n        this._elementSnapshots.delete(item);\n        this._changesInElement.delete(item);\n        this._removeAllNestedChanges(item, 0, item.maxOffset);\n      }\n    }\n  }\n}\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot(children) {\n  const snapshot = [];\n  for (const child of children) {\n    if (child.is('$text')) {\n      for (let i = 0; i < child.data.length; i++) {\n        snapshot.push({\n          name: '$text',\n          attributes: new Map(child.getAttributes())\n        });\n      }\n    } else {\n      snapshot.push({\n        name: child.name,\n        attributes: new Map(child.getAttributes())\n      });\n    }\n  }\n  return snapshot;\n}\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges(oldChildrenLength, changes) {\n  const actions = [];\n  let offset = 0;\n  let oldChildrenHandled = 0;\n  // Go through all buffered changes.\n  for (const change of changes) {\n    // First, fill \"holes\" between changes with \"equal\" actions.\n    if (change.offset > offset) {\n      for (let i = 0; i < change.offset - offset; i++) {\n        actions.push('e');\n      }\n      oldChildrenHandled += change.offset - offset;\n    }\n    // Then, fill up actions accordingly to change type.\n    if (change.type == 'insert') {\n      for (let i = 0; i < change.howMany; i++) {\n        actions.push('i');\n      }\n      // The last handled offset is after inserted range.\n      offset = change.offset + change.howMany;\n    } else if (change.type == 'remove') {\n      for (let i = 0; i < change.howMany; i++) {\n        actions.push('r');\n      }\n      // The last handled offset is at the position where the nodes were removed.\n      offset = change.offset;\n      // We removed `howMany` old nodes, update `oldChildrenHandled`.\n      oldChildrenHandled += change.howMany;\n    } else {\n      actions.push(...'a'.repeat(change.howMany).split(''));\n      // The last handled offset is at the position after the changed range.\n      offset = change.offset + change.howMany;\n      // We changed `howMany` old nodes, update `oldChildrenHandled`.\n      oldChildrenHandled += change.howMany;\n    }\n  }\n  // Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n  // has not been changed / removed at the end of their parent.\n  if (oldChildrenHandled < oldChildrenLength) {\n    for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {\n      actions.push('e');\n    }\n  }\n  return actions;\n}\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter(entry) {\n  const posInGy = 'position' in entry && entry.position.root.rootName == '$graveyard';\n  const rangeInGy = 'range' in entry && entry.range.root.rootName == '$graveyard';\n  return !posInGy && !rangeInGy;\n}\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */","map":{"version":3,"names":["Position","Range","Differ","constructor","markerCollection","_markerCollection","_changesInElement","Map","_elementSnapshots","_changedMarkers","_changeCount","_cachedChanges","_cachedChangesWithGraveyard","_refreshedItems","Set","isEmpty","size","bufferOperation","operationToBuffer","operation","type","_isInInsertedElement","position","parent","_markInsert","offset","nodes","maxOffset","item","range","getItems","shallow","_markAttribute","sourcePosition","isEqual","targetPosition","getShiftedBy","howMany","sourceParentInserted","targetParentInserted","_markRemove","getMovedRangeStart","_createFromPositionAndShift","marker","getMarkersIntersectingRange","markerData","getData","bufferMarkerChange","name","splitElement","splitPosition","insertionPosition","graveyardPosition","mergedElement","startOffset","graveyardParent","mergedIntoElement","markerName","oldMarkerData","newMarkerData","buffered","get","set","delete","getMarkersToRemove","result","change","push","getMarkersToAdd","getChangedMarkers","Array","from","map","data","oldRange","newRange","hasDataChanges","values","affectsData","markerAdded","markerRemoved","markerChanged","getChanges","options","includeChangesInGraveyard","slice","diffSet","element","keys","changes","sort","a","b","snapshotChildren","elementChildren","_getChildrenSnapshot","getChildren","actions","_generateActionsFromChanges","length","i","j","action","_getInsertDiff","_getRemoveDiff","elementAttributes","attributes","snapshotAttributes","_createAt","index","offsetToIndex","getChild","_getAttributesDiff","root","rootName","changeCount","isBefore","prevIndex","prevDiff","thisDiff","isConsecutiveTextRemove","isConsecutiveTextAdd","isConsecutiveAttributeChange","isFlat","attributeKey","attributeOldValue","attributeNewValue","end","filter","v","_changesInGraveyardFilter","getRefreshedItems","reset","clear","_refreshItem","offsetSize","add","_createOn","changeItem","count","_markChange","_removeAllNestedChanges","_makeSnapshot","_getChangesForElement","_handleChange","splice","has","inc","nodesToHandle","old","incEnd","oldEnd","unshift","intersectionLength","howManyAfter","attributePart","elementSnapshot","oldAttributes","newAttributes","diffs","key","oldValue","newValue","start","clone","is","children","snapshot","child","getAttributes","oldChildrenLength","oldChildrenHandled","repeat","split","entry","posInGy","rangeInGy"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/differ\n */\nimport Position from './position';\nimport Range from './range';\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n    /**\n     * Creates a `Differ` instance.\n     *\n     * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n     */\n    constructor(markerCollection) {\n        /**\n         * Reference to the model's marker collection.\n         *\n         * @private\n         * @type {module:engine/model/markercollection~MarkerCollection}\n         */\n        this._markerCollection = markerCollection;\n        /**\n         * A map that stores changes that happened in a given element.\n         *\n         * The keys of the map are references to the model elements.\n         * The values of the map are arrays with changes that were done on this element.\n         *\n         * @private\n         * @type {Map}\n         */\n        this._changesInElement = new Map();\n        /**\n         * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n         * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n         * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n         *\n         * @private\n         * @type {Map}\n         */\n        this._elementSnapshots = new Map();\n        /**\n         * A map that stores all changed markers.\n         *\n         * The keys of the map are marker names.\n         * The values of the map are objects with the following properties:\n         * - `oldMarkerData`,\n         * - `newMarkerData`.\n         *\n         * @private\n         * @type {Map.<String, Object>}\n         */\n        this._changedMarkers = new Map();\n        /**\n         * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n         * when changes are sorted.\n         *\n         * @private\n         * @type {Number}\n         */\n        this._changeCount = 0;\n        /**\n         * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n         * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n         * return the cached value instead of calculating it again.\n         *\n         * This property stores those changes that did not take place in graveyard root.\n         *\n         * @private\n         * @type {Array.<Object>|null}\n         */\n        this._cachedChanges = null;\n        /**\n         * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n         * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n         * return the cached value instead of calculating it again.\n         *\n         * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n         *\n         * @private\n         * @type {Array.<Object>|null}\n         */\n        this._cachedChangesWithGraveyard = null;\n        /**\n         * Set of model items that were marked to get refreshed in {@link #_refreshItem}.\n         *\n         * @private\n         * @type {Set.<module:engine/model/item~Item>}\n         */\n        this._refreshedItems = new Set();\n    }\n    /**\n     * Informs whether there are any changes buffered in `Differ`.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isEmpty() {\n        return this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n    }\n    /**\n     * Buffers the given operation. An operation has to be buffered before it is executed.\n     *\n     * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n     * in the state before the operation is executed.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operationToBuffer An operation to buffer.\n     */\n    bufferOperation(operationToBuffer) {\n        // Below we take an operation, check its type, then use its parameters in marking (private) methods.\n        // The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n        // Marking changes in them would cause a \"double\" changing then.\n        //\n        const operation = operationToBuffer;\n        switch (operation.type) {\n            case 'insert': {\n                if (this._isInInsertedElement(operation.position.parent)) {\n                    return;\n                }\n                this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);\n                break;\n            }\n            case 'addAttribute':\n            case 'removeAttribute':\n            case 'changeAttribute': {\n                for (const item of operation.range.getItems({ shallow: true })) {\n                    if (this._isInInsertedElement(item.parent)) {\n                        continue;\n                    }\n                    this._markAttribute(item);\n                }\n                break;\n            }\n            case 'remove':\n            case 'move':\n            case 'reinsert': {\n                // When range is moved to the same position then not mark it as a change.\n                // See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n                if (operation.sourcePosition.isEqual(operation.targetPosition) ||\n                    operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {\n                    return;\n                }\n                const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);\n                const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);\n                if (!sourceParentInserted) {\n                    this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);\n                }\n                if (!targetParentInserted) {\n                    this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);\n                }\n                break;\n            }\n            case 'rename': {\n                if (this._isInInsertedElement(operation.position.parent)) {\n                    return;\n                }\n                this._markRemove(operation.position.parent, operation.position.offset, 1);\n                this._markInsert(operation.position.parent, operation.position.offset, 1);\n                const range = Range._createFromPositionAndShift(operation.position, 1);\n                for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n                    const markerData = marker.getData();\n                    this.bufferMarkerChange(marker.name, markerData, markerData);\n                }\n                break;\n            }\n            case 'split': {\n                const splitElement = operation.splitPosition.parent;\n                // Mark that children of the split element were removed.\n                if (!this._isInInsertedElement(splitElement)) {\n                    this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);\n                }\n                // Mark that the new element (split copy) was inserted.\n                if (!this._isInInsertedElement(operation.insertionPosition.parent)) {\n                    this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);\n                }\n                // If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n                if (operation.graveyardPosition) {\n                    this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);\n                }\n                break;\n            }\n            case 'merge': {\n                // Mark that the merged element was removed.\n                const mergedElement = operation.sourcePosition.parent;\n                if (!this._isInInsertedElement(mergedElement.parent)) {\n                    this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);\n                }\n                // Mark that the merged element was inserted into graveyard.\n                const graveyardParent = operation.graveyardPosition.parent;\n                this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1);\n                // Mark that children of merged element were inserted at new parent.\n                const mergedIntoElement = operation.targetPosition.parent;\n                if (!this._isInInsertedElement(mergedIntoElement)) {\n                    this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);\n                }\n                break;\n            }\n        }\n        // Clear cache after each buffered operation as it is no longer valid.\n        this._cachedChanges = null;\n    }\n    /**\n     * Buffers a marker change.\n     *\n     * @param {String} markerName The name of the marker that changed.\n     * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Marker data before the change.\n     * @param {module:engine/model/markercollection~MarkerData} newMarkerData Marker data after the change.\n     */\n    bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {\n        const buffered = this._changedMarkers.get(markerName);\n        if (!buffered) {\n            this._changedMarkers.set(markerName, {\n                newMarkerData,\n                oldMarkerData\n            });\n        }\n        else {\n            buffered.newMarkerData = newMarkerData;\n            if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {\n                // The marker is going to be removed (`newMarkerData.range == null`) but it did not exist before the first buffered change\n                // (`buffered.oldMarkerData.range == null`). In this case, do not keep the marker in buffer at all.\n                this._changedMarkers.delete(markerName);\n            }\n        }\n    }\n    /**\n     * Returns all markers that should be removed as a result of buffered changes.\n     *\n     * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n     */\n    getMarkersToRemove() {\n        const result = [];\n        for (const [name, change] of this._changedMarkers) {\n            if (change.oldMarkerData.range != null) {\n                result.push({ name, range: change.oldMarkerData.range });\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns all markers which should be added as a result of buffered changes.\n     *\n     * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n     */\n    getMarkersToAdd() {\n        const result = [];\n        for (const [name, change] of this._changedMarkers) {\n            if (change.newMarkerData.range != null) {\n                result.push({ name, range: change.newMarkerData.range });\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns all markers which changed.\n     *\n     * @returns {Array.<Object>}\n     */\n    getChangedMarkers() {\n        return Array.from(this._changedMarkers).map(([name, change]) => ({\n            name,\n            data: {\n                oldRange: change.oldMarkerData.range,\n                newRange: change.newMarkerData.range\n            }\n        }));\n    }\n    /**\n     * Checks whether some of the buffered changes affect the editor data.\n     *\n     * Types of changes which affect the editor data:\n     *\n     * * model structure changes,\n     * * attribute changes,\n     * * changes of markers which were defined as `affectsData`,\n     * * changes of markers' `affectsData` property.\n     *\n     * @returns {Boolean}\n     */\n    hasDataChanges() {\n        if (this._changesInElement.size > 0) {\n            return true;\n        }\n        for (const { newMarkerData, oldMarkerData } of this._changedMarkers.values()) {\n            if (newMarkerData.affectsData !== oldMarkerData.affectsData) {\n                return true;\n            }\n            if (newMarkerData.affectsData) {\n                const markerAdded = newMarkerData.range && !oldMarkerData.range;\n                const markerRemoved = !newMarkerData.range && oldMarkerData.range;\n                const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);\n                if (markerAdded || markerRemoved || markerChanged) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n     * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n     *\n     * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n     * on the model. The items are sorted by the position on which the change happened. If a position\n     * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n     *\n     * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n     *\n     * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n     * previous {@link #getChanges} call, the next call will return the cached value.\n     *\n     * @param {Object} options Additional options.\n     * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n     * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n     * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n     */\n    getChanges(options = {}) {\n        // If there are cached changes, just return them instead of calculating changes again.\n        if (this._cachedChanges) {\n            if (options.includeChangesInGraveyard) {\n                return this._cachedChangesWithGraveyard.slice();\n            }\n            else {\n                return this._cachedChanges.slice();\n            }\n        }\n        // Will contain returned results.\n        let diffSet = [];\n        // Check all changed elements.\n        for (const element of this._changesInElement.keys()) {\n            // Get changes for this element and sort them.\n            const changes = this._changesInElement.get(element).sort((a, b) => {\n                if (a.offset === b.offset) {\n                    if (a.type != b.type) {\n                        // If there are multiple changes at the same position, \"remove\" change should be first.\n                        // If the order is different, for example, we would first add some nodes and then removed them\n                        // (instead of the nodes that we should remove).\n                        return a.type == 'remove' ? -1 : 1;\n                    }\n                    return 0;\n                }\n                return a.offset < b.offset ? -1 : 1;\n            });\n            // Get children of this element before any change was applied on it.\n            const snapshotChildren = this._elementSnapshots.get(element);\n            // Get snapshot of current element's children.\n            const elementChildren = _getChildrenSnapshot(element.getChildren());\n            // Generate actions basing on changes done on element.\n            const actions = _generateActionsFromChanges(snapshotChildren.length, changes);\n            let i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n            let j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n            // Process every action.\n            for (const action of actions) {\n                if (action === 'i') {\n                    // Generate diff item for this element and insert it into the diff set.\n                    diffSet.push(this._getInsertDiff(element, i, elementChildren[i]));\n                    i++;\n                }\n                else if (action === 'r') {\n                    // Generate diff item for this element and insert it into the diff set.\n                    diffSet.push(this._getRemoveDiff(element, i, snapshotChildren[j]));\n                    j++;\n                }\n                else if (action === 'a') {\n                    // Take attributes from saved and current children.\n                    const elementAttributes = elementChildren[i].attributes;\n                    const snapshotAttributes = snapshotChildren[j].attributes;\n                    let range;\n                    if (elementChildren[i].name == '$text') {\n                        range = new Range(Position._createAt(element, i), Position._createAt(element, i + 1));\n                    }\n                    else {\n                        const index = element.offsetToIndex(i);\n                        range = new Range(Position._createAt(element, i), Position._createAt(element.getChild(index), 0));\n                    }\n                    // Generate diff items for this change (there might be multiple attributes changed and\n                    // there is a single diff for each of them) and insert them into the diff set.\n                    diffSet.push(...this._getAttributesDiff(range, snapshotAttributes, elementAttributes));\n                    i++;\n                    j++;\n                }\n                else {\n                    // `action` is 'equal'. Child not changed.\n                    i++;\n                    j++;\n                }\n            }\n        }\n        // Then, sort the changes by the position (change at position before other changes is first).\n        diffSet.sort((a, b) => {\n            // If the change is in different root, we don't care much, but we'd like to have all changes in given\n            // root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n            // will be processed first.\n            if (a.position.root != b.position.root) {\n                return a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n            }\n            // If change happens at the same position...\n            if (a.position.isEqual(b.position)) {\n                // Keep chronological order of operations.\n                return a.changeCount - b.changeCount;\n            }\n            // If positions differ, position \"on the left\" should be earlier in the result.\n            return a.position.isBefore(b.position) ? -1 : 1;\n        });\n        // Glue together multiple changes (mostly on text nodes).\n        for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {\n            const prevDiff = diffSet[prevIndex];\n            const thisDiff = diffSet[i];\n            // Glue remove changes if they happen on text on same position.\n            const isConsecutiveTextRemove = prevDiff.type == 'remove' && thisDiff.type == 'remove' &&\n                prevDiff.name == '$text' && thisDiff.name == '$text' &&\n                prevDiff.position.isEqual(thisDiff.position);\n            // Glue insert changes if they happen on text on consecutive fragments.\n            const isConsecutiveTextAdd = prevDiff.type == 'insert' && thisDiff.type == 'insert' &&\n                prevDiff.name == '$text' && thisDiff.name == '$text' &&\n                prevDiff.position.parent == thisDiff.position.parent &&\n                prevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n            // Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n            const isConsecutiveAttributeChange = prevDiff.type == 'attribute' && thisDiff.type == 'attribute' &&\n                prevDiff.position.parent == thisDiff.position.parent &&\n                prevDiff.range.isFlat && thisDiff.range.isFlat &&\n                (prevDiff.position.offset + prevDiff.length) == thisDiff.position.offset &&\n                prevDiff.attributeKey == thisDiff.attributeKey &&\n                prevDiff.attributeOldValue == thisDiff.attributeOldValue &&\n                prevDiff.attributeNewValue == thisDiff.attributeNewValue;\n            if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {\n                prevDiff.length++;\n                if (isConsecutiveAttributeChange) {\n                    prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);\n                }\n                diffSet[i] = null;\n            }\n            else {\n                prevIndex = i;\n            }\n        }\n        diffSet = diffSet.filter(v => v);\n        // Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n        for (const item of diffSet) {\n            delete item.changeCount;\n            if (item.type == 'attribute') {\n                delete item.position;\n                delete item.length;\n            }\n        }\n        this._changeCount = 0;\n        // Cache changes.\n        this._cachedChangesWithGraveyard = diffSet;\n        this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);\n        if (options.includeChangesInGraveyard) {\n            return this._cachedChangesWithGraveyard.slice();\n        }\n        else {\n            return this._cachedChanges.slice();\n        }\n    }\n    /**\n     * Returns a set of model items that were marked to get refreshed.\n     *\n     * @return {Set.<module:engine/model/item~Item>}\n     */\n    getRefreshedItems() {\n        return new Set(this._refreshedItems);\n    }\n    /**\n     * Resets `Differ`. Removes all buffered changes.\n     */\n    reset() {\n        this._changesInElement.clear();\n        this._elementSnapshots.clear();\n        this._changedMarkers.clear();\n        this._refreshedItems = new Set();\n        this._cachedChanges = null;\n    }\n    /**\n     * Marks the given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted\n     * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.\n     *\n     * @protected\n     * @internal\n     * @param {module:engine/model/item~Item} item Item to refresh.\n     */\n    _refreshItem(item) {\n        if (this._isInInsertedElement(item.parent)) {\n            return;\n        }\n        this._markRemove(item.parent, item.startOffset, item.offsetSize);\n        this._markInsert(item.parent, item.startOffset, item.offsetSize);\n        this._refreshedItems.add(item);\n        const range = Range._createOn(item);\n        for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n            const markerData = marker.getData();\n            this.bufferMarkerChange(marker.name, markerData, markerData);\n        }\n        // Clear cache after each buffered operation as it is no longer valid.\n        this._cachedChanges = null;\n    }\n    /**\n     * Saves and handles an insert change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n    _markInsert(parent, offset, howMany) {\n        const changeItem = { type: 'insert', offset, howMany, count: this._changeCount++ };\n        this._markChange(parent, changeItem);\n    }\n    /**\n     * Saves and handles a remove change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n    _markRemove(parent, offset, howMany) {\n        const changeItem = { type: 'remove', offset, howMany, count: this._changeCount++ };\n        this._markChange(parent, changeItem);\n        this._removeAllNestedChanges(parent, offset, howMany);\n    }\n    /**\n     * Saves and handles an attribute change.\n     *\n     * @private\n     * @param {module:engine/model/item~Item} item\n     */\n    _markAttribute(item) {\n        const changeItem = { type: 'attribute', offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };\n        this._markChange(item.parent, changeItem);\n    }\n    /**\n     * Saves and handles a model change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Object} changeItem\n     */\n    _markChange(parent, changeItem) {\n        // First, make a snapshot of this parent's children (it will be made only if it was not made before).\n        this._makeSnapshot(parent);\n        // Then, get all changes that already were done on the element (empty array if this is the first change).\n        const changes = this._getChangesForElement(parent);\n        // Then, look through all the changes, and transform them or the new change.\n        this._handleChange(changeItem, changes);\n        // Add the new change.\n        changes.push(changeItem);\n        // Remove incorrect changes. During transformation some change might be, for example, included in another.\n        // In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n        for (let i = 0; i < changes.length; i++) {\n            if (changes[i].howMany < 1) {\n                changes.splice(i, 1);\n                i--;\n            }\n        }\n    }\n    /**\n     * Gets an array of changes that have already been saved for a given element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element\n     * @returns {Array.<Object>}\n     */\n    _getChangesForElement(element) {\n        let changes;\n        if (this._changesInElement.has(element)) {\n            changes = this._changesInElement.get(element);\n        }\n        else {\n            changes = [];\n            this._changesInElement.set(element, changes);\n        }\n        return changes;\n    }\n    /**\n     * Saves a children snapshot for a given element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element\n     */\n    _makeSnapshot(element) {\n        if (!this._elementSnapshots.has(element)) {\n            this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));\n        }\n    }\n    /**\n     * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n     * change and/or the old change.\n     *\n     * @private\n     * @param {Object} inc Incoming (new) change.\n     * @param {Array.<Object>} changes An array containing all the changes done on that element.\n     */\n    _handleChange(inc, changes) {\n        // We need a helper variable that will store how many nodes are to be still handled for this change item.\n        // `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n        // needs to be differentiated.\n        //\n        // This comes up when there are multiple changes that are affected by `inc` change item.\n        //\n        // For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n        // Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n        //\n        // Then, we:\n        // - \"forget\" about first insert change (it is \"eaten\" by remove),\n        // - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n        // - but still we have to change offset of the second insert change from `5` to `3`!\n        //\n        // So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n        // while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n        inc.nodesToHandle = inc.howMany;\n        for (const old of changes) {\n            const incEnd = inc.offset + inc.howMany;\n            const oldEnd = old.offset + old.howMany;\n            if (inc.type == 'insert') {\n                if (old.type == 'insert') {\n                    if (inc.offset <= old.offset) {\n                        old.offset += inc.howMany;\n                    }\n                    else if (inc.offset < oldEnd) {\n                        old.howMany += inc.nodesToHandle;\n                        inc.nodesToHandle = 0;\n                    }\n                }\n                if (old.type == 'remove') {\n                    if (inc.offset < old.offset) {\n                        old.offset += inc.howMany;\n                    }\n                }\n                if (old.type == 'attribute') {\n                    if (inc.offset <= old.offset) {\n                        old.offset += inc.howMany;\n                    }\n                    else if (inc.offset < oldEnd) {\n                        // This case is more complicated, because attribute change has to be split into two.\n                        // Example (assume that uppercase and lowercase letters mean different attributes):\n                        //\n                        // initial state:\t\tabcxyz\n                        // attribute change:\taBCXYz\n                        // incoming insert:\t\taBCfooXYz\n                        //\n                        // Change ranges cannot intersect because each item has to be described exactly (it was either\n                        // not changed, inserted, removed, or its attribute was changed). That's why old attribute\n                        // change has to be split and both parts has to be handled separately from now on.\n                        const howMany = old.howMany;\n                        old.howMany = inc.offset - old.offset;\n                        // Add the second part of attribute change to the beginning of processed array so it won't\n                        // be processed again in this loop.\n                        changes.unshift({\n                            type: 'attribute',\n                            offset: incEnd,\n                            howMany: howMany - old.howMany,\n                            count: this._changeCount++\n                        });\n                    }\n                }\n            }\n            if (inc.type == 'remove') {\n                if (old.type == 'insert') {\n                    if (incEnd <= old.offset) {\n                        old.offset -= inc.howMany;\n                    }\n                    else if (incEnd <= oldEnd) {\n                        if (inc.offset < old.offset) {\n                            const intersectionLength = incEnd - old.offset;\n                            old.offset = inc.offset;\n                            old.howMany -= intersectionLength;\n                            inc.nodesToHandle -= intersectionLength;\n                        }\n                        else {\n                            old.howMany -= inc.nodesToHandle;\n                            inc.nodesToHandle = 0;\n                        }\n                    }\n                    else {\n                        if (inc.offset <= old.offset) {\n                            inc.nodesToHandle -= old.howMany;\n                            old.howMany = 0;\n                        }\n                        else if (inc.offset < oldEnd) {\n                            const intersectionLength = oldEnd - inc.offset;\n                            old.howMany -= intersectionLength;\n                            inc.nodesToHandle -= intersectionLength;\n                        }\n                    }\n                }\n                if (old.type == 'remove') {\n                    if (incEnd <= old.offset) {\n                        old.offset -= inc.howMany;\n                    }\n                    else if (inc.offset < old.offset) {\n                        inc.nodesToHandle += old.howMany;\n                        old.howMany = 0;\n                    }\n                }\n                if (old.type == 'attribute') {\n                    if (incEnd <= old.offset) {\n                        old.offset -= inc.howMany;\n                    }\n                    else if (inc.offset < old.offset) {\n                        const intersectionLength = incEnd - old.offset;\n                        old.offset = inc.offset;\n                        old.howMany -= intersectionLength;\n                    }\n                    else if (inc.offset < oldEnd) {\n                        if (incEnd <= oldEnd) {\n                            // On first sight in this case we don't need to split attribute operation into two.\n                            // However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n                            // For that reason, no two changes may intersect.\n                            // So we cannot have an attribute change that \"contains\" remove change.\n                            // Attribute change needs to be split.\n                            const howMany = old.howMany;\n                            old.howMany = inc.offset - old.offset;\n                            const howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n                            // Add the second part of attribute change to the beginning of processed array so it won't\n                            // be processed again in this loop.\n                            changes.unshift({\n                                type: 'attribute',\n                                offset: inc.offset,\n                                howMany: howManyAfter,\n                                count: this._changeCount++\n                            });\n                        }\n                        else {\n                            old.howMany -= oldEnd - inc.offset;\n                        }\n                    }\n                }\n            }\n            if (inc.type == 'attribute') {\n                // In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n                if (old.type == 'insert') {\n                    if (inc.offset < old.offset && incEnd > old.offset) {\n                        if (incEnd > oldEnd) {\n                            // This case is similar to a case described when incoming change was insert and old change was attribute.\n                            // See comment above.\n                            //\n                            // This time incoming change is attribute. We need to split incoming change in this case too.\n                            // However this time, the second part of the attribute change needs to be processed further\n                            // because there might be other changes that it collides with.\n                            const attributePart = {\n                                type: 'attribute',\n                                offset: oldEnd,\n                                howMany: incEnd - oldEnd,\n                                count: this._changeCount++\n                            };\n                            this._handleChange(attributePart, changes);\n                            changes.push(attributePart);\n                        }\n                        inc.nodesToHandle = old.offset - inc.offset;\n                        inc.howMany = inc.nodesToHandle;\n                    }\n                    else if (inc.offset >= old.offset && inc.offset < oldEnd) {\n                        if (incEnd > oldEnd) {\n                            inc.nodesToHandle = incEnd - oldEnd;\n                            inc.offset = oldEnd;\n                        }\n                        else {\n                            inc.nodesToHandle = 0;\n                        }\n                    }\n                }\n                if (old.type == 'remove') {\n                    // This is a case when attribute change \"contains\" remove change.\n                    // The attribute change needs to be split into two because changes cannot intersect.\n                    if (inc.offset < old.offset && incEnd > old.offset) {\n                        const attributePart = {\n                            type: 'attribute',\n                            offset: old.offset,\n                            howMany: incEnd - old.offset,\n                            count: this._changeCount++\n                        };\n                        this._handleChange(attributePart, changes);\n                        changes.push(attributePart);\n                        inc.nodesToHandle = old.offset - inc.offset;\n                        inc.howMany = inc.nodesToHandle;\n                    }\n                }\n                if (old.type == 'attribute') {\n                    // There are only two conflicting scenarios possible here:\n                    if (inc.offset >= old.offset && incEnd <= oldEnd) {\n                        // `old` change includes `inc` change, or they are the same.\n                        inc.nodesToHandle = 0;\n                        inc.howMany = 0;\n                        inc.offset = 0;\n                    }\n                    else if (inc.offset <= old.offset && incEnd >= oldEnd) {\n                        // `inc` change includes `old` change.\n                        old.howMany = 0;\n                    }\n                }\n            }\n        }\n        inc.howMany = inc.nodesToHandle;\n        delete inc.nodesToHandle;\n    }\n    /**\n     * Returns an object with a single insert change description.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent The element in which the change happened.\n     * @param {Number} offset The offset at which change happened.\n     * @param {Object} elementSnapshot The snapshot of the removed element a character.\n     * @returns {Object} The diff item.\n     */\n    _getInsertDiff(parent, offset, elementSnapshot) {\n        return {\n            type: 'insert',\n            position: Position._createAt(parent, offset),\n            name: elementSnapshot.name,\n            attributes: new Map(elementSnapshot.attributes),\n            length: 1,\n            changeCount: this._changeCount++\n        };\n    }\n    /**\n     * Returns an object with a single remove change description.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent The element in which change happened.\n     * @param {Number} offset The offset at which change happened.\n     * @param {Object} elementSnapshot The snapshot of the removed element a character.\n     * @returns {Object} The diff item.\n     */\n    _getRemoveDiff(parent, offset, elementSnapshot) {\n        return {\n            type: 'remove',\n            position: Position._createAt(parent, offset),\n            name: elementSnapshot.name,\n            attributes: new Map(elementSnapshot.attributes),\n            length: 1,\n            changeCount: this._changeCount++\n        };\n    }\n    /**\n     * Returns an array of objects where each one is a single attribute change description.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range The range where the change happened.\n     * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n     * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n     * @returns {Array.<Object>} An array containing one or more diff items.\n     */\n    _getAttributesDiff(range, oldAttributes, newAttributes) {\n        // Results holder.\n        const diffs = [];\n        // Clone new attributes as we will be performing changes on this object.\n        newAttributes = new Map(newAttributes);\n        // Look through old attributes.\n        for (const [key, oldValue] of oldAttributes) {\n            // Check what is the new value of the attribute (or if it was removed).\n            const newValue = newAttributes.has(key) ? newAttributes.get(key) : null;\n            // If values are different (or attribute was removed)...\n            if (newValue !== oldValue) {\n                // Add diff item.\n                diffs.push({\n                    type: 'attribute',\n                    position: range.start,\n                    range: range.clone(),\n                    length: 1,\n                    attributeKey: key,\n                    attributeOldValue: oldValue,\n                    attributeNewValue: newValue,\n                    changeCount: this._changeCount++\n                });\n            }\n            // Prevent returning two diff items for the same change.\n            newAttributes.delete(key);\n        }\n        // Look through new attributes that weren't handled above.\n        for (const [key, newValue] of newAttributes) {\n            // Each of them is a new attribute. Add diff item.\n            diffs.push({\n                type: 'attribute',\n                position: range.start,\n                range: range.clone(),\n                length: 1,\n                attributeKey: key,\n                attributeOldValue: null,\n                attributeNewValue: newValue,\n                changeCount: this._changeCount++\n            });\n        }\n        return diffs;\n    }\n    /**\n     * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element Element to check.\n     * @returns {Boolean}\n     */\n    _isInInsertedElement(element) {\n        const parent = element.parent;\n        if (!parent) {\n            return false;\n        }\n        const changes = this._changesInElement.get(parent);\n        const offset = element.startOffset;\n        if (changes) {\n            for (const change of changes) {\n                if (change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany) {\n                    return true;\n                }\n            }\n        }\n        return this._isInInsertedElement(parent);\n    }\n    /**\n     * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n     * and `howMany`.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n    _removeAllNestedChanges(parent, offset, howMany) {\n        const range = new Range(Position._createAt(parent, offset), Position._createAt(parent, offset + howMany));\n        for (const item of range.getItems({ shallow: true })) {\n            if (item.is('element')) {\n                this._elementSnapshots.delete(item);\n                this._changesInElement.delete(item);\n                this._removeAllNestedChanges(item, 0, item.maxOffset);\n            }\n        }\n    }\n}\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot(children) {\n    const snapshot = [];\n    for (const child of children) {\n        if (child.is('$text')) {\n            for (let i = 0; i < child.data.length; i++) {\n                snapshot.push({\n                    name: '$text',\n                    attributes: new Map(child.getAttributes())\n                });\n            }\n        }\n        else {\n            snapshot.push({\n                name: child.name,\n                attributes: new Map(child.getAttributes())\n            });\n        }\n    }\n    return snapshot;\n}\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges(oldChildrenLength, changes) {\n    const actions = [];\n    let offset = 0;\n    let oldChildrenHandled = 0;\n    // Go through all buffered changes.\n    for (const change of changes) {\n        // First, fill \"holes\" between changes with \"equal\" actions.\n        if (change.offset > offset) {\n            for (let i = 0; i < change.offset - offset; i++) {\n                actions.push('e');\n            }\n            oldChildrenHandled += change.offset - offset;\n        }\n        // Then, fill up actions accordingly to change type.\n        if (change.type == 'insert') {\n            for (let i = 0; i < change.howMany; i++) {\n                actions.push('i');\n            }\n            // The last handled offset is after inserted range.\n            offset = change.offset + change.howMany;\n        }\n        else if (change.type == 'remove') {\n            for (let i = 0; i < change.howMany; i++) {\n                actions.push('r');\n            }\n            // The last handled offset is at the position where the nodes were removed.\n            offset = change.offset;\n            // We removed `howMany` old nodes, update `oldChildrenHandled`.\n            oldChildrenHandled += change.howMany;\n        }\n        else {\n            actions.push(...'a'.repeat(change.howMany).split(''));\n            // The last handled offset is at the position after the changed range.\n            offset = change.offset + change.howMany;\n            // We changed `howMany` old nodes, update `oldChildrenHandled`.\n            oldChildrenHandled += change.howMany;\n        }\n    }\n    // Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n    // has not been changed / removed at the end of their parent.\n    if (oldChildrenHandled < oldChildrenLength) {\n        for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {\n            actions.push('e');\n        }\n    }\n    return actions;\n}\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter(entry) {\n    const posInGy = 'position' in entry && entry.position.root.rootName == '$graveyard';\n    const rangeInGy = 'range' in entry && entry.range.root.rootName == '$graveyard';\n    return !posInGy && !rangeInGy;\n}\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,YAAY;AACjC,OAAOC,KAAK,MAAM,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,MAAM,CAAC;EACxB;AACJ;AACA;AACA;AACA;EACIC,WAAW,CAACC,gBAAgB,EAAE;IAC1B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAGD,gBAAgB;IACzC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,iBAAiB,GAAG,IAAIC,GAAG,EAAE;IAClC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,IAAID,GAAG,EAAE;IAClC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,eAAe,GAAG,IAAIF,GAAG,EAAE;IAChC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACG,YAAY,GAAG,CAAC;IACrB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,2BAA2B,GAAG,IAAI;IACvC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,EAAE;EACpC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,OAAO,GAAG;IACV,OAAO,IAAI,CAACT,iBAAiB,CAACU,IAAI,IAAI,CAAC,IAAI,IAAI,CAACP,eAAe,CAACO,IAAI,IAAI,CAAC;EAC7E;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,eAAe,CAACC,iBAAiB,EAAE;IAC/B;IACA;IACA;IACA;IACA,MAAMC,SAAS,GAAGD,iBAAiB;IACnC,QAAQC,SAAS,CAACC,IAAI;MAClB,KAAK,QAAQ;QAAE;UACX,IAAI,IAAI,CAACC,o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"},"metadata":{},"sourceType":"module"}