{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module module:engine/model/documentfragment\n */\nimport TypeCheckable from './typecheckable';\nimport Element from './element';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n// @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );\n/**\n * DocumentFragment represents a part of model which does not have a common root but its top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\nexport default class DocumentFragment extends TypeCheckable {\n  /**\n   * Creates an empty `DocumentFragment`.\n   *\n   * **Note:** Constructor of this class shouldn't be used directly in the code.\n   * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n   *\n   * @protected\n   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n   * Nodes to be contained inside the `DocumentFragment`.\n   */\n  constructor(children) {\n    super();\n    /**\n     * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n     * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n     * when DocumentFragment will be inserted to the document.\n     *\n     * @readonly\n     * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n     */\n    this.markers = new Map();\n    /**\n     * List of nodes contained inside the document fragment.\n     *\n     * @private\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n     */\n    this._children = new NodeList();\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Returns an iterator that iterates over all nodes contained inside this document fragment.\n   *\n   * @returns {Iterator.<module:engine/model/node~Node>}\n   */\n  [Symbol.iterator]() {\n    return this.getChildren();\n  }\n  /**\n   * Number of this document fragment's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get maxOffset() {\n    return this._children.maxOffset;\n  }\n  /**\n   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isEmpty() {\n    return this.childCount === 0;\n  }\n  /**\n   * Artificial next sibling. Returns `null`. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {null}\n   */\n  get nextSibling() {\n    return null;\n  }\n  /**\n   * Artificial previous sibling. Returns `null`. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {null}\n   */\n  get previousSibling() {\n    return null;\n  }\n  /**\n   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {module:engine/model/documentfragment~DocumentFragment}\n   */\n  get root() {\n    return this;\n  }\n  /**\n   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {null}\n   */\n  get parent() {\n    return null;\n  }\n  /**\n   * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {null}\n   */\n  get document() {\n    return null;\n  }\n  /**\n   * Returns empty array. Added for compatibility reasons.\n   *\n   * @returns {Array}\n   */\n  getAncestors() {\n    return [];\n  }\n  /**\n   * Gets the child at the given index. Returns `null` if incorrect index was passed.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/model/node~Node|null} Child node.\n   */\n  getChild(index) {\n    return this._children.getNode(index);\n  }\n  /**\n   * Returns an iterator that iterates over all of this document fragment's children.\n   *\n   * @returns {Iterable.<module:engine/model/node~Node>}\n   */\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number|null} Child node's index.\n   */\n  getChildIndex(node) {\n    return this._children.getNodeIndex(node);\n  }\n  /**\n   * Returns the starting offset of given child. Starting offset is equal to the sum of\n   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n   * given node is not a child of this document fragment.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number|null} Child node's starting offset.\n   */\n  getChildStartOffset(node) {\n    return this._children.getNodeStartOffset(node);\n  }\n  /**\n   * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n   *\n   * @returns {Array}\n   */\n  getPath() {\n    return [];\n  }\n  /**\n   * Returns a descendant node by its path relative to this element.\n   *\n   *\t\t// <this>a<b>c</b></this>\n   *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n   *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n   *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n   *\n   * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n   * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n   */\n  getNodeByPath(relativePath) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n    let node = this;\n    for (const index of relativePath) {\n      node = node.getChild(node.offsetToIndex(index));\n    }\n    return node;\n  }\n  /**\n   * Converts offset \"position\" to index \"position\".\n   *\n   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n   * too high, returns index after last child}.\n   *\n   *\t\tconst textNode = new Text( 'foo' );\n   *\t\tconst pElement = new Element( 'p' );\n   *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n   *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n   *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n   *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n   *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n   *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n   *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n   *\n   * @param {Number} offset Offset to look for.\n   * @returns {Number} Index of a node that occupies given offset.\n   */\n  offsetToIndex(offset) {\n    return this._children.offsetToIndex(offset);\n  }\n  /**\n   * Converts `DocumentFragment` instance to plain object and returns it.\n   * Takes care of converting all of this document fragment's children.\n   *\n   * @returns {Object} `DocumentFragment` instance converted to plain object.\n   */\n  toJSON() {\n    const json = [];\n    for (const node of this._children) {\n      json.push(node.toJSON());\n    }\n    return json;\n  }\n  /**\n   * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n   * Converts `DocumentFragment` children to proper nodes.\n   *\n   * @param {Object} json Plain object to be converted to `DocumentFragment`.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n   */\n  static fromJSON(json) {\n    const children = [];\n    for (const child of json) {\n      if (child.name) {\n        // If child has name property, it is an Element.\n        children.push(Element.fromJSON(child));\n      } else {\n        // Otherwise, it is a Text node.\n        children.push(Text.fromJSON(child));\n      }\n    }\n    return new DocumentFragment(children);\n  }\n  /**\n   * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n   *\n   * @internal\n   * @protected\n   * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} items Items to be inserted.\n   */\n  _appendChild(items) {\n    this._insertChild(this.childCount, items);\n  }\n  /**\n   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n   * to this document fragment.\n   *\n   * @internal\n   * @protected\n   * @param {Number} index Index at which nodes should be inserted.\n   * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} items Items to be inserted.\n   */\n  _insertChild(index, items) {\n    const nodes = normalize(items);\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n      node.parent = this;\n    }\n    this._children._insertNodes(index, nodes);\n  }\n  /**\n   * Removes one or more nodes starting at the given index\n   * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n   *\n   * @internal\n   * @protected\n   * @param {Number} index Index of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n   */\n  _removeChildren(index) {\n    let howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const nodes = this._children._removeNodes(index, howMany);\n    for (const node of nodes) {\n      node.parent = null;\n    }\n    return nodes;\n  }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tdocFrag.is( 'documentFragment' ); // -> true\n *\t\tdocFrag.is( 'model:documentFragment' ); // -> true\n *\n *\t\tdocFrag.is( 'view:documentFragment' ); // -> false\n *\t\tdocFrag.is( 'element' ); // -> false\n *\t\tdocFrag.is( 'node' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nDocumentFragment.prototype.is = function (type) {\n  return type === 'documentFragment' || type === 'model:documentFragment';\n};\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  }\n  // Array.from to enable .map() on non-arrays.\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n    if (node instanceof TextProxy) {\n      return new Text(node.data, node.getAttributes());\n    }\n    return node;\n  });\n}","map":{"version":3,"names":["TypeCheckable","Element","NodeList","Text","TextProxy","isIterable","DocumentFragment","constructor","children","markers","Map","_children","_insertChild","Symbol","iterator","getChildren","childCount","length","maxOffset","isEmpty","nextSibling","previousSibling","root","parent","document","getAncestors","getChild","index","getNode","getChildIndex","node","getNodeIndex","getChildStartOffset","getNodeStartOffset","getPath","getNodeByPath","relativePath","offsetToIndex","offset","toJSON","json","push","fromJSON","child","name","_appendChild","items","nodes","normalize","_remove","_insertNodes","_removeChildren","howMany","_removeNodes","prototype","is","type","Array","from","map","data","getAttributes"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module module:engine/model/documentfragment\n */\nimport TypeCheckable from './typecheckable';\nimport Element from './element';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n// @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );\n/**\n * DocumentFragment represents a part of model which does not have a common root but its top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\nexport default class DocumentFragment extends TypeCheckable {\n    /**\n     * Creates an empty `DocumentFragment`.\n     *\n     * **Note:** Constructor of this class shouldn't be used directly in the code.\n     * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n     *\n     * @protected\n     * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n     * Nodes to be contained inside the `DocumentFragment`.\n     */\n    constructor(children) {\n        super();\n        /**\n         * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n         * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n         * when DocumentFragment will be inserted to the document.\n         *\n         * @readonly\n         * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n         */\n        this.markers = new Map();\n        /**\n         * List of nodes contained inside the document fragment.\n         *\n         * @private\n         * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n         */\n        this._children = new NodeList();\n        if (children) {\n            this._insertChild(0, children);\n        }\n    }\n    /**\n     * Returns an iterator that iterates over all nodes contained inside this document fragment.\n     *\n     * @returns {Iterator.<module:engine/model/node~Node>}\n     */\n    [Symbol.iterator]() {\n        return this.getChildren();\n    }\n    /**\n     * Number of this document fragment's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get childCount() {\n        return this._children.length;\n    }\n    /**\n     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get maxOffset() {\n        return this._children.maxOffset;\n    }\n    /**\n     * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isEmpty() {\n        return this.childCount === 0;\n    }\n    /**\n     * Artificial next sibling. Returns `null`. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {null}\n     */\n    get nextSibling() {\n        return null;\n    }\n    /**\n     * Artificial previous sibling. Returns `null`. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {null}\n     */\n    get previousSibling() {\n        return null;\n    }\n    /**\n     * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {module:engine/model/documentfragment~DocumentFragment}\n     */\n    get root() {\n        return this;\n    }\n    /**\n     * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {null}\n     */\n    get parent() {\n        return null;\n    }\n    /**\n     * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {null}\n     */\n    get document() {\n        return null;\n    }\n    /**\n     * Returns empty array. Added for compatibility reasons.\n     *\n     * @returns {Array}\n     */\n    getAncestors() {\n        return [];\n    }\n    /**\n     * Gets the child at the given index. Returns `null` if incorrect index was passed.\n     *\n     * @param {Number} index Index of child.\n     * @returns {module:engine/model/node~Node|null} Child node.\n     */\n    getChild(index) {\n        return this._children.getNode(index);\n    }\n    /**\n     * Returns an iterator that iterates over all of this document fragment's children.\n     *\n     * @returns {Iterable.<module:engine/model/node~Node>}\n     */\n    getChildren() {\n        return this._children[Symbol.iterator]();\n    }\n    /**\n     * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number|null} Child node's index.\n     */\n    getChildIndex(node) {\n        return this._children.getNodeIndex(node);\n    }\n    /**\n     * Returns the starting offset of given child. Starting offset is equal to the sum of\n     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n     * given node is not a child of this document fragment.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number|null} Child node's starting offset.\n     */\n    getChildStartOffset(node) {\n        return this._children.getNodeStartOffset(node);\n    }\n    /**\n     * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n     *\n     * @returns {Array}\n     */\n    getPath() {\n        return [];\n    }\n    /**\n     * Returns a descendant node by its path relative to this element.\n     *\n     *\t\t// <this>a<b>c</b></this>\n     *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n     *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n     *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n     *\n     * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n     * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n     */\n    getNodeByPath(relativePath) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let node = this;\n        for (const index of relativePath) {\n            node = node.getChild(node.offsetToIndex(index));\n        }\n        return node;\n    }\n    /**\n     * Converts offset \"position\" to index \"position\".\n     *\n     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n     * too high, returns index after last child}.\n     *\n     *\t\tconst textNode = new Text( 'foo' );\n     *\t\tconst pElement = new Element( 'p' );\n     *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n     *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n     *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n     *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n     *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n     *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n     *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n     *\n     * @param {Number} offset Offset to look for.\n     * @returns {Number} Index of a node that occupies given offset.\n     */\n    offsetToIndex(offset) {\n        return this._children.offsetToIndex(offset);\n    }\n    /**\n     * Converts `DocumentFragment` instance to plain object and returns it.\n     * Takes care of converting all of this document fragment's children.\n     *\n     * @returns {Object} `DocumentFragment` instance converted to plain object.\n     */\n    toJSON() {\n        const json = [];\n        for (const node of this._children) {\n            json.push(node.toJSON());\n        }\n        return json;\n    }\n    /**\n     * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n     * Converts `DocumentFragment` children to proper nodes.\n     *\n     * @param {Object} json Plain object to be converted to `DocumentFragment`.\n     * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n     */\n    static fromJSON(json) {\n        const children = [];\n        for (const child of json) {\n            if (child.name) {\n                // If child has name property, it is an Element.\n                children.push(Element.fromJSON(child));\n            }\n            else {\n                // Otherwise, it is a Text node.\n                children.push(Text.fromJSON(child));\n            }\n        }\n        return new DocumentFragment(children);\n    }\n    /**\n     * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n     *\n     * @internal\n     * @protected\n     * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} items Items to be inserted.\n     */\n    _appendChild(items) {\n        this._insertChild(this.childCount, items);\n    }\n    /**\n     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n     * to this document fragment.\n     *\n     * @internal\n     * @protected\n     * @param {Number} index Index at which nodes should be inserted.\n     * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} items Items to be inserted.\n     */\n    _insertChild(index, items) {\n        const nodes = normalize(items);\n        for (const node of nodes) {\n            // If node that is being added to this element is already inside another element, first remove it from the old parent.\n            if (node.parent !== null) {\n                node._remove();\n            }\n            node.parent = this;\n        }\n        this._children._insertNodes(index, nodes);\n    }\n    /**\n     * Removes one or more nodes starting at the given index\n     * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n     *\n     * @internal\n     * @protected\n     * @param {Number} index Index of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n     */\n    _removeChildren(index, howMany = 1) {\n        const nodes = this._children._removeNodes(index, howMany);\n        for (const node of nodes) {\n            node.parent = null;\n        }\n        return nodes;\n    }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\tdocFrag.is( 'documentFragment' ); // -> true\n *\t\tdocFrag.is( 'model:documentFragment' ); // -> true\n *\n *\t\tdocFrag.is( 'view:documentFragment' ); // -> false\n *\t\tdocFrag.is( 'element' ); // -> false\n *\t\tdocFrag.is( 'node' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nDocumentFragment.prototype.is = function (type) {\n    return type === 'documentFragment' || type === 'model:documentFragment';\n};\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize(nodes) {\n    // Separate condition because string is iterable.\n    if (typeof nodes == 'string') {\n        return [new Text(nodes)];\n    }\n    if (!isIterable(nodes)) {\n        nodes = [nodes];\n    }\n    // Array.from to enable .map() on non-arrays.\n    return Array.from(nodes)\n        .map(node => {\n        if (typeof node == 'string') {\n            return new Text(node);\n        }\n        if (node instanceof TextProxy) {\n            return new Text(node.data, node.getAttributes());\n        }\n        return node;\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,OAAO,MAAM,WAAW;AAC/B,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,UAAU,MAAM,0CAA0C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,gBAAgB,SAASN,aAAa,CAAC;EACxD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,WAAW,CAACC,QAAQ,EAAE;IAClB,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,IAAIC,GAAG,EAAE;IACxB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,IAAIT,QAAQ,EAAE;IAC/B,IAAIM,QAAQ,EAAE;MACV,IAAI,CAACI,YAAY,CAAC,CAAC,EAAEJ,QAAQ,CAAC;IAClC;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI,CAACK,MAAM,CAACC,QAAQ,IAAI;IAChB,OAAO,IAAI,CAACC,WAAW,EAAE;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAG;IACb,OAAO,IAAI,CAACL,SAAS,CAACM,MAAM;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,SAAS,GAAG;IACZ,OAAO,IAAI,CAACP,SAAS,CAACO,SAAS;EACnC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,OAAO,GAAG;IACV,OAAO,IAAI,CAACH,UAAU,KAAK,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAII,WAAW,GAAG;IACd,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,eAAe,GAAG;IAClB,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,IAAI,GAAG;IACP,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,MAAM,GAAG;IACT,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,QAAQ,GAAG;IACX,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;EACIC,YAAY,GAAG;IACX,OAAO,EAAE;EACb;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,QAAQ,CAACC,KAAK,EAAE;IACZ,OAAO,IAAI,CAAChB,SAAS,CAACiB,OAAO,CAACD,KAAK,CAAC;EACxC;EACA;AACJ;AACA;AACA;AACA;EACIZ,WAAW,GAAG;IACV,OAAO,IAAI,CAACJ,SAAS,CAACE,MAAM,CAACC,QAAQ,CAAC,EAAE;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;EACIe,aAAa,CAACC,IAAI,EAAE;IAChB,OAAO,IAAI,CAACnB,SAAS,CAACoB,YAAY,CAACD,IAAI,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,mBAAmB,CAACF,IAAI,EAAE;IACtB,OAAO,IAAI,CAACnB,SAAS,CAACsB,kBAAkB,CAACH,IAAI,CAAC;EAClD;EACA;AACJ;AACA;AACA;AACA;EACII,OAAO,GAAG;IACN,OAAO,EAAE;EACb;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,CAACC,YAAY,EAAE;IACxB;IACA,IAAIN,IAAI,GAAG,IAAI;IACf,KAAK,MAAMH,KAAK,IAAIS,YAAY,EAAE;MAC9BN,IAAI,GAAGA,IAAI,CAACJ,QAAQ,CAACI,IAAI,CAACO,aAAa,CAACV,KAAK,CAAC,CAAC;IACnD;IACA,OAAOG,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,aAAa,CAACC,MAAM,EAAE;IAClB,OAAO,IAAI,CAAC3B,SAAS,CAAC0B,aAAa,CAACC,MAAM,CAAC;EAC/C;EACA;AACJ;AACA;AAC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"},"metadata":{},"sourceType":"module"}