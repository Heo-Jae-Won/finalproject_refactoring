{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/mapper\n */\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Maps elements, positions and markers between the {@link module:engine/view/document~Document view} and\n * the {@link module:engine/model/model model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map the complex model to/from view relations, you may provide custom callbacks for the\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by the {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds its own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Mapper extends Emitter {\n  /**\n   * Creates an instance of the mapper.\n   */\n  constructor() {\n    super();\n    /**\n     * Model element to view element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n    this._modelToViewMapping = new WeakMap();\n    /**\n     * View element to model element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n    this._viewToModelMapping = new WeakMap();\n    /**\n     * A map containing callbacks between view element names and functions evaluating length of view elements\n     * in model.\n     *\n     * @private\n     * @member {Map}\n     */\n    this._viewToModelLengthCallbacks = new Map();\n    /**\n     * Model marker name to view elements mapping.\n     *\n     * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n     * One marker (name) can be mapped to multiple elements.\n     *\n     * @private\n     * @member {Map}\n     */\n    this._markerNameToElements = new Map();\n    /**\n     * View element to model marker names mapping.\n     *\n     * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n     *\n     * @private\n     * @member {Map}\n     */\n    this._elementToMarkerNames = new Map();\n    /**\n     * The map of removed view elements with their current root (used for deferred unbinding).\n     *\n     * @private\n     * @member {Map.<module:engine/view/element~Element,module:engine/view/documentfragment~DocumentFragment>}\n     */\n    this._deferredBindingRemovals = new Map();\n    /**\n     * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n     * has been removed, moved or renamed).\n     *\n     * @private\n     * @member {Set.<module:engine/model/markercollection~Marker>}\n     */\n    this._unboundMarkerNames = new Set();\n    // Default mapper algorithm for mapping model position to view position.\n    this.on('modelToViewPosition', (evt, data) => {\n      if (data.viewPosition) {\n        return;\n      }\n      const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);\n      if (!viewContainer) {\n        /**\n         * A model position could not be mapped to the view because the parent of the model position\n         * does not have a mapped view element (might have not been converted yet or it has no converter).\n         *\n         * Make sure that the model element is correctly converted to the view.\n         *\n         * @error mapping-model-position-view-parent-not-found\n         */\n        throw new CKEditorError('mapping-model-position-view-parent-not-found', this, {\n          modelPosition: data.modelPosition\n        });\n      }\n      data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);\n    }, {\n      priority: 'low'\n    });\n    // Default mapper algorithm for mapping view position to model position.\n    this.on('viewToModelPosition', (evt, data) => {\n      if (data.modelPosition) {\n        return;\n      }\n      const viewBlock = this.findMappedViewAncestor(data.viewPosition);\n      const modelParent = this._viewToModelMapping.get(viewBlock);\n      const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);\n      data.modelPosition = ModelPosition._createAt(modelParent, modelOffset);\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n   * The information that elements are bound is also used to translate positions.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element.\n   * @param {module:engine/view/element~Element} viewElement View element.\n   */\n  bindElements(modelElement, viewElement) {\n    this._modelToViewMapping.set(modelElement, viewElement);\n    this._viewToModelMapping.set(viewElement, modelElement);\n  }\n  /**\n   * Unbinds the given {@link module:engine/view/element~Element view element} from the map.\n   *\n   * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n   * will be removed only if model element is still bound to the passed `viewElement`.\n   *\n   * This behavior allows for re-binding model element to another view element without fear of losing the new binding\n   * when the previously bound view element is unbound.\n   *\n   * @param {module:engine/view/element~Element} viewElement View element to unbind.\n   * @param {Object} [options={}] The options object.\n   * @param {Boolean} [options.defer=false] Controls whether the binding should be removed immediately or deferred until a\n   * {@link #flushDeferredBindings `flushDeferredBindings()`} call.\n   */\n  unbindViewElement(viewElement) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const modelElement = this.toModelElement(viewElement);\n    if (this._elementToMarkerNames.has(viewElement)) {\n      for (const markerName of this._elementToMarkerNames.get(viewElement)) {\n        this._unboundMarkerNames.add(markerName);\n      }\n    }\n    if (options.defer) {\n      this._deferredBindingRemovals.set(viewElement, viewElement.root);\n    } else {\n      this._viewToModelMapping.delete(viewElement);\n      if (this._modelToViewMapping.get(modelElement) == viewElement) {\n        this._modelToViewMapping.delete(modelElement);\n      }\n    }\n  }\n  /**\n   * Unbinds the given {@link module:engine/model/element~Element model element} from the map.\n   *\n   * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding\n   * will be removed only if the view element is still bound to the passed `modelElement`.\n   *\n   * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n   * when the previously bound model element is unbound.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n   */\n  unbindModelElement(modelElement) {\n    const viewElement = this.toViewElement(modelElement);\n    this._modelToViewMapping.delete(modelElement);\n    if (this._viewToModelMapping.get(viewElement) == modelElement) {\n      this._viewToModelMapping.delete(viewElement);\n    }\n  }\n  /**\n   * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element\n   * will be added to the current set of elements bound with the given marker name.\n   *\n   * @param {module:engine/view/element~Element} element Element to bind.\n   * @param {String} name Marker name.\n   */\n  bindElementToMarker(element, name) {\n    const elements = this._markerNameToElements.get(name) || new Set();\n    elements.add(element);\n    const names = this._elementToMarkerNames.get(element) || new Set();\n    names.add(name);\n    this._markerNameToElements.set(name, elements);\n    this._elementToMarkerNames.set(element, names);\n  }\n  /**\n   * Unbinds an element from given marker name.\n   *\n   * @param {module:engine/view/element~Element} element Element to unbind.\n   * @param {String} name Marker name.\n   */\n  unbindElementFromMarkerName(element, name) {\n    const nameToElements = this._markerNameToElements.get(name);\n    if (nameToElements) {\n      nameToElements.delete(element);\n      if (nameToElements.size == 0) {\n        this._markerNameToElements.delete(name);\n      }\n    }\n    const elementToNames = this._elementToMarkerNames.get(element);\n    if (elementToNames) {\n      elementToNames.delete(name);\n      if (elementToNames.size == 0) {\n        this._elementToMarkerNames.delete(element);\n      }\n    }\n  }\n  /**\n   * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n   * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n   *\n   * @returns {Array.<String>}\n   */\n  flushUnboundMarkerNames() {\n    const markerNames = Array.from(this._unboundMarkerNames);\n    this._unboundMarkerNames.clear();\n    return markerNames;\n  }\n  /**\n   * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.\n   *\n   * See: {@link #unbindViewElement `unbindViewElement()`}.\n   */\n  flushDeferredBindings() {\n    for (const [viewElement, root] of this._deferredBindingRemovals) {\n      // Unbind it only if it wasn't re-attached to some root or document fragment.\n      if (viewElement.root == root) {\n        this.unbindViewElement(viewElement);\n      }\n    }\n    this._deferredBindingRemovals = new Map();\n  }\n  /**\n   * Removes all model to view and view to model bindings.\n   */\n  clearBindings() {\n    this._modelToViewMapping = new WeakMap();\n    this._viewToModelMapping = new WeakMap();\n    this._markerNameToElements = new Map();\n    this._elementToMarkerNames = new Map();\n    this._unboundMarkerNames = new Set();\n    this._deferredBindingRemovals = new Map();\n  }\n  toModelElement(viewElement) {\n    return this._viewToModelMapping.get(viewElement);\n  }\n  toViewElement(modelElement) {\n    return this._modelToViewMapping.get(modelElement);\n  }\n  /**\n   * Gets the corresponding model range.\n   *\n   * @param {module:engine/view/range~Range} viewRange View range.\n   * @returns {module:engine/model/range~Range} Corresponding model range.\n   */\n  toModelRange(viewRange) {\n    return new ModelRange(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));\n  }\n  /**\n   * Gets the corresponding view range.\n   *\n   * @param {module:engine/model/range~Range} modelRange Model range.\n   * @returns {module:engine/view/range~Range} Corresponding view range.\n   */\n  toViewRange(modelRange) {\n    return new ViewRange(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));\n  }\n  /**\n   * Gets the corresponding model position.\n   *\n   * @fires viewToModelPosition\n   * @param {module:engine/view/position~Position} viewPosition View position.\n   * @returns {module:engine/model/position~Position} Corresponding model position.\n   */\n  toModelPosition(viewPosition) {\n    const data = {\n      viewPosition,\n      mapper: this\n    };\n    this.fire('viewToModelPosition', data);\n    return data.modelPosition;\n  }\n  /**\n   * Gets the corresponding view position.\n   *\n   * @fires modelToViewPosition\n   * @param {module:engine/model/position~Position} modelPosition Model position.\n   * @param {Object} [options] Additional options for position mapping process.\n   * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n   * in model tree which no longer exists. For example, it could be an end of a removed model range.\n   * @returns {module:engine/view/position~Position} Corresponding view position.\n   */\n  toViewPosition(modelPosition) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const data = {\n      modelPosition,\n      mapper: this,\n      isPhantom: options.isPhantom\n    };\n    this.fire('modelToViewPosition', data);\n    return data.viewPosition;\n  }\n  /**\n   * Gets all view elements bound to the given marker name.\n   *\n   * @param {String} name Marker name.\n   * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with the given marker name or `null`\n   * if no elements are bound to the given marker name.\n   */\n  markerNameToElements(name) {\n    const boundElements = this._markerNameToElements.get(name);\n    if (!boundElements) {\n      return null;\n    }\n    const elements = new Set();\n    for (const element of boundElements) {\n      if (element.is('attributeElement')) {\n        for (const clone of element.getElementsWithSameId()) {\n          elements.add(clone);\n        }\n      } else {\n        elements.add(element);\n      }\n    }\n    return elements;\n  }\n  /**\n   * Registers a callback that evaluates the length in the model of a view element with the given name.\n   *\n   * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n   * a number representing the length of the view element in the model.\n   *\n   *\t\t// List item in view may contain nested list, which have other list items. In model though,\n   *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n   *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n   *\n   *\t\tfunction getViewListItemLength( element ) {\n   *\t\t\tlet length = 1;\n   *\n   *\t\t\tfor ( let child of element.getChildren() ) {\n   *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n   *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n   *\t\t\t\t\t\tlength += getViewListItemLength( item );\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t}\n   *\n   *\t\t\treturn length;\n   *\t\t}\n   *\n   *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n   *\n   * @param {String} viewElementName Name of view element for which callback is registered.\n   * @param {Function} lengthCallback Function return a length of view element instance in model.\n   */\n  registerViewToModelLength(viewElementName, lengthCallback) {\n    this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);\n  }\n  /**\n   * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n   * the model.\n   *\n   * @param {module:engine/view/position~Position} viewPosition Position for which a mapped ancestor should be found.\n   * @returns {module:engine/view/element~Element}\n   */\n  findMappedViewAncestor(viewPosition) {\n    let parent = viewPosition.parent;\n    while (!this._viewToModelMapping.has(parent)) {\n      parent = parent.parent;\n    }\n    return parent;\n  }\n  /**\n   * Calculates model offset based on the view position and the block element.\n   *\n   * Example:\n   *\n   *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n   *\n   * Is a sum of:\n   *\n   *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n   *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewParent Position parent.\n   * @param {Number} viewOffset Position offset.\n   * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n   * @returns {Number} Offset in the model.\n   */\n  _toModelOffset(viewParent, viewOffset, viewBlock) {\n    if (viewBlock != viewParent) {\n      // See example.\n      const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);\n      const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);\n      return offsetToParentStart + offsetInParent;\n    }\n    // viewBlock == viewParent, so we need to calculate the offset in the parent element.\n    // If the position is a text it is simple (\"ba|r\" -> 2).\n    if (viewParent.is('$text')) {\n      return viewOffset;\n    }\n    // If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n    let modelOffset = 0;\n    for (let i = 0; i < viewOffset; i++) {\n      modelOffset += this.getModelLength(viewParent.getChild(i));\n    }\n    return modelOffset;\n  }\n  /**\n   * Gets the length of the view element in the model.\n   *\n   * The length is calculated as follows:\n   * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to\n   * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),\n   * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its\n   * {@link module:engine/view/text~Text#data data},\n   * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n   * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n   * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.\n   *\n   * Examples:\n   *\n   *\t\tfoo                          -> 3 // Text length is equal to its data length.\n   *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n   *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n   *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n   *\n   * @param {module:engine/view/element~Element} viewNode View node.\n   * @returns {Number} Length of the node in the tree model.\n   */\n  getModelLength(viewNode) {\n    if (this._viewToModelLengthCallbacks.get(viewNode.name)) {\n      const callback = this._viewToModelLengthCallbacks.get(viewNode.name);\n      return callback(viewNode);\n    } else if (this._viewToModelMapping.has(viewNode)) {\n      return 1;\n    } else if (viewNode.is('$text')) {\n      return viewNode.data.length;\n    } else if (viewNode.is('uiElement')) {\n      return 0;\n    } else {\n      let len = 0;\n      for (const child of viewNode.getChildren()) {\n        len += this.getModelLength(child);\n      }\n      return len;\n    }\n  }\n  /**\n   * Finds the position in the view node (or in its children) with the expected model offset.\n   *\n   * Example:\n   *\n   *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n   *\n   *\t\tfindPositionIn( p, 4 ):\n   *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n   *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n   *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n   *\n   *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n   *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n   *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n   *\n   *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n   *\t\tWe are in the text node so we can simple find the offset.\n   *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n   *\n   * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n   * @param {Number} expectedOffset Expected offset.\n   * @returns {module:engine/view/position~Position} Found position.\n   */\n  findPositionIn(viewParent, expectedOffset) {\n    // Last scanned view node.\n    let viewNode;\n    // Length of the last scanned view node.\n    let lastLength = 0;\n    let modelOffset = 0;\n    let viewOffset = 0;\n    // In the text node it is simple: the offset in the model equals the offset in the text.\n    if (viewParent.is('$text')) {\n      return new ViewPosition(viewParent, expectedOffset);\n    }\n    // In other cases we add lengths of child nodes to find the proper offset.\n    // If it is smaller we add the length.\n    while (modelOffset < expectedOffset) {\n      viewNode = viewParent.getChild(viewOffset);\n      lastLength = this.getModelLength(viewNode);\n      modelOffset += lastLength;\n      viewOffset++;\n    }\n    // If it equals we found the position.\n    if (modelOffset == expectedOffset) {\n      return this._moveViewPositionToTextNode(new ViewPosition(viewParent, viewOffset));\n    }\n    // If it is higher we need to enter last child.\n    else {\n      // ( modelOffset - lastLength ) is the offset to the child we enter,\n      // so we subtract it from the expected offset to fine the offset in the child.\n      return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));\n    }\n  }\n  /**\n   * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,\n   * it moves it into the text node instead.\n   *\n   *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n   *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n   *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n   *\n   * @private\n   * @param {module:engine/view/position~Position} viewPosition Position potentially next to the text node.\n   * @returns {module:engine/view/position~Position} Position in the text node if possible.\n   */\n  _moveViewPositionToTextNode(viewPosition) {\n    // If the position is just after a text node, put it at the end of that text node.\n    // If the position is just before a text node, put it at the beginning of that text node.\n    const nodeBefore = viewPosition.nodeBefore;\n    const nodeAfter = viewPosition.nodeAfter;\n    if (nodeBefore instanceof ViewText) {\n      return new ViewPosition(nodeBefore, nodeBefore.data.length);\n    } else if (nodeAfter instanceof ViewText) {\n      return new ViewPosition(nodeAfter, 0);\n    }\n    // Otherwise, just return the given position.\n    return viewPosition;\n  }\n}","map":{"version":3,"names":["ModelPosition","ModelRange","ViewPosition","ViewRange","ViewText","Emitter","CKEditorError","Mapper","constructor","_modelToViewMapping","WeakMap","_viewToModelMapping","_viewToModelLengthCallbacks","Map","_markerNameToElements","_elementToMarkerNames","_deferredBindingRemovals","_unboundMarkerNames","Set","on","evt","data","viewPosition","viewContainer","get","modelPosition","parent","findPositionIn","offset","priority","viewBlock","findMappedViewAncestor","modelParent","modelOffset","_toModelOffset","_createAt","bindElements","modelElement","viewElement","set","unbindViewElement","options","toModelElement","has","markerName","add","defer","root","delete","unbindModelElement","toViewElement","bindElementToMarker","element","name","elements","names","unbindElementFromMarkerName","nameToElements","size","elementToNames","flushUnboundMarkerNames","markerNames","Array","from","clear","flushDeferredBindings","clearBindings","toModelRange","viewRange","toModelPosition","start","end","toViewRange","modelRange","toViewPosition","mapper","fire","isPhantom","markerNameToElements","boundElements","is","clone","getElementsWithSameId","registerViewToModelLength","viewElementName","lengthCallback","viewParent","viewOffset","offsetToParentStart","index","offsetInParent","i","getModelLength","getChild","viewNode","callback","length","len","child","getChildren","expectedOffset","lastLength","_moveViewPositionToTextNode","nodeBefore","nodeAfter"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/mapper\n */\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Maps elements, positions and markers between the {@link module:engine/view/document~Document view} and\n * the {@link module:engine/model/model model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map the complex model to/from view relations, you may provide custom callbacks for the\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by the {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds its own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Mapper extends Emitter {\n    /**\n     * Creates an instance of the mapper.\n     */\n    constructor() {\n        super();\n        /**\n         * Model element to view element mapping.\n         *\n         * @private\n         * @member {WeakMap}\n         */\n        this._modelToViewMapping = new WeakMap();\n        /**\n         * View element to model element mapping.\n         *\n         * @private\n         * @member {WeakMap}\n         */\n        this._viewToModelMapping = new WeakMap();\n        /**\n         * A map containing callbacks between view element names and functions evaluating length of view elements\n         * in model.\n         *\n         * @private\n         * @member {Map}\n         */\n        this._viewToModelLengthCallbacks = new Map();\n        /**\n         * Model marker name to view elements mapping.\n         *\n         * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n         * One marker (name) can be mapped to multiple elements.\n         *\n         * @private\n         * @member {Map}\n         */\n        this._markerNameToElements = new Map();\n        /**\n         * View element to model marker names mapping.\n         *\n         * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n         *\n         * @private\n         * @member {Map}\n         */\n        this._elementToMarkerNames = new Map();\n        /**\n         * The map of removed view elements with their current root (used for deferred unbinding).\n         *\n         * @private\n         * @member {Map.<module:engine/view/element~Element,module:engine/view/documentfragment~DocumentFragment>}\n         */\n        this._deferredBindingRemovals = new Map();\n        /**\n         * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n         * has been removed, moved or renamed).\n         *\n         * @private\n         * @member {Set.<module:engine/model/markercollection~Marker>}\n         */\n        this._unboundMarkerNames = new Set();\n        // Default mapper algorithm for mapping model position to view position.\n        this.on('modelToViewPosition', (evt, data) => {\n            if (data.viewPosition) {\n                return;\n            }\n            const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);\n            if (!viewContainer) {\n                /**\n                 * A model position could not be mapped to the view because the parent of the model position\n                 * does not have a mapped view element (might have not been converted yet or it has no converter).\n                 *\n                 * Make sure that the model element is correctly converted to the view.\n                 *\n                 * @error mapping-model-position-view-parent-not-found\n                 */\n                throw new CKEditorError('mapping-model-position-view-parent-not-found', this, { modelPosition: data.modelPosition });\n            }\n            data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);\n        }, { priority: 'low' });\n        // Default mapper algorithm for mapping view position to model position.\n        this.on('viewToModelPosition', (evt, data) => {\n            if (data.modelPosition) {\n                return;\n            }\n            const viewBlock = this.findMappedViewAncestor(data.viewPosition);\n            const modelParent = this._viewToModelMapping.get(viewBlock);\n            const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);\n            data.modelPosition = ModelPosition._createAt(modelParent, modelOffset);\n        }, { priority: 'low' });\n    }\n    /**\n     * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n     * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n     * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n     * The information that elements are bound is also used to translate positions.\n     *\n     * @param {module:engine/model/element~Element} modelElement Model element.\n     * @param {module:engine/view/element~Element} viewElement View element.\n     */\n    bindElements(modelElement, viewElement) {\n        this._modelToViewMapping.set(modelElement, viewElement);\n        this._viewToModelMapping.set(viewElement, modelElement);\n    }\n    /**\n     * Unbinds the given {@link module:engine/view/element~Element view element} from the map.\n     *\n     * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n     * will be removed only if model element is still bound to the passed `viewElement`.\n     *\n     * This behavior allows for re-binding model element to another view element without fear of losing the new binding\n     * when the previously bound view element is unbound.\n     *\n     * @param {module:engine/view/element~Element} viewElement View element to unbind.\n     * @param {Object} [options={}] The options object.\n     * @param {Boolean} [options.defer=false] Controls whether the binding should be removed immediately or deferred until a\n     * {@link #flushDeferredBindings `flushDeferredBindings()`} call.\n     */\n    unbindViewElement(viewElement, options = {}) {\n        const modelElement = this.toModelElement(viewElement);\n        if (this._elementToMarkerNames.has(viewElement)) {\n            for (const markerName of this._elementToMarkerNames.get(viewElement)) {\n                this._unboundMarkerNames.add(markerName);\n            }\n        }\n        if (options.defer) {\n            this._deferredBindingRemovals.set(viewElement, viewElement.root);\n        }\n        else {\n            this._viewToModelMapping.delete(viewElement);\n            if (this._modelToViewMapping.get(modelElement) == viewElement) {\n                this._modelToViewMapping.delete(modelElement);\n            }\n        }\n    }\n    /**\n     * Unbinds the given {@link module:engine/model/element~Element model element} from the map.\n     *\n     * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding\n     * will be removed only if the view element is still bound to the passed `modelElement`.\n     *\n     * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n     * when the previously bound model element is unbound.\n     *\n     * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n     */\n    unbindModelElement(modelElement) {\n        const viewElement = this.toViewElement(modelElement);\n        this._modelToViewMapping.delete(modelElement);\n        if (this._viewToModelMapping.get(viewElement) == modelElement) {\n            this._viewToModelMapping.delete(viewElement);\n        }\n    }\n    /**\n     * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element\n     * will be added to the current set of elements bound with the given marker name.\n     *\n     * @param {module:engine/view/element~Element} element Element to bind.\n     * @param {String} name Marker name.\n     */\n    bindElementToMarker(element, name) {\n        const elements = this._markerNameToElements.get(name) || new Set();\n        elements.add(element);\n        const names = this._elementToMarkerNames.get(element) || new Set();\n        names.add(name);\n        this._markerNameToElements.set(name, elements);\n        this._elementToMarkerNames.set(element, names);\n    }\n    /**\n     * Unbinds an element from given marker name.\n     *\n     * @param {module:engine/view/element~Element} element Element to unbind.\n     * @param {String} name Marker name.\n     */\n    unbindElementFromMarkerName(element, name) {\n        const nameToElements = this._markerNameToElements.get(name);\n        if (nameToElements) {\n            nameToElements.delete(element);\n            if (nameToElements.size == 0) {\n                this._markerNameToElements.delete(name);\n            }\n        }\n        const elementToNames = this._elementToMarkerNames.get(element);\n        if (elementToNames) {\n            elementToNames.delete(name);\n            if (elementToNames.size == 0) {\n                this._elementToMarkerNames.delete(element);\n            }\n        }\n    }\n    /**\n     * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n     * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n     *\n     * @returns {Array.<String>}\n     */\n    flushUnboundMarkerNames() {\n        const markerNames = Array.from(this._unboundMarkerNames);\n        this._unboundMarkerNames.clear();\n        return markerNames;\n    }\n    /**\n     * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.\n     *\n     * See: {@link #unbindViewElement `unbindViewElement()`}.\n     */\n    flushDeferredBindings() {\n        for (const [viewElement, root] of this._deferredBindingRemovals) {\n            // Unbind it only if it wasn't re-attached to some root or document fragment.\n            if (viewElement.root == root) {\n                this.unbindViewElement(viewElement);\n            }\n        }\n        this._deferredBindingRemovals = new Map();\n    }\n    /**\n     * Removes all model to view and view to model bindings.\n     */\n    clearBindings() {\n        this._modelToViewMapping = new WeakMap();\n        this._viewToModelMapping = new WeakMap();\n        this._markerNameToElements = new Map();\n        this._elementToMarkerNames = new Map();\n        this._unboundMarkerNames = new Set();\n        this._deferredBindingRemovals = new Map();\n    }\n    toModelElement(viewElement) {\n        return this._viewToModelMapping.get(viewElement);\n    }\n    toViewElement(modelElement) {\n        return this._modelToViewMapping.get(modelElement);\n    }\n    /**\n     * Gets the corresponding model range.\n     *\n     * @param {module:engine/view/range~Range} viewRange View range.\n     * @returns {module:engine/model/range~Range} Corresponding model range.\n     */\n    toModelRange(viewRange) {\n        return new ModelRange(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));\n    }\n    /**\n     * Gets the corresponding view range.\n     *\n     * @param {module:engine/model/range~Range} modelRange Model range.\n     * @returns {module:engine/view/range~Range} Corresponding view range.\n     */\n    toViewRange(modelRange) {\n        return new ViewRange(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));\n    }\n    /**\n     * Gets the corresponding model position.\n     *\n     * @fires viewToModelPosition\n     * @param {module:engine/view/position~Position} viewPosition View position.\n     * @returns {module:engine/model/position~Position} Corresponding model position.\n     */\n    toModelPosition(viewPosition) {\n        const data = {\n            viewPosition,\n            mapper: this\n        };\n        this.fire('viewToModelPosition', data);\n        return data.modelPosition;\n    }\n    /**\n     * Gets the corresponding view position.\n     *\n     * @fires modelToViewPosition\n     * @param {module:engine/model/position~Position} modelPosition Model position.\n     * @param {Object} [options] Additional options for position mapping process.\n     * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n     * in model tree which no longer exists. For example, it could be an end of a removed model range.\n     * @returns {module:engine/view/position~Position} Corresponding view position.\n     */\n    toViewPosition(modelPosition, options = {}) {\n        const data = {\n            modelPosition,\n            mapper: this,\n            isPhantom: options.isPhantom\n        };\n        this.fire('modelToViewPosition', data);\n        return data.viewPosition;\n    }\n    /**\n     * Gets all view elements bound to the given marker name.\n     *\n     * @param {String} name Marker name.\n     * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with the given marker name or `null`\n     * if no elements are bound to the given marker name.\n     */\n    markerNameToElements(name) {\n        const boundElements = this._markerNameToElements.get(name);\n        if (!boundElements) {\n            return null;\n        }\n        const elements = new Set();\n        for (const element of boundElements) {\n            if (element.is('attributeElement')) {\n                for (const clone of element.getElementsWithSameId()) {\n                    elements.add(clone);\n                }\n            }\n            else {\n                elements.add(element);\n            }\n        }\n        return elements;\n    }\n    /**\n     * Registers a callback that evaluates the length in the model of a view element with the given name.\n     *\n     * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n     * a number representing the length of the view element in the model.\n     *\n     *\t\t// List item in view may contain nested list, which have other list items. In model though,\n     *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n     *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n     *\n     *\t\tfunction getViewListItemLength( element ) {\n     *\t\t\tlet length = 1;\n     *\n     *\t\t\tfor ( let child of element.getChildren() ) {\n     *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n     *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n     *\t\t\t\t\t\tlength += getViewListItemLength( item );\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\n     *\t\t\treturn length;\n     *\t\t}\n     *\n     *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n     *\n     * @param {String} viewElementName Name of view element for which callback is registered.\n     * @param {Function} lengthCallback Function return a length of view element instance in model.\n     */\n    registerViewToModelLength(viewElementName, lengthCallback) {\n        this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);\n    }\n    /**\n     * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n     * the model.\n     *\n     * @param {module:engine/view/position~Position} viewPosition Position for which a mapped ancestor should be found.\n     * @returns {module:engine/view/element~Element}\n     */\n    findMappedViewAncestor(viewPosition) {\n        let parent = viewPosition.parent;\n        while (!this._viewToModelMapping.has(parent)) {\n            parent = parent.parent;\n        }\n        return parent;\n    }\n    /**\n     * Calculates model offset based on the view position and the block element.\n     *\n     * Example:\n     *\n     *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n     *\n     * Is a sum of:\n     *\n     *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n     *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewParent Position parent.\n     * @param {Number} viewOffset Position offset.\n     * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n     * @returns {Number} Offset in the model.\n     */\n    _toModelOffset(viewParent, viewOffset, viewBlock) {\n        if (viewBlock != viewParent) {\n            // See example.\n            const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);\n            const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);\n            return offsetToParentStart + offsetInParent;\n        }\n        // viewBlock == viewParent, so we need to calculate the offset in the parent element.\n        // If the position is a text it is simple (\"ba|r\" -> 2).\n        if (viewParent.is('$text')) {\n            return viewOffset;\n        }\n        // If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n        let modelOffset = 0;\n        for (let i = 0; i < viewOffset; i++) {\n            modelOffset += this.getModelLength(viewParent.getChild(i));\n        }\n        return modelOffset;\n    }\n    /**\n     * Gets the length of the view element in the model.\n     *\n     * The length is calculated as follows:\n     * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to\n     * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),\n     * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its\n     * {@link module:engine/view/text~Text#data data},\n     * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n     * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n     * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.\n     *\n     * Examples:\n     *\n     *\t\tfoo                          -> 3 // Text length is equal to its data length.\n     *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n     *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n     *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n     *\n     * @param {module:engine/view/element~Element} viewNode View node.\n     * @returns {Number} Length of the node in the tree model.\n     */\n    getModelLength(viewNode) {\n        if (this._viewToModelLengthCallbacks.get(viewNode.name)) {\n            const callback = this._viewToModelLengthCallbacks.get(viewNode.name);\n            return callback(viewNode);\n        }\n        else if (this._viewToModelMapping.has(viewNode)) {\n            return 1;\n        }\n        else if (viewNode.is('$text')) {\n            return viewNode.data.length;\n        }\n        else if (viewNode.is('uiElement')) {\n            return 0;\n        }\n        else {\n            let len = 0;\n            for (const child of viewNode.getChildren()) {\n                len += this.getModelLength(child);\n            }\n            return len;\n        }\n    }\n    /**\n     * Finds the position in the view node (or in its children) with the expected model offset.\n     *\n     * Example:\n     *\n     *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n     *\n     *\t\tfindPositionIn( p, 4 ):\n     *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n     *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n     *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n     *\n     *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n     *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n     *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n     *\n     *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n     *\t\tWe are in the text node so we can simple find the offset.\n     *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n     *\n     * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n     * @param {Number} expectedOffset Expected offset.\n     * @returns {module:engine/view/position~Position} Found position.\n     */\n    findPositionIn(viewParent, expectedOffset) {\n        // Last scanned view node.\n        let viewNode;\n        // Length of the last scanned view node.\n        let lastLength = 0;\n        let modelOffset = 0;\n        let viewOffset = 0;\n        // In the text node it is simple: the offset in the model equals the offset in the text.\n        if (viewParent.is('$text')) {\n            return new ViewPosition(viewParent, expectedOffset);\n        }\n        // In other cases we add lengths of child nodes to find the proper offset.\n        // If it is smaller we add the length.\n        while (modelOffset < expectedOffset) {\n            viewNode = viewParent.getChild(viewOffset);\n            lastLength = this.getModelLength(viewNode);\n            modelOffset += lastLength;\n            viewOffset++;\n        }\n        // If it equals we found the position.\n        if (modelOffset == expectedOffset) {\n            return this._moveViewPositionToTextNode(new ViewPosition(viewParent, viewOffset));\n        }\n        // If it is higher we need to enter last child.\n        else {\n            // ( modelOffset - lastLength ) is the offset to the child we enter,\n            // so we subtract it from the expected offset to fine the offset in the child.\n            return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));\n        }\n    }\n    /**\n     * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,\n     * it moves it into the text node instead.\n     *\n     *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n     *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n     *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n     *\n     * @private\n     * @param {module:engine/view/position~Position} viewPosition Position potentially next to the text node.\n     * @returns {module:engine/view/position~Position} Position in the text node if possible.\n     */\n    _moveViewPositionToTextNode(viewPosition) {\n        // If the position is just after a text node, put it at the end of that text node.\n        // If the position is just before a text node, put it at the beginning of that text node.\n        const nodeBefore = viewPosition.nodeBefore;\n        const nodeAfter = viewPosition.nodeAfter;\n        if (nodeBefore instanceof ViewText) {\n            return new ViewPosition(nodeBefore, nodeBefore.data.length);\n        }\n        else if (nodeAfter instanceof ViewText) {\n            return new ViewPosition(nodeAfter, 0);\n        }\n        // Otherwise, just return the given position.\n        return viewPosition;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}