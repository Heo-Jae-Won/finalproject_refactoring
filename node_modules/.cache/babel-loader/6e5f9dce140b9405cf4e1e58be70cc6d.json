{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { CKEditorError } from '@ckeditor/ckeditor5-utils';\n/**\n * @module engine/model/history\n */\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n  /**\n   * Creates an empty History instance.\n   */\n  constructor() {\n    /**\n     * Operations added to the history.\n     *\n     * @private\n     * @readonly\n     * @type {Array.<module:engine/model/operation/operation~Operation>}\n     */\n    this._operations = [];\n    /**\n     * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     *\n     * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n     * value is an operation that has been undone by the \"undoing operation\".\n     *\n     * @private\n     * @member {Map} module:engine/model/history~History#_undoPairs\n     */\n    this._undoPairs = new Map();\n    /**\n     * Holds all undone operations.\n     *\n     * @private\n     * @type {Set.<module:engine/model/operation/operation~Operation>}\n     */\n    this._undoneOperations = new Set();\n    /**\n     * A map that allows retrieving the operations fast based on the given base version.\n     *\n     * @private\n     * @type Map.<Number,Number>\n     */\n    this._baseVersionToOperationIndex = new Map();\n    /**\n     * The history version.\n     *\n     * @private\n     * @type {Number}\n     */\n    this._version = 0;\n    /**\n     * The gap pairs kept in the <from,to> format.\n     *\n     * Anytime the `history.version` is set to a version larger than `history.version + 1`,\n     * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.\n     *\n     * @private\n     * @type Map.<number,number>\n     */\n    this._gaps = new Map();\n  }\n  /**\n   * The version of the last operation in the history.\n   *\n   * The history version is incremented automatically when a new operation is added to the history.\n   * Setting the version manually should be done only in rare circumstances when a gap is planned\n   * between history versions. When doing so, a gap will be created and the history will accept adding\n   * an operation with base version equal to the new history version.\n   *\n   * @type {Number}\n   */\n  get version() {\n    return this._version;\n  }\n  set version(version) {\n    // Store a gap if there are some operations already in the history and the\n    // new version does not increment the latest one.\n    if (this._operations.length && version > this._version + 1) {\n      this._gaps.set(this._version, version);\n    }\n    this._version = version;\n  }\n  /**\n   * The last history operation.\n   *\n   * @readonly\n   * @type {module:engine/model/operation/operation~Operation|undefined}\n   */\n  get lastOperation() {\n    return this._operations[this._operations.length - 1];\n  }\n  /**\n   * Adds an operation to the history and increments the history version.\n   *\n   * The operation's base version should be equal to the history version. Otherwise an error is thrown.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n   */\n  addOperation(operation) {\n    if (operation.baseVersion !== this.version) {\n      /**\n       * Only operations with matching versions can be added to the history.\n       *\n       * @error model-document-history-addoperation-incorrect-version\n       * @param {Object} errorData The operation and the current document history version.\n       */\n      throw new CKEditorError('model-document-history-addoperation-incorrect-version', this, {\n        operation,\n        historyVersion: this.version\n      });\n    }\n    this._operations.push(operation);\n    this._version++;\n    this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);\n  }\n  /**\n   * Returns operations from the given range of operation base versions that were added to the history.\n   *\n   * Note that there may be gaps in operations base versions.\n   *\n   * @param {Number} [fromBaseVersion] Base version from which operations should be returned (inclusive).\n   * @param {Number} [toBaseVersion] Base version up to which operations should be returned (exclusive).\n   * @returns {Array.<module:engine/model/operation/operation~Operation>} History operations for the given range, in chronological order.\n   */\n  getOperations(fromBaseVersion) {\n    let toBaseVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.version;\n    // When there is no operation in the history, return an empty array.\n    // After that we can be sure that `firstOperation`, `lastOperation` are not nullish.\n    if (!this._operations.length) {\n      return [];\n    }\n    const firstOperation = this._operations[0];\n    if (fromBaseVersion === undefined) {\n      fromBaseVersion = firstOperation.baseVersion;\n    }\n    // Change exclusive `toBaseVersion` to inclusive, so it will refer to the actual index.\n    // Thanks to that mapping from base versions to operation indexes are possible.\n    let inclusiveTo = toBaseVersion - 1;\n    // Check if \"from\" or \"to\" point to a gap between versions.\n    // If yes, then change the incorrect position to the proper side of the gap.\n    // Thanks to it, it will be possible to get index of the operation.\n    for (const [gapFrom, gapTo] of this._gaps) {\n      if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {\n        fromBaseVersion = gapTo;\n      }\n      if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {\n        inclusiveTo = gapFrom - 1;\n      }\n    }\n    // If the whole range is outside of the operation versions, then return an empty array.\n    if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {\n      return [];\n    }\n    let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion);\n    // If the range starts before the first operation, then use the first operation as the range's start.\n    if (fromIndex === undefined) {\n      fromIndex = 0;\n    }\n    let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo);\n    // If the range ends after the last operation, then use the last operation as the range's end.\n    if (toIndex === undefined) {\n      toIndex = this._operations.length - 1;\n    }\n    // Return the part of the history operations based on the calculated start index and end index.\n    return this._operations.slice(fromIndex,\n    // The `toIndex` should be included in the returned operations, so add `1`.\n    toIndex + 1);\n  }\n  /**\n   * Returns operation from the history that bases on given `baseVersion`.\n   *\n   * @param {Number} baseVersion Base version of the operation to get.\n   * @returns {module:engine/model/operation/operation~Operation|undefined} Operation with given base version or `undefined` if\n   * there is no such operation in history.\n   */\n  getOperation(baseVersion) {\n    const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);\n    if (operationIndex === undefined) {\n      return;\n    }\n    return this._operations[operationIndex];\n  }\n  /**\n   * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n   * history is keeping more context information about operations, which helps in operational transformation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n   */\n  setOperationAsUndone(undoneOperation, undoingOperation) {\n    this._undoPairs.set(undoingOperation, undoneOperation);\n    this._undoneOperations.add(undoneOperation);\n  }\n  /**\n   * Checks whether given `operation` is undoing any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n   */\n  isUndoingOperation(operation) {\n    return this._undoPairs.has(operation);\n  }\n  /**\n   * Checks whether given `operation` has been undone by any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n   */\n  isUndoneOperation(operation) {\n    return this._undoneOperations.has(operation);\n  }\n  /**\n   * For given `undoingOperation`, returns the operation which has been undone by it.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation\n   * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n   * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n   */\n  getUndoneOperation(undoingOperation) {\n    return this._undoPairs.get(undoingOperation);\n  }\n  /**\n   * Resets the history of operations.\n   */\n  reset() {\n    this._version = 0;\n    this._undoPairs = new Map();\n    this._operations = [];\n    this._undoneOperations = new Set();\n    this._gaps = new Map();\n    this._baseVersionToOperationIndex = new Map();\n  }\n}","map":{"version":3,"names":["CKEditorError","History","constructor","_operations","_undoPairs","Map","_undoneOperations","Set","_baseVersionToOperationIndex","_version","_gaps","version","length","set","lastOperation","addOperation","operation","baseVersion","historyVersion","push","getOperations","fromBaseVersion","toBaseVersion","firstOperation","undefined","inclusiveTo","gapFrom","gapTo","fromIndex","get","toIndex","slice","getOperation","operationIndex","setOperationAsUndone","undoneOperation","undoingOperation","add","isUndoingOperation","has","isUndoneOperation","getUndoneOperation","reset"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/history.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { CKEditorError } from '@ckeditor/ckeditor5-utils';\n/**\n * @module engine/model/history\n */\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n    /**\n     * Creates an empty History instance.\n     */\n    constructor() {\n        /**\n         * Operations added to the history.\n         *\n         * @private\n         * @readonly\n         * @type {Array.<module:engine/model/operation/operation~Operation>}\n         */\n        this._operations = [];\n        /**\n         * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n         * {@link module:engine/model/operation/operation~Operation operation}.\n         *\n         * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n         * value is an operation that has been undone by the \"undoing operation\".\n         *\n         * @private\n         * @member {Map} module:engine/model/history~History#_undoPairs\n         */\n        this._undoPairs = new Map();\n        /**\n         * Holds all undone operations.\n         *\n         * @private\n         * @type {Set.<module:engine/model/operation/operation~Operation>}\n         */\n        this._undoneOperations = new Set();\n        /**\n         * A map that allows retrieving the operations fast based on the given base version.\n         *\n         * @private\n         * @type Map.<Number,Number>\n         */\n        this._baseVersionToOperationIndex = new Map();\n        /**\n         * The history version.\n         *\n         * @private\n         * @type {Number}\n         */\n        this._version = 0;\n        /**\n         * The gap pairs kept in the <from,to> format.\n         *\n         * Anytime the `history.version` is set to a version larger than `history.version + 1`,\n         * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.\n         *\n         * @private\n         * @type Map.<number,number>\n         */\n        this._gaps = new Map();\n    }\n    /**\n     * The version of the last operation in the history.\n     *\n     * The history version is incremented automatically when a new operation is added to the history.\n     * Setting the version manually should be done only in rare circumstances when a gap is planned\n     * between history versions. When doing so, a gap will be created and the history will accept adding\n     * an operation with base version equal to the new history version.\n     *\n     * @type {Number}\n     */\n    get version() {\n        return this._version;\n    }\n    set version(version) {\n        // Store a gap if there are some operations already in the history and the\n        // new version does not increment the latest one.\n        if (this._operations.length && version > this._version + 1) {\n            this._gaps.set(this._version, version);\n        }\n        this._version = version;\n    }\n    /**\n     * The last history operation.\n     *\n     * @readonly\n     * @type {module:engine/model/operation/operation~Operation|undefined}\n     */\n    get lastOperation() {\n        return this._operations[this._operations.length - 1];\n    }\n    /**\n     * Adds an operation to the history and increments the history version.\n     *\n     * The operation's base version should be equal to the history version. Otherwise an error is thrown.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n     */\n    addOperation(operation) {\n        if (operation.baseVersion !== this.version) {\n            /**\n             * Only operations with matching versions can be added to the history.\n             *\n             * @error model-document-history-addoperation-incorrect-version\n             * @param {Object} errorData The operation and the current document history version.\n             */\n            throw new CKEditorError('model-document-history-addoperation-incorrect-version', this, {\n                operation,\n                historyVersion: this.version\n            });\n        }\n        this._operations.push(operation);\n        this._version++;\n        this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);\n    }\n    /**\n     * Returns operations from the given range of operation base versions that were added to the history.\n     *\n     * Note that there may be gaps in operations base versions.\n     *\n     * @param {Number} [fromBaseVersion] Base version from which operations should be returned (inclusive).\n     * @param {Number} [toBaseVersion] Base version up to which operations should be returned (exclusive).\n     * @returns {Array.<module:engine/model/operation/operation~Operation>} History operations for the given range, in chronological order.\n     */\n    getOperations(fromBaseVersion, toBaseVersion = this.version) {\n        // When there is no operation in the history, return an empty array.\n        // After that we can be sure that `firstOperation`, `lastOperation` are not nullish.\n        if (!this._operations.length) {\n            return [];\n        }\n        const firstOperation = this._operations[0];\n        if (fromBaseVersion === undefined) {\n            fromBaseVersion = firstOperation.baseVersion;\n        }\n        // Change exclusive `toBaseVersion` to inclusive, so it will refer to the actual index.\n        // Thanks to that mapping from base versions to operation indexes are possible.\n        let inclusiveTo = toBaseVersion - 1;\n        // Check if \"from\" or \"to\" point to a gap between versions.\n        // If yes, then change the incorrect position to the proper side of the gap.\n        // Thanks to it, it will be possible to get index of the operation.\n        for (const [gapFrom, gapTo] of this._gaps) {\n            if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {\n                fromBaseVersion = gapTo;\n            }\n            if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {\n                inclusiveTo = gapFrom - 1;\n            }\n        }\n        // If the whole range is outside of the operation versions, then return an empty array.\n        if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {\n            return [];\n        }\n        let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion);\n        // If the range starts before the first operation, then use the first operation as the range's start.\n        if (fromIndex === undefined) {\n            fromIndex = 0;\n        }\n        let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo);\n        // If the range ends after the last operation, then use the last operation as the range's end.\n        if (toIndex === undefined) {\n            toIndex = this._operations.length - 1;\n        }\n        // Return the part of the history operations based on the calculated start index and end index.\n        return this._operations.slice(fromIndex, \n        // The `toIndex` should be included in the returned operations, so add `1`.\n        toIndex + 1);\n    }\n    /**\n     * Returns operation from the history that bases on given `baseVersion`.\n     *\n     * @param {Number} baseVersion Base version of the operation to get.\n     * @returns {module:engine/model/operation/operation~Operation|undefined} Operation with given base version or `undefined` if\n     * there is no such operation in history.\n     */\n    getOperation(baseVersion) {\n        const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);\n        if (operationIndex === undefined) {\n            return;\n        }\n        return this._operations[operationIndex];\n    }\n    /**\n     * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n     * history is keeping more context information about operations, which helps in operational transformation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n     * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n     */\n    setOperationAsUndone(undoneOperation, undoingOperation) {\n        this._undoPairs.set(undoingOperation, undoneOperation);\n        this._undoneOperations.add(undoneOperation);\n    }\n    /**\n     * Checks whether given `operation` is undoing any other operation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n     * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n     */\n    isUndoingOperation(operation) {\n        return this._undoPairs.has(operation);\n    }\n    /**\n     * Checks whether given `operation` has been undone by any other operation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n     * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n     */\n    isUndoneOperation(operation) {\n        return this._undoneOperations.has(operation);\n    }\n    /**\n     * For given `undoingOperation`, returns the operation which has been undone by it.\n     *\n     * @param {module:engine/model/operation/operation~Operation} undoingOperation\n     * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n     * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n     */\n    getUndoneOperation(undoingOperation) {\n        return this._undoPairs.get(undoingOperation);\n    }\n    /**\n     * Resets the history of operations.\n     */\n    reset() {\n        this._version = 0;\n        this._undoPairs = new Map();\n        this._operations = [];\n        this._undoneOperations = new Set();\n        this._gaps = new Map();\n        this._baseVersionToOperationIndex = new Map();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}