{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/treewalker\n */\nimport Element from './element';\nimport { default as Position, getTextNodeAtPosition, getNodeAfterPosition, getNodeBeforePosition } from './position';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n  /**\n   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n   *\n   * @constructor\n   * @param {Object} [options={}] Object with configuration.\n   * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n   * @param {module:engine/model/range~Range|null} [options.boundaries=null] Range to define boundaries of the iterator.\n   * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n   * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n   * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n   * {@link module:engine/model/textproxy~TextProxy} (`false`).\n   * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n   * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n   * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n   * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n   * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n   * twice: for `'elementStart'` and `'elementEnd'`.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!options.boundaries && !options.startPosition) {\n      /**\n       * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n       *\n       * @error model-tree-walker-no-start-position\n       */\n      throw new CKEditorError('model-tree-walker-no-start-position', null);\n    }\n    const direction = options.direction || 'forward';\n    if (direction != 'forward' && direction != 'backward') {\n      /**\n       * Only `backward` and `forward` direction allowed.\n       *\n       * @error model-tree-walker-unknown-direction\n       */\n      throw new CKEditorError('model-tree-walker-unknown-direction', options, {\n        direction\n      });\n    }\n    /**\n     * Walking direction. Defaults `'forward'`.\n     *\n     * @readonly\n     * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n     */\n    this.direction = direction;\n    /**\n     * Iterator boundaries.\n     *\n     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n     * on the start of boundary, then `{ done: true }` is returned.\n     *\n     * If boundaries are not defined they are set before first and after last child of the root node.\n     *\n     * @readonly\n     * @member {module:engine/model/range~Range|null} module:engine/model/treewalker~TreeWalker#boundaries\n     */\n    this.boundaries = options.boundaries || null;\n    /**\n     * Iterator position. This is always static position, even if the initial position was a\n     * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n     * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n     * is `'backward'` position starts from the end.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n     */\n    if (options.startPosition) {\n      this.position = options.startPosition.clone();\n    } else {\n      this.position = Position._createAt(this.boundaries[this.direction == 'backward' ? 'end' : 'start']);\n    }\n    // Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.\n    this.position.stickiness = 'toNone';\n    /**\n     * Flag indicating whether all consecutive characters with the same attributes should be\n     * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n     */\n    this.singleCharacters = !!options.singleCharacters;\n    /**\n     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n     * iterated node will not be returned along with `elementEnd` tag.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n     */\n    this.shallow = !!options.shallow;\n    /**\n     * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n     * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n     * be returned once, while if the option is `false` they might be returned twice:\n     * for `'elementStart'` and `'elementEnd'`.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n     */\n    this.ignoreElementEnd = !!options.ignoreElementEnd;\n    /**\n     * Start boundary cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n     */\n    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n    /**\n     * End boundary cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n     */\n    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n    /**\n     * Parent of the most recently visited node. Cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     * module:engine/model/treewalker~TreeWalker#_visitedParent\n     */\n    this._visitedParent = this.position.parent;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n   */\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n   *\n   * For example:\n   *\n   * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n   * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n   * \t\twalker.skip( () => false ); // Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   */\n  skip(skip) {\n    let done, value, prevPosition, prevVisitedParent;\n    do {\n      prevPosition = this.position;\n      prevVisitedParent = this._visitedParent;\n      ({\n        done,\n        value\n      } = this.next());\n    } while (!done && skip(value));\n    if (!done) {\n      this.position = prevPosition;\n      this._visitedParent = prevVisitedParent;\n    }\n  }\n  /**\n   * Gets the next tree walker's value.\n   *\n   * @returns {IteratorResult} Next tree walker's value.\n   */\n  next() {\n    if (this.direction == 'forward') {\n      return this._next();\n    } else {\n      return this._previous();\n    }\n  }\n  /**\n   * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done True if iterator is done.\n   * @returns {IteratorResult} return.value Information about taken step.\n   */\n  _next() {\n    const previousPosition = this.position;\n    const position = this.position.clone();\n    const parent = this._visitedParent;\n    // We are at the end of the root.\n    if (parent.parent === null && position.offset === parent.maxOffset) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // We reached the walker boundary.\n    if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // Get node just after the current position.\n    // Use a highly optimized version instead of checking the text node first and then getting the node after. See #6582.\n    const textNodeAtPosition = getTextNodeAtPosition(position, parent);\n    const node = textNodeAtPosition ? textNodeAtPosition : getNodeAfterPosition(position, parent, textNodeAtPosition);\n    if (node instanceof Element) {\n      if (!this.shallow) {\n        // Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n        position.path.push(0);\n        this._visitedParent = node;\n      } else {\n        position.offset++;\n      }\n      this.position = position;\n      return formatReturnValue('elementStart', node, previousPosition, position, 1);\n    } else if (node instanceof Text) {\n      let charactersCount;\n      if (this.singleCharacters) {\n        charactersCount = 1;\n      } else {\n        let offset = node.endOffset;\n        if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {\n          offset = this.boundaries.end.offset;\n        }\n        charactersCount = offset - position.offset;\n      }\n      const offsetInTextNode = position.offset - node.startOffset;\n      const item = new TextProxy(node, offsetInTextNode, charactersCount);\n      position.offset += charactersCount;\n      this.position = position;\n      return formatReturnValue('text', item, previousPosition, position, charactersCount);\n    } else {\n      // `node` is not set, we reached the end of current `parent`.\n      position.path.pop();\n      position.offset++;\n      this.position = position;\n      this._visitedParent = parent.parent;\n      if (this.ignoreElementEnd) {\n        return this._next();\n      } else {\n        return formatReturnValue('elementEnd', parent, previousPosition, position);\n      }\n    }\n  }\n  /**\n   * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done True if iterator is done.\n   * @returns {IteratorResulte} return.value Information about taken step.\n   */\n  _previous() {\n    const previousPosition = this.position;\n    const position = this.position.clone();\n    const parent = this._visitedParent;\n    // We are at the beginning of the root.\n    if (parent.parent === null && position.offset === 0) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // We reached the walker boundary.\n    if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // Get node just before the current position.\n    // Use a highly optimized version instead of checking the text node first and then getting the node before. See #6582.\n    const positionParent = position.parent;\n    const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);\n    const node = textNodeAtPosition ? textNodeAtPosition : getNodeBeforePosition(position, positionParent, textNodeAtPosition);\n    if (node instanceof Element) {\n      position.offset--;\n      if (!this.shallow) {\n        position.path.push(node.maxOffset);\n        this.position = position;\n        this._visitedParent = node;\n        if (this.ignoreElementEnd) {\n          return this._previous();\n        } else {\n          return formatReturnValue('elementEnd', node, previousPosition, position);\n        }\n      } else {\n        this.position = position;\n        return formatReturnValue('elementStart', node, previousPosition, position, 1);\n      }\n    } else if (node instanceof Text) {\n      let charactersCount;\n      if (this.singleCharacters) {\n        charactersCount = 1;\n      } else {\n        let offset = node.startOffset;\n        if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {\n          offset = this.boundaries.start.offset;\n        }\n        charactersCount = position.offset - offset;\n      }\n      const offsetInTextNode = position.offset - node.startOffset;\n      const item = new TextProxy(node, offsetInTextNode - charactersCount, charactersCount);\n      position.offset -= charactersCount;\n      this.position = position;\n      return formatReturnValue('text', item, previousPosition, position, charactersCount);\n    } else {\n      // `node` is not set, we reached the beginning of current `parent`.\n      position.path.pop();\n      this.position = position;\n      this._visitedParent = parent.parent;\n      return formatReturnValue('elementStart', parent, previousPosition, position, 1);\n    }\n  }\n}\nfunction formatReturnValue(type, item, previousPosition, nextPosition, length) {\n  return {\n    done: false,\n    value: {\n      type,\n      item,\n      previousPosition,\n      nextPosition,\n      length\n    }\n  };\n}","map":{"version":3,"names":["Element","default","Position","getTextNodeAtPosition","getNodeAfterPosition","getNodeBeforePosition","Text","TextProxy","CKEditorError","TreeWalker","constructor","options","boundaries","startPosition","direction","position","clone","_createAt","stickiness","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","start","parent","_boundaryEndParent","end","_visitedParent","Symbol","iterator","skip","done","value","prevPosition","prevVisitedParent","next","_next","_previous","previousPosition","offset","maxOffset","undefined","textNodeAtPosition","node","path","push","formatReturnValue","charactersCount","endOffset","offsetInTextNode","startOffset","item","pop","positionParent","type","nextPosition","length"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/treewalker\n */\nimport Element from './element';\nimport { default as Position, getTextNodeAtPosition, getNodeAfterPosition, getNodeBeforePosition } from './position';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n    /**\n     * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n     *\n     * @constructor\n     * @param {Object} [options={}] Object with configuration.\n     * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n     * @param {module:engine/model/range~Range|null} [options.boundaries=null] Range to define boundaries of the iterator.\n     * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n     * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n     * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n     * {@link module:engine/model/textproxy~TextProxy} (`false`).\n     * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n     * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n     * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n     * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n     * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n     * twice: for `'elementStart'` and `'elementEnd'`.\n     */\n    constructor(options = {}) {\n        if (!options.boundaries && !options.startPosition) {\n            /**\n             * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n             *\n             * @error model-tree-walker-no-start-position\n             */\n            throw new CKEditorError('model-tree-walker-no-start-position', null);\n        }\n        const direction = options.direction || 'forward';\n        if (direction != 'forward' && direction != 'backward') {\n            /**\n             * Only `backward` and `forward` direction allowed.\n             *\n             * @error model-tree-walker-unknown-direction\n             */\n            throw new CKEditorError('model-tree-walker-unknown-direction', options, { direction });\n        }\n        /**\n         * Walking direction. Defaults `'forward'`.\n         *\n         * @readonly\n         * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n         */\n        this.direction = direction;\n        /**\n         * Iterator boundaries.\n         *\n         * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n         * on the start of boundary, then `{ done: true }` is returned.\n         *\n         * If boundaries are not defined they are set before first and after last child of the root node.\n         *\n         * @readonly\n         * @member {module:engine/model/range~Range|null} module:engine/model/treewalker~TreeWalker#boundaries\n         */\n        this.boundaries = options.boundaries || null;\n        /**\n         * Iterator position. This is always static position, even if the initial position was a\n         * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n         * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n         * is `'backward'` position starts from the end.\n         *\n         * @readonly\n         * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n         */\n        if (options.startPosition) {\n            this.position = options.startPosition.clone();\n        }\n        else {\n            this.position = Position._createAt(this.boundaries[this.direction == 'backward' ? 'end' : 'start']);\n        }\n        // Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.\n        this.position.stickiness = 'toNone';\n        /**\n         * Flag indicating whether all consecutive characters with the same attributes should be\n         * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n         *\n         * @readonly\n         * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n         */\n        this.singleCharacters = !!options.singleCharacters;\n        /**\n         * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n         * iterated node will not be returned along with `elementEnd` tag.\n         *\n         * @readonly\n         * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n         */\n        this.shallow = !!options.shallow;\n        /**\n         * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n         * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n         * be returned once, while if the option is `false` they might be returned twice:\n         * for `'elementStart'` and `'elementEnd'`.\n         *\n         * @readonly\n         * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n         */\n        this.ignoreElementEnd = !!options.ignoreElementEnd;\n        /**\n         * Start boundary cached for optimization purposes.\n         *\n         * @private\n         * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n         */\n        this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n        /**\n         * End boundary cached for optimization purposes.\n         *\n         * @private\n         * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n         */\n        this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n        /**\n         * Parent of the most recently visited node. Cached for optimization purposes.\n         *\n         * @private\n         * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n         * module:engine/model/treewalker~TreeWalker#_visitedParent\n         */\n        this._visitedParent = this.position.parent;\n    }\n    /**\n     * Iterable interface.\n     *\n     * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n     */\n    [Symbol.iterator]() {\n        return this;\n    }\n    /**\n     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n     *\n     * For example:\n     *\n     * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n     * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n     * \t\twalker.skip( () => false ); // Do not move the position.\n     *\n     * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n     * return `true` if the value should be skipped or `false` if not.\n     */\n    skip(skip) {\n        let done, value, prevPosition, prevVisitedParent;\n        do {\n            prevPosition = this.position;\n            prevVisitedParent = this._visitedParent;\n            ({ done, value } = this.next());\n        } while (!done && skip(value));\n        if (!done) {\n            this.position = prevPosition;\n            this._visitedParent = prevVisitedParent;\n        }\n    }\n    /**\n     * Gets the next tree walker's value.\n     *\n     * @returns {IteratorResult} Next tree walker's value.\n     */\n    next() {\n        if (this.direction == 'forward') {\n            return this._next();\n        }\n        else {\n            return this._previous();\n        }\n    }\n    /**\n     * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done True if iterator is done.\n     * @returns {IteratorResult} return.value Information about taken step.\n     */\n    _next() {\n        const previousPosition = this.position;\n        const position = this.position.clone();\n        const parent = this._visitedParent;\n        // We are at the end of the root.\n        if (parent.parent === null && position.offset === parent.maxOffset) {\n            return { done: true, value: undefined };\n        }\n        // We reached the walker boundary.\n        if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n            return { done: true, value: undefined };\n        }\n        // Get node just after the current position.\n        // Use a highly optimized version instead of checking the text node first and then getting the node after. See #6582.\n        const textNodeAtPosition = getTextNodeAtPosition(position, parent);\n        const node = textNodeAtPosition ? textNodeAtPosition : getNodeAfterPosition(position, parent, textNodeAtPosition);\n        if (node instanceof Element) {\n            if (!this.shallow) {\n                // Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n                position.path.push(0);\n                this._visitedParent = node;\n            }\n            else {\n                position.offset++;\n            }\n            this.position = position;\n            return formatReturnValue('elementStart', node, previousPosition, position, 1);\n        }\n        else if (node instanceof Text) {\n            let charactersCount;\n            if (this.singleCharacters) {\n                charactersCount = 1;\n            }\n            else {\n                let offset = node.endOffset;\n                if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {\n                    offset = this.boundaries.end.offset;\n                }\n                charactersCount = offset - position.offset;\n            }\n            const offsetInTextNode = position.offset - node.startOffset;\n            const item = new TextProxy(node, offsetInTextNode, charactersCount);\n            position.offset += charactersCount;\n            this.position = position;\n            return formatReturnValue('text', item, previousPosition, position, charactersCount);\n        }\n        else {\n            // `node` is not set, we reached the end of current `parent`.\n            position.path.pop();\n            position.offset++;\n            this.position = position;\n            this._visitedParent = parent.parent;\n            if (this.ignoreElementEnd) {\n                return this._next();\n            }\n            else {\n                return formatReturnValue('elementEnd', parent, previousPosition, position);\n            }\n        }\n    }\n    /**\n     * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done True if iterator is done.\n     * @returns {IteratorResulte} return.value Information about taken step.\n     */\n    _previous() {\n        const previousPosition = this.position;\n        const position = this.position.clone();\n        const parent = this._visitedParent;\n        // We are at the beginning of the root.\n        if (parent.parent === null && position.offset === 0) {\n            return { done: true, value: undefined };\n        }\n        // We reached the walker boundary.\n        if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n            return { done: true, value: undefined };\n        }\n        // Get node just before the current position.\n        // Use a highly optimized version instead of checking the text node first and then getting the node before. See #6582.\n        const positionParent = position.parent;\n        const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);\n        const node = textNodeAtPosition ? textNodeAtPosition : getNodeBeforePosition(position, positionParent, textNodeAtPosition);\n        if (node instanceof Element) {\n            position.offset--;\n            if (!this.shallow) {\n                position.path.push(node.maxOffset);\n                this.position = position;\n                this._visitedParent = node;\n                if (this.ignoreElementEnd) {\n                    return this._previous();\n                }\n                else {\n                    return formatReturnValue('elementEnd', node, previousPosition, position);\n                }\n            }\n            else {\n                this.position = position;\n                return formatReturnValue('elementStart', node, previousPosition, position, 1);\n            }\n        }\n        else if (node instanceof Text) {\n            let charactersCount;\n            if (this.singleCharacters) {\n                charactersCount = 1;\n            }\n            else {\n                let offset = node.startOffset;\n                if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {\n                    offset = this.boundaries.start.offset;\n                }\n                charactersCount = position.offset - offset;\n            }\n            const offsetInTextNode = position.offset - node.startOffset;\n            const item = new TextProxy(node, offsetInTextNode - charactersCount, charactersCount);\n            position.offset -= charactersCount;\n            this.position = position;\n            return formatReturnValue('text', item, previousPosition, position, charactersCount);\n        }\n        else {\n            // `node` is not set, we reached the beginning of current `parent`.\n            position.path.pop();\n            this.position = position;\n            this._visitedParent = parent.parent;\n            return formatReturnValue('elementStart', parent, previousPosition, position, 1);\n        }\n    }\n}\nfunction formatReturnValue(type, item, previousPosition, nextPosition, length) {\n    return {\n        done: false,\n        value: {\n            type,\n            item,\n            previousPosition,\n            nextPosition,\n            length\n        }\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}