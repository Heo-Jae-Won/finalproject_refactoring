{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/renderer\n */\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller } from './filler';\nimport { default as diff } from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport '../../theme/renderer.css';\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\nexport default class Renderer extends Observable {\n  /**\n   * Creates a renderer instance.\n   *\n   * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n   * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n   */\n  constructor(domConverter, selection) {\n    super();\n    /**\n     * Set of DOM Documents instances.\n     *\n     * @readonly\n     * @member {Set.<Document>}\n     */\n    this.domDocuments = new Set();\n    /**\n     * Converter instance.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n    this.domConverter = domConverter;\n    /**\n     * Set of nodes which attributes changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~ViewNode>}\n     */\n    this.markedAttributes = new Set();\n    /**\n     * Set of elements which child lists changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~ViewNode>}\n     */\n    this.markedChildren = new Set();\n    /**\n     * Set of text nodes which text data changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~ViewNode>}\n     */\n    this.markedTexts = new Set();\n    /**\n     * View selection. Renderer updates DOM selection based on the view selection.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     */\n    this.selection = selection;\n    /**\n     * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n     * this is set to `false`.\n     *\n     * @member {Boolean}\n     * @observable\n     */\n    this.set('isFocused', false);\n    /**\n     * Indicates whether the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n     * When they stop selecting, the property goes back to `false`.\n     *\n     * Note: In some browsers, the renderer will stop rendering the selection and inline fillers while the user is making\n     * a selection to avoid glitches in DOM selection\n     * (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n     *\n     * @member {Boolean}\n     * @observable\n     */\n    this.set('isSelecting', false);\n    // Rendering the selection and inline filler manipulation should be postponed in (non-Android) Blink until the user finishes\n    // creating the selection in DOM to avoid accidental selection collapsing\n    // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n    // When the user stops selecting, all pending changes should be rendered ASAP, though.\n    if (env.isBlink && !env.isAndroid) {\n      this.on('change:isSelecting', () => {\n        if (!this.isSelecting) {\n          this.render();\n        }\n      });\n    }\n    /**\n     * The text node in which the inline filler was rendered.\n     *\n     * @private\n     * @member {Text}\n     */\n    this._inlineFiller = null;\n    /**\n     * DOM element containing fake selection.\n     *\n     * @private\n     * @type {null|HTMLElement}\n     */\n    this._fakeSelectionContainer = null;\n  }\n  /**\n   * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n   *\n   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n   *\n   * @see #markedAttributes\n   * @see #markedChildren\n   * @see #markedTexts\n   *\n   * @param {module:engine/view/document~ChangeType} type Type of the change.\n   * @param {module:engine/view/node~ViewNode} node ViewNode to be marked.\n   */\n  markToSync(type, node) {\n    if (type === 'text') {\n      if (this.domConverter.mapViewToDom(node.parent)) {\n        this.markedTexts.add(node);\n      }\n    } else {\n      // If the node has no DOM element it is not rendered yet,\n      // its children/attributes do not need to be marked to be sync.\n      if (!this.domConverter.mapViewToDom(node)) {\n        return;\n      }\n      if (type === 'attributes') {\n        this.markedAttributes.add(node);\n      } else if (type === 'children') {\n        this.markedChildren.add(node);\n      } else {\n        /**\n         * Unknown type passed to Renderer.markToSync.\n         *\n         * @error view-renderer-unknown-type\n         */\n        throw new CKEditorError('view-renderer-unknown-type', this);\n      }\n    }\n  }\n  /**\n   * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n   * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n   *\n   * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n   * so it does as little as it is needed to update the DOM.\n   *\n   * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n   * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n   * removed as long as the selection is in the text node which needed it at first.\n   */\n  render() {\n    let inlineFillerPosition = null;\n    const isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true;\n    // Refresh mappings.\n    for (const element of this.markedChildren) {\n      this._updateChildrenMappings(element);\n    }\n    // Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n    // DOM selection collapsing\n    // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n    if (isInlineFillerRenderingPossible) {\n      // There was inline filler rendered in the DOM but it's not\n      // at the selection position any more, so we can remove it\n      // (cause even if it's needed, it must be placed in another location).\n      if (this._inlineFiller && !this._isSelectionInInlineFiller()) {\n        this._removeInlineFiller();\n      }\n      // If we've got the filler, let's try to guess its position in the view.\n      if (this._inlineFiller) {\n        inlineFillerPosition = this._getInlineFillerPosition();\n      }\n      // Otherwise, if it's needed, create it at the selection position.\n      else if (this._needsInlineFillerAtSelection()) {\n        inlineFillerPosition = this.selection.getFirstPosition();\n        // Do not use `markToSync` so it will be added even if the parent is already added.\n        this.markedChildren.add(inlineFillerPosition.parent);\n      }\n    }\n    // Make sure the inline filler has any parent, so it can be mapped to view position by DomConverter.\n    else if (this._inlineFiller && this._inlineFiller.parentNode) {\n      // While the user is making selection, preserve the inline filler at its original position.\n      inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);\n      // While down-casting the document selection attributes, all existing empty\n      // attribute elements (for selection position) are removed from the view and DOM,\n      // so make sure that we were able to map filler position.\n      // https://github.com/ckeditor/ckeditor5/issues/12026\n      if (inlineFillerPosition && inlineFillerPosition.parent.is('$text')) {\n        // The inline filler position is expected to be before the text node.\n        inlineFillerPosition = ViewPosition._createBefore(inlineFillerPosition.parent);\n      }\n    }\n    for (const element of this.markedAttributes) {\n      this._updateAttrs(element);\n    }\n    for (const element of this.markedChildren) {\n      this._updateChildren(element, {\n        inlineFillerPosition\n      });\n    }\n    for (const node of this.markedTexts) {\n      if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {\n        this._updateText(node, {\n          inlineFillerPosition\n        });\n      }\n    }\n    // * Check whether the inline filler is required and where it really is in the DOM.\n    //   At this point in most cases it will be in the DOM, but there are exceptions.\n    //   For example, if the inline filler was deep in the created DOM structure, it will not be created.\n    //   Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n    //   it will not be present. Fix those and similar scenarios.\n    // * Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n    //   DOM selection collapsing\n    //   (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n    if (isInlineFillerRenderingPossible) {\n      if (inlineFillerPosition) {\n        const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);\n        const domDocument = fillerDomPosition.parent.ownerDocument;\n        if (!startsWithFiller(fillerDomPosition.parent)) {\n          // Filler has not been created at filler position. Create it now.\n          this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);\n        } else {\n          // Filler has been found, save it.\n          this._inlineFiller = fillerDomPosition.parent;\n        }\n      } else {\n        // There is no filler needed.\n        this._inlineFiller = null;\n      }\n    }\n    // First focus the new editing host, then update the selection.\n    // Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n    this._updateFocus();\n    this._updateSelection();\n    this.markedTexts.clear();\n    this.markedAttributes.clear();\n    this.markedChildren.clear();\n  }\n  /**\n   * Updates mappings of view element's children.\n   *\n   * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n   * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n   * Thanks to that these elements do not need to be re-rendered completely.\n   *\n   * @private\n   * @param {module:engine/view/node~ViewNode} viewElement The view element whose children mappings will be updated.\n   */\n  _updateChildrenMappings(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n      return;\n    }\n    // Removing nodes from the DOM as we iterate can cause `actualDomChildren`\n    // (which is a live-updating `NodeList`) to get out of sync with the\n    // indices that we compute as we iterate over `actions`.\n    // This would produce incorrect element mappings.\n    //\n    // Converting live list to an array to make the list static.\n    const actualDomChildren = Array.from(this.domConverter.mapViewToDom(viewElement).childNodes);\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {\n      withChildren: false\n    }));\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n    const actions = this._findReplaceActions(diff, actualDomChildren, expectedDomChildren);\n    if (actions.indexOf('replace') !== -1) {\n      const counter = {\n        equal: 0,\n        insert: 0,\n        delete: 0\n      };\n      for (const action of actions) {\n        if (action === 'replace') {\n          const insertIndex = counter.equal + counter.insert;\n          const deleteIndex = counter.equal + counter.delete;\n          const viewChild = viewElement.getChild(insertIndex);\n          // UIElement and RawElement are special cases. Their children are not stored in a view (#799)\n          // so we cannot use them with replacing flow (since they use view children during rendering\n          // which will always result in rendering empty elements).\n          if (viewChild && !(viewChild.is('uiElement') || viewChild.is('rawElement'))) {\n            this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);\n          }\n          remove(expectedDomChildren[insertIndex]);\n          counter.equal++;\n        } else {\n          counter[action]++;\n        }\n      }\n    }\n  }\n  /**\n   * Updates mappings of a given view element.\n   *\n   * @private\n   * @param {module:engine/view/node~ViewNode} viewElement The view element whose mappings will be updated.\n   * @param {ViewNode} domElement The DOM element representing the given view element.\n   */\n  _updateElementMappings(viewElement, domElement) {\n    // Remap 'DomConverter' bindings.\n    this.domConverter.unbindDomElement(domElement);\n    this.domConverter.bindElements(domElement, viewElement);\n    // View element may have children which needs to be updated, but are not marked, mark them to update.\n    this.markedChildren.add(viewElement);\n    // Because we replace new view element mapping with the existing one, the corresponding DOM element\n    // will not be rerendered. The new view element may have different attributes than the previous one.\n    // Since its corresponding DOM element will not be rerendered, new attributes will not be added\n    // to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n    // detailed case study.\n    // Also there are cases where replaced element is removed from the view structure and then has\n    // its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n    // and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n    // To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n    this.markedAttributes.add(viewElement);\n  }\n  /**\n   * Gets the position of the inline filler based on the current selection.\n   * Here, we assume that we know that the filler is needed and\n   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n   * it is somewhere at the selection position.\n   *\n   * Note: The filler position cannot be restored based on the filler's DOM text node, because\n   * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n   * bindings are only dependable after rendering.\n   *\n   * @private\n   * @returns {module:engine/view/position~Position}\n   */\n  _getInlineFillerPosition() {\n    const firstPos = this.selection.getFirstPosition();\n    if (firstPos.parent.is('$text')) {\n      return ViewPosition._createBefore(firstPos.parent);\n    } else {\n      return firstPos;\n    }\n  }\n  /**\n   * Returns `true` if the selection has not left the inline filler's text node.\n   * If it is `true`, it means that the filler had been added for a reason and the selection did not\n   * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n   */\n  _isSelectionInInlineFiller() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    }\n    // Note, we can't check if selection's position equals position of the\n    // this._inlineFiller node, because of #663. We may not be able to calculate\n    // the filler's position in the view at this stage.\n    // Instead, we check it the other way – whether selection is anchored in\n    // that text node or next to it.\n    // Possible options are:\n    // \"FILLER{}\"\n    // \"FILLERadded-text{}\"\n    const selectionPosition = this.selection.getFirstPosition();\n    const position = this.domConverter.viewPositionToDom(selectionPosition);\n    if (position && isText(position.parent) && startsWithFiller(position.parent)) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Removes the inline filler.\n   *\n   * @private\n   */\n  _removeInlineFiller() {\n    const domFillerNode = this._inlineFiller;\n    // Something weird happened and the stored node doesn't contain the filler's text.\n    if (!startsWithFiller(domFillerNode)) {\n      /**\n       * The inline filler node was lost. Most likely, something overwrote the filler text node\n       * in the DOM.\n       *\n       * @error view-renderer-filler-was-lost\n       */\n      throw new CKEditorError('view-renderer-filler-was-lost', this);\n    }\n    if (isInlineFiller(domFillerNode)) {\n      domFillerNode.remove();\n    } else {\n      domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);\n    }\n    this._inlineFiller = null;\n  }\n  /**\n   * Checks if the inline {@link module:engine/view/filler filler} should be added.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler should be added.\n   */\n  _needsInlineFillerAtSelection() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    }\n    const selectionPosition = this.selection.getFirstPosition();\n    const selectionParent = selectionPosition.parent;\n    const selectionOffset = selectionPosition.offset;\n    // If there is no DOM root we do not care about fillers.\n    if (!this.domConverter.mapViewToDom(selectionParent.root)) {\n      return false;\n    }\n    if (!selectionParent.is('element')) {\n      return false;\n    }\n    // Prevent adding inline filler inside elements with contenteditable=false.\n    // https://github.com/ckeditor/ckeditor5-engine/issues/1170\n    if (!isEditable(selectionParent)) {\n      return false;\n    }\n    // We have block filler, we do not need inline one.\n    if (selectionOffset === selectionParent.getFillerOffset()) {\n      return false;\n    }\n    const nodeBefore = selectionPosition.nodeBefore;\n    const nodeAfter = selectionPosition.nodeAfter;\n    if (nodeBefore instanceof ViewText || nodeAfter instanceof ViewText) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Checks if text needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} viewText View text to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n  _updateText(viewText, options) {\n    const domText = this.domConverter.findCorrespondingDomText(viewText);\n    const newDomText = this.domConverter.viewToDom(viewText);\n    const actualText = domText.data;\n    let expectedText = newDomText.data;\n    const filler = options.inlineFillerPosition;\n    if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {\n      expectedText = INLINE_FILLER + expectedText;\n    }\n    if (actualText != expectedText) {\n      const actions = fastDiff(actualText, expectedText);\n      for (const action of actions) {\n        if (action.type === 'insert') {\n          domText.insertData(action.index, action.values.join(''));\n        } else {\n          // 'delete'\n          domText.deleteData(action.index, action.howMany);\n        }\n      }\n    }\n  }\n  /**\n   * Checks if attribute list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement The view element to update.\n   */\n  _updateAttrs(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n    if (!domElement) {\n      // If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n      // in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n      // replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n      // in 'this._updateChildrenMappings()' so it will be processed separately.\n      return;\n    }\n    const domAttrKeys = Array.from(domElement.attributes).map(attr => attr.name);\n    const viewAttrKeys = viewElement.getAttributeKeys();\n    // Add or overwrite attributes.\n    for (const key of viewAttrKeys) {\n      this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);\n    }\n    // Remove from DOM attributes which do not exists in the view.\n    for (const key of domAttrKeys) {\n      // All other attributes not present in the DOM should be removed.\n      if (!viewElement.hasAttribute(key)) {\n        this.domConverter.removeDomElementAttribute(domElement, key);\n      }\n    }\n  }\n  /**\n   * Checks if elements child list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement View element to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n  _updateChildren(viewElement, options) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM.\n      // There is no need to process it. It will be processed when re-inserted.\n      return;\n    }\n    const inlineFillerPosition = options.inlineFillerPosition;\n    const actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {\n      bind: true\n    }));\n    // Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n    // during diffing so text nodes could be compared correctly and also during rendering to maintain\n    // proper order and indexes while updating the DOM.\n    if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {\n      addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);\n    }\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n    let i = 0;\n    const nodesToUnbind = new Set();\n    // Handle deletions first.\n    // This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different\n    // index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,\n    // and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.\n    //\n    // It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.\n    for (const action of diff) {\n      if (action === 'delete') {\n        nodesToUnbind.add(actualDomChildren[i]);\n        remove(actualDomChildren[i]);\n      } else if (action === 'equal') {\n        i++;\n      }\n    }\n    i = 0;\n    for (const action of diff) {\n      if (action === 'insert') {\n        insertAt(domElement, i, expectedDomChildren[i]);\n        i++;\n      } else if (action === 'equal') {\n        // Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n        // Do it here (not in the loop above) because only after insertions the `i` index is correct.\n        this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));\n        i++;\n      }\n    }\n    // Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n    // comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n    // it was moved to DOM tree out of the removed node.\n    for (const node of nodesToUnbind) {\n      if (!node.parentNode) {\n        this.domConverter.unbindDomElement(node);\n      }\n    }\n  }\n  /**\n   * Shorthand for diffing two arrays or node lists of DOM nodes.\n   *\n   * @private\n   * @param {Array.<ViewNode>|NodeList} actualDomChildren Actual DOM children\n   * @param {Array.<ViewNode>|NodeList} expectedDomChildren Expected DOM children.\n   * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n   */\n  _diffNodeLists(actualDomChildren, expectedDomChildren) {\n    actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);\n    return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter));\n  }\n  /**\n   * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n   * within one `insert`/`delete` action group, for example:\n   *\n   * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n   * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n   * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n   * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n   *\n   * @private\n   * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n   * @param {Array.<ViewNode>|NodeList} actualDom Actual DOM children\n   * @param {Array.<ViewNode>} expectedDom Expected DOM children.\n   * @returns {Array.<String>} Actions array modified with the `replace` actions.\n   */\n  _findReplaceActions(actions, actualDom, expectedDom) {\n    // If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n    if (actions.indexOf('insert') === -1 || actions.indexOf('delete') === -1) {\n      return actions;\n    }\n    let newActions = [];\n    let actualSlice = [];\n    let expectedSlice = [];\n    const counter = {\n      equal: 0,\n      insert: 0,\n      delete: 0\n    };\n    for (const action of actions) {\n      if (action === 'insert') {\n        expectedSlice.push(expectedDom[counter.equal + counter.insert]);\n      } else if (action === 'delete') {\n        actualSlice.push(actualDom[counter.equal + counter.delete]);\n      } else {\n        // equal\n        newActions = newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n        newActions.push('equal');\n        // Reset stored elements on 'equal'.\n        actualSlice = [];\n        expectedSlice = [];\n      }\n      counter[action]++;\n    }\n    return newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n  }\n  /**\n   * Marks text nodes to be synchronized.\n   *\n   * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n   *\n   * @private\n   * @param {module:engine/view/node~ViewNode} viewNode View node to sync.\n   */\n  _markDescendantTextToSync(viewNode) {\n    if (!viewNode) {\n      return;\n    }\n    if (viewNode.is('$text')) {\n      this.markedTexts.add(viewNode);\n    } else if (viewNode.is('element')) {\n      for (const child of viewNode.getChildren()) {\n        this._markDescendantTextToSync(child);\n      }\n    }\n  }\n  /**\n   * Checks if the selection needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n  _updateSelection() {\n    // Block updating DOM selection in (non-Android) Blink while the user is selecting to prevent accidental selection collapsing.\n    // Note: Structural changes in DOM must trigger selection rendering, though. Nodes the selection was anchored\n    // to, may disappear in DOM which would break the selection (e.g. in real-time collaboration scenarios).\n    // https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723\n    if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {\n      return;\n    }\n    // If there is no selection - remove DOM and fake selections.\n    if (this.selection.rangeCount === 0) {\n      this._removeDomSelection();\n      this._removeFakeSelection();\n      return;\n    }\n    const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement);\n    // Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n    if (!this.isFocused || !domRoot) {\n      return;\n    }\n    // Render selection.\n    if (this.selection.isFake) {\n      this._updateFakeSelection(domRoot);\n    } else {\n      this._removeFakeSelection();\n      this._updateDomSelection(domRoot);\n    }\n  }\n  /**\n   * Updates the fake selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n   */\n  _updateFakeSelection(domRoot) {\n    const domDocument = domRoot.ownerDocument;\n    if (!this._fakeSelectionContainer) {\n      this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);\n    }\n    const container = this._fakeSelectionContainer;\n    // Bind fake selection container with the current selection *position*.\n    this.domConverter.bindFakeSelection(container, this.selection);\n    if (!this._fakeSelectionNeedsUpdate(domRoot)) {\n      return;\n    }\n    if (!container.parentElement || container.parentElement != domRoot) {\n      domRoot.appendChild(container);\n    }\n    container.textContent = this.selection.fakeSelectionLabel || '\\u00A0';\n    const domSelection = domDocument.getSelection();\n    const domRange = domDocument.createRange();\n    domSelection.removeAllRanges();\n    domRange.selectNodeContents(container);\n    domSelection.addRange(domRange);\n  }\n  /**\n   * Updates the DOM selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n   */\n  _updateDomSelection(domRoot) {\n    const domSelection = domRoot.ownerDocument.defaultView.getSelection();\n    // Let's check whether DOM selection needs updating at all.\n    if (!this._domSelectionNeedsUpdate(domSelection)) {\n      return;\n    }\n    // Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n    // set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n    // and focus of view selection.\n    // Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n    // selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n    const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);\n    const focus = this.domConverter.viewPositionToDom(this.selection.focus);\n    domSelection.collapse(anchor.parent, anchor.offset);\n    domSelection.extend(focus.parent, focus.offset);\n    // Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n    if (env.isGecko) {\n      fixGeckoSelectionAfterBr(focus, domSelection);\n    }\n  }\n  /**\n   * Checks whether a given DOM selection needs to be updated.\n   *\n   * @private\n   * @param {Selection} domSelection The DOM selection to check.\n   * @returns {Boolean}\n   */\n  _domSelectionNeedsUpdate(domSelection) {\n    if (!this.domConverter.isDomSelectionCorrect(domSelection)) {\n      // Current DOM selection is in incorrect position. We need to update it.\n      return true;\n    }\n    const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);\n    if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {\n      return false;\n    }\n    // If selection is not collapsed, it does not need to be updated if it is similar.\n    if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {\n      // Selection did not changed and is correct, do not update.\n      return false;\n    }\n    // Selections are not similar.\n    return true;\n  }\n  /**\n   * Checks whether the fake selection needs to be updated.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.\n   * @returns {Boolean}\n   */\n  _fakeSelectionNeedsUpdate(domRoot) {\n    const container = this._fakeSelectionContainer;\n    const domSelection = domRoot.ownerDocument.getSelection();\n    // Fake selection needs to be updated if there's no fake selection container, or the container currently sits\n    // in a different root.\n    if (!container || container.parentElement !== domRoot) {\n      return true;\n    }\n    // Make sure that the selection actually is within the fake selection.\n    if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {\n      return true;\n    }\n    return container.textContent !== this.selection.fakeSelectionLabel;\n  }\n  /**\n   * Removes the DOM selection.\n   *\n   * @private\n   */\n  _removeDomSelection() {\n    for (const doc of this.domDocuments) {\n      const domSelection = doc.getSelection();\n      if (domSelection.rangeCount) {\n        const activeDomElement = doc.activeElement;\n        const viewElement = this.domConverter.mapDomToView(activeDomElement);\n        if (activeDomElement && viewElement) {\n          domSelection.removeAllRanges();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the fake selection.\n   *\n   * @private\n   */\n  _removeFakeSelection() {\n    const container = this._fakeSelectionContainer;\n    if (container) {\n      container.remove();\n    }\n  }\n  /**\n   * Checks if focus needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n  _updateFocus() {\n    if (this.isFocused) {\n      const editable = this.selection.editableElement;\n      if (editable) {\n        this.domConverter.focus(editable);\n      }\n    }\n  }\n}\n// Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\nfunction isEditable(element) {\n  if (element.getAttribute('contenteditable') == 'false') {\n    return false;\n  }\n  const parent = element.findAncestor(element => element.hasAttribute('contenteditable'));\n  return !parent || parent.getAttribute('contenteditable') == 'true';\n}\n// Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<ViewNode>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\nfunction addInlineFiller(domDocument, domParentOrArray, offset) {\n  const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n  const nodeAfterFiller = childNodes[offset];\n  if (isText(nodeAfterFiller)) {\n    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n    return nodeAfterFiller;\n  } else {\n    const fillerNode = domDocument.createTextNode(INLINE_FILLER);\n    if (Array.isArray(domParentOrArray)) {\n      childNodes.splice(offset, 0, fillerNode);\n    } else {\n      insertAt(domParentOrArray, offset, fillerNode);\n    }\n    return fillerNode;\n  }\n}\n// Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {ViewNode} node1\n// @param {ViewNode} node2\n// @returns {Boolean}\nfunction areSimilar(node1, node2) {\n  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n}\n// Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.\n// @param {ViewNode} node1\n// @param {ViewNode} node2\n// @returns {Boolean}\nfunction sameNodes(domConverter, actualDomChild, expectedDomChild) {\n  // Elements.\n  if (actualDomChild === expectedDomChild) {\n    return true;\n  }\n  // Texts.\n  else if (isText(actualDomChild) && isText(expectedDomChild)) {\n    return actualDomChild.data === expectedDomChild.data;\n  }\n  // Block fillers.\n  else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {\n    return true;\n  }\n  // Not matching types.\n  return false;\n}\n// The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\nfunction fixGeckoSelectionAfterBr(focus, domSelection) {\n  const parent = focus.parent;\n  // This fix works only when the focus point is at the very end of an element.\n  // There is no point in running it in cases unrelated to the browser bug.\n  if (parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1) {\n    return;\n  }\n  const childAtOffset = parent.childNodes[focus.offset];\n  // To stay on the safe side, the fix being as specific as possible, it targets only the\n  // selection which is at the very end of the element and preceded by <br />.\n  if (childAtOffset && childAtOffset.tagName == 'BR') {\n    domSelection.addRange(domSelection.getRangeAt(0));\n  }\n}\nfunction filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {\n  const childList = Array.from(domChildList);\n  if (childList.length == 0 || !fakeSelectionContainer) {\n    return childList;\n  }\n  const last = childList[childList.length - 1];\n  if (last == fakeSelectionContainer) {\n    childList.pop();\n  }\n  return childList;\n}\n// Creates a fake selection container for a given document.\n//\n// @private\n// @param {Document} domDocument\n// @returns {HTMLElement}\nfunction createFakeSelectionContainer(domDocument) {\n  const container = domDocument.createElement('div');\n  container.className = 'ck-fake-selection-container';\n  Object.assign(container.style, {\n    position: 'fixed',\n    top: 0,\n    left: '-9999px',\n    // See https://github.com/ckeditor/ckeditor5/issues/752.\n    width: '42px'\n  });\n  // Fill it with a text node so we can update it later.\n  container.textContent = '\\u00A0';\n  return container;\n}","map":{"version":3,"names":["ViewText","ViewPosition","INLINE_FILLER","INLINE_FILLER_LENGTH","startsWithFiller","isInlineFiller","default","diff","insertAt","remove","Observable","CKEditorError","isText","isComment","isNode","fastDiff","env","Renderer","constructor","domConverter","selection","domDocuments","Set","markedAttributes","markedChildren","markedTexts","set","isBlink","isAndroid","on","isSelecting","render","_inlineFiller","_fakeSelectionContainer","markToSync","type","node","mapViewToDom","parent","add","inlineFillerPosition","isInlineFillerRenderingPossible","element","_updateChildrenMappings","_isSelectionInInlineFiller","_removeInlineFiller","_getInlineFillerPosition","_needsInlineFillerAtSelection","getFirstPosition","parentNode","domPositionToView","is","_createBefore","_updateAttrs","_updateChildren","has","_updateText","fillerDomPosition","viewPositionToDom","domDocument","ownerDocument","addInlineFiller","offset","_updateFocus","_updateSelection","clear","viewElement","domElement","actualDomChildren","Array","from","childNodes","expectedDomChildren","viewChildrenToDom","withChildren","_diffNodeLists","actions","_findReplaceActions","indexOf","counter","equal","insert","delete","action","insertIndex","deleteIndex","viewChild","getChild","_updateElementMappings","unbindDomElement","bindElements","firstPos","rangeCount","isCollapsed","selectionPosition","position","domFillerNode","data","substr","selectionParent","selectionOffset","root","isEditable","getFillerOffset","nodeBefore","nodeAfter","viewText","options","domText","findCorrespondingDomText","newDomText","viewToDom","actualText","expectedText","filler","index","insertData","values","join","deleteData","howMany","domAttrKeys","attributes","map","attr","name","viewAttrKeys","getAttributeKeys","key","setDomElementAttribute","getAttribute","hasAttribute","removeDomElementAttribute","bind","i","nodesToUnbind","_markDescendantTextToSync","domToView","filterOutFakeSelectionContainer","sameNodes","actualDom","expectedDom","newActions","actualSlice","expectedSlice","push","concat","areSimilar","x","viewNode","child","getChildren","size","_removeDomSelection","_removeFakeSelection","domRoot","editableElement","isFocused","isFake","_updateFakeSelection","_updateDomSelection","createFakeSelectionContainer","container","bindFakeSelection","_fakeSelectionNeedsUpdate","parentElement","appendChild","textContent","fakeSelectionLabel","domSelection","getSelection","domRange","createRange","removeAllRanges","selectNodeContents","addRange","defaultView","_domSelectionNeedsUpdate","anchor","focus","collapse","extend","isGecko","fixGeckoSelectionAfterBr","isDomSelectionCorrect","oldViewSelection","domSelectionToView","isEqual","isSimilar","anchorNode","contains","doc","activeDomElement","activeElement","mapDomToView","editable","findAncestor","domParentOrArray","nodeAfterFiller","fillerNode","createTextNode","isArray","splice","node1","node2","tagName","toLowerCase","actualDomChild","expectedDomChild","isBlockFiller","nodeType","Node","ELEMENT_NODE","length","childAtOffset","getRangeAt","domChildList","fakeSelectionContainer","childList","last","pop","createElement","className","Object","assign","style","top","left","width"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/renderer.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/renderer\n */\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller } from './filler';\nimport { default as diff } from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport '../../theme/renderer.css';\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\nexport default class Renderer extends Observable {\n    /**\n     * Creates a renderer instance.\n     *\n     * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n     * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n     */\n    constructor(domConverter, selection) {\n        super();\n        /**\n         * Set of DOM Documents instances.\n         *\n         * @readonly\n         * @member {Set.<Document>}\n         */\n        this.domDocuments = new Set();\n        /**\n         * Converter instance.\n         *\n         * @readonly\n         * @member {module:engine/view/domconverter~DomConverter}\n         */\n        this.domConverter = domConverter;\n        /**\n         * Set of nodes which attributes changed and may need to be rendered.\n         *\n         * @readonly\n         * @member {Set.<module:engine/view/node~ViewNode>}\n         */\n        this.markedAttributes = new Set();\n        /**\n         * Set of elements which child lists changed and may need to be rendered.\n         *\n         * @readonly\n         * @member {Set.<module:engine/view/node~ViewNode>}\n         */\n        this.markedChildren = new Set();\n        /**\n         * Set of text nodes which text data changed and may need to be rendered.\n         *\n         * @readonly\n         * @member {Set.<module:engine/view/node~ViewNode>}\n         */\n        this.markedTexts = new Set();\n        /**\n         * View selection. Renderer updates DOM selection based on the view selection.\n         *\n         * @readonly\n         * @member {module:engine/view/documentselection~DocumentSelection}\n         */\n        this.selection = selection;\n        /**\n         * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n         * this is set to `false`.\n         *\n         * @member {Boolean}\n         * @observable\n         */\n        this.set('isFocused', false);\n        /**\n         * Indicates whether the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n         * When they stop selecting, the property goes back to `false`.\n         *\n         * Note: In some browsers, the renderer will stop rendering the selection and inline fillers while the user is making\n         * a selection to avoid glitches in DOM selection\n         * (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n         *\n         * @member {Boolean}\n         * @observable\n         */\n        this.set('isSelecting', false);\n        // Rendering the selection and inline filler manipulation should be postponed in (non-Android) Blink until the user finishes\n        // creating the selection in DOM to avoid accidental selection collapsing\n        // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n        // When the user stops selecting, all pending changes should be rendered ASAP, though.\n        if (env.isBlink && !env.isAndroid) {\n            this.on('change:isSelecting', () => {\n                if (!this.isSelecting) {\n                    this.render();\n                }\n            });\n        }\n        /**\n         * The text node in which the inline filler was rendered.\n         *\n         * @private\n         * @member {Text}\n         */\n        this._inlineFiller = null;\n        /**\n         * DOM element containing fake selection.\n         *\n         * @private\n         * @type {null|HTMLElement}\n         */\n        this._fakeSelectionContainer = null;\n    }\n    /**\n     * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n     *\n     * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n     *\n     * @see #markedAttributes\n     * @see #markedChildren\n     * @see #markedTexts\n     *\n     * @param {module:engine/view/document~ChangeType} type Type of the change.\n     * @param {module:engine/view/node~ViewNode} node ViewNode to be marked.\n     */\n    markToSync(type, node) {\n        if (type === 'text') {\n            if (this.domConverter.mapViewToDom(node.parent)) {\n                this.markedTexts.add(node);\n            }\n        }\n        else {\n            // If the node has no DOM element it is not rendered yet,\n            // its children/attributes do not need to be marked to be sync.\n            if (!this.domConverter.mapViewToDom(node)) {\n                return;\n            }\n            if (type === 'attributes') {\n                this.markedAttributes.add(node);\n            }\n            else if (type === 'children') {\n                this.markedChildren.add(node);\n            }\n            else {\n                /**\n                 * Unknown type passed to Renderer.markToSync.\n                 *\n                 * @error view-renderer-unknown-type\n                 */\n                throw new CKEditorError('view-renderer-unknown-type', this);\n            }\n        }\n    }\n    /**\n     * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n     * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n     *\n     * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n     * so it does as little as it is needed to update the DOM.\n     *\n     * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n     * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n     * removed as long as the selection is in the text node which needed it at first.\n     */\n    render() {\n        let inlineFillerPosition = null;\n        const isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true;\n        // Refresh mappings.\n        for (const element of this.markedChildren) {\n            this._updateChildrenMappings(element);\n        }\n        // Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n        // DOM selection collapsing\n        // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n        if (isInlineFillerRenderingPossible) {\n            // There was inline filler rendered in the DOM but it's not\n            // at the selection position any more, so we can remove it\n            // (cause even if it's needed, it must be placed in another location).\n            if (this._inlineFiller && !this._isSelectionInInlineFiller()) {\n                this._removeInlineFiller();\n            }\n            // If we've got the filler, let's try to guess its position in the view.\n            if (this._inlineFiller) {\n                inlineFillerPosition = this._getInlineFillerPosition();\n            }\n            // Otherwise, if it's needed, create it at the selection position.\n            else if (this._needsInlineFillerAtSelection()) {\n                inlineFillerPosition = this.selection.getFirstPosition();\n                // Do not use `markToSync` so it will be added even if the parent is already added.\n                this.markedChildren.add(inlineFillerPosition.parent);\n            }\n        }\n        // Make sure the inline filler has any parent, so it can be mapped to view position by DomConverter.\n        else if (this._inlineFiller && this._inlineFiller.parentNode) {\n            // While the user is making selection, preserve the inline filler at its original position.\n            inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);\n            // While down-casting the document selection attributes, all existing empty\n            // attribute elements (for selection position) are removed from the view and DOM,\n            // so make sure that we were able to map filler position.\n            // https://github.com/ckeditor/ckeditor5/issues/12026\n            if (inlineFillerPosition && inlineFillerPosition.parent.is('$text')) {\n                // The inline filler position is expected to be before the text node.\n                inlineFillerPosition = ViewPosition._createBefore(inlineFillerPosition.parent);\n            }\n        }\n        for (const element of this.markedAttributes) {\n            this._updateAttrs(element);\n        }\n        for (const element of this.markedChildren) {\n            this._updateChildren(element, { inlineFillerPosition });\n        }\n        for (const node of this.markedTexts) {\n            if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {\n                this._updateText(node, { inlineFillerPosition });\n            }\n        }\n        // * Check whether the inline filler is required and where it really is in the DOM.\n        //   At this point in most cases it will be in the DOM, but there are exceptions.\n        //   For example, if the inline filler was deep in the created DOM structure, it will not be created.\n        //   Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n        //   it will not be present. Fix those and similar scenarios.\n        // * Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n        //   DOM selection collapsing\n        //   (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n        if (isInlineFillerRenderingPossible) {\n            if (inlineFillerPosition) {\n                const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);\n                const domDocument = fillerDomPosition.parent.ownerDocument;\n                if (!startsWithFiller(fillerDomPosition.parent)) {\n                    // Filler has not been created at filler position. Create it now.\n                    this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);\n                }\n                else {\n                    // Filler has been found, save it.\n                    this._inlineFiller = fillerDomPosition.parent;\n                }\n            }\n            else {\n                // There is no filler needed.\n                this._inlineFiller = null;\n            }\n        }\n        // First focus the new editing host, then update the selection.\n        // Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n        this._updateFocus();\n        this._updateSelection();\n        this.markedTexts.clear();\n        this.markedAttributes.clear();\n        this.markedChildren.clear();\n    }\n    /**\n     * Updates mappings of view element's children.\n     *\n     * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n     * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n     * Thanks to that these elements do not need to be re-rendered completely.\n     *\n     * @private\n     * @param {module:engine/view/node~ViewNode} viewElement The view element whose children mappings will be updated.\n     */\n    _updateChildrenMappings(viewElement) {\n        const domElement = this.domConverter.mapViewToDom(viewElement);\n        if (!domElement) {\n            // If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n            return;\n        }\n        // Removing nodes from the DOM as we iterate can cause `actualDomChildren`\n        // (which is a live-updating `NodeList`) to get out of sync with the\n        // indices that we compute as we iterate over `actions`.\n        // This would produce incorrect element mappings.\n        //\n        // Converting live list to an array to make the list static.\n        const actualDomChildren = Array.from(this.domConverter.mapViewToDom(viewElement).childNodes);\n        const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, { withChildren: false }));\n        const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n        const actions = this._findReplaceActions(diff, actualDomChildren, expectedDomChildren);\n        if (actions.indexOf('replace') !== -1) {\n            const counter = { equal: 0, insert: 0, delete: 0 };\n            for (const action of actions) {\n                if (action === 'replace') {\n                    const insertIndex = counter.equal + counter.insert;\n                    const deleteIndex = counter.equal + counter.delete;\n                    const viewChild = viewElement.getChild(insertIndex);\n                    // UIElement and RawElement are special cases. Their children are not stored in a view (#799)\n                    // so we cannot use them with replacing flow (since they use view children during rendering\n                    // which will always result in rendering empty elements).\n                    if (viewChild && !(viewChild.is('uiElement') || viewChild.is('rawElement'))) {\n                        this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);\n                    }\n                    remove(expectedDomChildren[insertIndex]);\n                    counter.equal++;\n                }\n                else {\n                    counter[action]++;\n                }\n            }\n        }\n    }\n    /**\n     * Updates mappings of a given view element.\n     *\n     * @private\n     * @param {module:engine/view/node~ViewNode} viewElement The view element whose mappings will be updated.\n     * @param {ViewNode} domElement The DOM element representing the given view element.\n     */\n    _updateElementMappings(viewElement, domElement) {\n        // Remap 'DomConverter' bindings.\n        this.domConverter.unbindDomElement(domElement);\n        this.domConverter.bindElements(domElement, viewElement);\n        // View element may have children which needs to be updated, but are not marked, mark them to update.\n        this.markedChildren.add(viewElement);\n        // Because we replace new view element mapping with the existing one, the corresponding DOM element\n        // will not be rerendered. The new view element may have different attributes than the previous one.\n        // Since its corresponding DOM element will not be rerendered, new attributes will not be added\n        // to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n        // detailed case study.\n        // Also there are cases where replaced element is removed from the view structure and then has\n        // its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n        // and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n        // To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n        this.markedAttributes.add(viewElement);\n    }\n    /**\n     * Gets the position of the inline filler based on the current selection.\n     * Here, we assume that we know that the filler is needed and\n     * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n     * it is somewhere at the selection position.\n     *\n     * Note: The filler position cannot be restored based on the filler's DOM text node, because\n     * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n     * bindings are only dependable after rendering.\n     *\n     * @private\n     * @returns {module:engine/view/position~Position}\n     */\n    _getInlineFillerPosition() {\n        const firstPos = this.selection.getFirstPosition();\n        if (firstPos.parent.is('$text')) {\n            return ViewPosition._createBefore(firstPos.parent);\n        }\n        else {\n            return firstPos;\n        }\n    }\n    /**\n     * Returns `true` if the selection has not left the inline filler's text node.\n     * If it is `true`, it means that the filler had been added for a reason and the selection did not\n     * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n     *\n     * @private\n     * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n     */\n    _isSelectionInInlineFiller() {\n        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n            return false;\n        }\n        // Note, we can't check if selection's position equals position of the\n        // this._inlineFiller node, because of #663. We may not be able to calculate\n        // the filler's position in the view at this stage.\n        // Instead, we check it the other way – whether selection is anchored in\n        // that text node or next to it.\n        // Possible options are:\n        // \"FILLER{}\"\n        // \"FILLERadded-text{}\"\n        const selectionPosition = this.selection.getFirstPosition();\n        const position = this.domConverter.viewPositionToDom(selectionPosition);\n        if (position && isText(position.parent) && startsWithFiller(position.parent)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Removes the inline filler.\n     *\n     * @private\n     */\n    _removeInlineFiller() {\n        const domFillerNode = this._inlineFiller;\n        // Something weird happened and the stored node doesn't contain the filler's text.\n        if (!startsWithFiller(domFillerNode)) {\n            /**\n             * The inline filler node was lost. Most likely, something overwrote the filler text node\n             * in the DOM.\n             *\n             * @error view-renderer-filler-was-lost\n             */\n            throw new CKEditorError('view-renderer-filler-was-lost', this);\n        }\n        if (isInlineFiller(domFillerNode)) {\n            domFillerNode.remove();\n        }\n        else {\n            domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);\n        }\n        this._inlineFiller = null;\n    }\n    /**\n     * Checks if the inline {@link module:engine/view/filler filler} should be added.\n     *\n     * @private\n     * @returns {Boolean} `true` if the inline filler should be added.\n     */\n    _needsInlineFillerAtSelection() {\n        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n            return false;\n        }\n        const selectionPosition = this.selection.getFirstPosition();\n        const selectionParent = selectionPosition.parent;\n        const selectionOffset = selectionPosition.offset;\n        // If there is no DOM root we do not care about fillers.\n        if (!this.domConverter.mapViewToDom(selectionParent.root)) {\n            return false;\n        }\n        if (!(selectionParent.is('element'))) {\n            return false;\n        }\n        // Prevent adding inline filler inside elements with contenteditable=false.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/1170\n        if (!isEditable(selectionParent)) {\n            return false;\n        }\n        // We have block filler, we do not need inline one.\n        if (selectionOffset === selectionParent.getFillerOffset()) {\n            return false;\n        }\n        const nodeBefore = selectionPosition.nodeBefore;\n        const nodeAfter = selectionPosition.nodeAfter;\n        if (nodeBefore instanceof ViewText || nodeAfter instanceof ViewText) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Checks if text needs to be updated and possibly updates it.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} viewText View text to update.\n     * @param {Object} options\n     * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n     * filler should be rendered.\n     */\n    _updateText(viewText, options) {\n        const domText = this.domConverter.findCorrespondingDomText(viewText);\n        const newDomText = this.domConverter.viewToDom(viewText);\n        const actualText = domText.data;\n        let expectedText = newDomText.data;\n        const filler = options.inlineFillerPosition;\n        if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {\n            expectedText = INLINE_FILLER + expectedText;\n        }\n        if (actualText != expectedText) {\n            const actions = fastDiff(actualText, expectedText);\n            for (const action of actions) {\n                if (action.type === 'insert') {\n                    domText.insertData(action.index, action.values.join(''));\n                }\n                else { // 'delete'\n                    domText.deleteData(action.index, action.howMany);\n                }\n            }\n        }\n    }\n    /**\n     * Checks if attribute list needs to be updated and possibly updates it.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewElement The view element to update.\n     */\n    _updateAttrs(viewElement) {\n        const domElement = this.domConverter.mapViewToDom(viewElement);\n        if (!domElement) {\n            // If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n            // in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n            // replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n            // in 'this._updateChildrenMappings()' so it will be processed separately.\n            return;\n        }\n        const domAttrKeys = Array.from(domElement.attributes).map(attr => attr.name);\n        const viewAttrKeys = viewElement.getAttributeKeys();\n        // Add or overwrite attributes.\n        for (const key of viewAttrKeys) {\n            this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);\n        }\n        // Remove from DOM attributes which do not exists in the view.\n        for (const key of domAttrKeys) {\n            // All other attributes not present in the DOM should be removed.\n            if (!viewElement.hasAttribute(key)) {\n                this.domConverter.removeDomElementAttribute(domElement, key);\n            }\n        }\n    }\n    /**\n     * Checks if elements child list needs to be updated and possibly updates it.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewElement View element to update.\n     * @param {Object} options\n     * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n     * filler should be rendered.\n     */\n    _updateChildren(viewElement, options) {\n        const domElement = this.domConverter.mapViewToDom(viewElement);\n        if (!domElement) {\n            // If there is no `domElement` it means that it was already removed from DOM.\n            // There is no need to process it. It will be processed when re-inserted.\n            return;\n        }\n        const inlineFillerPosition = options.inlineFillerPosition;\n        const actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;\n        const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, { bind: true }));\n        // Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n        // during diffing so text nodes could be compared correctly and also during rendering to maintain\n        // proper order and indexes while updating the DOM.\n        if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {\n            addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);\n        }\n        const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n        let i = 0;\n        const nodesToUnbind = new Set();\n        // Handle deletions first.\n        // This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different\n        // index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,\n        // and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.\n        //\n        // It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.\n        for (const action of diff) {\n            if (action === 'delete') {\n                nodesToUnbind.add(actualDomChildren[i]);\n                remove(actualDomChildren[i]);\n            }\n            else if (action === 'equal') {\n                i++;\n            }\n        }\n        i = 0;\n        for (const action of diff) {\n            if (action === 'insert') {\n                insertAt(domElement, i, expectedDomChildren[i]);\n                i++;\n            }\n            else if (action === 'equal') {\n                // Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n                // Do it here (not in the loop above) because only after insertions the `i` index is correct.\n                this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));\n                i++;\n            }\n        }\n        // Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n        // comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n        // it was moved to DOM tree out of the removed node.\n        for (const node of nodesToUnbind) {\n            if (!node.parentNode) {\n                this.domConverter.unbindDomElement(node);\n            }\n        }\n    }\n    /**\n     * Shorthand for diffing two arrays or node lists of DOM nodes.\n     *\n     * @private\n     * @param {Array.<ViewNode>|NodeList} actualDomChildren Actual DOM children\n     * @param {Array.<ViewNode>|NodeList} expectedDomChildren Expected DOM children.\n     * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n     */\n    _diffNodeLists(actualDomChildren, expectedDomChildren) {\n        actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);\n        return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter));\n    }\n    /**\n     * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n     * within one `insert`/`delete` action group, for example:\n     *\n     * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n     * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n     * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n     * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n     *\n     * @private\n     * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n     * @param {Array.<ViewNode>|NodeList} actualDom Actual DOM children\n     * @param {Array.<ViewNode>} expectedDom Expected DOM children.\n     * @returns {Array.<String>} Actions array modified with the `replace` actions.\n     */\n    _findReplaceActions(actions, actualDom, expectedDom) {\n        // If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n        if (actions.indexOf('insert') === -1 || actions.indexOf('delete') === -1) {\n            return actions;\n        }\n        let newActions = [];\n        let actualSlice = [];\n        let expectedSlice = [];\n        const counter = { equal: 0, insert: 0, delete: 0 };\n        for (const action of actions) {\n            if (action === 'insert') {\n                expectedSlice.push(expectedDom[counter.equal + counter.insert]);\n            }\n            else if (action === 'delete') {\n                actualSlice.push(actualDom[counter.equal + counter.delete]);\n            }\n            else { // equal\n                newActions = newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n                newActions.push('equal');\n                // Reset stored elements on 'equal'.\n                actualSlice = [];\n                expectedSlice = [];\n            }\n            counter[action]++;\n        }\n        return newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n    }\n    /**\n     * Marks text nodes to be synchronized.\n     *\n     * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n     *\n     * @private\n     * @param {module:engine/view/node~ViewNode} viewNode View node to sync.\n     */\n    _markDescendantTextToSync(viewNode) {\n        if (!viewNode) {\n            return;\n        }\n        if (viewNode.is('$text')) {\n            this.markedTexts.add(viewNode);\n        }\n        else if (viewNode.is('element')) {\n            for (const child of viewNode.getChildren()) {\n                this._markDescendantTextToSync(child);\n            }\n        }\n    }\n    /**\n     * Checks if the selection needs to be updated and possibly updates it.\n     *\n     * @private\n     */\n    _updateSelection() {\n        // Block updating DOM selection in (non-Android) Blink while the user is selecting to prevent accidental selection collapsing.\n        // Note: Structural changes in DOM must trigger selection rendering, though. Nodes the selection was anchored\n        // to, may disappear in DOM which would break the selection (e.g. in real-time collaboration scenarios).\n        // https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723\n        if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {\n            return;\n        }\n        // If there is no selection - remove DOM and fake selections.\n        if (this.selection.rangeCount === 0) {\n            this._removeDomSelection();\n            this._removeFakeSelection();\n            return;\n        }\n        const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement);\n        // Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n        if (!this.isFocused || !domRoot) {\n            return;\n        }\n        // Render selection.\n        if (this.selection.isFake) {\n            this._updateFakeSelection(domRoot);\n        }\n        else {\n            this._removeFakeSelection();\n            this._updateDomSelection(domRoot);\n        }\n    }\n    /**\n     * Updates the fake selection.\n     *\n     * @private\n     * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n     */\n    _updateFakeSelection(domRoot) {\n        const domDocument = domRoot.ownerDocument;\n        if (!this._fakeSelectionContainer) {\n            this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);\n        }\n        const container = this._fakeSelectionContainer;\n        // Bind fake selection container with the current selection *position*.\n        this.domConverter.bindFakeSelection(container, this.selection);\n        if (!this._fakeSelectionNeedsUpdate(domRoot)) {\n            return;\n        }\n        if (!container.parentElement || container.parentElement != domRoot) {\n            domRoot.appendChild(container);\n        }\n        container.textContent = this.selection.fakeSelectionLabel || '\\u00A0';\n        const domSelection = domDocument.getSelection();\n        const domRange = domDocument.createRange();\n        domSelection.removeAllRanges();\n        domRange.selectNodeContents(container);\n        domSelection.addRange(domRange);\n    }\n    /**\n     * Updates the DOM selection.\n     *\n     * @private\n     * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n     */\n    _updateDomSelection(domRoot) {\n        const domSelection = domRoot.ownerDocument.defaultView.getSelection();\n        // Let's check whether DOM selection needs updating at all.\n        if (!this._domSelectionNeedsUpdate(domSelection)) {\n            return;\n        }\n        // Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n        // set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n        // and focus of view selection.\n        // Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n        // selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n        const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);\n        const focus = this.domConverter.viewPositionToDom(this.selection.focus);\n        domSelection.collapse(anchor.parent, anchor.offset);\n        domSelection.extend(focus.parent, focus.offset);\n        // Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n        if (env.isGecko) {\n            fixGeckoSelectionAfterBr(focus, domSelection);\n        }\n    }\n    /**\n     * Checks whether a given DOM selection needs to be updated.\n     *\n     * @private\n     * @param {Selection} domSelection The DOM selection to check.\n     * @returns {Boolean}\n     */\n    _domSelectionNeedsUpdate(domSelection) {\n        if (!this.domConverter.isDomSelectionCorrect(domSelection)) {\n            // Current DOM selection is in incorrect position. We need to update it.\n            return true;\n        }\n        const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);\n        if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {\n            return false;\n        }\n        // If selection is not collapsed, it does not need to be updated if it is similar.\n        if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {\n            // Selection did not changed and is correct, do not update.\n            return false;\n        }\n        // Selections are not similar.\n        return true;\n    }\n    /**\n     * Checks whether the fake selection needs to be updated.\n     *\n     * @private\n     * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.\n     * @returns {Boolean}\n     */\n    _fakeSelectionNeedsUpdate(domRoot) {\n        const container = this._fakeSelectionContainer;\n        const domSelection = domRoot.ownerDocument.getSelection();\n        // Fake selection needs to be updated if there's no fake selection container, or the container currently sits\n        // in a different root.\n        if (!container || container.parentElement !== domRoot) {\n            return true;\n        }\n        // Make sure that the selection actually is within the fake selection.\n        if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {\n            return true;\n        }\n        return container.textContent !== this.selection.fakeSelectionLabel;\n    }\n    /**\n     * Removes the DOM selection.\n     *\n     * @private\n     */\n    _removeDomSelection() {\n        for (const doc of this.domDocuments) {\n            const domSelection = doc.getSelection();\n            if (domSelection.rangeCount) {\n                const activeDomElement = doc.activeElement;\n                const viewElement = this.domConverter.mapDomToView(activeDomElement);\n                if (activeDomElement && viewElement) {\n                    domSelection.removeAllRanges();\n                }\n            }\n        }\n    }\n    /**\n     * Removes the fake selection.\n     *\n     * @private\n     */\n    _removeFakeSelection() {\n        const container = this._fakeSelectionContainer;\n        if (container) {\n            container.remove();\n        }\n    }\n    /**\n     * Checks if focus needs to be updated and possibly updates it.\n     *\n     * @private\n     */\n    _updateFocus() {\n        if (this.isFocused) {\n            const editable = this.selection.editableElement;\n            if (editable) {\n                this.domConverter.focus(editable);\n            }\n        }\n    }\n}\n// Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\nfunction isEditable(element) {\n    if (element.getAttribute('contenteditable') == 'false') {\n        return false;\n    }\n    const parent = element.findAncestor(element => element.hasAttribute('contenteditable'));\n    return !parent || parent.getAttribute('contenteditable') == 'true';\n}\n// Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<ViewNode>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\nfunction addInlineFiller(domDocument, domParentOrArray, offset) {\n    const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n    const nodeAfterFiller = childNodes[offset];\n    if (isText(nodeAfterFiller)) {\n        nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n        return nodeAfterFiller;\n    }\n    else {\n        const fillerNode = domDocument.createTextNode(INLINE_FILLER);\n        if (Array.isArray(domParentOrArray)) {\n            childNodes.splice(offset, 0, fillerNode);\n        }\n        else {\n            insertAt(domParentOrArray, offset, fillerNode);\n        }\n        return fillerNode;\n    }\n}\n// Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {ViewNode} node1\n// @param {ViewNode} node2\n// @returns {Boolean}\nfunction areSimilar(node1, node2) {\n    return isNode(node1) && isNode(node2) &&\n        !isText(node1) && !isText(node2) &&\n        !isComment(node1) && !isComment(node2) &&\n        node1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n}\n// Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.\n// @param {ViewNode} node1\n// @param {ViewNode} node2\n// @returns {Boolean}\nfunction sameNodes(domConverter, actualDomChild, expectedDomChild) {\n    // Elements.\n    if (actualDomChild === expectedDomChild) {\n        return true;\n    }\n    // Texts.\n    else if (isText(actualDomChild) && isText(expectedDomChild)) {\n        return actualDomChild.data === expectedDomChild.data;\n    }\n    // Block fillers.\n    else if (domConverter.isBlockFiller(actualDomChild) &&\n        domConverter.isBlockFiller(expectedDomChild)) {\n        return true;\n    }\n    // Not matching types.\n    return false;\n}\n// The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\nfunction fixGeckoSelectionAfterBr(focus, domSelection) {\n    const parent = focus.parent;\n    // This fix works only when the focus point is at the very end of an element.\n    // There is no point in running it in cases unrelated to the browser bug.\n    if (parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1) {\n        return;\n    }\n    const childAtOffset = parent.childNodes[focus.offset];\n    // To stay on the safe side, the fix being as specific as possible, it targets only the\n    // selection which is at the very end of the element and preceded by <br />.\n    if (childAtOffset && childAtOffset.tagName == 'BR') {\n        domSelection.addRange(domSelection.getRangeAt(0));\n    }\n}\nfunction filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {\n    const childList = Array.from(domChildList);\n    if (childList.length == 0 || !fakeSelectionContainer) {\n        return childList;\n    }\n    const last = childList[childList.length - 1];\n    if (last == fakeSelectionContainer) {\n        childList.pop();\n    }\n    return childList;\n}\n// Creates a fake selection container for a given document.\n//\n// @private\n// @param {Document} domDocument\n// @returns {HTMLElement}\nfunction createFakeSelectionContainer(domDocument) {\n    const container = domDocument.createElement('div');\n    container.className = 'ck-fake-selection-container';\n    Object.assign(container.style, {\n        position: 'fixed',\n        top: 0,\n        left: '-9999px',\n        // See https://github.com/ckeditor/ckeditor5/issues/752.\n        width: '42px'\n    });\n    // Fill it with a text node so we can update it later.\n    container.textContent = '\\u00A0';\n    return container;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}