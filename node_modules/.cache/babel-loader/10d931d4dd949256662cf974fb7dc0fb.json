{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/selection-post-fixer\n */\nimport Position from '../position';\nimport Range from '../range';\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isSelectable selectable elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><imageBlock></imageBlock>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\nexport function injectSelectionPostFixer(model) {\n  model.document.registerPostFixer(writer => selectionPostFixer(writer, model));\n}\n// The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction selectionPostFixer(writer, model) {\n  const selection = model.document.selection;\n  const schema = model.schema;\n  const ranges = [];\n  let wasFixed = false;\n  for (const modelRange of selection.getRanges()) {\n    // Go through all ranges in selection and try fixing each of them.\n    // Those ranges might overlap but will be corrected later.\n    const correctedRange = tryFixingRange(modelRange, schema);\n    // \"Selection fixing\" algorithms sometimes get lost. In consequence, it may happen\n    // that a new range is returned but, in fact, it has the same positions as the original\n    // range anyway. If this range is not discarded, a new selection will be set and that,\n    // for instance, would destroy the selection attributes. Let's make sure that the post-fixer\n    // actually worked first before setting a new selection.\n    //\n    // https://github.com/ckeditor/ckeditor5/issues/6693\n    if (correctedRange && !correctedRange.isEqual(modelRange)) {\n      ranges.push(correctedRange);\n      wasFixed = true;\n    } else {\n      ranges.push(modelRange);\n    }\n  }\n  // If any of ranges were corrected update the selection.\n  if (wasFixed) {\n    writer.setSelection(mergeIntersectingRanges(ranges), {\n      backward: selection.isBackward\n    });\n  }\n  return false;\n}\n// Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingRange(range, schema) {\n  if (range.isCollapsed) {\n    return tryFixingCollapsedRange(range, schema);\n  }\n  return tryFixingNonCollapsedRage(range, schema);\n}\n// Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingCollapsedRange(range, schema) {\n  const originalPosition = range.start;\n  const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition);\n  // This might be null, i.e. when the editor data is empty or the selection is inside a limit element\n  // that doesn't allow text inside.\n  // In the first case, there is no need to fix the selection range.\n  // In the second, let's go up to the outer selectable element\n  if (!nearestSelectionRange) {\n    const ancestorObject = originalPosition.getAncestors().reverse().find(item => schema.isObject(item));\n    if (ancestorObject) {\n      return Range._createOn(ancestorObject);\n    }\n    return null;\n  }\n  if (!nearestSelectionRange.isCollapsed) {\n    return nearestSelectionRange;\n  }\n  const fixedPosition = nearestSelectionRange.start;\n  // Fixed position is the same as original - no need to return corrected range.\n  if (originalPosition.isEqual(fixedPosition)) {\n    return null;\n  }\n  return new Range(fixedPosition);\n}\n// Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingNonCollapsedRage(range, schema) {\n  const {\n    start,\n    end\n  } = range;\n  const isTextAllowedOnStart = schema.checkChild(start, '$text');\n  const isTextAllowedOnEnd = schema.checkChild(end, '$text');\n  const startLimitElement = schema.getLimitElement(start);\n  const endLimitElement = schema.getLimitElement(end);\n  // Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n  if (startLimitElement === endLimitElement) {\n    // Range is valid when both position allows to place a text:\n    // - <block>f[oobarba]z</block>\n    // This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n    if (isTextAllowedOnStart && isTextAllowedOnEnd) {\n      return null;\n    }\n    // Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n    // - [<block>foo</block>]    ->    <block>[foo]</block>\n    // - [<block>foo]</block>    ->    <block>[foo]</block>\n    // - <block>f[oo</block>]    ->    <block>f[oo]</block>\n    // - [<block>foo</block><selectable></selectable>]    ->    <block>[foo</block><selectable></selectable>]\n    if (checkSelectionOnNonLimitElements(start, end, schema)) {\n      const isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);\n      const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, 'forward');\n      const isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);\n      const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, 'backward');\n      // The schema.getNearestSelectionRange might return null - if that happens use original position.\n      const rangeStart = fixedStart ? fixedStart.start : start;\n      const rangeEnd = fixedEnd ? fixedEnd.end : end;\n      return new Range(rangeStart, rangeEnd);\n    }\n  }\n  const isStartInLimit = startLimitElement && !startLimitElement.is('rootElement');\n  const isEndInLimit = endLimitElement && !endLimitElement.is('rootElement');\n  // At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n  // then the range crossed limit element boundaries and needs to be fixed.\n  if (isStartInLimit || isEndInLimit) {\n    const bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;\n    const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));\n    const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema));\n    // Although we've already found limit element on start/end positions we must find the outer-most limit element.\n    // as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n    let fixedStart = start;\n    let fixedEnd = end;\n    if (expandStart) {\n      fixedStart = Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));\n    }\n    if (expandEnd) {\n      fixedEnd = Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));\n    }\n    return new Range(fixedStart, fixedEnd);\n  }\n  // Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n  return null;\n}\n// Finds the outer-most ancestor.\n//\n// @param {module:engine/model/node~Node} startingNode\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/node~Node}\nfunction findOutermostLimitAncestor(startingNode, schema) {\n  let isLimitNode = startingNode;\n  let parent = isLimitNode;\n  // Find outer most isLimit block as such blocks might be nested (ie. in tables).\n  while (schema.isLimit(parent) && parent.parent) {\n    isLimitNode = parent;\n    parent = parent.parent;\n  }\n  return isLimitNode;\n}\n// Checks whether any of range boundaries is placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction checkSelectionOnNonLimitElements(start, end, schema) {\n  const startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, '$text');\n  const endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, '$text');\n  // We should fix such selection when one of those nodes needs fixing.\n  return startIsOnBlock || endIsOnBlock;\n}\n/**\n * Returns a minimal non-intersecting array of ranges without duplicates.\n *\n * @param {Array.<module:engine/model/range~Range>} Ranges to merge.\n * @returns {Array.<module:engine/model/range~Range>} Array of unique and nonIntersecting ranges.\n */\nexport function mergeIntersectingRanges(ranges) {\n  const rangesToMerge = [...ranges];\n  const rangeIndexesToRemove = new Set();\n  let currentRangeIndex = 1;\n  while (currentRangeIndex < rangesToMerge.length) {\n    const currentRange = rangesToMerge[currentRangeIndex];\n    const previousRanges = rangesToMerge.slice(0, currentRangeIndex);\n    for (const [previousRangeIndex, previousRange] of previousRanges.entries()) {\n      if (rangeIndexesToRemove.has(previousRangeIndex)) {\n        continue;\n      }\n      if (currentRange.isEqual(previousRange)) {\n        rangeIndexesToRemove.add(previousRangeIndex);\n      } else if (currentRange.isIntersecting(previousRange)) {\n        rangeIndexesToRemove.add(previousRangeIndex);\n        rangeIndexesToRemove.add(currentRangeIndex);\n        const mergedRange = currentRange.getJoined(previousRange);\n        rangesToMerge.push(mergedRange);\n      }\n    }\n    currentRangeIndex++;\n  }\n  const nonIntersectingRanges = rangesToMerge.filter((_, index) => !rangeIndexesToRemove.has(index));\n  return nonIntersectingRanges;\n}\n// Checks if node exists and if it's a selectable.\n//\n// @param {module:engine/model/node~Node} node\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction isSelectable(node, schema) {\n  return node && schema.isSelectable(node);\n}","map":{"version":3,"names":["Position","Range","injectSelectionPostFixer","model","document","registerPostFixer","writer","selectionPostFixer","selection","schema","ranges","wasFixed","modelRange","getRanges","correctedRange","tryFixingRange","isEqual","push","setSelection","mergeIntersectingRanges","backward","isBackward","range","isCollapsed","tryFixingCollapsedRange","tryFixingNonCollapsedRage","originalPosition","start","nearestSelectionRange","getNearestSelectionRange","ancestorObject","getAncestors","reverse","find","item","isObject","_createOn","fixedPosition","end","isTextAllowedOnStart","checkChild","isTextAllowedOnEnd","startLimitElement","getLimitElement","endLimitElement","checkSelectionOnNonLimitElements","isStartBeforeSelectable","nodeAfter","isSelectable","fixedStart","isEndAfterSelectable","nodeBefore","fixedEnd","rangeStart","rangeEnd","isStartInLimit","is","isEndInLimit","bothInSameParent","parent","expandStart","expandEnd","_createBefore","findOutermostLimitAncestor","_createAfter","startingNode","isLimitNode","isLimit","startIsOnBlock","endIsOnBlock","rangesToMerge","rangeIndexesToRemove","Set","currentRangeIndex","length","currentRange","previousRanges","slice","previousRangeIndex","previousRange","entries","has","add","isIntersecting","mergedRange","getJoined","nonIntersectingRanges","filter","_","index","node"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/selection-post-fixer\n */\nimport Position from '../position';\nimport Range from '../range';\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isSelectable selectable elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><imageBlock></imageBlock>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\nexport function injectSelectionPostFixer(model) {\n    model.document.registerPostFixer(writer => selectionPostFixer(writer, model));\n}\n// The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction selectionPostFixer(writer, model) {\n    const selection = model.document.selection;\n    const schema = model.schema;\n    const ranges = [];\n    let wasFixed = false;\n    for (const modelRange of selection.getRanges()) {\n        // Go through all ranges in selection and try fixing each of them.\n        // Those ranges might overlap but will be corrected later.\n        const correctedRange = tryFixingRange(modelRange, schema);\n        // \"Selection fixing\" algorithms sometimes get lost. In consequence, it may happen\n        // that a new range is returned but, in fact, it has the same positions as the original\n        // range anyway. If this range is not discarded, a new selection will be set and that,\n        // for instance, would destroy the selection attributes. Let's make sure that the post-fixer\n        // actually worked first before setting a new selection.\n        //\n        // https://github.com/ckeditor/ckeditor5/issues/6693\n        if (correctedRange && !correctedRange.isEqual(modelRange)) {\n            ranges.push(correctedRange);\n            wasFixed = true;\n        }\n        else {\n            ranges.push(modelRange);\n        }\n    }\n    // If any of ranges were corrected update the selection.\n    if (wasFixed) {\n        writer.setSelection(mergeIntersectingRanges(ranges), { backward: selection.isBackward });\n    }\n    return false;\n}\n// Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingRange(range, schema) {\n    if (range.isCollapsed) {\n        return tryFixingCollapsedRange(range, schema);\n    }\n    return tryFixingNonCollapsedRage(range, schema);\n}\n// Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingCollapsedRange(range, schema) {\n    const originalPosition = range.start;\n    const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition);\n    // This might be null, i.e. when the editor data is empty or the selection is inside a limit element\n    // that doesn't allow text inside.\n    // In the first case, there is no need to fix the selection range.\n    // In the second, let's go up to the outer selectable element\n    if (!nearestSelectionRange) {\n        const ancestorObject = originalPosition.getAncestors().reverse().find(item => schema.isObject(item));\n        if (ancestorObject) {\n            return Range._createOn(ancestorObject);\n        }\n        return null;\n    }\n    if (!nearestSelectionRange.isCollapsed) {\n        return nearestSelectionRange;\n    }\n    const fixedPosition = nearestSelectionRange.start;\n    // Fixed position is the same as original - no need to return corrected range.\n    if (originalPosition.isEqual(fixedPosition)) {\n        return null;\n    }\n    return new Range(fixedPosition);\n}\n// Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingNonCollapsedRage(range, schema) {\n    const { start, end } = range;\n    const isTextAllowedOnStart = schema.checkChild(start, '$text');\n    const isTextAllowedOnEnd = schema.checkChild(end, '$text');\n    const startLimitElement = schema.getLimitElement(start);\n    const endLimitElement = schema.getLimitElement(end);\n    // Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n    if (startLimitElement === endLimitElement) {\n        // Range is valid when both position allows to place a text:\n        // - <block>f[oobarba]z</block>\n        // This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n        if (isTextAllowedOnStart && isTextAllowedOnEnd) {\n            return null;\n        }\n        // Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n        // - [<block>foo</block>]    ->    <block>[foo]</block>\n        // - [<block>foo]</block>    ->    <block>[foo]</block>\n        // - <block>f[oo</block>]    ->    <block>f[oo]</block>\n        // - [<block>foo</block><selectable></selectable>]    ->    <block>[foo</block><selectable></selectable>]\n        if (checkSelectionOnNonLimitElements(start, end, schema)) {\n            const isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);\n            const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, 'forward');\n            const isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);\n            const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, 'backward');\n            // The schema.getNearestSelectionRange might return null - if that happens use original position.\n            const rangeStart = fixedStart ? fixedStart.start : start;\n            const rangeEnd = fixedEnd ? fixedEnd.end : end;\n            return new Range(rangeStart, rangeEnd);\n        }\n    }\n    const isStartInLimit = startLimitElement && !startLimitElement.is('rootElement');\n    const isEndInLimit = endLimitElement && !endLimitElement.is('rootElement');\n    // At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n    // then the range crossed limit element boundaries and needs to be fixed.\n    if (isStartInLimit || isEndInLimit) {\n        const bothInSameParent = (start.nodeAfter && end.nodeBefore) && start.nodeAfter.parent === end.nodeBefore.parent;\n        const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));\n        const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema));\n        // Although we've already found limit element on start/end positions we must find the outer-most limit element.\n        // as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n        let fixedStart = start;\n        let fixedEnd = end;\n        if (expandStart) {\n            fixedStart = Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));\n        }\n        if (expandEnd) {\n            fixedEnd = Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));\n        }\n        return new Range(fixedStart, fixedEnd);\n    }\n    // Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n    return null;\n}\n// Finds the outer-most ancestor.\n//\n// @param {module:engine/model/node~Node} startingNode\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/node~Node}\nfunction findOutermostLimitAncestor(startingNode, schema) {\n    let isLimitNode = startingNode;\n    let parent = isLimitNode;\n    // Find outer most isLimit block as such blocks might be nested (ie. in tables).\n    while (schema.isLimit(parent) && parent.parent) {\n        isLimitNode = parent;\n        parent = parent.parent;\n    }\n    return isLimitNode;\n}\n// Checks whether any of range boundaries is placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction checkSelectionOnNonLimitElements(start, end, schema) {\n    const startIsOnBlock = (start.nodeAfter && !schema.isLimit(start.nodeAfter)) || schema.checkChild(start, '$text');\n    const endIsOnBlock = (end.nodeBefore && !schema.isLimit(end.nodeBefore)) || schema.checkChild(end, '$text');\n    // We should fix such selection when one of those nodes needs fixing.\n    return startIsOnBlock || endIsOnBlock;\n}\n/**\n * Returns a minimal non-intersecting array of ranges without duplicates.\n *\n * @param {Array.<module:engine/model/range~Range>} Ranges to merge.\n * @returns {Array.<module:engine/model/range~Range>} Array of unique and nonIntersecting ranges.\n */\nexport function mergeIntersectingRanges(ranges) {\n    const rangesToMerge = [...ranges];\n    const rangeIndexesToRemove = new Set();\n    let currentRangeIndex = 1;\n    while (currentRangeIndex < rangesToMerge.length) {\n        const currentRange = rangesToMerge[currentRangeIndex];\n        const previousRanges = rangesToMerge.slice(0, currentRangeIndex);\n        for (const [previousRangeIndex, previousRange] of previousRanges.entries()) {\n            if (rangeIndexesToRemove.has(previousRangeIndex)) {\n                continue;\n            }\n            if (currentRange.isEqual(previousRange)) {\n                rangeIndexesToRemove.add(previousRangeIndex);\n            }\n            else if (currentRange.isIntersecting(previousRange)) {\n                rangeIndexesToRemove.add(previousRangeIndex);\n                rangeIndexesToRemove.add(currentRangeIndex);\n                const mergedRange = currentRange.getJoined(previousRange);\n                rangesToMerge.push(mergedRange);\n            }\n        }\n        currentRangeIndex++;\n    }\n    const nonIntersectingRanges = rangesToMerge.filter((_, index) => !rangeIndexesToRemove.has(index));\n    return nonIntersectingRanges;\n}\n// Checks if node exists and if it's a selectable.\n//\n// @param {module:engine/model/node~Node} node\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction isSelectable(node, schema) {\n    return node && schema.isSelectable(node);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}