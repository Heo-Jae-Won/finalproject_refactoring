{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/document\n */\nimport Differ from './differ';\nimport DocumentSelection from './documentselection';\nimport History from './history';\nimport RootElement from './rootelement';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es';\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\nconst graveyardName = '$graveyard';\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Document extends Emitter {\n  /**\n   * Creates an empty document instance with no {@link #roots} (other than\n   * the {@link #graveyard graveyard root}).\n   */\n  constructor(model) {\n    super();\n    /**\n     * The {@link module:engine/model/model~Model model} that the document is a part of.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The document's history.\n     *\n     * @readonly\n     * @type {module:engine/model/history~History}\n     */\n    this.history = new History();\n    /**\n     * The selection in this document.\n     *\n     * @readonly\n     * @type {module:engine/model/documentselection~DocumentSelection}\n     */\n    this.selection = new DocumentSelection(this);\n    /**\n     * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n     * {@link #getRoot} to manipulate it.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n     *\n     * @readonly\n     * @type {module:engine/model/differ~Differ}\n     */\n    this.differ = new Differ(model.markers);\n    /**\n     * Post-fixer callbacks registered to the model document.\n     *\n     * @private\n     * @type {Set.<Function>}\n     */\n    this._postFixers = new Set();\n    /**\n     * A boolean indicates whether the selection has changed until\n     *\n     * @private\n     * @type {Boolean}\n     */\n    this._hasSelectionChangedFromTheLastChangeBlock = false;\n    // Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n    this.createRoot('$root', graveyardName);\n    // Then, still before an operation is applied on model, buffer the change in differ.\n    this.listenTo(model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n      if (operation.isDocumentOperation) {\n        this.differ.bufferOperation(operation);\n      }\n    }, {\n      priority: 'high'\n    });\n    // After the operation is applied, bump document's version and add the operation to the history.\n    this.listenTo(model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n      if (operation.isDocumentOperation) {\n        this.history.addOperation(operation);\n      }\n    }, {\n      priority: 'low'\n    });\n    // Listen to selection changes. If selection changed, mark it.\n    this.listenTo(this.selection, 'change', () => {\n      this._hasSelectionChangedFromTheLastChangeBlock = true;\n    });\n    // Buffer marker changes.\n    // This is not covered in buffering operations because markers may change outside of them (when they\n    // are modified using `model.markers` collection, not through `MarkerOperation`).\n    this.listenTo(model.markers, 'update', (evt, marker, oldRange, newRange, oldMarkerData) => {\n      // Copy the `newRange` to the new marker data as during the marker removal the range is not updated.\n      const newMarkerData = {\n        ...marker.getData(),\n        range: newRange\n      };\n      // Whenever marker is updated, buffer that change.\n      this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);\n      if (oldRange === null) {\n        // If this is a new marker, add a listener that will buffer change whenever marker changes.\n        marker.on('change', (evt, oldRange) => {\n          const markerData = marker.getData();\n          this.differ.bufferMarkerChange(marker.name, {\n            ...markerData,\n            range: oldRange\n          }, markerData);\n        });\n      }\n    });\n  }\n  /**\n   * The document version. Every applied operation increases the version number. It is used to\n   * ensure that operations are applied on a proper document version.\n   *\n   * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.\n   *\n   * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n   * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n   *\n   * @type {Number}\n   */\n  get version() {\n    return this.history.version;\n  }\n  set version(version) {\n    this.history.version = version;\n  }\n  /**\n   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n   *\n   * @readonly\n   * @member {module:engine/model/rootelement~RootElement}\n   */\n  get graveyard() {\n    return this.getRoot(graveyardName);\n  }\n  /**\n   * Creates a new root.\n   *\n   * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n   * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n   * @param {String} [rootName='main'] A unique root name.\n   * @returns {module:engine/model/rootelement~RootElement} The created root.\n   */\n  createRoot() {\n    let elementName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$root';\n    let rootName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';\n    if (this.roots.get(rootName)) {\n      /**\n       * A root with the specified name already exists.\n       *\n       * @error model-document-createroot-name-exists\n       * @param {module:engine/model/document~Document} doc\n       * @param {String} name\n       */\n      throw new CKEditorError('model-document-createroot-name-exists', this, {\n        name: rootName\n      });\n    }\n    const root = new RootElement(this, elementName, rootName);\n    this.roots.add(root);\n    return root;\n  }\n  /**\n   * Removes all event listeners set by the document instance.\n   */\n  destroy() {\n    this.selection.destroy();\n    this.stopListening();\n  }\n  /**\n   * Returns a root by its name.\n   *\n   * @param {String} [name='main'] A unique root name.\n   * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n   * there is no root with the given name.\n   */\n  getRoot() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n    return this.roots.get(name);\n  }\n  /**\n   * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n   *\n   * @returns {Array.<String>} Roots names.\n   */\n  getRootNames() {\n    return Array.from(this.roots, root => root.rootName).filter(name => name != graveyardName);\n  }\n  /**\n   * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n   * will operate on a correct model state.\n   *\n   * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n   * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n   * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n   * not be fixed in the new document tree state.\n   *\n   * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n   * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n   * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n   * for the user.\n   *\n   * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n   * callback should add an empty paragraph so that the editor is never empty:\n   *\n   *\t\tdocument.registerPostFixer( writer => {\n   *\t\t\tconst changes = document.differ.getChanges();\n   *\n   *\t\t\t// Check if the changes lead to an empty root in the editor.\n   *\t\t\tfor ( const entry of changes ) {\n   *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n   *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n   *\n   *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n   *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n   *\t\t\t\t\treturn true;\n   *\t\t\t\t}\n   *\t\t\t}\n   *\n   *\t\t\treturn false;\n   *\t\t} );\n   *\n   * @param {Function} postFixer\n   */\n  registerPostFixer(postFixer) {\n    this._postFixers.add(postFixer);\n  }\n  /**\n   * A custom `toJSON()` method to solve child-parent circular dependencies.\n   *\n   * @returns {Object} A clone of this object with the document property changed to a string.\n   */\n  toJSON() {\n    const json = clone(this);\n    // Due to circular references we need to remove parent reference.\n    json.selection = '[engine.model.DocumentSelection]';\n    json.model = '[engine.model.Model]';\n    return json;\n  }\n  /**\n   * Check if there were any changes done on document, and if so, call post-fixers,\n   * fire `change` event for features and conversion and then reset the differ.\n   * Fire `change:data` event when at least one operation or buffered marker changes the data.\n   *\n   * @internal\n   * @protected\n   * @fires change\n   * @fires change:data\n   * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n   */\n  _handleChangeBlock(writer) {\n    if (this._hasDocumentChangedFromTheLastChangeBlock()) {\n      this._callPostFixers(writer);\n      // Refresh selection attributes according to the final position in the model after the change.\n      this.selection.refresh();\n      if (this.differ.hasDataChanges()) {\n        this.fire('change:data', writer.batch);\n      } else {\n        this.fire('change', writer.batch);\n      }\n      // Theoretically, it is not necessary to refresh selection after change event because\n      // post-fixers are the last who should change the model, but just in case...\n      this.selection.refresh();\n      this.differ.reset();\n    }\n    this._hasSelectionChangedFromTheLastChangeBlock = false;\n  }\n  /**\n   * Returns whether there is a buffered change or if the selection has changed from the last\n   * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n   * or {@link module:engine/model/model~Model#change `change()` block}.\n   *\n   * @protected\n   * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n   */\n  _hasDocumentChangedFromTheLastChangeBlock() {\n    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n  }\n  /**\n   * Returns the default root for this document which is either the first root that was added to the document using\n   * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n   *\n   * @protected\n   * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n   */\n  _getDefaultRoot() {\n    for (const root of this.roots) {\n      if (root !== this.graveyard) {\n        return root;\n      }\n    }\n    return this.graveyard;\n  }\n  /**\n   * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n   * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n   *\n   * @internal\n   * @protected\n   * @returns {module:engine/model/range~Range}\n   */\n  _getDefaultRange() {\n    const defaultRoot = this._getDefaultRoot();\n    const model = this.model;\n    const schema = model.schema;\n    // Find the first position where the selection can be put.\n    const position = model.createPositionFromPath(defaultRoot, [0]);\n    const nearestRange = schema.getNearestSelectionRange(position);\n    // If valid selection range is not found - return range collapsed at the beginning of the root.\n    return nearestRange || model.createRange(position);\n  }\n  /**\n   * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n   * the {@link #selection document's selection}.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/range~Range} range A range to check.\n   * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n   */\n  _validateSelectionRange(range) {\n    return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);\n  }\n  /**\n   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n   *\n   * @private\n   * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n   */\n  _callPostFixers(writer) {\n    let wasFixed = false;\n    do {\n      for (const callback of this._postFixers) {\n        // Ensure selection attributes are up to date before each post-fixer.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n        //\n        // It might be good to refresh the selection after each operation but at the moment it leads\n        // to losing attributes for composition or and spell checking\n        // https://github.com/ckeditor/ckeditor5-typing/issues/188\n        this.selection.refresh();\n        wasFixed = callback(writer);\n        if (wasFixed) {\n          break;\n        }\n      }\n    } while (wasFixed);\n  }\n}\n// Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\nfunction validateTextNodePosition(rangeBoundary) {\n  const textNode = rangeBoundary.textNode;\n  if (textNode) {\n    const data = textNode.data;\n    const offset = rangeBoundary.offset - textNode.startOffset;\n    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);\n  }\n  return true;\n}","map":{"version":3,"names":["Differ","DocumentSelection","History","RootElement","Collection","Emitter","CKEditorError","isInsideSurrogatePair","isInsideCombinedSymbol","clone","graveyardName","Document","constructor","model","history","selection","roots","idProperty","differ","markers","_postFixers","Set","_hasSelectionChangedFromTheLastChangeBlock","createRoot","listenTo","evt","args","operation","isDocumentOperation","bufferOperation","priority","addOperation","marker","oldRange","newRange","oldMarkerData","newMarkerData","getData","range","bufferMarkerChange","name","on","markerData","version","graveyard","getRoot","elementName","rootName","get","root","add","destroy","stopListening","getRootNames","Array","from","filter","registerPostFixer","postFixer","toJSON","json","_handleChangeBlock","writer","_hasDocumentChangedFromTheLastChangeBlock","_callPostFixers","refresh","hasDataChanges","fire","batch","reset","isEmpty","_getDefaultRoot","_getDefaultRange","defaultRoot","schema","position","createPositionFromPath","nearestRange","getNearestSelectionRange","createRange","_validateSelectionRange","validateTextNodePosition","start","end","wasFixed","callback","rangeBoundary","textNode","data","offset","startOffset"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/document\n */\nimport Differ from './differ';\nimport DocumentSelection from './documentselection';\nimport History from './history';\nimport RootElement from './rootelement';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es';\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\nconst graveyardName = '$graveyard';\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Document extends Emitter {\n    /**\n     * Creates an empty document instance with no {@link #roots} (other than\n     * the {@link #graveyard graveyard root}).\n     */\n    constructor(model) {\n        super();\n        /**\n         * The {@link module:engine/model/model~Model model} that the document is a part of.\n         *\n         * @readonly\n         * @type {module:engine/model/model~Model}\n         */\n        this.model = model;\n        /**\n         * The document's history.\n         *\n         * @readonly\n         * @type {module:engine/model/history~History}\n         */\n        this.history = new History();\n        /**\n         * The selection in this document.\n         *\n         * @readonly\n         * @type {module:engine/model/documentselection~DocumentSelection}\n         */\n        this.selection = new DocumentSelection(this);\n        /**\n         * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n         * {@link #getRoot} to manipulate it.\n         *\n         * @readonly\n         * @type {module:utils/collection~Collection}\n         */\n        this.roots = new Collection({ idProperty: 'rootName' });\n        /**\n         * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n         *\n         * @readonly\n         * @type {module:engine/model/differ~Differ}\n         */\n        this.differ = new Differ(model.markers);\n        /**\n         * Post-fixer callbacks registered to the model document.\n         *\n         * @private\n         * @type {Set.<Function>}\n         */\n        this._postFixers = new Set();\n        /**\n         * A boolean indicates whether the selection has changed until\n         *\n         * @private\n         * @type {Boolean}\n         */\n        this._hasSelectionChangedFromTheLastChangeBlock = false;\n        // Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n        this.createRoot('$root', graveyardName);\n        // Then, still before an operation is applied on model, buffer the change in differ.\n        this.listenTo(model, 'applyOperation', (evt, args) => {\n            const operation = args[0];\n            if (operation.isDocumentOperation) {\n                this.differ.bufferOperation(operation);\n            }\n        }, { priority: 'high' });\n        // After the operation is applied, bump document's version and add the operation to the history.\n        this.listenTo(model, 'applyOperation', (evt, args) => {\n            const operation = args[0];\n            if (operation.isDocumentOperation) {\n                this.history.addOperation(operation);\n            }\n        }, { priority: 'low' });\n        // Listen to selection changes. If selection changed, mark it.\n        this.listenTo(this.selection, 'change', () => {\n            this._hasSelectionChangedFromTheLastChangeBlock = true;\n        });\n        // Buffer marker changes.\n        // This is not covered in buffering operations because markers may change outside of them (when they\n        // are modified using `model.markers` collection, not through `MarkerOperation`).\n        this.listenTo(model.markers, 'update', (evt, marker, oldRange, newRange, oldMarkerData) => {\n            // Copy the `newRange` to the new marker data as during the marker removal the range is not updated.\n            const newMarkerData = { ...marker.getData(), range: newRange };\n            // Whenever marker is updated, buffer that change.\n            this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);\n            if (oldRange === null) {\n                // If this is a new marker, add a listener that will buffer change whenever marker changes.\n                marker.on('change', (evt, oldRange) => {\n                    const markerData = marker.getData();\n                    this.differ.bufferMarkerChange(marker.name, { ...markerData, range: oldRange }, markerData);\n                });\n            }\n        });\n    }\n    /**\n     * The document version. Every applied operation increases the version number. It is used to\n     * ensure that operations are applied on a proper document version.\n     *\n     * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.\n     *\n     * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n     * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n     *\n     * @type {Number}\n     */\n    get version() {\n        return this.history.version;\n    }\n    set version(version) {\n        this.history.version = version;\n    }\n    /**\n     * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n     *\n     * @readonly\n     * @member {module:engine/model/rootelement~RootElement}\n     */\n    get graveyard() {\n        return this.getRoot(graveyardName);\n    }\n    /**\n     * Creates a new root.\n     *\n     * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n     * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n     * @param {String} [rootName='main'] A unique root name.\n     * @returns {module:engine/model/rootelement~RootElement} The created root.\n     */\n    createRoot(elementName = '$root', rootName = 'main') {\n        if (this.roots.get(rootName)) {\n            /**\n             * A root with the specified name already exists.\n             *\n             * @error model-document-createroot-name-exists\n             * @param {module:engine/model/document~Document} doc\n             * @param {String} name\n             */\n            throw new CKEditorError('model-document-createroot-name-exists', this, { name: rootName });\n        }\n        const root = new RootElement(this, elementName, rootName);\n        this.roots.add(root);\n        return root;\n    }\n    /**\n     * Removes all event listeners set by the document instance.\n     */\n    destroy() {\n        this.selection.destroy();\n        this.stopListening();\n    }\n    /**\n     * Returns a root by its name.\n     *\n     * @param {String} [name='main'] A unique root name.\n     * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n     * there is no root with the given name.\n     */\n    getRoot(name = 'main') {\n        return this.roots.get(name);\n    }\n    /**\n     * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n     *\n     * @returns {Array.<String>} Roots names.\n     */\n    getRootNames() {\n        return Array.from(this.roots, root => root.rootName).filter(name => name != graveyardName);\n    }\n    /**\n     * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n     * will operate on a correct model state.\n     *\n     * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n     * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n     * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n     * not be fixed in the new document tree state.\n     *\n     * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n     * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n     * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n     * for the user.\n     *\n     * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n     * callback should add an empty paragraph so that the editor is never empty:\n     *\n     *\t\tdocument.registerPostFixer( writer => {\n     *\t\t\tconst changes = document.differ.getChanges();\n     *\n     *\t\t\t// Check if the changes lead to an empty root in the editor.\n     *\t\t\tfor ( const entry of changes ) {\n     *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n     *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n     *\n     *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n     *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n     *\t\t\t\t\treturn true;\n     *\t\t\t\t}\n     *\t\t\t}\n     *\n     *\t\t\treturn false;\n     *\t\t} );\n     *\n     * @param {Function} postFixer\n     */\n    registerPostFixer(postFixer) {\n        this._postFixers.add(postFixer);\n    }\n    /**\n     * A custom `toJSON()` method to solve child-parent circular dependencies.\n     *\n     * @returns {Object} A clone of this object with the document property changed to a string.\n     */\n    toJSON() {\n        const json = clone(this);\n        // Due to circular references we need to remove parent reference.\n        json.selection = '[engine.model.DocumentSelection]';\n        json.model = '[engine.model.Model]';\n        return json;\n    }\n    /**\n     * Check if there were any changes done on document, and if so, call post-fixers,\n     * fire `change` event for features and conversion and then reset the differ.\n     * Fire `change:data` event when at least one operation or buffered marker changes the data.\n     *\n     * @internal\n     * @protected\n     * @fires change\n     * @fires change:data\n     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n     */\n    _handleChangeBlock(writer) {\n        if (this._hasDocumentChangedFromTheLastChangeBlock()) {\n            this._callPostFixers(writer);\n            // Refresh selection attributes according to the final position in the model after the change.\n            this.selection.refresh();\n            if (this.differ.hasDataChanges()) {\n                this.fire('change:data', writer.batch);\n            }\n            else {\n                this.fire('change', writer.batch);\n            }\n            // Theoretically, it is not necessary to refresh selection after change event because\n            // post-fixers are the last who should change the model, but just in case...\n            this.selection.refresh();\n            this.differ.reset();\n        }\n        this._hasSelectionChangedFromTheLastChangeBlock = false;\n    }\n    /**\n     * Returns whether there is a buffered change or if the selection has changed from the last\n     * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n     * or {@link module:engine/model/model~Model#change `change()` block}.\n     *\n     * @protected\n     * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n     */\n    _hasDocumentChangedFromTheLastChangeBlock() {\n        return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n    }\n    /**\n     * Returns the default root for this document which is either the first root that was added to the document using\n     * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n     *\n     * @protected\n     * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n     */\n    _getDefaultRoot() {\n        for (const root of this.roots) {\n            if (root !== this.graveyard) {\n                return root;\n            }\n        }\n        return this.graveyard;\n    }\n    /**\n     * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n     * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n     *\n     * @internal\n     * @protected\n     * @returns {module:engine/model/range~Range}\n     */\n    _getDefaultRange() {\n        const defaultRoot = this._getDefaultRoot();\n        const model = this.model;\n        const schema = model.schema;\n        // Find the first position where the selection can be put.\n        const position = model.createPositionFromPath(defaultRoot, [0]);\n        const nearestRange = schema.getNearestSelectionRange(position);\n        // If valid selection range is not found - return range collapsed at the beginning of the root.\n        return nearestRange || model.createRange(position);\n    }\n    /**\n     * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n     * the {@link #selection document's selection}.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/range~Range} range A range to check.\n     * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n     */\n    _validateSelectionRange(range) {\n        return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);\n    }\n    /**\n     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n     *\n     * @private\n     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n     */\n    _callPostFixers(writer) {\n        let wasFixed = false;\n        do {\n            for (const callback of this._postFixers) {\n                // Ensure selection attributes are up to date before each post-fixer.\n                // https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n                //\n                // It might be good to refresh the selection after each operation but at the moment it leads\n                // to losing attributes for composition or and spell checking\n                // https://github.com/ckeditor/ckeditor5-typing/issues/188\n                this.selection.refresh();\n                wasFixed = callback(writer);\n                if (wasFixed) {\n                    break;\n                }\n            }\n        } while (wasFixed);\n    }\n}\n// Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\nfunction validateTextNodePosition(rangeBoundary) {\n    const textNode = rangeBoundary.textNode;\n    if (textNode) {\n        const data = textNode.data;\n        const offset = rangeBoundary.offset - textNode.startOffset;\n        return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);\n    }\n    return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}