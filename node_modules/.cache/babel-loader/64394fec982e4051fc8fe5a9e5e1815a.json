{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/mergeoperation\n */\nimport Operation from './operation';\nimport SplitOperation from './splitoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to merge two {@link module:engine/model/element~Element elements}.\n *\n * The merged element is the parent of {@link ~MergeOperation#sourcePosition} and it is merged into the parent of\n * {@link ~MergeOperation#targetPosition}. All nodes from the merged element are moved to {@link ~MergeOperation#targetPosition}.\n *\n * The merged element is moved to the graveyard at {@link ~MergeOperation#graveyardPosition}.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class MergeOperation extends Operation {\n  /**\n   * Creates a merge operation.\n   *\n   * @param {module:engine/model/position~Position} sourcePosition Position inside the merged element. All nodes from that\n   * element after that position will be moved to {@link ~#targetPosition}.\n   * @param {Number} howMany Summary offset size of nodes which will be moved from the merged element to the new parent.\n   * @param {module:engine/model/position~Position} targetPosition Position which the nodes from the merged elements will be moved to.\n   * @param {module:engine/model/position~Position} graveyardPosition Position in graveyard to which the merged element will be moved.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {\n    super(baseVersion);\n    /**\n     * Position inside the merged element. All nodes from that element after that position will be moved to {@link ~#targetPosition}.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#sourcePosition\n     */\n    this.sourcePosition = sourcePosition.clone();\n    // This is, and should always remain, the first position in its parent.\n    this.sourcePosition.stickiness = 'toPrevious';\n    /**\n     * Summary offset size of nodes which will be moved from the merged element to the new parent.\n     *\n     * @member {Number} module:engine/model/operation/mergeoperation~MergeOperation#howMany\n     */\n    this.howMany = howMany;\n    /**\n     * Position which the nodes from the merged elements will be moved to.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#targetPosition\n     */\n    this.targetPosition = targetPosition.clone();\n    // Except of a rare scenario in `MergeOperation` x `MergeOperation` transformation,\n    // this is, and should always remain, the last position in its parent.\n    this.targetPosition.stickiness = 'toNext';\n    /**\n     * Position in graveyard to which the merged element will be moved.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#graveyardPosition\n     */\n    this.graveyardPosition = graveyardPosition.clone();\n  }\n  /**\n   * @inheritDoc\n   */\n  get type() {\n    return 'merge';\n  }\n  /**\n   * Position before the merged element (which will be deleted).\n   *\n   * @readonly\n   * @type {module:engine/model/position~Position}\n   */\n  get deletionPosition() {\n    return new Position(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));\n  }\n  /**\n   * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.\n   * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n   *\n   * @readonly\n   * @type {module:engine/model/range~Range}\n   */\n  get movedRange() {\n    const end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);\n    return new Range(this.sourcePosition, end);\n  }\n  /**\n   * Creates and returns an operation that has the same parameters as this operation.\n   *\n   * @returns {module:engine/model/operation/mergeoperation~MergeOperation} Clone of this operation.\n   */\n  clone() {\n    return new MergeOperation(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);\n  }\n  /**\n   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n   *\n   * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n   */\n  getReversed() {\n    // Positions in this method are transformed by this merge operation because the split operation bases on\n    // the context after this merge operation happened (because split operation reverses it).\n    // So we need to acknowledge that the merge operation happened and those positions changed a little.\n    const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);\n    const path = this.sourcePosition.path.slice(0, -1);\n    const insertionPosition = new Position(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);\n    return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);\n  }\n  /**\n   * @inheritDoc\n   * @internal\n   */\n  _validate() {\n    const sourceElement = this.sourcePosition.parent;\n    const targetElement = this.targetPosition.parent;\n    // Validate whether merge operation has correct parameters.\n    if (!sourceElement.parent) {\n      /**\n       * Merge source position is invalid. The element to be merged must have a parent node.\n       *\n       * @error merge-operation-source-position-invalid\n       */\n      throw new CKEditorError('merge-operation-source-position-invalid', this);\n    } else if (!targetElement.parent) {\n      /**\n       * Merge target position is invalid. The element to be merged must have a parent node.\n       *\n       * @error merge-operation-target-position-invalid\n       */\n      throw new CKEditorError('merge-operation-target-position-invalid', this);\n    } else if (this.howMany != sourceElement.maxOffset) {\n      /**\n       * Merge operation specifies wrong number of nodes to move.\n       *\n       * @error merge-operation-how-many-invalid\n       */\n      throw new CKEditorError('merge-operation-how-many-invalid', this);\n    }\n  }\n  /**\n   * @inheritDoc\n   * @internal\n   */\n  _execute() {\n    const mergedElement = this.sourcePosition.parent;\n    const sourceRange = Range._createIn(mergedElement);\n    _move(sourceRange, this.targetPosition);\n    _move(Range._createOn(mergedElement), this.graveyardPosition);\n  }\n  /**\n   * @inheritDoc\n   */\n  toJSON() {\n    const json = super.toJSON();\n    json.sourcePosition = json.sourcePosition.toJSON();\n    json.targetPosition = json.targetPosition.toJSON();\n    json.graveyardPosition = json.graveyardPosition.toJSON();\n    return json;\n  }\n  /**\n   * @inheritDoc\n   */\n  static get className() {\n    return 'MergeOperation';\n  }\n  /**\n   * Creates `MergeOperation` object from deserilized object, i.e. from parsed JSON string.\n   *\n   * @param {Object} json Deserialized JSON object.\n   * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n   * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n   */\n  static fromJSON(json, document) {\n    const sourcePosition = Position.fromJSON(json.sourcePosition, document);\n    const targetPosition = Position.fromJSON(json.targetPosition, document);\n    const graveyardPosition = Position.fromJSON(json.graveyardPosition, document);\n    return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);\n  }\n}","map":{"version":3,"names":["Operation","SplitOperation","Position","Range","_move","CKEditorError","MergeOperation","constructor","sourcePosition","howMany","targetPosition","graveyardPosition","baseVersion","clone","stickiness","type","deletionPosition","root","path","slice","movedRange","end","getShiftedBy","Number","POSITIVE_INFINITY","getReversed","_getTransformedByMergeOperation","insertionPosition","_validate","sourceElement","parent","targetElement","maxOffset","_execute","mergedElement","sourceRange","_createIn","_createOn","toJSON","json","className","fromJSON","document"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/mergeoperation.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/mergeoperation\n */\nimport Operation from './operation';\nimport SplitOperation from './splitoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to merge two {@link module:engine/model/element~Element elements}.\n *\n * The merged element is the parent of {@link ~MergeOperation#sourcePosition} and it is merged into the parent of\n * {@link ~MergeOperation#targetPosition}. All nodes from the merged element are moved to {@link ~MergeOperation#targetPosition}.\n *\n * The merged element is moved to the graveyard at {@link ~MergeOperation#graveyardPosition}.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class MergeOperation extends Operation {\n    /**\n     * Creates a merge operation.\n     *\n     * @param {module:engine/model/position~Position} sourcePosition Position inside the merged element. All nodes from that\n     * element after that position will be moved to {@link ~#targetPosition}.\n     * @param {Number} howMany Summary offset size of nodes which will be moved from the merged element to the new parent.\n     * @param {module:engine/model/position~Position} targetPosition Position which the nodes from the merged elements will be moved to.\n     * @param {module:engine/model/position~Position} graveyardPosition Position in graveyard to which the merged element will be moved.\n     * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n     * can be applied or `null` if the operation operates on detached (non-document) tree.\n     */\n    constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {\n        super(baseVersion);\n        /**\n         * Position inside the merged element. All nodes from that element after that position will be moved to {@link ~#targetPosition}.\n         *\n         * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#sourcePosition\n         */\n        this.sourcePosition = sourcePosition.clone();\n        // This is, and should always remain, the first position in its parent.\n        this.sourcePosition.stickiness = 'toPrevious';\n        /**\n         * Summary offset size of nodes which will be moved from the merged element to the new parent.\n         *\n         * @member {Number} module:engine/model/operation/mergeoperation~MergeOperation#howMany\n         */\n        this.howMany = howMany;\n        /**\n         * Position which the nodes from the merged elements will be moved to.\n         *\n         * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#targetPosition\n         */\n        this.targetPosition = targetPosition.clone();\n        // Except of a rare scenario in `MergeOperation` x `MergeOperation` transformation,\n        // this is, and should always remain, the last position in its parent.\n        this.targetPosition.stickiness = 'toNext';\n        /**\n         * Position in graveyard to which the merged element will be moved.\n         *\n         * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#graveyardPosition\n         */\n        this.graveyardPosition = graveyardPosition.clone();\n    }\n    /**\n     * @inheritDoc\n     */\n    get type() {\n        return 'merge';\n    }\n    /**\n     * Position before the merged element (which will be deleted).\n     *\n     * @readonly\n     * @type {module:engine/model/position~Position}\n     */\n    get deletionPosition() {\n        return new Position(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));\n    }\n    /**\n     * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.\n     * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n     *\n     * @readonly\n     * @type {module:engine/model/range~Range}\n     */\n    get movedRange() {\n        const end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);\n        return new Range(this.sourcePosition, end);\n    }\n    /**\n     * Creates and returns an operation that has the same parameters as this operation.\n     *\n     * @returns {module:engine/model/operation/mergeoperation~MergeOperation} Clone of this operation.\n     */\n    clone() {\n        return new MergeOperation(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);\n    }\n    /**\n     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n     *\n     * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n     */\n    getReversed() {\n        // Positions in this method are transformed by this merge operation because the split operation bases on\n        // the context after this merge operation happened (because split operation reverses it).\n        // So we need to acknowledge that the merge operation happened and those positions changed a little.\n        const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);\n        const path = this.sourcePosition.path.slice(0, -1);\n        const insertionPosition = new Position(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);\n        return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);\n    }\n    /**\n     * @inheritDoc\n     * @internal\n     */\n    _validate() {\n        const sourceElement = this.sourcePosition.parent;\n        const targetElement = this.targetPosition.parent;\n        // Validate whether merge operation has correct parameters.\n        if (!sourceElement.parent) {\n            /**\n             * Merge source position is invalid. The element to be merged must have a parent node.\n             *\n             * @error merge-operation-source-position-invalid\n             */\n            throw new CKEditorError('merge-operation-source-position-invalid', this);\n        }\n        else if (!targetElement.parent) {\n            /**\n             * Merge target position is invalid. The element to be merged must have a parent node.\n             *\n             * @error merge-operation-target-position-invalid\n             */\n            throw new CKEditorError('merge-operation-target-position-invalid', this);\n        }\n        else if (this.howMany != sourceElement.maxOffset) {\n            /**\n             * Merge operation specifies wrong number of nodes to move.\n             *\n             * @error merge-operation-how-many-invalid\n             */\n            throw new CKEditorError('merge-operation-how-many-invalid', this);\n        }\n    }\n    /**\n     * @inheritDoc\n     * @internal\n     */\n    _execute() {\n        const mergedElement = this.sourcePosition.parent;\n        const sourceRange = Range._createIn(mergedElement);\n        _move(sourceRange, this.targetPosition);\n        _move(Range._createOn(mergedElement), this.graveyardPosition);\n    }\n    /**\n     * @inheritDoc\n     */\n    toJSON() {\n        const json = super.toJSON();\n        json.sourcePosition = json.sourcePosition.toJSON();\n        json.targetPosition = json.targetPosition.toJSON();\n        json.graveyardPosition = json.graveyardPosition.toJSON();\n        return json;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get className() {\n        return 'MergeOperation';\n    }\n    /**\n     * Creates `MergeOperation` object from deserilized object, i.e. from parsed JSON string.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n     * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n     */\n    static fromJSON(json, document) {\n        const sourcePosition = Position.fromJSON(json.sourcePosition, document);\n        const targetPosition = Position.fromJSON(json.targetPosition, document);\n        const graveyardPosition = Position.fromJSON(json.graveyardPosition, document);\n        return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,SAAS,MAAM,aAAa;AACnC,OAAOC,cAAc,MAAM,kBAAkB;AAC7C,OAAOC,QAAQ,MAAM,aAAa;AAClC,OAAOC,KAAK,MAAM,UAAU;AAC5B,SAASC,KAAK,QAAQ,SAAS;AAC/B,OAAOC,aAAa,MAAM,6CAA6C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,cAAc,SAASN,SAAS,CAAC;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,WAAW,CAACC,cAAc,EAAEC,OAAO,EAAEC,cAAc,EAAEC,iBAAiB,EAAEC,WAAW,EAAE;IACjF,KAAK,CAACA,WAAW,CAAC;IAClB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACJ,cAAc,GAAGA,cAAc,CAACK,KAAK,EAAE;IAC5C;IACA,IAAI,CAACL,cAAc,CAACM,UAAU,GAAG,YAAY;IAC7C;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACL,OAAO,GAAGA,OAAO;IACtB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAGA,cAAc,CAACG,KAAK,EAAE;IAC5C;IACA;IACA,IAAI,CAACH,cAAc,CAACI,UAAU,GAAG,QAAQ;IACzC;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACH,iBAAiB,GAAGA,iBAAiB,CAACE,KAAK,EAAE;EACtD;EACA;AACJ;AACA;EACI,IAAIE,IAAI,GAAG;IACP,OAAO,OAAO;EAClB;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,gBAAgB,GAAG;IACnB,OAAO,IAAId,QAAQ,CAAC,IAAI,CAACM,cAAc,CAACS,IAAI,EAAE,IAAI,CAACT,cAAc,CAACU,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACxF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAG;IACb,MAAMC,GAAG,GAAG,IAAI,CAACb,cAAc,CAACc,YAAY,CAACC,MAAM,CAACC,iBAAiB,CAAC;IACtE,OAAO,IAAIrB,KAAK,CAAC,IAAI,CAACK,cAAc,EAAEa,GAAG,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;EACIR,KAAK,GAAG;IACJ,OAAO,IAAIP,cAAc,CAAC,IAAI,CAACE,cAAc,EAAE,IAAI,CAACC,OAAO,EAAE,IAAI,CAACC,cAAc,EAAE,IAAI,CAACC,iBAAiB,EAAE,IAAI,CAACC,WAAW,CAAC;EAC/H;EACA;AACJ;AACA;AACA;AACA;EACIa,WAAW,GAAG;IACV;IACA;IACA;IACA,MAAMf,cAAc,GAAG,IAAI,CAACA,cAAc,CAACgB,+BAA+B,CAAC,IAAI,CAAC;IAChF,MAAMR,IAAI,GAAG,IAAI,CAACV,cAAc,CAACU,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAClD,MAAMQ,iBAAiB,GAAG,IAAIzB,QAAQ,CAAC,IAAI,CAACM,cAAc,CAACS,IAAI,EAAEC,IAAI,CAAC,CAACQ,+BAA+B,CAAC,IAAI,CAAC;IAC5G,OAAO,IAAIzB,cAAc,CAACS,cAAc,EAAE,IAAI,CAACD,OAAO,EAAEkB,iBAAiB,EAAE,IAAI,CAAChB,iBAAiB,EAAE,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;EAC5H;EACA;AACJ;AACA;AACA;EACIgB,SAAS,GAAG;IACR,MAAMC,aAAa,GAAG,IAAI,CAACrB,cAAc,CAACsB,MAAM;IAChD,MAAMC,aAAa,GAAG,IAAI,CAACrB,cAAc,CAACoB,MAAM;IAChD;IACA,IAAI,CAACD,aAAa,CAACC,MAAM,EAAE;MACvB;AACZ;AACA;AACA;AACA;MACY,MAAM,IAAIzB,aAAa,CAAC,yCAAyC,EAAE,IAAI,CAAC;IAC5E,CAAC,MACI,IAAI,CAAC0B,aAAa,CAACD,MAAM,EAAE;MAC5B;AACZ;AACA;AACA;AACA;MACY,MAAM,IAAIzB,aAAa,CAAC,yCAAyC,EAAE,IAAI,CAAC;IAC5E,CAAC,MACI,IAAI,IAAI,CAACI,OAAO,IAAIoB,aAAa,CAACG,SAAS,EAAE;MAC9C;AACZ;AACA;AACA;AACA;MACY,MAAM,IAAI3B,aAAa,CAAC,kCAAkC,EAAE,IAAI,CAAC;IACrE;EACJ;EACA;AACJ;AACA;AACA;EACI4B,QAAQ,GAAG;IACP,MAAMC,aAAa,GAAG,IAAI,CAAC1B,cAAc,CAACsB,MAAM;IAChD,MAAMK,WAAW,GAAGhC,KAAK,CAACiC,SAAS,CAACF,aAAa,CAAC;IAClD9B,KAAK,CAAC+B,WAAW,EAAE,IAAI,CAACzB,cAAc,CAAC;IACvCN,KAAK,CAACD,KAAK,CAACkC,SAAS,CAACH,aAAa,CAAC,EAAE,IAAI,CAACvB,iBAAiB,CAAC;EACjE;EACA;AACJ;AACA;EACI2B,MAAM,GAAG;IACL,MAAMC,IAAI,GAAG,KAAK,CAACD,MAAM,EAAE;IAC3BC,IAAI,CAAC/B,cAAc,GAAG+B,IAAI,CAAC/B,cAAc,CAAC8B,MAAM,EAAE;IAClDC,IAAI,CAAC7B,cAAc,GAAG6B,IAAI,CAAC7B,cAAc,CAAC4B,MAAM,EAAE;IAClDC,IAAI,CAAC5B,iBAAiB,GAAG4B,IAAI,CAAC5B,iBAAiB,CAAC2B,MAAM,EAAE;IACxD,OAAOC,IAAI;EACf;EACA;AACJ;AACA;EACI,WAAWC,SAAS,GAAG;IACnB,OAAO,gBAAgB;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,QAAQ,CAACF,IAAI,EAAEG,QAAQ,EAAE;IAC5B,MAAMlC,cAAc,GAAGN,QAAQ,CAACuC,QAAQ,CAACF,IAAI,CAAC/B,cAAc,EAAEkC,QAAQ,CAAC;IACvE,MAAMhC,cAAc,GAAGR,QAAQ,CAACuC,QAAQ,CAACF,IAAI,CAAC7B,cAAc,EAAEgC,QAAQ,CAAC;IACvE,MAAM/B,iBAAiB,GAAGT,QAAQ,CAACuC,QAAQ,CAACF,IAAI,CAAC5B,iBAAiB,EAAE+B,QAAQ,CAAC;IAC7E,OAAO,IAAI,IAAI,CAAClC,cAAc,EAAE+B,IAAI,CAAC9B,OAAO,EAAEC,cAAc,EAAEC,iBAAiB,EAAE4B,IAAI,CAAC3B,WAAW,CAAC;EACtG;AACJ"},"metadata":{},"sourceType":"module"}