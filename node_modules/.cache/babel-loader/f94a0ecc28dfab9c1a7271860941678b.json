{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/range\n */\nimport TypeCheckable from './typecheckable';\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\nexport default class Range extends TypeCheckable {\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * @param {module:engine/model/position~Position} start The start position.\n   * @param {module:engine/model/position~Position|null} [end] The end position. If not set,\n   * the range will be collapsed at the `start` position.\n   */\n  constructor(start, end) {\n    super();\n    /**\n     * Start position.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position}\n     */\n    this.start = Position._createAt(start);\n    /**\n     * End position.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position}\n     */\n    this.end = end ? Position._createAt(end) : Position._createAt(start);\n    // If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n    // In other case, make the boundaries stick to the \"inside\" of the range.\n    this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n    this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n   * them together with additional information like length or {@link module:engine/model/position~Position positions},\n   * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n   * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n   * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n   *\n   * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n   * and `ignoreElementEnd` option set to `true`.\n   *\n   * @returns {Iterator.<module:engine/model/treewalker~TreeWalkerValue>}\n   */\n  *[Symbol.iterator]() {\n    yield* new TreeWalker({\n      boundaries: this,\n      ignoreElementEnd: true\n    });\n  }\n  /**\n   * Returns whether the range is collapsed, that is if {@link #start} and\n   * {@link #end} positions are equal.\n   *\n   * @type {Boolean}\n   */\n  get isCollapsed() {\n    return this.start.isEqual(this.end);\n  }\n  /**\n   * Returns whether this range is flat, that is if {@link #start} position and\n   * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n   *\n   * @type {Boolean}\n   */\n  get isFlat() {\n    const startParentPath = this.start.getParentPath();\n    const endParentPath = this.end.getParentPath();\n    return compareArrays(startParentPath, endParentPath) == 'same';\n  }\n  /**\n   * Range root element.\n   *\n   * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n   */\n  get root() {\n    return this.start.root;\n  }\n  /**\n   * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n   *\n   * @param {module:engine/model/position~Position} position Position to check.\n   * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n   * in this range,`false` otherwise.\n   */\n  containsPosition(position) {\n    return position.isAfter(this.start) && position.isBefore(this.end);\n  }\n  /**\n   * Checks whether this range contains given {@link ~Range range}.\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to check.\n   * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n   * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n   */\n  containsRange(otherRange) {\n    let loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (otherRange.isCollapsed) {\n      loose = false;\n    }\n    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);\n    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);\n    return containsStart && containsEnd;\n  }\n  /**\n   * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n   *\n   * @param {module:engine/model/item~Item} item Model item to check.\n   */\n  containsItem(item) {\n    const pos = Position._createBefore(item);\n    return this.containsPosition(pos) || this.start.isEqual(pos);\n  }\n  /**\n   * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n   */\n  isEqual(otherRange) {\n    return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);\n  }\n  /**\n   * Checks and returns whether this range intersects with given range.\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n   */\n  isIntersecting(otherRange) {\n    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n  }\n  /**\n   * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n   * Returned array contains zero, one or two {@link ~Range ranges}.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n   *\t\tlet transformed = range.getDifference( otherRange );\n   *\t\t// transformed array has no ranges because `otherRange` contains `range`\n   *\n   *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n   *\n   *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n   * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n   */\n  getDifference(otherRange) {\n    const ranges = [];\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect.\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means that we have to\n        // add shrunken range - from the start to the middle of this range.\n        ranges.push(new Range(this.start, otherRange.start));\n      }\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // add shrunken range - from the middle of this range to the end.\n        ranges.push(new Range(otherRange.end, this.end));\n      }\n    } else {\n      // Ranges do not intersect, return the original range.\n      ranges.push(new Range(this.start, this.end));\n    }\n    return ranges;\n  }\n  /**\n   * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n   *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n   *\n   *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n   *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n   * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n   */\n  getIntersection(otherRange) {\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect, so a common range will be returned.\n      // At most, it will be same as this range.\n      let commonRangeStart = this.start;\n      let commonRangeEnd = this.end;\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means thaNt we have to\n        // shrink common range to the given range start.\n        commonRangeStart = otherRange.start;\n      }\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // shrink common range to the given range end.\n        commonRangeEnd = otherRange.end;\n      }\n      return new Range(commonRangeStart, commonRangeEnd);\n    }\n    // Ranges do not intersect, so they do not have common part.\n    return null;\n  }\n  /**\n   * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.\n   * If ranges have no common part, returns `null`.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet otherRange = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 1 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 2 ] )\n   *\t\t);\n   *\t\tlet transformed = range.getJoined( otherRange ); // null - ranges have no common part\n   *\n   *\t\totherRange = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 3 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 5 ] )\n   *\t\t);\n   *\t\ttransformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to be joined.\n   * @param {Boolean} [loose=false] Whether the intersection check is loose or strict. If the check is strict (`false`),\n   * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),\n   * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.\n   * @returns {module:engine/model/range~Range|null} A sum of given ranges or `null` if ranges have no common part.\n   */\n  getJoined(otherRange) {\n    let loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let shouldJoin = this.isIntersecting(otherRange);\n    if (!shouldJoin) {\n      if (this.start.isBefore(otherRange.start)) {\n        shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);\n      } else {\n        shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);\n      }\n    }\n    if (!shouldJoin) {\n      return null;\n    }\n    let startPosition = this.start;\n    let endPosition = this.end;\n    if (otherRange.start.isBefore(startPosition)) {\n      startPosition = otherRange.start;\n    }\n    if (otherRange.end.isAfter(endPosition)) {\n      endPosition = otherRange.end;\n    }\n    return new Range(startPosition, endPosition);\n  }\n  /**\n   * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n   *\n   * See an example of a model structure (`[` and `]` are range boundaries):\n   *\n   *\t\troot                                                            root\n   *\t\t |- element DIV                         DIV             P2              P3             DIV\n   *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n   *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n   *\t\t |   |- element P1\n   *\t\t |   |   |- \"lorem\"                                              ||\n   *\t\t |- element P2                                                   ||\n   *\t\t |   |- \"foo\"                                                    VV\n   *\t\t |- element P3\n   *\t\t |   |- \"bar\"                                                   root\n   *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n   *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n   *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n   *\t\t |   |- element P4\n   *\t\t |   |   |- \"ipsum\"\n   *\n   * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n   * We are looking for minimal set of flat ranges that contains the same nodes.\n   *\n   * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n   *\n   *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n   *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n   *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n   *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n   *\n   * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n   * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n   * were omitted. Only their parts that were wholly in the range were returned.\n   *\n   * **Note:** this method is not returning flat ranges that contain no nodes.\n   *\n   * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n   */\n  getMinimalFlatRanges() {\n    const ranges = [];\n    const diffAt = this.start.getCommonPath(this.end).length;\n    const pos = Position._createAt(this.start);\n    let posParent = pos.parent;\n    // Go up.\n    while (pos.path.length > diffAt + 1) {\n      const howMany = posParent.maxOffset - pos.offset;\n      if (howMany !== 0) {\n        ranges.push(new Range(pos, pos.getShiftedBy(howMany)));\n      }\n      pos.path = pos.path.slice(0, -1);\n      pos.offset++;\n      posParent = posParent.parent;\n    }\n    // Go down.\n    while (pos.path.length <= this.end.path.length) {\n      const offset = this.end.path[pos.path.length - 1];\n      const howMany = offset - pos.offset;\n      if (howMany !== 0) {\n        ranges.push(new Range(pos, pos.getShiftedBy(howMany)));\n      }\n      pos.offset = offset;\n      pos.path.push(0);\n    }\n    return ranges;\n  }\n  /**\n   * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n   *\n   * For example, to iterate over all items in the entire document root:\n   *\n   *\t\t// Create a range spanning over the entire root content:\n   *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n   *\n   *\t\t// Iterate over all items in this range:\n   *\t\tfor ( const value of range.getWalker() ) {\n   *\t\t\tconsole.log( value.item );\n   *\t\t}\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   * @param {module:engine/model/position~Position} [options.startPosition]\n   * @param {Boolean} [options.singleCharacters=false]\n   * @param {Boolean} [options.shallow=false]\n   * @param {Boolean} [options.ignoreElementEnd=false]\n   * @returns {module:engine/model/treewalker~TreeWalker}\n   */\n  getWalker() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    return new TreeWalker(options);\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n   * them.\n   *\n   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n   * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n   * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} [options] Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/model/item~Item>}\n   */\n  *getItems() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    options.ignoreElementEnd = true;\n    const treeWalker = new TreeWalker(options);\n    for (const value of treeWalker) {\n      yield value.item;\n    }\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n   * contained in this range.\n   *\n   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n   * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/model/position~Position>}\n   */\n  *getPositions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    const treeWalker = new TreeWalker(options);\n    yield treeWalker.position;\n    for (const value of treeWalker) {\n      yield value.nextPosition;\n    }\n  }\n  /**\n   * Returns a range that is a result of transforming this range by given `operation`.\n   *\n   * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n   * moved to a different part of document tree). For this reason, an array is returned by this method and it\n   * may contain one or more `Range` instances.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n   * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n   */\n  getTransformedByOperation(operation) {\n    switch (operation.type) {\n      case 'insert':\n        return this._getTransformedByInsertOperation(operation);\n      case 'move':\n      case 'remove':\n      case 'reinsert':\n        return this._getTransformedByMoveOperation(operation);\n      case 'split':\n        return [this._getTransformedBySplitOperation(operation)];\n      case 'merge':\n        return [this._getTransformedByMergeOperation(operation)];\n    }\n    return [new Range(this.start, this.end)];\n  }\n  /**\n   * Returns a range that is a result of transforming this range by multiple `operations`.\n   *\n   * @see ~Range#getTransformedByOperation\n   * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n   * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n   */\n  getTransformedByOperations(operations) {\n    const ranges = [new Range(this.start, this.end)];\n    for (const operation of operations) {\n      for (let i = 0; i < ranges.length; i++) {\n        const result = ranges[i].getTransformedByOperation(operation);\n        ranges.splice(i, 1, ...result);\n        i += result.length - 1;\n      }\n    }\n    // It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n    // \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n    // because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n    // are inside other ranges and we simply remove them.\n    for (let i = 0; i < ranges.length; i++) {\n      const range = ranges[i];\n      for (let j = i + 1; j < ranges.length; j++) {\n        const next = ranges[j];\n        if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {\n          ranges.splice(j, 1);\n        }\n      }\n    }\n    return ranges;\n  }\n  /**\n   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n   * which is a common ancestor of the range's both ends (in which the entire range is contained).\n   *\n   * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n  getCommonAncestor() {\n    return this.start.getCommonAncestor(this.end);\n  }\n  /**\n   * Returns an {@link module:engine/model/element~Element Element} contained by the range.\n   * The element will be returned when it is the **only** node within the range and **fully–contained**\n   * at the same time.\n   *\n   * @returns {module:engine/model/element~Element|null}\n   */\n  getContainedElement() {\n    if (this.isCollapsed) {\n      return null;\n    }\n    const nodeAfterStart = this.start.nodeAfter;\n    const nodeBeforeEnd = this.end.nodeBefore;\n    if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n      return nodeAfterStart;\n    }\n    return null;\n  }\n  /**\n   * Converts `Range` to plain object and returns it.\n   *\n   * @returns {Object} `Node` converted to plain object.\n   */\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n  /**\n   * Returns a new range that is equal to current range.\n   *\n   * @returns {module:engine/model/range~Range}\n   */\n  clone() {\n    return new this.constructor(this.start, this.end);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by insert operation.\n   *\n   * One or more ranges may be returned as a result of this transformation.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n   * @returns {Array.<module:engine/model/range~Range>}\n   */\n  _getTransformedByInsertOperation(operation) {\n    let spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._getTransformedByInsertion(operation.position, operation.howMany, spread);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by move operation.\n   *\n   * One or more ranges may be returned as a result of this transformation.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n   * @returns {Array.<module:engine/model/range~Range>}\n   */\n  _getTransformedByMoveOperation(operation) {\n    let spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const sourcePosition = operation.sourcePosition;\n    const howMany = operation.howMany;\n    const targetPosition = operation.targetPosition;\n    return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by split operation.\n   *\n   * Always one range is returned. The transformation is done in a way to not break the range.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n   * @returns {module:engine/model/range~Range}\n   */\n  _getTransformedBySplitOperation(operation) {\n    const start = this.start._getTransformedBySplitOperation(operation);\n    let end = this.end._getTransformedBySplitOperation(operation);\n    if (this.end.isEqual(operation.insertionPosition)) {\n      end = this.end.getShiftedBy(1);\n    }\n    // Below may happen when range contains graveyard element used by split operation.\n    if (start.root != end.root) {\n      // End position was next to the moved graveyard element and was moved with it.\n      // Fix it by using old `end` which has proper `root`.\n      end = this.end.getShiftedBy(-1);\n    }\n    return new Range(start, end);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by merge operation.\n   *\n   * Always one range is returned. The transformation is done in a way to not break the range.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n   * @returns {module:engine/model/range~Range}\n   */\n  _getTransformedByMergeOperation(operation) {\n    // Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n    // transformations, especially when a content of a few block elements were removed. For example:\n    //\n    // {} is the transformed range, [] is the removed range.\n    // <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n    //\n    // <p>Fo{o</p><p>B}ar</p><p>z</p>\n    // <p>F{</p><p>B}ar</p><p>z</p>\n    // <p>F{</p>}<p>z</p>\n    // <p>F{}z</p>\n    //\n    if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {\n      return new Range(this.start);\n    }\n    let start = this.start._getTransformedByMergeOperation(operation);\n    let end = this.end._getTransformedByMergeOperation(operation);\n    if (start.root != end.root) {\n      // This happens when the end position was next to the merged (deleted) element.\n      // Then, the end position was moved to the graveyard root. In this case we need to fix\n      // the range cause its boundaries would be in different roots.\n      end = this.end.getShiftedBy(-1);\n    }\n    if (start.isAfter(end)) {\n      // This happens in three following cases:\n      //\n      // Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n      //         This means that start can be moved before the end of the range.\n      //\n      // Before: <p>a{a</p><p>b}b</p><p>cc</p>\n      // Merge:  <p>b}b</p><p>cca{a</p>\n      // Fix:    <p>{b}b</p><p>ccaa</p>\n      //\n      // Case 2: Range start is before merged node but not directly.\n      //         Result should include all nodes that were in the original range.\n      //\n      // Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n      // Merge:  <p>aab}b</p>{<p>cc</p>\n      // Fix:    <p>aa{bb</p><p>cc</p>}\n      //\n      //         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n      //\n      // Case 3: Range start is directly before merged node.\n      //         Resulting range should include only nodes from the merged element:\n      //\n      // Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n      // Merge:  <p>aab}b</p>{<p>cc</p>\n      // Fix:    <p>aa{b}b</p><p>cc</p>\n      //\n      if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n        // Case 1.\n        start = Position._createAt(end);\n        start.offset = 0;\n      } else {\n        if (!operation.deletionPosition.isEqual(start)) {\n          // Case 2.\n          end = operation.deletionPosition;\n        }\n        // In both case 2 and 3 start is at the end of the merge-to element.\n        start = operation.targetPosition;\n      }\n      return new Range(start, end);\n    }\n    return new Range(start, end);\n  }\n  /**\n   * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n   * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n   * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n   *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n   *\n   *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n   *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n   *\n   *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n   *\t\t// transformed array has one range, which is equal to original range\n   *\n   *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n   *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n   * @param {Number} howMany How many nodes are inserted.\n   * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n   * was inside the range. Defaults to `false`.\n   * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n   */\n  _getTransformedByInsertion(insertPosition, howMany) {\n    let spread = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (spread && this.containsPosition(insertPosition)) {\n      // Range has to be spread. The first part is from original start to the spread point.\n      // The other part is from spread point to the original end, but transformed by\n      // insertion to reflect insertion changes.\n      return [new Range(this.start, insertPosition), new Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))];\n    } else {\n      const range = new Range(this.start, this.end);\n      range.start = range.start._getTransformedByInsertion(insertPosition, howMany);\n      range.end = range.end._getTransformedByInsertion(insertPosition, howMany);\n      return [range];\n    }\n  }\n  /**\n   * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n   * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n   * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n   * @param {Number} howMany How many nodes are moved.\n   * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n   * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n   */\n  _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n    let spread = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    // Special case for transforming a collapsed range. Just transform it like a position.\n    if (this.isCollapsed) {\n      const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n      return [new Range(newPos)];\n    }\n    // Special case for transformation when a part of the range is moved towards the range.\n    //\n    // Examples:\n    //\n    // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n    // <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n    //\n    // Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n    //\n    // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n    //\n    // This special case is applied only if the range is to be kept together (not spread).\n    const moveRange = Range._createFromPositionAndShift(sourcePosition, howMany);\n    const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n    if (this.containsPosition(targetPosition) && !spread) {\n      if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {\n        const start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n        const end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);\n        return [new Range(start, end)];\n      }\n    }\n    // Default algorithm.\n    let result;\n    const differenceSet = this.getDifference(moveRange);\n    let difference = null;\n    const common = this.getIntersection(moveRange);\n    if (differenceSet.length == 1) {\n      // `moveRange` and this range may intersect but may be separate.\n      difference = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));\n    } else if (differenceSet.length == 2) {\n      // `moveRange` is inside this range.\n      difference = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));\n    } // else, `moveRange` contains this range.\n    if (difference) {\n      result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);\n    } else {\n      result = [];\n    }\n    if (common) {\n      const transformedCommon = new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));\n      if (result.length == 2) {\n        result.splice(1, 0, transformedCommon);\n      } else {\n        result.push(transformedCommon);\n      }\n    }\n    return result;\n  }\n  /**\n   * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n   *\n   * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n   *\n   * If the deleted range contains transformed range, `null` will be returned.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n   * @param {Number} howMany How many nodes are removed.\n   * @returns {module:engine/model/range~Range|null} Result of the transformation.\n   */\n  _getTransformedByDeletion(deletePosition, howMany) {\n    let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);\n    let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);\n    if (newStart == null && newEnd == null) {\n      return null;\n    }\n    if (newStart == null) {\n      newStart = deletePosition;\n    }\n    if (newEnd == null) {\n      newEnd = deletePosition;\n    }\n    return new Range(newStart, newEnd);\n  }\n  /**\n   * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/position~Position} position Beginning of the range.\n   * @param {Number} shift How long the range should be.\n   * @returns {module:engine/model/range~Range}\n   */\n  static _createFromPositionAndShift(position, shift) {\n    const start = position;\n    const end = position.getShiftedBy(shift);\n    return shift > 0 ? new this(start, end) : new this(end, start);\n  }\n  /**\n   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n  static _createIn(element) {\n    return new this(Position._createAt(element, 0), Position._createAt(element, element.maxOffset));\n  }\n  /**\n   * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/item~Item} item\n   * @returns {module:engine/model/range~Range}\n   */\n  static _createOn(item) {\n    return this._createFromPositionAndShift(Position._createBefore(item), item.offsetSize);\n  }\n  /**\n   * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n   * Passed ranges must not have common parts.\n   *\n   * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n   * the reference range, they get combined into one range.\n   *\n   *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n   *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n   *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n   *\t                                           [  ]  // The result of the function if the last range was a reference range.\n   *\n   * @internal\n   * @protected\n   * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n   * @returns {module:engine/model/range~Range} Combined range.\n   */\n  static _createFromRanges(ranges) {\n    if (ranges.length === 0) {\n      /**\n       * At least one range has to be passed to\n       * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n       *\n       * @error range-create-from-ranges-empty-array\n       */\n      throw new CKEditorError('range-create-from-ranges-empty-array', null);\n    } else if (ranges.length == 1) {\n      return ranges[0].clone();\n    }\n    // 1. Set the first range in `ranges` array as a reference range.\n    // If we are going to return just a one range, one of the ranges need to be the reference one.\n    // Other ranges will be stuck to that range, if possible.\n    const ref = ranges[0];\n    // 2. Sort all the ranges so it's easier to process them.\n    ranges.sort((a, b) => {\n      return a.start.isAfter(b.start) ? 1 : -1;\n    });\n    // 3. Check at which index the reference range is now.\n    const refIndex = ranges.indexOf(ref);\n    // 4. At this moment we don't need the original range.\n    // We are going to modify the result and we need to return a new instance of Range.\n    // We have to create a copy of the reference range.\n    const result = new this(ref.start, ref.end);\n    // 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n    // Since ranges are sorted, start with the range with index that is closest to reference range index.\n    if (refIndex > 0) {\n      // eslint-disable-next-line no-constant-condition\n      for (let i = refIndex - 1; true; i++) {\n        if (ranges[i].end.isEqual(result.start)) {\n          result.start = Position._createAt(ranges[i].start);\n        } else {\n          // If ranges are not starting/ending at the same position there is no point in looking further.\n          break;\n        }\n      }\n    }\n    // 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n    // Since ranges are sorted, start with the range with index that is closest to reference range index.\n    for (let i = refIndex + 1; i < ranges.length; i++) {\n      if (ranges[i].start.isEqual(result.end)) {\n        result.end = Position._createAt(ranges[i].end);\n      } else {\n        // If ranges are not starting/ending at the same position there is no point in looking further.\n        break;\n      }\n    }\n    return result;\n  }\n  /**\n   * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n   *\n   * @param {Object} json Plain object to be converted to `Range`.\n   * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n   * @returns {module:engine/model/range~Range} `Range` instance created using given plain object.\n   */\n  static fromJSON(json, doc) {\n    return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\trange.is( 'range' ); // -> true\n *\t\trange.is( 'model:range' ); // -> true\n *\n *\t\trange.is( 'view:range' ); // -> false\n *\t\trange.is( 'documentSelection' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nRange.prototype.is = function (type) {\n  return type === 'range' || type === 'model:range';\n};","map":{"version":3,"names":["TypeCheckable","Position","TreeWalker","CKEditorError","compareArrays","Range","constructor","start","end","_createAt","stickiness","isCollapsed","Symbol","iterator","boundaries","ignoreElementEnd","isEqual","isFlat","startParentPath","getParentPath","endParentPath","root","containsPosition","position","isAfter","isBefore","containsRange","otherRange","loose","containsStart","containsEnd","containsItem","item","pos","_createBefore","isIntersecting","getDifference","ranges","push","getIntersection","commonRangeStart","commonRangeEnd","getJoined","shouldJoin","isTouching","startPosition","endPosition","getMinimalFlatRanges","diffAt","getCommonPath","length","posParent","parent","path","howMany","maxOffset","offset","getShiftedBy","slice","getWalker","options","getItems","treeWalker","value","getPositions","nextPosition","getTransformedByOperation","operation","type","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","getTransformedByOperations","operations","i","result","splice","range","j","next","getCommonAncestor","getContainedElement","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","is","toJSON","clone","spread","_getTransformedByInsertion","sourcePosition","targetPosition","_getTransformedByMove","insertionPosition","deletionPosition","insertPosition","newPos","moveRange","_createFromPositionAndShift","_getTransformedByDeletion","differenceSet","difference","common","transformedCommon","_getCombined","deletePosition","newStart","newEnd","shift","_createIn","element","_createOn","offsetSize","_createFromRanges","ref","sort","a","b","refIndex","indexOf","fromJSON","json","doc","prototype"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/range\n */\nimport TypeCheckable from './typecheckable';\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\nexport default class Range extends TypeCheckable {\n    /**\n     * Creates a range spanning from `start` position to `end` position.\n     *\n     * @param {module:engine/model/position~Position} start The start position.\n     * @param {module:engine/model/position~Position|null} [end] The end position. If not set,\n     * the range will be collapsed at the `start` position.\n     */\n    constructor(start, end) {\n        super();\n        /**\n         * Start position.\n         *\n         * @readonly\n         * @member {module:engine/model/position~Position}\n         */\n        this.start = Position._createAt(start);\n        /**\n         * End position.\n         *\n         * @readonly\n         * @member {module:engine/model/position~Position}\n         */\n        this.end = end ? Position._createAt(end) : Position._createAt(start);\n        // If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n        // In other case, make the boundaries stick to the \"inside\" of the range.\n        this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n        this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n    }\n    /**\n     * Iterable interface.\n     *\n     * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n     * them together with additional information like length or {@link module:engine/model/position~Position positions},\n     * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n     * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n     * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n     *\n     * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n     * and `ignoreElementEnd` option set to `true`.\n     *\n     * @returns {Iterator.<module:engine/model/treewalker~TreeWalkerValue>}\n     */\n    *[Symbol.iterator]() {\n        yield* new TreeWalker({ boundaries: this, ignoreElementEnd: true });\n    }\n    /**\n     * Returns whether the range is collapsed, that is if {@link #start} and\n     * {@link #end} positions are equal.\n     *\n     * @type {Boolean}\n     */\n    get isCollapsed() {\n        return this.start.isEqual(this.end);\n    }\n    /**\n     * Returns whether this range is flat, that is if {@link #start} position and\n     * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n     *\n     * @type {Boolean}\n     */\n    get isFlat() {\n        const startParentPath = this.start.getParentPath();\n        const endParentPath = this.end.getParentPath();\n        return compareArrays(startParentPath, endParentPath) == 'same';\n    }\n    /**\n     * Range root element.\n     *\n     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     */\n    get root() {\n        return this.start.root;\n    }\n    /**\n     * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n     *\n     * @param {module:engine/model/position~Position} position Position to check.\n     * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n     * in this range,`false` otherwise.\n     */\n    containsPosition(position) {\n        return position.isAfter(this.start) && position.isBefore(this.end);\n    }\n    /**\n     * Checks whether this range contains given {@link ~Range range}.\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to check.\n     * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n     * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n     */\n    containsRange(otherRange, loose = false) {\n        if (otherRange.isCollapsed) {\n            loose = false;\n        }\n        const containsStart = this.containsPosition(otherRange.start) || (loose && this.start.isEqual(otherRange.start));\n        const containsEnd = this.containsPosition(otherRange.end) || (loose && this.end.isEqual(otherRange.end));\n        return containsStart && containsEnd;\n    }\n    /**\n     * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n     *\n     * @param {module:engine/model/item~Item} item Model item to check.\n     */\n    containsItem(item) {\n        const pos = Position._createBefore(item);\n        return this.containsPosition(pos) || this.start.isEqual(pos);\n    }\n    /**\n     * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n     */\n    isEqual(otherRange) {\n        return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);\n    }\n    /**\n     * Checks and returns whether this range intersects with given range.\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n     */\n    isIntersecting(otherRange) {\n        return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n    }\n    /**\n     * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n     * Returned array contains zero, one or two {@link ~Range ranges}.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n     *\t\tlet transformed = range.getDifference( otherRange );\n     *\t\t// transformed array has no ranges because `otherRange` contains `range`\n     *\n     *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n     *\n     *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n     * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n     */\n    getDifference(otherRange) {\n        const ranges = [];\n        if (this.isIntersecting(otherRange)) {\n            // Ranges intersect.\n            if (this.containsPosition(otherRange.start)) {\n                // Given range start is inside this range. This means that we have to\n                // add shrunken range - from the start to the middle of this range.\n                ranges.push(new Range(this.start, otherRange.start));\n            }\n            if (this.containsPosition(otherRange.end)) {\n                // Given range end is inside this range. This means that we have to\n                // add shrunken range - from the middle of this range to the end.\n                ranges.push(new Range(otherRange.end, this.end));\n            }\n        }\n        else {\n            // Ranges do not intersect, return the original range.\n            ranges.push(new Range(this.start, this.end));\n        }\n        return ranges;\n    }\n    /**\n     * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n     *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n     *\n     *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n     *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n     * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n     */\n    getIntersection(otherRange) {\n        if (this.isIntersecting(otherRange)) {\n            // Ranges intersect, so a common range will be returned.\n            // At most, it will be same as this range.\n            let commonRangeStart = this.start;\n            let commonRangeEnd = this.end;\n            if (this.containsPosition(otherRange.start)) {\n                // Given range start is inside this range. This means thaNt we have to\n                // shrink common range to the given range start.\n                commonRangeStart = otherRange.start;\n            }\n            if (this.containsPosition(otherRange.end)) {\n                // Given range end is inside this range. This means that we have to\n                // shrink common range to the given range end.\n                commonRangeEnd = otherRange.end;\n            }\n            return new Range(commonRangeStart, commonRangeEnd);\n        }\n        // Ranges do not intersect, so they do not have common part.\n        return null;\n    }\n    /**\n     * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.\n     * If ranges have no common part, returns `null`.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet otherRange = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 1 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 2 ] )\n     *\t\t);\n     *\t\tlet transformed = range.getJoined( otherRange ); // null - ranges have no common part\n     *\n     *\t\totherRange = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 3 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 5 ] )\n     *\t\t);\n     *\t\ttransformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to be joined.\n     * @param {Boolean} [loose=false] Whether the intersection check is loose or strict. If the check is strict (`false`),\n     * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),\n     * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.\n     * @returns {module:engine/model/range~Range|null} A sum of given ranges or `null` if ranges have no common part.\n     */\n    getJoined(otherRange, loose = false) {\n        let shouldJoin = this.isIntersecting(otherRange);\n        if (!shouldJoin) {\n            if (this.start.isBefore(otherRange.start)) {\n                shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);\n            }\n            else {\n                shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);\n            }\n        }\n        if (!shouldJoin) {\n            return null;\n        }\n        let startPosition = this.start;\n        let endPosition = this.end;\n        if (otherRange.start.isBefore(startPosition)) {\n            startPosition = otherRange.start;\n        }\n        if (otherRange.end.isAfter(endPosition)) {\n            endPosition = otherRange.end;\n        }\n        return new Range(startPosition, endPosition);\n    }\n    /**\n     * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n     *\n     * See an example of a model structure (`[` and `]` are range boundaries):\n     *\n     *\t\troot                                                            root\n     *\t\t |- element DIV                         DIV             P2              P3             DIV\n     *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n     *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n     *\t\t |   |- element P1\n     *\t\t |   |   |- \"lorem\"                                              ||\n     *\t\t |- element P2                                                   ||\n     *\t\t |   |- \"foo\"                                                    VV\n     *\t\t |- element P3\n     *\t\t |   |- \"bar\"                                                   root\n     *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n     *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n     *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n     *\t\t |   |- element P4\n     *\t\t |   |   |- \"ipsum\"\n     *\n     * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n     * We are looking for minimal set of flat ranges that contains the same nodes.\n     *\n     * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n     *\n     *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n     *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n     *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n     *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n     *\n     * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n     * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n     * were omitted. Only their parts that were wholly in the range were returned.\n     *\n     * **Note:** this method is not returning flat ranges that contain no nodes.\n     *\n     * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n     */\n    getMinimalFlatRanges() {\n        const ranges = [];\n        const diffAt = this.start.getCommonPath(this.end).length;\n        const pos = Position._createAt(this.start);\n        let posParent = pos.parent;\n        // Go up.\n        while (pos.path.length > diffAt + 1) {\n            const howMany = posParent.maxOffset - pos.offset;\n            if (howMany !== 0) {\n                ranges.push(new Range(pos, pos.getShiftedBy(howMany)));\n            }\n            pos.path = pos.path.slice(0, -1);\n            pos.offset++;\n            posParent = posParent.parent;\n        }\n        // Go down.\n        while (pos.path.length <= this.end.path.length) {\n            const offset = this.end.path[pos.path.length - 1];\n            const howMany = offset - pos.offset;\n            if (howMany !== 0) {\n                ranges.push(new Range(pos, pos.getShiftedBy(howMany)));\n            }\n            pos.offset = offset;\n            pos.path.push(0);\n        }\n        return ranges;\n    }\n    /**\n     * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n     *\n     * For example, to iterate over all items in the entire document root:\n     *\n     *\t\t// Create a range spanning over the entire root content:\n     *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n     *\n     *\t\t// Iterate over all items in this range:\n     *\t\tfor ( const value of range.getWalker() ) {\n     *\t\t\tconsole.log( value.item );\n     *\t\t}\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     * @param {module:engine/model/position~Position} [options.startPosition]\n     * @param {Boolean} [options.singleCharacters=false]\n     * @param {Boolean} [options.shallow=false]\n     * @param {Boolean} [options.ignoreElementEnd=false]\n     * @returns {module:engine/model/treewalker~TreeWalker}\n     */\n    getWalker(options = {}) {\n        options.boundaries = this;\n        return new TreeWalker(options);\n    }\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n     * them.\n     *\n     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n     * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n     * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} [options] Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/model/item~Item>}\n     */\n    *getItems(options = {}) {\n        options.boundaries = this;\n        options.ignoreElementEnd = true;\n        const treeWalker = new TreeWalker(options);\n        for (const value of treeWalker) {\n            yield value.item;\n        }\n    }\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n     * contained in this range.\n     *\n     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n     * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/model/position~Position>}\n     */\n    *getPositions(options = {}) {\n        options.boundaries = this;\n        const treeWalker = new TreeWalker(options);\n        yield treeWalker.position;\n        for (const value of treeWalker) {\n            yield value.nextPosition;\n        }\n    }\n    /**\n     * Returns a range that is a result of transforming this range by given `operation`.\n     *\n     * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n     * moved to a different part of document tree). For this reason, an array is returned by this method and it\n     * may contain one or more `Range` instances.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n     * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n     */\n    getTransformedByOperation(operation) {\n        switch (operation.type) {\n            case 'insert':\n                return this._getTransformedByInsertOperation(operation);\n            case 'move':\n            case 'remove':\n            case 'reinsert':\n                return this._getTransformedByMoveOperation(operation);\n            case 'split':\n                return [this._getTransformedBySplitOperation(operation)];\n            case 'merge':\n                return [this._getTransformedByMergeOperation(operation)];\n        }\n        return [new Range(this.start, this.end)];\n    }\n    /**\n     * Returns a range that is a result of transforming this range by multiple `operations`.\n     *\n     * @see ~Range#getTransformedByOperation\n     * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n     * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n     */\n    getTransformedByOperations(operations) {\n        const ranges = [new Range(this.start, this.end)];\n        for (const operation of operations) {\n            for (let i = 0; i < ranges.length; i++) {\n                const result = ranges[i].getTransformedByOperation(operation);\n                ranges.splice(i, 1, ...result);\n                i += result.length - 1;\n            }\n        }\n        // It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n        // \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n        // because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n        // are inside other ranges and we simply remove them.\n        for (let i = 0; i < ranges.length; i++) {\n            const range = ranges[i];\n            for (let j = i + 1; j < ranges.length; j++) {\n                const next = ranges[j];\n                if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {\n                    ranges.splice(j, 1);\n                }\n            }\n        }\n        return ranges;\n    }\n    /**\n     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n     * which is a common ancestor of the range's both ends (in which the entire range is contained).\n     *\n     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n    getCommonAncestor() {\n        return this.start.getCommonAncestor(this.end);\n    }\n    /**\n     * Returns an {@link module:engine/model/element~Element Element} contained by the range.\n     * The element will be returned when it is the **only** node within the range and **fully–contained**\n     * at the same time.\n     *\n     * @returns {module:engine/model/element~Element|null}\n     */\n    getContainedElement() {\n        if (this.isCollapsed) {\n            return null;\n        }\n        const nodeAfterStart = this.start.nodeAfter;\n        const nodeBeforeEnd = this.end.nodeBefore;\n        if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n            return nodeAfterStart;\n        }\n        return null;\n    }\n    /**\n     * Converts `Range` to plain object and returns it.\n     *\n     * @returns {Object} `Node` converted to plain object.\n     */\n    toJSON() {\n        return {\n            start: this.start.toJSON(),\n            end: this.end.toJSON()\n        };\n    }\n    /**\n     * Returns a new range that is equal to current range.\n     *\n     * @returns {module:engine/model/range~Range}\n     */\n    clone() {\n        return new this.constructor(this.start, this.end);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by insert operation.\n     *\n     * One or more ranges may be returned as a result of this transformation.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n     * @returns {Array.<module:engine/model/range~Range>}\n     */\n    _getTransformedByInsertOperation(operation, spread = false) {\n        return this._getTransformedByInsertion(operation.position, operation.howMany, spread);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by move operation.\n     *\n     * One or more ranges may be returned as a result of this transformation.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n     * @returns {Array.<module:engine/model/range~Range>}\n     */\n    _getTransformedByMoveOperation(operation, spread = false) {\n        const sourcePosition = operation.sourcePosition;\n        const howMany = operation.howMany;\n        const targetPosition = operation.targetPosition;\n        return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by split operation.\n     *\n     * Always one range is returned. The transformation is done in a way to not break the range.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n     * @returns {module:engine/model/range~Range}\n     */\n    _getTransformedBySplitOperation(operation) {\n        const start = this.start._getTransformedBySplitOperation(operation);\n        let end = this.end._getTransformedBySplitOperation(operation);\n        if (this.end.isEqual(operation.insertionPosition)) {\n            end = this.end.getShiftedBy(1);\n        }\n        // Below may happen when range contains graveyard element used by split operation.\n        if (start.root != end.root) {\n            // End position was next to the moved graveyard element and was moved with it.\n            // Fix it by using old `end` which has proper `root`.\n            end = this.end.getShiftedBy(-1);\n        }\n        return new Range(start, end);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by merge operation.\n     *\n     * Always one range is returned. The transformation is done in a way to not break the range.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n     * @returns {module:engine/model/range~Range}\n     */\n    _getTransformedByMergeOperation(operation) {\n        // Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n        // transformations, especially when a content of a few block elements were removed. For example:\n        //\n        // {} is the transformed range, [] is the removed range.\n        // <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n        //\n        // <p>Fo{o</p><p>B}ar</p><p>z</p>\n        // <p>F{</p><p>B}ar</p><p>z</p>\n        // <p>F{</p>}<p>z</p>\n        // <p>F{}z</p>\n        //\n        if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {\n            return new Range(this.start);\n        }\n        let start = this.start._getTransformedByMergeOperation(operation);\n        let end = this.end._getTransformedByMergeOperation(operation);\n        if (start.root != end.root) {\n            // This happens when the end position was next to the merged (deleted) element.\n            // Then, the end position was moved to the graveyard root. In this case we need to fix\n            // the range cause its boundaries would be in different roots.\n            end = this.end.getShiftedBy(-1);\n        }\n        if (start.isAfter(end)) {\n            // This happens in three following cases:\n            //\n            // Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n            //         This means that start can be moved before the end of the range.\n            //\n            // Before: <p>a{a</p><p>b}b</p><p>cc</p>\n            // Merge:  <p>b}b</p><p>cca{a</p>\n            // Fix:    <p>{b}b</p><p>ccaa</p>\n            //\n            // Case 2: Range start is before merged node but not directly.\n            //         Result should include all nodes that were in the original range.\n            //\n            // Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n            // Merge:  <p>aab}b</p>{<p>cc</p>\n            // Fix:    <p>aa{bb</p><p>cc</p>}\n            //\n            //         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n            //\n            // Case 3: Range start is directly before merged node.\n            //         Resulting range should include only nodes from the merged element:\n            //\n            // Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n            // Merge:  <p>aab}b</p>{<p>cc</p>\n            // Fix:    <p>aa{b}b</p><p>cc</p>\n            //\n            if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n                // Case 1.\n                start = Position._createAt(end);\n                start.offset = 0;\n            }\n            else {\n                if (!operation.deletionPosition.isEqual(start)) {\n                    // Case 2.\n                    end = operation.deletionPosition;\n                }\n                // In both case 2 and 3 start is at the end of the merge-to element.\n                start = operation.targetPosition;\n            }\n            return new Range(start, end);\n        }\n        return new Range(start, end);\n    }\n    /**\n     * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n     * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n     * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n     *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n     *\n     *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n     *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n     *\n     *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n     *\t\t// transformed array has one range, which is equal to original range\n     *\n     *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n     *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n     * @param {Number} howMany How many nodes are inserted.\n     * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n     * was inside the range. Defaults to `false`.\n     * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n     */\n    _getTransformedByInsertion(insertPosition, howMany, spread = false) {\n        if (spread && this.containsPosition(insertPosition)) {\n            // Range has to be spread. The first part is from original start to the spread point.\n            // The other part is from spread point to the original end, but transformed by\n            // insertion to reflect insertion changes.\n            return [\n                new Range(this.start, insertPosition),\n                new Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))\n            ];\n        }\n        else {\n            const range = new Range(this.start, this.end);\n            range.start = range.start._getTransformedByInsertion(insertPosition, howMany);\n            range.end = range.end._getTransformedByInsertion(insertPosition, howMany);\n            return [range];\n        }\n    }\n    /**\n     * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n     * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n     * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n     * @param {Number} howMany How many nodes are moved.\n     * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n     * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n     */\n    _getTransformedByMove(sourcePosition, targetPosition, howMany, spread = false) {\n        // Special case for transforming a collapsed range. Just transform it like a position.\n        if (this.isCollapsed) {\n            const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n            return [new Range(newPos)];\n        }\n        // Special case for transformation when a part of the range is moved towards the range.\n        //\n        // Examples:\n        //\n        // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n        // <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n        //\n        // Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n        //\n        // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n        //\n        // This special case is applied only if the range is to be kept together (not spread).\n        const moveRange = Range._createFromPositionAndShift(sourcePosition, howMany);\n        const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n        if (this.containsPosition(targetPosition) && !spread) {\n            if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {\n                const start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n                const end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);\n                return [new Range(start, end)];\n            }\n        }\n        // Default algorithm.\n        let result;\n        const differenceSet = this.getDifference(moveRange);\n        let difference = null;\n        const common = this.getIntersection(moveRange);\n        if (differenceSet.length == 1) {\n            // `moveRange` and this range may intersect but may be separate.\n            difference = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));\n        }\n        else if (differenceSet.length == 2) {\n            // `moveRange` is inside this range.\n            difference = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));\n        } // else, `moveRange` contains this range.\n        if (difference) {\n            result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);\n        }\n        else {\n            result = [];\n        }\n        if (common) {\n            const transformedCommon = new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));\n            if (result.length == 2) {\n                result.splice(1, 0, transformedCommon);\n            }\n            else {\n                result.push(transformedCommon);\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n     *\n     * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n     *\n     * If the deleted range contains transformed range, `null` will be returned.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n     * @param {Number} howMany How many nodes are removed.\n     * @returns {module:engine/model/range~Range|null} Result of the transformation.\n     */\n    _getTransformedByDeletion(deletePosition, howMany) {\n        let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);\n        let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);\n        if (newStart == null && newEnd == null) {\n            return null;\n        }\n        if (newStart == null) {\n            newStart = deletePosition;\n        }\n        if (newEnd == null) {\n            newEnd = deletePosition;\n        }\n        return new Range(newStart, newEnd);\n    }\n    /**\n     * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/position~Position} position Beginning of the range.\n     * @param {Number} shift How long the range should be.\n     * @returns {module:engine/model/range~Range}\n     */\n    static _createFromPositionAndShift(position, shift) {\n        const start = position;\n        const end = position.getShiftedBy(shift);\n        return shift > 0 ? new this(start, end) : new this(end, start);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n    static _createIn(element) {\n        return new this(Position._createAt(element, 0), Position._createAt(element, element.maxOffset));\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/item~Item} item\n     * @returns {module:engine/model/range~Range}\n     */\n    static _createOn(item) {\n        return this._createFromPositionAndShift(Position._createBefore(item), item.offsetSize);\n    }\n    /**\n     * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n     * Passed ranges must not have common parts.\n     *\n     * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n     * the reference range, they get combined into one range.\n     *\n     *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n     *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n     *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n     *\t                                           [  ]  // The result of the function if the last range was a reference range.\n     *\n     * @internal\n     * @protected\n     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n     * @returns {module:engine/model/range~Range} Combined range.\n     */\n    static _createFromRanges(ranges) {\n        if (ranges.length === 0) {\n            /**\n             * At least one range has to be passed to\n             * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n             *\n             * @error range-create-from-ranges-empty-array\n             */\n            throw new CKEditorError('range-create-from-ranges-empty-array', null);\n        }\n        else if (ranges.length == 1) {\n            return ranges[0].clone();\n        }\n        // 1. Set the first range in `ranges` array as a reference range.\n        // If we are going to return just a one range, one of the ranges need to be the reference one.\n        // Other ranges will be stuck to that range, if possible.\n        const ref = ranges[0];\n        // 2. Sort all the ranges so it's easier to process them.\n        ranges.sort((a, b) => {\n            return a.start.isAfter(b.start) ? 1 : -1;\n        });\n        // 3. Check at which index the reference range is now.\n        const refIndex = ranges.indexOf(ref);\n        // 4. At this moment we don't need the original range.\n        // We are going to modify the result and we need to return a new instance of Range.\n        // We have to create a copy of the reference range.\n        const result = new this(ref.start, ref.end);\n        // 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n        // Since ranges are sorted, start with the range with index that is closest to reference range index.\n        if (refIndex > 0) {\n            // eslint-disable-next-line no-constant-condition\n            for (let i = refIndex - 1; true; i++) {\n                if (ranges[i].end.isEqual(result.start)) {\n                    result.start = Position._createAt(ranges[i].start);\n                }\n                else {\n                    // If ranges are not starting/ending at the same position there is no point in looking further.\n                    break;\n                }\n            }\n        }\n        // 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n        // Since ranges are sorted, start with the range with index that is closest to reference range index.\n        for (let i = refIndex + 1; i < ranges.length; i++) {\n            if (ranges[i].start.isEqual(result.end)) {\n                result.end = Position._createAt(ranges[i].end);\n            }\n            else {\n                // If ranges are not starting/ending at the same position there is no point in looking further.\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n     *\n     * @param {Object} json Plain object to be converted to `Range`.\n     * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n     * @returns {module:engine/model/range~Range} `Range` instance created using given plain object.\n     */\n    static fromJSON(json, doc) {\n        return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\trange.is( 'range' ); // -> true\n *\t\trange.is( 'model:range' ); // -> true\n *\n *\t\trange.is( 'view:range' ); // -> false\n *\t\trange.is( 'documentSelection' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nRange.prototype.is = function (type) {\n    return type === 'range' || type === 'model:range';\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}