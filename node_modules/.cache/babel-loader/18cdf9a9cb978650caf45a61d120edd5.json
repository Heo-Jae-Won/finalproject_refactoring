{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global DOMParser */\n\n/**\n * @module widget/widgettypearound\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport Enter from '@ckeditor/ckeditor5-enter/src/enter';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport { isForwardArrowKeyCode, keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { isTypeAroundWidget, getClosestTypeAroundDomButton, getTypeAroundButtonPosition, getClosestWidgetViewElement, getTypeAroundFakeCaretPosition, TYPE_AROUND_SELECTION_ATTRIBUTE } from './utils';\nimport { isNonTypingKeystroke } from '@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling';\nimport { isWidget } from '../utils';\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\nconst POSSIBLE_INSERTION_POSITIONS = ['before', 'after'];\n\n// Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, 'image/svg+xml').firstChild;\nconst PLUGIN_DISABLED_EDITING_ROOT_CLASS = 'ck-widget__type-around_disabled';\n\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects the user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class WidgetTypeAround extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'WidgetTypeAround';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [Enter, Delete];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  constructor(editor) {\n    super(editor);\n\n    /**\n     * A reference to the model widget element that has the fake caret active\n     * on either side of it. It is later used to remove CSS classes associated with the fake caret\n     * when the widget no longer needs it.\n     *\n     * @private\n     * @member {module:engine/model/element~Element|null}\n     */\n    this._currentFakeCaretModelElement = null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  init() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n\n    // Set a CSS class on the view editing root when the plugin is disabled so all the buttons\n    // and lines visually disappear. All the interactions are disabled in individual plugin methods.\n    this.on('change:isEnabled', (evt, data, isEnabled) => {\n      editingView.change(writer => {\n        for (const root of editingView.document.roots) {\n          if (isEnabled) {\n            writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n          } else {\n            writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n          }\n        }\n      });\n      if (!isEnabled) {\n        editor.model.change(writer => {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n        });\n      }\n    });\n    this._enableTypeAroundUIInjection();\n    this._enableInsertingParagraphsOnButtonClick();\n    this._enableInsertingParagraphsOnEnterKeypress();\n    this._enableInsertingParagraphsOnTypingKeystroke();\n    this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n    this._enableDeleteIntegration();\n    this._enableInsertContentIntegration();\n    this._enableInsertObjectIntegration();\n    this._enableDeleteContentIntegration();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  destroy() {\n    this._currentFakeCaretModelElement = null;\n  }\n\n  /**\n   * Inserts a new paragraph next to a widget element with the selection anchored in it.\n   *\n   * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n   * the viewport to the selection in the inserted paragraph.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.\n   * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n   */\n  _insertParagraph(widgetModelElement, position) {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, 'copyOnReplace', true);\n    editor.execute('insertParagraph', {\n      position: editor.model.createPositionAt(widgetModelElement, position),\n      attributes: attributesToCopy\n    });\n    editingView.focus();\n    editingView.scrollToTheSelection();\n  }\n\n  /**\n   * A wrapper for the {@link module:utils/emittermixin~EmitterMixin#listenTo} method that executes the callbacks only\n   * when the plugin {@link #isEnabled is enabled}.\n   *\n   * @private\n   * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n   * @param {String} event The name of the event.\n   * @param {Function} callback The function to be called on event.\n   * @param {Object} [options={}] Additional options.\n   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n   * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n   * order they were added.\n   */\n  _listenToIfEnabled(emitter, event, callback, options) {\n    var _this = this;\n    this.listenTo(emitter, event, function () {\n      // Do not respond if the plugin is disabled.\n      if (_this.isEnabled) {\n        callback(...arguments);\n      }\n    }, options);\n  }\n\n  /**\n   * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n   * does not expect a position. Instead, it performs the insertion next to a selected widget\n   * according to the `widget-type-around` model selection attribute value (fake caret position).\n   *\n   * Because this method requires the `widget-type-around` attribute to be set,\n   * the insertion can only happen when the widget's fake caret is active (e.g. activated\n   * using the keyboard).\n   *\n   * @private\n   * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n   */\n  _insertParagraphAccordingToFakeCaretPosition() {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n    if (!typeAroundFakeCaretPosition) {\n      return false;\n    }\n    const selectedModelElement = modelSelection.getSelectedElement();\n    this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);\n    return true;\n  }\n\n  /**\n   * Creates a listener in the editing conversion pipeline that injects the widget type around\n   * UI into every single widget instance created in the editor.\n   *\n   * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n   * wrapper which renders DOM buttons that users can use to insert paragraphs.\n   *\n   * @private\n   */\n  _enableTypeAroundUIInjection() {\n    const editor = this.editor;\n    const schema = editor.model.schema;\n    const t = editor.locale.t;\n    const buttonTitles = {\n      before: t('Insert paragraph before block'),\n      after: t('Insert paragraph after block')\n    };\n    editor.editing.downcastDispatcher.on('insert', (evt, data, conversionApi) => {\n      const viewElement = conversionApi.mapper.toViewElement(data.item);\n\n      // Filter out non-widgets and inline widgets.\n      if (isTypeAroundWidget(viewElement, data.item, schema)) {\n        injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);\n      }\n    }, {\n      priority: 'low'\n    });\n  }\n\n  /**\n   * Brings support for the fake caret that appears when either:\n   *\n   * * the selection moves to a widget from a position next to it using arrow keys,\n   * * the arrow key is pressed when the widget is already selected.\n   *\n   * The fake caret lets the user know that they can start typing or just press\n   * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.\n   *\n   * The fake caret disappears when the user changes the selection or the editor\n   * gets blurred.\n   *\n   * The whole idea is as follows:\n   *\n   * 1. A user does one of the 2 scenarios described at the beginning.\n   * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the fake caret.\n   * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating\n   *    on which side of the widget it should appear.\n   * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n   *    fake caret on the view widget.\n   * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher\n   *    does the CSS class clean-up in the view.\n   * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection\n   *    attribute (the former also removes widget CSS classes).\n   *\n   * @private\n   */\n  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const schema = model.schema;\n    const editingView = editor.editing.view;\n\n    // This is the main listener responsible for the fake caret.\n    // Note: The priority must precede the default Widget class keydown handler (\"high\").\n    this._listenToIfEnabled(editingView.document, 'arrowKey', (evt, domEventData) => {\n      this._handleArrowKeyPress(evt, domEventData);\n    }, {\n      context: [isWidget, '$text'],\n      priority: 'high'\n    });\n\n    // This listener makes sure the widget type around selection attribute will be gone from the model\n    // selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n    // (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n    // let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n    this._listenToIfEnabled(modelSelection, 'change:range', (evt, data) => {\n      // Do not reset the selection attribute when the change was indirect.\n      if (!data.directChange) {\n        return;\n      }\n\n      // Get rid of the widget type around attribute of the selection on every change:range.\n      // If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n      editor.model.change(writer => {\n        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n      });\n    });\n\n    // Get rid of the widget type around attribute of the selection on every document change\n    // that makes widget not selected any more (i.e. widget was removed).\n    this._listenToIfEnabled(model.document, 'change:data', () => {\n      const selectedModelElement = modelSelection.getSelectedElement();\n      if (selectedModelElement) {\n        const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n          return;\n        }\n      }\n      editor.model.change(writer => {\n        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n      });\n    });\n\n    // React to changes of the model selection attribute made by the arrow keys listener.\n    // If the block widget is selected and the attribute changes, downcast the attribute to special\n    // CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n    this._listenToIfEnabled(editor.editing.downcastDispatcher, 'selection', (evt, data, conversionApi) => {\n      const writer = conversionApi.writer;\n      if (this._currentFakeCaretModelElement) {\n        const selectedViewElement = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);\n        if (selectedViewElement) {\n          // Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n          writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement);\n          this._currentFakeCaretModelElement = null;\n        }\n      }\n      const selectedModelElement = data.selection.getSelectedElement();\n      if (!selectedModelElement) {\n        return;\n      }\n      const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);\n      if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n        return;\n      }\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n      writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);\n\n      // Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n      // selection changes\n      this._currentFakeCaretModelElement = selectedModelElement;\n    });\n    this._listenToIfEnabled(editor.ui.focusTracker, 'change:isFocused', (evt, name, isFocused) => {\n      if (!isFocused) {\n        editor.model.change(writer => {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n        });\n      }\n    });\n    function positionToWidgetCssClass(position) {\n      return `ck-widget_type-around_show-fake-caret_${position}`;\n    }\n  }\n\n  /**\n   * A listener executed on each \"keydown\" in the view document, a part of\n   * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n   *\n   * It decides whether the arrow keypress should activate the fake caret or not (also whether it should\n   * be deactivated).\n   *\n   * The fake caret activation is done by setting the `widget-type-around` model selection attribute\n   * in this listener, and stopping and preventing the event that would normally be handled by the widget\n   * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n   * includes inline widgets, which are ignored by the widget type around plugin).\n   *\n   * @private\n   */\n  _handleArrowKeyPress(evt, domEventData) {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const schema = model.schema;\n    const editingView = editor.editing.view;\n    const keyCode = domEventData.keyCode;\n    const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);\n    const selectedViewElement = editingView.document.selection.getSelectedElement();\n    const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);\n    let shouldStopAndPreventDefault;\n\n    // Handle keyboard navigation when a type-around-compatible widget is currently selected.\n    if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n      shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);\n    }\n    // Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n    // and the widget is about to be selected.\n    else if (modelSelection.isCollapsed) {\n      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);\n    }\n    // Handle collapsing a non-collapsed selection that is wider than on a single widget.\n    else if (!domEventData.shiftKey) {\n      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);\n    }\n    if (shouldStopAndPreventDefault) {\n      domEventData.preventDefault();\n      evt.stop();\n    }\n  }\n\n  /**\n   * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n   * the fake caret for that widget, depending on the current value of the `widget-type-around` model\n   * selection attribute and the direction of the pressed arrow key.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n   * process the event any further. Returns `false` otherwise.\n   */\n  _handleArrowKeyPressOnSelectedWidget(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n    return model.change(writer => {\n      // If the fake caret is displayed...\n      if (typeAroundFakeCaretPosition) {\n        const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? 'after' : 'before');\n\n        // If the keyboard arrow works against the value of the selection attribute...\n        // then remove the selection attribute but prevent default DOM actions\n        // and do not let the Widget plugin listener move the selection. This brings\n        // the widget back to the state, for instance, like if was selected using the mouse.\n        //\n        // **Note**: If leaving the widget when the fake caret is active, then the default\n        // Widget handler will change the selection and, in turn, this will automatically discard\n        // the selection attribute.\n        if (!isLeavingWidget) {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n          return true;\n        }\n      }\n      // If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n      // key press. This also means we cannot let the Widget plugin listener move the selection.\n      else {\n        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n        return true;\n      }\n      return false;\n    });\n  }\n\n  /**\n   * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n   * to one and upon the fake caret should become active for this widget upon arrow keypress\n   * (AKA entering/selecting the widget).\n   *\n   * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.\n   * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the\n   * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n   * process the event any further. Returns `false` otherwise.\n   */\n  _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const schema = model.schema;\n    const widgetPlugin = editor.plugins.get('Widget');\n\n    // This is the widget the selection is about to be set on.\n    const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);\n    const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);\n    if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {\n      model.change(writer => {\n        widgetPlugin._setSelectionOverElement(modelElementNextToSelection);\n        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after');\n      });\n\n      // The change() block above does the same job as the Widget plugin. The event can\n      // be safely canceled.\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handles the keyboard navigation on \"keydown\" when a widget is currently selected (together with some other content)\n   * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n   * process the event any further. Returns `false` otherwise.\n   */\n  _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const schema = model.schema;\n    const mapper = editor.editing.mapper;\n    const modelSelection = model.document.selection;\n    const selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;\n    const selectedViewNode = mapper.toViewElement(selectedModelNode);\n\n    // There is a widget at the collapse position so collapse the selection to the fake caret on it.\n    if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {\n      model.change(writer => {\n        writer.setSelection(selectedModelNode, 'on');\n        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n      });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Registers a `mousedown` listener for the view document which intercepts events\n   * coming from the widget type around UI, which happens when a user clicks one of the buttons\n   * that insert a paragraph next to a widget.\n   *\n   * @private\n   */\n  _enableInsertingParagraphsOnButtonClick() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    this._listenToIfEnabled(editingView.document, 'mousedown', (evt, domEventData) => {\n      const button = getClosestTypeAroundDomButton(domEventData.domTarget);\n      if (!button) {\n        return;\n      }\n      const buttonPosition = getTypeAroundButtonPosition(button);\n      const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);\n      const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);\n      this._insertParagraph(widgetModelElement, buttonPosition);\n      domEventData.preventDefault();\n      evt.stop();\n    });\n  }\n\n  /**\n   * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph\n   * near the widget when either:\n   *\n   * * The fake caret was first activated using the arrow keys,\n   * * The entire widget is selected in the model.\n   *\n   * In the first case, the new paragraph is inserted according to the `widget-type-around` selection\n   * attribute (see {@link #_handleArrowKeyPress}).\n   *\n   * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke\n   * was pressed or not.\n   *\n   * @private\n   */\n  _enableInsertingParagraphsOnEnterKeypress() {\n    const editor = this.editor;\n    const selection = editor.model.document.selection;\n    const editingView = editor.editing.view;\n    this._listenToIfEnabled(editingView.document, 'enter', (evt, domEventData) => {\n      // This event could be triggered from inside the widget but we are interested\n      // only when the widget is selected itself.\n      if (evt.eventPhase != 'atTarget') {\n        return;\n      }\n      const selectedModelElement = selection.getSelectedElement();\n      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n      const schema = editor.model.schema;\n      let wasHandled;\n\n      // First check if the widget is selected and there's a type around selection attribute associated\n      // with the fake caret that would tell where to insert a new paragraph.\n      if (this._insertParagraphAccordingToFakeCaretPosition()) {\n        wasHandled = true;\n      }\n      // Then, if there is no selection attribute associated with the fake caret, check if the widget\n      // simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n      else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n        this._insertParagraph(selectedModelElement, domEventData.isSoft ? 'before' : 'after');\n        wasHandled = true;\n      }\n      if (wasHandled) {\n        domEventData.preventDefault();\n        evt.stop();\n      }\n    }, {\n      context: isWidget\n    });\n  }\n\n  /**\n   * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n   * to insert a paragraph next to a widget when the fake caret was activated using arrow\n   * keys but it responds to typing keystrokes instead of <kbd>Enter</kbd>.\n   *\n   * \"Typing keystrokes\" are keystrokes that insert new content into the document,\n   * for instance, letters (\"a\") or numbers (\"4\"). The \"keydown\" listener enabled by this method\n   * will insert a new paragraph according to the `widget-type-around` model selection attribute\n   * as the user simply starts typing, which creates the impression that the fake caret\n   * behaves like a real one rendered by the browser (AKA your text appears where the caret was).\n   *\n   * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command\n   * and another one for actual typing. It is not a disaster but this may need to be fixed\n   * sooner or later.\n   *\n   * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.\n   *\n   * @private\n   */\n  _enableInsertingParagraphsOnTypingKeystroke() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const keyCodesHandledSomewhereElse = [keyCodes.enter, keyCodes.delete, keyCodes.backspace];\n\n    // Note: The priority must precede the default observers.\n    this._listenToIfEnabled(editingView.document, 'keydown', (evt, domEventData) => {\n      // Don't handle enter/backspace/delete here. They are handled in dedicated listeners.\n      if (!keyCodesHandledSomewhereElse.includes(domEventData.keyCode) && !isNonTypingKeystroke(domEventData)) {\n        this._insertParagraphAccordingToFakeCaretPosition();\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n\n  /**\n   * It creates a \"delete\" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>\n   * is pressed and the fake caret is currently active.\n   *\n   * The fake caret should create an illusion of a real browser caret so that when it appears before or after\n   * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content\n   * before or after a widget (depending on the content surrounding the widget).\n   *\n   * @private\n   */\n  _enableDeleteIntegration() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const model = editor.model;\n    const schema = model.schema;\n    this._listenToIfEnabled(editingView.document, 'delete', (evt, domEventData) => {\n      // This event could be triggered from inside the widget but we are interested\n      // only when the widget is selected itself.\n      if (evt.eventPhase != 'atTarget') {\n        return;\n      }\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);\n\n      // This listener handles only these cases when the fake caret is active.\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n      const direction = domEventData.direction;\n      const selectedModelWidget = model.document.selection.getSelectedElement();\n      const isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n      const isDeleteForward = direction == 'forward';\n      const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;\n      if (shouldDeleteEntireWidget) {\n        editor.execute('delete', {\n          selection: model.createSelection(selectedModelWidget, 'on')\n        });\n      } else {\n        const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);\n\n        // If there is somewhere to move selection to, then there will be something to delete.\n        if (range) {\n          // If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n          if (!range.isCollapsed) {\n            model.change(writer => {\n              writer.setSelection(range);\n              editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n            });\n          } else {\n            const probe = model.createSelection(range.start);\n            model.modifySelection(probe, {\n              direction\n            });\n\n            // If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n            // If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n            if (!probe.focus.isEqual(range.start)) {\n              model.change(writer => {\n                writer.setSelection(range);\n                editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n              });\n            }\n            // If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n            // next to a widget that should be removed. \"delete\" and \"deleteForward\" commands cannot get rid of it\n            // so calling Model#deleteContent here manually.\n            else {\n              const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);\n              model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, 'on'), {\n                doNotAutoparagraph: true\n              });\n            }\n          }\n        }\n      }\n\n      // If some content was deleted, don't let the handler from the Widget plugin kick in.\n      // If nothing was deleted, then the default handler will have nothing to do anyway.\n      domEventData.preventDefault();\n      evt.stop();\n    }, {\n      context: isWidget\n    });\n  }\n\n  /**\n   * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n   * content near a widget when the fake caret is first activated using the arrow keys.\n   *\n   * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n   *\n   * @private\n   */\n  _enableInsertContentIntegration() {\n    const editor = this.editor;\n    const model = this.editor.model;\n    const documentSelection = model.document.selection;\n    this._listenToIfEnabled(editor.model, 'insertContent', (evt, _ref) => {\n      let [content, selectable] = _ref;\n      if (selectable && !selectable.is('documentSelection')) {\n        return;\n      }\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n      evt.stop();\n      return model.change(writer => {\n        const selectedElement = documentSelection.getSelectedElement();\n        const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);\n        const selection = writer.createSelection(position);\n        const result = model.insertContent(content, selection);\n        writer.setSelection(selection);\n        return result;\n      });\n    }, {\n      priority: 'high'\n    });\n  }\n\n  /**\n   * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the\n   * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element\n   * to reflect user's intent of desired insertion position.\n   *\n   * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n   *\n   * @private\n   */\n  _enableInsertObjectIntegration() {\n    const editor = this.editor;\n    const model = this.editor.model;\n    const documentSelection = model.document.selection;\n    this._listenToIfEnabled(editor.model, 'insertObject', (evt, args) => {\n      const [, selectable,, options = {}] = args;\n      if (selectable && !selectable.is('documentSelection')) {\n        return;\n      }\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n      options.findOptimalPosition = typeAroundFakeCaretPosition;\n      args[3] = options;\n    }, {\n      priority: 'high'\n    });\n  }\n\n  /**\n   * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake\n   * caret is active.\n   *\n   * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n   * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,\n   * plain text pasting.\n   *\n   * @private\n   */\n  _enableDeleteContentIntegration() {\n    const editor = this.editor;\n    const model = this.editor.model;\n    const documentSelection = model.document.selection;\n    this._listenToIfEnabled(editor.model, 'deleteContent', (evt, _ref2) => {\n      let [selection] = _ref2;\n      if (selection && !selection.is('documentSelection')) {\n        return;\n      }\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n\n      // Disable removing the selection content while pasting plain text.\n      if (typeAroundFakeCaretPosition) {\n        evt.stop();\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n}\n\n// Injects the type around UI into a view widget instance.\n//\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {Object.<String,String>} buttonTitles\n// @param {module:engine/view/element~Element} widgetViewElement\nfunction injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {\n  const typeAroundWrapper = viewWriter.createUIElement('div', {\n    class: 'ck ck-reset_all ck-widget__type-around'\n  }, function (domDocument) {\n    const wrapperDomElement = this.toDomElement(domDocument);\n    injectButtons(wrapperDomElement, buttonTitles);\n    injectFakeCaret(wrapperDomElement);\n    return wrapperDomElement;\n  });\n\n  // Inject the type around wrapper into the widget's wrapper.\n  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, 'end'), typeAroundWrapper);\n}\n\n// FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n// <svg> here.\n//\n// @param {HTMLElement} wrapperDomElement\n// @param {Object.<String,String>} buttonTitles\nfunction injectButtons(wrapperDomElement, buttonTitles) {\n  for (const position of POSSIBLE_INSERTION_POSITIONS) {\n    const buttonTemplate = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-widget__type-around__button', `ck-widget__type-around__button_${position}`],\n        title: buttonTitles[position]\n      },\n      children: [wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)]\n    });\n    wrapperDomElement.appendChild(buttonTemplate.render());\n  }\n}\n\n// @param {HTMLElement} wrapperDomElement\nfunction injectFakeCaret(wrapperDomElement) {\n  const caretTemplate = new Template({\n    tag: 'div',\n    attributes: {\n      class: ['ck', 'ck-widget__type-around__fake-caret']\n    }\n  });\n  wrapperDomElement.appendChild(caretTemplate.render());\n}\n\n// Returns the ancestor of an element closest to the root which is empty. For instance,\n// for `<baz>`:\n//\n//\t\t<foo>abc<bar><baz></baz></bar></foo>\n//\n// it returns `<bar>`.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/element~Element|null}\nfunction getDeepestEmptyElementAncestor(schema, element) {\n  let deepestEmptyAncestor = element;\n  for (const ancestor of element.getAncestors({\n    parentFirst: true\n  })) {\n    if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {\n      break;\n    }\n    deepestEmptyAncestor = ancestor;\n  }\n  return deepestEmptyAncestor;\n}","map":{"version":3,"names":["Plugin","Template","Enter","Delete","isForwardArrowKeyCode","keyCodes","isTypeAroundWidget","getClosestTypeAroundDomButton","getTypeAroundButtonPosition","getClosestWidgetViewElement","getTypeAroundFakeCaretPosition","TYPE_AROUND_SELECTION_ATTRIBUTE","isNonTypingKeystroke","isWidget","returnIcon","POSSIBLE_INSERTION_POSITIONS","RETURN_ARROW_ICON_ELEMENT","DOMParser","parseFromString","firstChild","PLUGIN_DISABLED_EDITING_ROOT_CLASS","WidgetTypeAround","pluginName","requires","constructor","editor","_currentFakeCaretModelElement","init","editingView","editing","view","on","evt","data","isEnabled","change","writer","root","document","roots","removeClass","addClass","model","removeSelectionAttribute","_enableTypeAroundUIInjection","_enableInsertingParagraphsOnButtonClick","_enableInsertingParagraphsOnEnterKeypress","_enableInsertingParagraphsOnTypingKeystroke","_enableTypeAroundFakeCaretActivationUsingKeyboardArrows","_enableDeleteIntegration","_enableInsertContentIntegration","_enableInsertObjectIntegration","_enableDeleteContentIntegration","destroy","_insertParagraph","widgetModelElement","position","attributesToCopy","schema","getAttributesWithProperty","execute","createPositionAt","attributes","focus","scrollToTheSelection","_listenToIfEnabled","emitter","event","callback","options","listenTo","_insertParagraphAccordingToFakeCaretPosition","modelSelection","selection","typeAroundFakeCaretPosition","selectedModelElement","getSelectedElement","t","locale","buttonTitles","before","after","downcastDispatcher","conversionApi","viewElement","mapper","toViewElement","item","injectUIIntoWidget","priority","domEventData","_handleArrowKeyPress","context","directChange","selectedViewElement","map","positionToWidgetCssClass","ui","focusTracker","name","isFocused","keyCode","isForward","contentLanguageDirection","toModelElement","shouldStopAndPreventDefault","_handleArrowKeyPressOnSelectedWidget","isCollapsed","_handleArrowKeyPressWhenSelectionNextToAWidget","shiftKey","_handleArrowKeyPressWhenNonCollapsedSelection","preventDefault","stop","isLeavingWidget","setSelectionAttribute","widgetPlugin","plugins","get","modelElementNextToSelection","_getObjectElementNextToSelection","viewElementNextToSelection","_setSelectionOverElement","selectedModelNode","getLastPosition","nodeBefore","getFirstPosition","nodeAfter","selectedViewNode","setSelection","button","domTarget","buttonPosition","widgetViewElement","domConverter","eventPhase","wasHandled","isSoft","keyCodesHandledSomewhereElse","enter","delete","backspace","includes","direction","selectedModelWidget","isFakeCaretBefore","isDeleteForward","shouldDeleteEntireWidget","createSelection","range","getNearestSelectionRange","probe","start","modifySelection","isEqual","deepestEmptyRangeAncestor","getDeepestEmptyElementAncestor","parent","deleteContent","doNotAutoparagraph","documentSelection","content","selectable","is","selectedElement","result","insertContent","args","findOptimalPosition","viewWriter","typeAroundWrapper","createUIElement","class","domDocument","wrapperDomElement","toDomElement","injectButtons","injectFakeCaret","insert","buttonTemplate","tag","title","children","ownerDocument","importNode","appendChild","render","caretTemplate","element","deepestEmptyAncestor","ancestor","getAncestors","parentFirst","childCount","isLimit"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global DOMParser */\n\n/**\n * @module widget/widgettypearound\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport Enter from '@ckeditor/ckeditor5-enter/src/enter';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport {\n\tisForwardArrowKeyCode,\n\tkeyCodes\n} from '@ckeditor/ckeditor5-utils/src/keyboard';\n\nimport {\n\tisTypeAroundWidget,\n\tgetClosestTypeAroundDomButton,\n\tgetTypeAroundButtonPosition,\n\tgetClosestWidgetViewElement,\n\tgetTypeAroundFakeCaretPosition,\n\tTYPE_AROUND_SELECTION_ATTRIBUTE\n} from './utils';\n\nimport {\n\tisNonTypingKeystroke\n} from '@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling';\n\nimport { isWidget } from '../utils';\n\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\n\nconst POSSIBLE_INSERTION_POSITIONS = [ 'before', 'after' ];\n\n// Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString( returnIcon, 'image/svg+xml' ).firstChild;\n\nconst PLUGIN_DISABLED_EDITING_ROOT_CLASS = 'ck-widget__type-around_disabled';\n\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects the user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class WidgetTypeAround extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'WidgetTypeAround';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ Enter, Delete ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * A reference to the model widget element that has the fake caret active\n\t\t * on either side of it. It is later used to remove CSS classes associated with the fake caret\n\t\t * when the widget no longer needs it.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element|null}\n\t\t */\n\t\tthis._currentFakeCaretModelElement = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\t// Set a CSS class on the view editing root when the plugin is disabled so all the buttons\n\t\t// and lines visually disappear. All the interactions are disabled in individual plugin methods.\n\t\tthis.on( 'change:isEnabled', ( evt, data, isEnabled ) => {\n\t\t\teditingView.change( writer => {\n\t\t\t\tfor ( const root of editingView.document.roots ) {\n\t\t\t\t\tif ( isEnabled ) {\n\t\t\t\t\t\twriter.removeClass( PLUGIN_DISABLED_EDITING_ROOT_CLASS, root );\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriter.addClass( PLUGIN_DISABLED_EDITING_ROOT_CLASS, root );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tif ( !isEnabled ) {\n\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tthis._enableTypeAroundUIInjection();\n\t\tthis._enableInsertingParagraphsOnButtonClick();\n\t\tthis._enableInsertingParagraphsOnEnterKeypress();\n\t\tthis._enableInsertingParagraphsOnTypingKeystroke();\n\t\tthis._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n\t\tthis._enableDeleteIntegration();\n\t\tthis._enableInsertContentIntegration();\n\t\tthis._enableInsertObjectIntegration();\n\t\tthis._enableDeleteContentIntegration();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tthis._currentFakeCaretModelElement = null;\n\t}\n\n\t/**\n\t * Inserts a new paragraph next to a widget element with the selection anchored in it.\n\t *\n\t * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n\t * the viewport to the selection in the inserted paragraph.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.\n\t * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n\t */\n\t_insertParagraph( widgetModelElement, position ) {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\tconst attributesToCopy = editor.model.schema.getAttributesWithProperty( widgetModelElement, 'copyOnReplace', true );\n\n\t\teditor.execute( 'insertParagraph', {\n\t\t\tposition: editor.model.createPositionAt( widgetModelElement, position ),\n\t\t\tattributes: attributesToCopy\n\t\t} );\n\n\t\teditingView.focus();\n\t\teditingView.scrollToTheSelection();\n\t}\n\n\t/**\n\t * A wrapper for the {@link module:utils/emittermixin~EmitterMixin#listenTo} method that executes the callbacks only\n\t * when the plugin {@link #isEnabled is enabled}.\n\t *\n\t * @private\n\t * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n\t * @param {String} event The name of the event.\n\t * @param {Function} callback The function to be called on event.\n\t * @param {Object} [options={}] Additional options.\n\t * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n\t * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n\t * order they were added.\n\t */\n\t_listenToIfEnabled( emitter, event, callback, options ) {\n\t\tthis.listenTo( emitter, event, ( ...args ) => {\n\t\t\t// Do not respond if the plugin is disabled.\n\t\t\tif ( this.isEnabled ) {\n\t\t\t\tcallback( ...args );\n\t\t\t}\n\t\t}, options );\n\t}\n\n\t/**\n\t * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n\t * does not expect a position. Instead, it performs the insertion next to a selected widget\n\t * according to the `widget-type-around` model selection attribute value (fake caret position).\n\t *\n\t * Because this method requires the `widget-type-around` attribute to be set,\n\t * the insertion can only happen when the widget's fake caret is active (e.g. activated\n\t * using the keyboard).\n\t *\n\t * @private\n\t * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n\t */\n\t_insertParagraphAccordingToFakeCaretPosition() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( modelSelection );\n\n\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\tthis._insertParagraph( selectedModelElement, typeAroundFakeCaretPosition );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a listener in the editing conversion pipeline that injects the widget type around\n\t * UI into every single widget instance created in the editor.\n\t *\n\t * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n\t * wrapper which renders DOM buttons that users can use to insert paragraphs.\n\t *\n\t * @private\n\t */\n\t_enableTypeAroundUIInjection() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\t\tconst t = editor.locale.t;\n\t\tconst buttonTitles = {\n\t\t\tbefore: t( 'Insert paragraph before block' ),\n\t\t\tafter: t( 'Insert paragraph after block' )\n\t\t};\n\n\t\teditor.editing.downcastDispatcher.on( 'insert', ( evt, data, conversionApi ) => {\n\t\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\t\t// Filter out non-widgets and inline widgets.\n\t\t\tif ( isTypeAroundWidget( viewElement, data.item, schema ) ) {\n\t\t\t\tinjectUIIntoWidget( conversionApi.writer, buttonTitles, viewElement );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Brings support for the fake caret that appears when either:\n\t *\n\t * * the selection moves to a widget from a position next to it using arrow keys,\n\t * * the arrow key is pressed when the widget is already selected.\n\t *\n\t * The fake caret lets the user know that they can start typing or just press\n\t * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.\n\t *\n\t * The fake caret disappears when the user changes the selection or the editor\n\t * gets blurred.\n\t *\n\t * The whole idea is as follows:\n\t *\n\t * 1. A user does one of the 2 scenarios described at the beginning.\n\t * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the fake caret.\n\t * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating\n\t *    on which side of the widget it should appear.\n\t * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n\t *    fake caret on the view widget.\n\t * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher\n\t *    does the CSS class clean-up in the view.\n\t * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection\n\t *    attribute (the former also removes widget CSS classes).\n\t *\n\t * @private\n\t */\n\t_enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst schema = model.schema;\n\t\tconst editingView = editor.editing.view;\n\n\t\t// This is the main listener responsible for the fake caret.\n\t\t// Note: The priority must precede the default Widget class keydown handler (\"high\").\n\t\tthis._listenToIfEnabled( editingView.document, 'arrowKey', ( evt, domEventData ) => {\n\t\t\tthis._handleArrowKeyPress( evt, domEventData );\n\t\t}, { context: [ isWidget, '$text' ], priority: 'high' } );\n\n\t\t// This listener makes sure the widget type around selection attribute will be gone from the model\n\t\t// selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n\t\t// (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n\t\t// let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n\t\tthis._listenToIfEnabled( modelSelection, 'change:range', ( evt, data ) => {\n\t\t\t// Do not reset the selection attribute when the change was indirect.\n\t\t\tif ( !data.directChange ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get rid of the widget type around attribute of the selection on every change:range.\n\t\t\t// If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n\t\t\teditor.model.change( writer => {\n\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t} );\n\t\t} );\n\n\t\t// Get rid of the widget type around attribute of the selection on every document change\n\t\t// that makes widget not selected any more (i.e. widget was removed).\n\t\tthis._listenToIfEnabled( model.document, 'change:data', () => {\n\t\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\t\tif ( selectedModelElement ) {\n\t\t\t\tconst selectedViewElement = editor.editing.mapper.toViewElement( selectedModelElement );\n\n\t\t\t\tif ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t} );\n\t\t} );\n\n\t\t// React to changes of the model selection attribute made by the arrow keys listener.\n\t\t// If the block widget is selected and the attribute changes, downcast the attribute to special\n\t\t// CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n\t\tthis._listenToIfEnabled( editor.editing.downcastDispatcher, 'selection', ( evt, data, conversionApi ) => {\n\t\t\tconst writer = conversionApi.writer;\n\n\t\t\tif ( this._currentFakeCaretModelElement ) {\n\t\t\t\tconst selectedViewElement = conversionApi.mapper.toViewElement( this._currentFakeCaretModelElement );\n\n\t\t\t\tif ( selectedViewElement ) {\n\t\t\t\t\t// Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n\t\t\t\t\twriter.removeClass( POSSIBLE_INSERTION_POSITIONS.map( positionToWidgetCssClass ), selectedViewElement );\n\n\t\t\t\t\tthis._currentFakeCaretModelElement = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst selectedModelElement = data.selection.getSelectedElement();\n\n\t\t\tif ( !selectedModelElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedViewElement = conversionApi.mapper.toViewElement( selectedModelElement );\n\n\t\t\tif ( !isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( data.selection );\n\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twriter.addClass( positionToWidgetCssClass( typeAroundFakeCaretPosition ), selectedViewElement );\n\n\t\t\t// Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n\t\t\t// selection changes\n\t\t\tthis._currentFakeCaretModelElement = selectedModelElement;\n\t\t} );\n\n\t\tthis._listenToIfEnabled( editor.ui.focusTracker, 'change:isFocused', ( evt, name, isFocused ) => {\n\t\t\tif ( !isFocused ) {\n\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tfunction positionToWidgetCssClass( position ) {\n\t\t\treturn `ck-widget_type-around_show-fake-caret_${ position }`;\n\t\t}\n\t}\n\n\t/**\n\t * A listener executed on each \"keydown\" in the view document, a part of\n\t * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n\t *\n\t * It decides whether the arrow keypress should activate the fake caret or not (also whether it should\n\t * be deactivated).\n\t *\n\t * The fake caret activation is done by setting the `widget-type-around` model selection attribute\n\t * in this listener, and stopping and preventing the event that would normally be handled by the widget\n\t * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n\t * includes inline widgets, which are ignored by the widget type around plugin).\n\t *\n\t * @private\n\t */\n\t_handleArrowKeyPress( evt, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst schema = model.schema;\n\t\tconst editingView = editor.editing.view;\n\n\t\tconst keyCode = domEventData.keyCode;\n\t\tconst isForward = isForwardArrowKeyCode( keyCode, editor.locale.contentLanguageDirection );\n\t\tconst selectedViewElement = editingView.document.selection.getSelectedElement();\n\t\tconst selectedModelElement = editor.editing.mapper.toModelElement( selectedViewElement );\n\t\tlet shouldStopAndPreventDefault;\n\n\t\t// Handle keyboard navigation when a type-around-compatible widget is currently selected.\n\t\tif ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget( isForward );\n\t\t}\n\t\t// Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n\t\t// and the widget is about to be selected.\n\t\telse if ( modelSelection.isCollapsed ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget( isForward );\n\t\t}\n\t\t// Handle collapsing a non-collapsed selection that is wider than on a single widget.\n\t\telse if ( !domEventData.shiftKey ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection( isForward );\n\t\t}\n\n\t\tif ( shouldStopAndPreventDefault ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n\t * the fake caret for that widget, depending on the current value of the `widget-type-around` model\n\t * selection attribute and the direction of the pressed arrow key.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n\t * process the event any further. Returns `false` otherwise.\n\t */\n\t_handleArrowKeyPressOnSelectedWidget( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( modelSelection );\n\n\t\treturn model.change( writer => {\n\t\t\t// If the fake caret is displayed...\n\t\t\tif ( typeAroundFakeCaretPosition ) {\n\t\t\t\tconst isLeavingWidget = typeAroundFakeCaretPosition === ( isForward ? 'after' : 'before' );\n\n\t\t\t\t// If the keyboard arrow works against the value of the selection attribute...\n\t\t\t\t// then remove the selection attribute but prevent default DOM actions\n\t\t\t\t// and do not let the Widget plugin listener move the selection. This brings\n\t\t\t\t// the widget back to the state, for instance, like if was selected using the mouse.\n\t\t\t\t//\n\t\t\t\t// **Note**: If leaving the widget when the fake caret is active, then the default\n\t\t\t\t// Widget handler will change the selection and, in turn, this will automatically discard\n\t\t\t\t// the selection attribute.\n\t\t\t\tif ( !isLeavingWidget ) {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n\t\t\t// key press. This also means we cannot let the Widget plugin listener move the selection.\n\t\t\telse {\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before' );\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t} );\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n\t * to one and upon the fake caret should become active for this widget upon arrow keypress\n\t * (AKA entering/selecting the widget).\n\t *\n\t * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.\n\t * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the\n\t * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n\t * process the event any further. Returns `false` otherwise.\n\t */\n\t_handleArrowKeyPressWhenSelectionNextToAWidget( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\t\tconst widgetPlugin = editor.plugins.get( 'Widget' );\n\n\t\t// This is the widget the selection is about to be set on.\n\t\tconst modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection( isForward );\n\t\tconst viewElementNextToSelection = editor.editing.mapper.toViewElement( modelElementNextToSelection );\n\n\t\tif ( isTypeAroundWidget( viewElementNextToSelection, modelElementNextToSelection, schema ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twidgetPlugin._setSelectionOverElement( modelElementNextToSelection );\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after' );\n\t\t\t} );\n\n\t\t\t// The change() block above does the same job as the Widget plugin. The event can\n\t\t\t// be safely canceled.\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when a widget is currently selected (together with some other content)\n\t * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n\t * process the event any further. Returns `false` otherwise.\n\t */\n\t_handleArrowKeyPressWhenNonCollapsedSelection( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\t\tconst mapper = editor.editing.mapper;\n\t\tconst modelSelection = model.document.selection;\n\n\t\tconst selectedModelNode = isForward ?\n\t\t\tmodelSelection.getLastPosition().nodeBefore :\n\t\t\tmodelSelection.getFirstPosition().nodeAfter;\n\n\t\tconst selectedViewNode = mapper.toViewElement( selectedModelNode );\n\n\t\t// There is a widget at the collapse position so collapse the selection to the fake caret on it.\n\t\tif ( isTypeAroundWidget( selectedViewNode, selectedModelNode, schema ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( selectedModelNode, 'on' );\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before' );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Registers a `mousedown` listener for the view document which intercepts events\n\t * coming from the widget type around UI, which happens when a user clicks one of the buttons\n\t * that insert a paragraph next to a widget.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnButtonClick() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\tthis._listenToIfEnabled( editingView.document, 'mousedown', ( evt, domEventData ) => {\n\t\t\tconst button = getClosestTypeAroundDomButton( domEventData.domTarget );\n\n\t\t\tif ( !button ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst buttonPosition = getTypeAroundButtonPosition( button );\n\t\t\tconst widgetViewElement = getClosestWidgetViewElement( button, editingView.domConverter );\n\t\t\tconst widgetModelElement = editor.editing.mapper.toModelElement( widgetViewElement );\n\n\t\t\tthis._insertParagraph( widgetModelElement, buttonPosition );\n\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t} );\n\t}\n\n\t/**\n\t * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph\n\t * near the widget when either:\n\t *\n\t * * The fake caret was first activated using the arrow keys,\n\t * * The entire widget is selected in the model.\n\t *\n\t * In the first case, the new paragraph is inserted according to the `widget-type-around` selection\n\t * attribute (see {@link #_handleArrowKeyPress}).\n\t *\n\t * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke\n\t * was pressed or not.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnEnterKeypress() {\n\t\tconst editor = this.editor;\n\t\tconst selection = editor.model.document.selection;\n\t\tconst editingView = editor.editing.view;\n\n\t\tthis._listenToIfEnabled( editingView.document, 'enter', ( evt, domEventData ) => {\n\t\t\t// This event could be triggered from inside the widget but we are interested\n\t\t\t// only when the widget is selected itself.\n\t\t\tif ( evt.eventPhase != 'atTarget' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedModelElement = selection.getSelectedElement();\n\t\t\tconst selectedViewElement = editor.editing.mapper.toViewElement( selectedModelElement );\n\n\t\t\tconst schema = editor.model.schema;\n\t\t\tlet wasHandled;\n\n\t\t\t// First check if the widget is selected and there's a type around selection attribute associated\n\t\t\t// with the fake caret that would tell where to insert a new paragraph.\n\t\t\tif ( this._insertParagraphAccordingToFakeCaretPosition() ) {\n\t\t\t\twasHandled = true;\n\t\t\t}\n\t\t\t// Then, if there is no selection attribute associated with the fake caret, check if the widget\n\t\t\t// simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n\t\t\telse if ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\tthis._insertParagraph( selectedModelElement, domEventData.isSoft ? 'before' : 'after' );\n\n\t\t\t\twasHandled = true;\n\t\t\t}\n\n\t\t\tif ( wasHandled ) {\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { context: isWidget } );\n\t}\n\n\t/**\n\t * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n\t * to insert a paragraph next to a widget when the fake caret was activated using arrow\n\t * keys but it responds to typing keystrokes instead of <kbd>Enter</kbd>.\n\t *\n\t * \"Typing keystrokes\" are keystrokes that insert new content into the document,\n\t * for instance, letters (\"a\") or numbers (\"4\"). The \"keydown\" listener enabled by this method\n\t * will insert a new paragraph according to the `widget-type-around` model selection attribute\n\t * as the user simply starts typing, which creates the impression that the fake caret\n\t * behaves like a real one rendered by the browser (AKA your text appears where the caret was).\n\t *\n\t * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command\n\t * and another one for actual typing. It is not a disaster but this may need to be fixed\n\t * sooner or later.\n\t *\n\t * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnTypingKeystroke() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\t\tconst keyCodesHandledSomewhereElse = [\n\t\t\tkeyCodes.enter,\n\t\t\tkeyCodes.delete,\n\t\t\tkeyCodes.backspace\n\t\t];\n\n\t\t// Note: The priority must precede the default observers.\n\t\tthis._listenToIfEnabled( editingView.document, 'keydown', ( evt, domEventData ) => {\n\t\t\t// Don't handle enter/backspace/delete here. They are handled in dedicated listeners.\n\t\t\tif ( !keyCodesHandledSomewhereElse.includes( domEventData.keyCode ) && !isNonTypingKeystroke( domEventData ) ) {\n\t\t\t\tthis._insertParagraphAccordingToFakeCaretPosition();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * It creates a \"delete\" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>\n\t * is pressed and the fake caret is currently active.\n\t *\n\t * The fake caret should create an illusion of a real browser caret so that when it appears before or after\n\t * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content\n\t * before or after a widget (depending on the content surrounding the widget).\n\t *\n\t * @private\n\t */\n\t_enableDeleteIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\n\t\tthis._listenToIfEnabled( editingView.document, 'delete', ( evt, domEventData ) => {\n\t\t\t// This event could be triggered from inside the widget but we are interested\n\t\t\t// only when the widget is selected itself.\n\t\t\tif ( evt.eventPhase != 'atTarget' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( model.document.selection );\n\n\t\t\t// This listener handles only these cases when the fake caret is active.\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst direction = domEventData.direction;\n\t\t\tconst selectedModelWidget = model.document.selection.getSelectedElement();\n\n\t\t\tconst isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n\t\t\tconst isDeleteForward = direction == 'forward';\n\t\t\tconst shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;\n\n\t\t\tif ( shouldDeleteEntireWidget ) {\n\t\t\t\teditor.execute( 'delete', {\n\t\t\t\t\tselection: model.createSelection( selectedModelWidget, 'on' )\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tconst range = schema.getNearestSelectionRange(\n\t\t\t\t\tmodel.createPositionAt( selectedModelWidget, typeAroundFakeCaretPosition ),\n\t\t\t\t\tdirection\n\t\t\t\t);\n\n\t\t\t\t// If there is somewhere to move selection to, then there will be something to delete.\n\t\t\t\tif ( range ) {\n\t\t\t\t\t// If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n\t\t\t\t\tif ( !range.isCollapsed ) {\n\t\t\t\t\t\tmodel.change( writer => {\n\t\t\t\t\t\t\twriter.setSelection( range );\n\t\t\t\t\t\t\teditor.execute( isDeleteForward ? 'deleteForward' : 'delete' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst probe = model.createSelection( range.start );\n\t\t\t\t\t\tmodel.modifySelection( probe, { direction } );\n\n\t\t\t\t\t\t// If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n\t\t\t\t\t\t// If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n\t\t\t\t\t\tif ( !probe.focus.isEqual( range.start ) ) {\n\t\t\t\t\t\t\tmodel.change( writer => {\n\t\t\t\t\t\t\t\twriter.setSelection( range );\n\t\t\t\t\t\t\t\teditor.execute( isDeleteForward ? 'deleteForward' : 'delete' );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n\t\t\t\t\t\t// next to a widget that should be removed. \"delete\" and \"deleteForward\" commands cannot get rid of it\n\t\t\t\t\t\t// so calling Model#deleteContent here manually.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor( schema, range.start.parent );\n\n\t\t\t\t\t\t\tmodel.deleteContent( model.createSelection( deepestEmptyRangeAncestor, 'on' ), {\n\t\t\t\t\t\t\t\tdoNotAutoparagraph: true\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If some content was deleted, don't let the handler from the Widget plugin kick in.\n\t\t\t// If nothing was deleted, then the default handler will have nothing to do anyway.\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t}, { context: isWidget } );\n\t}\n\n\t/**\n\t * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n\t * content near a widget when the fake caret is first activated using the arrow keys.\n\t *\n\t * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n\t *\n\t * @private\n\t */\n\t_enableInsertContentIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\n\t\tthis._listenToIfEnabled( editor.model, 'insertContent', ( evt, [ content, selectable ] ) => {\n\t\t\tif ( selectable && !selectable.is( 'documentSelection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( documentSelection );\n\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevt.stop();\n\n\t\t\treturn model.change( writer => {\n\t\t\t\tconst selectedElement = documentSelection.getSelectedElement();\n\t\t\t\tconst position = model.createPositionAt( selectedElement, typeAroundFakeCaretPosition );\n\t\t\t\tconst selection = writer.createSelection( position );\n\n\t\t\t\tconst result = model.insertContent( content, selection );\n\n\t\t\t\twriter.setSelection( selection );\n\n\t\t\t\treturn result;\n\t\t\t} );\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the\n\t * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element\n\t * to reflect user's intent of desired insertion position.\n\t *\n\t * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n\t *\n\t * @private\n\t */\n\t_enableInsertObjectIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\n\t\tthis._listenToIfEnabled( editor.model, 'insertObject', ( evt, args ) => {\n\t\t\tconst [ , selectable, , options = {} ] = args;\n\n\t\t\tif ( selectable && !selectable.is( 'documentSelection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( documentSelection );\n\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\toptions.findOptimalPosition = typeAroundFakeCaretPosition;\n\t\t\targs[ 3 ] = options;\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake\n\t * caret is active.\n\t *\n\t * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n\t * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,\n\t * plain text pasting.\n\t *\n\t * @private\n\t */\n\t_enableDeleteContentIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\n\t\tthis._listenToIfEnabled( editor.model, 'deleteContent', ( evt, [ selection ] ) => {\n\t\t\tif ( selection && !selection.is( 'documentSelection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( documentSelection );\n\n\t\t\t// Disable removing the selection content while pasting plain text.\n\t\t\tif ( typeAroundFakeCaretPosition ) {\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n}\n\n// Injects the type around UI into a view widget instance.\n//\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {Object.<String,String>} buttonTitles\n// @param {module:engine/view/element~Element} widgetViewElement\nfunction injectUIIntoWidget( viewWriter, buttonTitles, widgetViewElement ) {\n\tconst typeAroundWrapper = viewWriter.createUIElement( 'div', {\n\t\tclass: 'ck ck-reset_all ck-widget__type-around'\n\t}, function( domDocument ) {\n\t\tconst wrapperDomElement = this.toDomElement( domDocument );\n\n\t\tinjectButtons( wrapperDomElement, buttonTitles );\n\t\tinjectFakeCaret( wrapperDomElement );\n\n\t\treturn wrapperDomElement;\n\t} );\n\n\t// Inject the type around wrapper into the widget's wrapper.\n\tviewWriter.insert( viewWriter.createPositionAt( widgetViewElement, 'end' ), typeAroundWrapper );\n}\n\n// FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n// <svg> here.\n//\n// @param {HTMLElement} wrapperDomElement\n// @param {Object.<String,String>} buttonTitles\nfunction injectButtons( wrapperDomElement, buttonTitles ) {\n\tfor ( const position of POSSIBLE_INSERTION_POSITIONS ) {\n\t\tconst buttonTemplate = new Template( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-widget__type-around__button',\n\t\t\t\t\t`ck-widget__type-around__button_${ position }`\n\t\t\t\t],\n\t\t\t\ttitle: buttonTitles[ position ]\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\twrapperDomElement.ownerDocument.importNode( RETURN_ARROW_ICON_ELEMENT, true )\n\t\t\t]\n\t\t} );\n\n\t\twrapperDomElement.appendChild( buttonTemplate.render() );\n\t}\n}\n\n// @param {HTMLElement} wrapperDomElement\nfunction injectFakeCaret( wrapperDomElement ) {\n\tconst caretTemplate = new Template( {\n\t\ttag: 'div',\n\t\tattributes: {\n\t\t\tclass: [\n\t\t\t\t'ck',\n\t\t\t\t'ck-widget__type-around__fake-caret'\n\t\t\t]\n\t\t}\n\t} );\n\n\twrapperDomElement.appendChild( caretTemplate.render() );\n}\n\n// Returns the ancestor of an element closest to the root which is empty. For instance,\n// for `<baz>`:\n//\n//\t\t<foo>abc<bar><baz></baz></bar></foo>\n//\n// it returns `<bar>`.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/element~Element|null}\nfunction getDeepestEmptyElementAncestor( schema, element ) {\n\tlet deepestEmptyAncestor = element;\n\n\tfor ( const ancestor of element.getAncestors( { parentFirst: true } ) ) {\n\t\tif ( ancestor.childCount > 1 || schema.isLimit( ancestor ) ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdeepestEmptyAncestor = ancestor;\n\t}\n\n\treturn deepestEmptyAncestor;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}