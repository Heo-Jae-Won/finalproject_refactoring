{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/keystrokehandler\n */\nimport DomEmitterMixin from './dom/emittermixin';\nimport { getCode, parseKeystroke } from './keyboard';\n/**\n * Keystroke handler allows registering callbacks for given keystrokes.\n *\n * The most frequent use of this class is through the {@link module:core/editor/editor~Editor#keystrokes `editor.keystrokes`}\n * property. It allows listening to keystrokes executed in the editing view:\n *\n *\t\teditor.keystrokes.set( 'Ctrl+A', ( keyEvtData, cancel ) => {\n *\t\t\tconsole.log( 'Ctrl+A has been pressed' );\n *\t\t\tcancel();\n *\t\t} );\n *\n * However, this utility class can be used in various part of the UI. For instance, a certain {@link module:ui/view~View}\n * can use it like this:\n *\n *\t\tclass MyView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.keystrokes = new KeystrokeHandler();\n *\n * \t\t\t\tthis.keystrokes.set( 'tab', handleTabKey );\n *\t\t\t}\n *\n *\t\t\trender() {\n *\t\t\t\tsuper.render();\n *\n *\t\t\t\tthis.keystrokes.listenTo( this.element );\n *\t\t\t}\n *\t\t}\n *\n * That keystroke handler will listen to `keydown` events fired in this view's main element.\n *\n */\nexport default class KeystrokeHandler {\n  /**\n   * Creates an instance of the keystroke handler.\n   */\n  constructor() {\n    this._listener = Object.create(DomEmitterMixin);\n  }\n  /**\n   * Starts listening for `keydown` events from a given emitter.\n   *\n   * @param {module:utils/emittermixin~Emitter|HTMLElement|Window} emitter\n   */\n  listenTo(emitter) {\n    // The #_listener works here as a kind of dispatcher. It groups the events coming from the same\n    // keystroke so the listeners can be attached to them with different priorities.\n    //\n    // E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated\n    // as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`\n    // method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts\n    // only with other listeners of this particular event, thus making it possible to prioritize\n    // the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,\n    // the KeystrokeHandler re–uses it to do its job.\n    this._listener.listenTo(emitter, 'keydown', (evt, keyEvtData) => {\n      this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n    });\n  }\n  /**\n   * Registers a handler for the specified keystroke.\n   *\n   * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n   * the {@link module:utils/keyboard~parseKeystroke} function.\n   * @param {Function} callback A function called with the\n   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n   * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.\n   * @param {Object} [options={}] Additional options.\n   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n   * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n   * are called in the order they were added.\n   */\n  set(keystroke, callback) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const keyCode = parseKeystroke(keystroke);\n    const priority = options.priority;\n    // Execute the passed callback on KeystrokeHandler#_keydown.\n    // TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144\n    this._listener.listenTo(this._listener, '_keydown:' + keyCode, (evt, keyEvtData) => {\n      callback(keyEvtData, () => {\n        // Stop the event in the DOM: no listener in the web page\n        // will be triggered by this event.\n        keyEvtData.preventDefault();\n        keyEvtData.stopPropagation();\n        // Stop the event in the KeystrokeHandler: no more callbacks\n        // will be executed for this keystroke.\n        evt.stop();\n      });\n      // Mark this keystroke as handled by the callback. See: #press.\n      evt.return = true;\n    }, {\n      priority\n    });\n  }\n  /**\n   * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.\n   *\n   * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.\n   * @returns {Boolean} Whether the keystroke was handled.\n   */\n  press(keyEvtData) {\n    return !!this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n  }\n  /**\n   * Destroys the keystroke handler.\n   */\n  destroy() {\n    this._listener.stopListening();\n  }\n}","map":{"version":3,"names":["DomEmitterMixin","getCode","parseKeystroke","KeystrokeHandler","constructor","_listener","Object","create","listenTo","emitter","evt","keyEvtData","fire","set","keystroke","callback","options","keyCode","priority","preventDefault","stopPropagation","stop","return","press","destroy","stopListening"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/keystrokehandler.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/keystrokehandler\n */\nimport DomEmitterMixin from './dom/emittermixin';\nimport { getCode, parseKeystroke } from './keyboard';\n/**\n * Keystroke handler allows registering callbacks for given keystrokes.\n *\n * The most frequent use of this class is through the {@link module:core/editor/editor~Editor#keystrokes `editor.keystrokes`}\n * property. It allows listening to keystrokes executed in the editing view:\n *\n *\t\teditor.keystrokes.set( 'Ctrl+A', ( keyEvtData, cancel ) => {\n *\t\t\tconsole.log( 'Ctrl+A has been pressed' );\n *\t\t\tcancel();\n *\t\t} );\n *\n * However, this utility class can be used in various part of the UI. For instance, a certain {@link module:ui/view~View}\n * can use it like this:\n *\n *\t\tclass MyView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.keystrokes = new KeystrokeHandler();\n *\n * \t\t\t\tthis.keystrokes.set( 'tab', handleTabKey );\n *\t\t\t}\n *\n *\t\t\trender() {\n *\t\t\t\tsuper.render();\n *\n *\t\t\t\tthis.keystrokes.listenTo( this.element );\n *\t\t\t}\n *\t\t}\n *\n * That keystroke handler will listen to `keydown` events fired in this view's main element.\n *\n */\nexport default class KeystrokeHandler {\n    /**\n     * Creates an instance of the keystroke handler.\n     */\n    constructor() {\n        this._listener = Object.create(DomEmitterMixin);\n    }\n    /**\n     * Starts listening for `keydown` events from a given emitter.\n     *\n     * @param {module:utils/emittermixin~Emitter|HTMLElement|Window} emitter\n     */\n    listenTo(emitter) {\n        // The #_listener works here as a kind of dispatcher. It groups the events coming from the same\n        // keystroke so the listeners can be attached to them with different priorities.\n        //\n        // E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated\n        // as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`\n        // method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts\n        // only with other listeners of this particular event, thus making it possible to prioritize\n        // the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,\n        // the KeystrokeHandler re–uses it to do its job.\n        this._listener.listenTo(emitter, 'keydown', (evt, keyEvtData) => {\n            this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n        });\n    }\n    /**\n     * Registers a handler for the specified keystroke.\n     *\n     * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n     * the {@link module:utils/keyboard~parseKeystroke} function.\n     * @param {Function} callback A function called with the\n     * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n     * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.\n     * @param {Object} [options={}] Additional options.\n     * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n     * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n     * are called in the order they were added.\n     */\n    set(keystroke, callback, options = {}) {\n        const keyCode = parseKeystroke(keystroke);\n        const priority = options.priority;\n        // Execute the passed callback on KeystrokeHandler#_keydown.\n        // TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144\n        this._listener.listenTo(this._listener, '_keydown:' + keyCode, (evt, keyEvtData) => {\n            callback(keyEvtData, () => {\n                // Stop the event in the DOM: no listener in the web page\n                // will be triggered by this event.\n                keyEvtData.preventDefault();\n                keyEvtData.stopPropagation();\n                // Stop the event in the KeystrokeHandler: no more callbacks\n                // will be executed for this keystroke.\n                evt.stop();\n            });\n            // Mark this keystroke as handled by the callback. See: #press.\n            evt.return = true;\n        }, { priority });\n    }\n    /**\n     * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.\n     *\n     * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.\n     * @returns {Boolean} Whether the keystroke was handled.\n     */\n    press(keyEvtData) {\n        return !!this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n    }\n    /**\n     * Destroys the keystroke handler.\n     */\n    destroy() {\n        this._listener.stopListening();\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,eAAe,MAAM,oBAAoB;AAChD,SAASC,OAAO,EAAEC,cAAc,QAAQ,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,gBAAgB,CAAC;EAClC;AACJ;AACA;EACIC,WAAW,GAAG;IACV,IAAI,CAACC,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACP,eAAe,CAAC;EACnD;EACA;AACJ;AACA;AACA;AACA;EACIQ,QAAQ,CAACC,OAAO,EAAE;IACd;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACJ,SAAS,CAACG,QAAQ,CAACC,OAAO,EAAE,SAAS,EAAE,CAACC,GAAG,EAAEC,UAAU,KAAK;MAC7D,IAAI,CAACN,SAAS,CAACO,IAAI,CAAC,WAAW,GAAGX,OAAO,CAACU,UAAU,CAAC,EAAEA,UAAU,CAAC;IACtE,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,GAAG,CAACC,SAAS,EAAEC,QAAQ,EAAgB;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IACjC,MAAMC,OAAO,GAAGf,cAAc,CAACY,SAAS,CAAC;IACzC,MAAMI,QAAQ,GAAGF,OAAO,CAACE,QAAQ;IACjC;IACA;IACA,IAAI,CAACb,SAAS,CAACG,QAAQ,CAAC,IAAI,CAACH,SAAS,EAAE,WAAW,GAAGY,OAAO,EAAE,CAACP,GAAG,EAAEC,UAAU,KAAK;MAChFI,QAAQ,CAACJ,UAAU,EAAE,MAAM;QACvB;QACA;QACAA,UAAU,CAACQ,cAAc,EAAE;QAC3BR,UAAU,CAACS,eAAe,EAAE;QAC5B;QACA;QACAV,GAAG,CAACW,IAAI,EAAE;MACd,CAAC,CAAC;MACF;MACAX,GAAG,CAACY,MAAM,GAAG,IAAI;IACrB,CAAC,EAAE;MAAEJ;IAAS,CAAC,CAAC;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIK,KAAK,CAACZ,UAAU,EAAE;IACd,OAAO,CAAC,CAAC,IAAI,CAACN,SAAS,CAACO,IAAI,CAAC,WAAW,GAAGX,OAAO,CAACU,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC/E;EACA;AACJ;AACA;EACIa,OAAO,GAAG;IACN,IAAI,CAACnB,SAAS,CAACoB,aAAa,EAAE;EAClC;AACJ"},"metadata":{},"sourceType":"module"}