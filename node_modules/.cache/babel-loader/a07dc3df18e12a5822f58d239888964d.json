{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/model\n */\nimport Batch from './batch';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ModelPosition from './position';\nimport ModelRange from './range';\nimport ModelSelection from './selection';\nimport OperationFactory from './operation/operationfactory';\nimport Schema from './schema';\nimport Writer from './writer';\nimport { autoParagraphEmptyRoots } from './utils/autoparagraphing';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport deleteContent from './utils/deletecontent';\nimport getSelectedContent from './utils/getselectedcontent';\nimport insertContent from './utils/insertcontent';\nimport insertObject from './utils/insertobject';\nimport modifySelection from './utils/modifyselection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\n// @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Model extends Observable {\n  constructor() {\n    super();\n    /**\n     * Model's marker collection.\n     *\n     * @readonly\n     * @member {module:engine/model/markercollection~MarkerCollection}\n     */\n    this.markers = new MarkerCollection();\n    /**\n     * Model's document.\n     *\n     * @readonly\n     * @member {module:engine/model/document~Document}\n     */\n    this.document = new Document(this);\n    /**\n     * Model's schema.\n     *\n     * @readonly\n     * @member {module:engine/model/schema~Schema}\n     */\n    this.schema = new Schema();\n    /**\n     * All callbacks added by {@link module:engine/model/model~Model#change} or\n     * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n     *\n     * @private\n     * @type {Array.<Function>}\n     */\n    this._pendingChanges = [];\n    /**\n     * The last created and currently used writer instance.\n     *\n     * @private\n     * @member {module:engine/model/writer~Writer}\n     */\n    this._currentWriter = null;\n    ['insertContent', 'insertObject', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach(methodName => this.decorate(methodName));\n    // Adding operation validation with `highest` priority, so it is called before any other feature would like\n    // to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n    this.on('applyOperation', (evt, args) => {\n      const operation = args[0];\n      operation._validate();\n    }, {\n      priority: 'highest'\n    });\n    // Register some default abstract entities.\n    this.schema.register('$root', {\n      isLimit: true\n    });\n    this.schema.register('$container', {\n      allowIn: ['$root', '$container']\n    });\n    this.schema.register('$block', {\n      allowIn: ['$root', '$container'],\n      isBlock: true\n    });\n    this.schema.register('$blockObject', {\n      allowWhere: '$block',\n      isBlock: true,\n      isObject: true\n    });\n    this.schema.register('$inlineObject', {\n      allowWhere: '$text',\n      allowAttributesOf: '$text',\n      isInline: true,\n      isObject: true\n    });\n    this.schema.register('$text', {\n      allowIn: '$block',\n      isInline: true,\n      isContent: true\n    });\n    this.schema.register('$clipboardHolder', {\n      allowContentOf: '$root',\n      allowChildren: '$text',\n      isLimit: true\n    });\n    this.schema.register('$documentFragment', {\n      allowContentOf: '$root',\n      allowChildren: '$text',\n      isLimit: true\n    });\n    // An element needed by the `upcastElementToMarker` converter.\n    // This element temporarily represents a marker boundary during the conversion process and is removed\n    // at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n    // better place for this registration but both know nothing about `Schema`.\n    this.schema.register('$marker');\n    this.schema.addChildCheck((context, childDefinition) => {\n      if (childDefinition.name === '$marker') {\n        return true;\n      }\n    });\n    injectSelectionPostFixer(this);\n    // Post-fixer which takes care of adding empty paragraph elements to the empty roots.\n    this.document.registerPostFixer(autoParagraphEmptyRoots);\n    // @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n    // @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n    // @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n  }\n  /**\n   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n   * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n   * the {@link module:engine/model/document~Document#selection document's selection}, and\n   * {@link module:engine/model/model~Model#markers model markers}.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t} );\n   *\n   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n   * into a single undo step.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n   *\n   *\t\t\tmodel.change( writer => {\n   *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n   *\t\t\t} );\n   *\n   * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n   *\t\t} );\n   *\n   * The callback of the `change()` block is executed synchronously.\n   *\n   * You can also return a value from the change block.\n   *\n   *\t\tconst img = model.change( writer => {\n   *\t\t\treturn writer.createElement( 'img' );\n   *\t\t} );\n   *\n   * @see #enqueueChange\n   * @param {Function} callback Callback function which may modify the model.\n   * @returns {*} Value returned by the callback.\n   */\n  change(callback) {\n    try {\n      if (this._pendingChanges.length === 0) {\n        // If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n        this._pendingChanges.push({\n          batch: new Batch(),\n          callback\n        });\n        return this._runPendingChanges()[0];\n      } else {\n        // If this is not the outermost block, just execute the callback.\n        return callback(this._currentWriter);\n      }\n    } catch (err) {\n      // @if CK_DEBUG // throw err;\n      /* istanbul ignore next */\n      CKEditorError.rethrowUnexpectedError(err, this);\n    }\n  }\n  /**\n   * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n   *\n   * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n   * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n   * it will be delayed and executed after the outermost block.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconsole.log( 1 );\n   *\n   *\t\t\tmodel.enqueueChange( writer => {\n   *\t\t\t\tconsole.log( 2 );\n   *\t\t\t} );\n   *\n   * \t\t\tconsole.log( 3 );\n   *\t\t} ); // Will log: 1, 3, 2.\n   *\n   * In addition to that, the changes enqueued with `enqueueChange()` will be converted separately from the changes\n   * done in the outer `change()` block.\n   *\n   * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n   * By default, a new batch with the default {@link module:engine/model/batch~Batch#constructor batch type} is created.\n   * In the sample above, the `change` and `enqueueChange` blocks will use a different batch (and a different\n   * {@link module:engine/model/writer~Writer} instance since each of them operates on a separate batch).\n   *\n   *\t\tmodel.enqueueChange( { isUndoable: false }, writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t} );\n   *\n   * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n   *\n   *\t\tmodel.enqueueChange( batch, writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t} );\n   *\n   * In order to make a nested `enqueueChange()` create a single undo step together with the changes done in the outer `change()`\n   * block, you can obtain the batch instance from the  {@link module:engine/model/writer~Writer#batch writer} of the outer block.\n   *\n   * @param {module:engine/model/batch~Batch|Object} [batchOrType] A batch or a\n   * {@link module:engine/model/batch~Batch#constructor batch type} that should be used in the callback. If not defined, a new batch with\n   * the default type will be created.\n   * @param {Function} callback Callback function which may modify the model.\n   */\n  enqueueChange(batchOrType, callback) {\n    try {\n      if (!batchOrType) {\n        batchOrType = new Batch();\n      } else if (typeof batchOrType === 'function') {\n        callback = batchOrType;\n        batchOrType = new Batch();\n      } else if (!(batchOrType instanceof Batch)) {\n        batchOrType = new Batch(batchOrType);\n      }\n      this._pendingChanges.push({\n        batch: batchOrType,\n        callback\n      });\n      if (this._pendingChanges.length == 1) {\n        this._runPendingChanges();\n      }\n    } catch (err) {\n      // @if CK_DEBUG // throw err;\n      /* istanbul ignore next */\n      CKEditorError.rethrowUnexpectedError(err, this);\n    }\n  }\n  /**\n   * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n   * {@link module:engine/model/operation/operation~Operation operations} to the model.\n   *\n   * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n   * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n   * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n   * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n   */\n  applyOperation(operation) {\n    // @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n    // @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n    // @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n    // @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n    // @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n    // @if CK_DEBUG_ENGINE //}\n    // @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n    operation._execute();\n  }\n  // @if CK_DEBUG_ENGINE // getAppliedOperation() {\n  // @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n  // @if CK_DEBUG_ENGINE //\t\treturn '';\n  // @if CK_DEBUG_ENGINE //\t}\n  // @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n  // @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n  // @if CK_DEBUG_ENGINE // }\n  /**\n   * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n   * functionality to work.\n   *\n   * **Note**: If you want to insert an {@glink framework/guides/deep-dive/schema#object-elements object element}\n   * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.\n   *\n   * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n   * the content, clears the given selection's content before inserting nodes and moves the selection\n   * to its target position at the end of the process.\n   * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n   * pasting feature should do.\n   *\n   * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n   *\n   * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n   * inside a {@link #change `change()` block}.\n   *\n   * # Conversion and schema\n   *\n   * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n   * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n   * is only adding nodes to the model. Additionally, you need to define\n   * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n   * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n   *\n   * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n   * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n   * unless converters are defined for all elements and attributes in that HTML.\n   *\n   * # Examples\n   *\n   * Using `insertContent()` with a manually created model structure:\n   *\n   *\t\t// Let's create a document fragment containing such content as:\n   *\t\t//\n   *\t\t// <paragraph>foo</paragraph>\n   *\t\t// <blockQuote>\n   *\t\t//    <paragraph>bar</paragraph>\n   *\t\t// </blockQuote>\n   *\t\tconst docFrag = editor.model.change( writer => {\n   *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n   *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n   *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n   *\t\t\tconst docFrag = writer.createDocumentFragment();\n   *\n   *\t\t\twriter.append( p1, docFrag );\n   *\t\t\twriter.append( blockQuote, docFrag );\n   *\t\t\twriter.append( p2, blockQuote );\n   *\t\t\twriter.insertText( 'foo', p1 );\n   *\t\t\twriter.insertText( 'bar', p2 );\n   *\n   *\t\t\treturn docFrag;\n   *\t\t} );\n   *\n   *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n   *\t\t// so this code could be moved to the callback defined above.\n   *\t\teditor.model.insertContent( docFrag );\n   *\n   * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n   *\n   *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n   *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n   *\t\tconst htmlDP = new HtmlDataProcessor( viewDocument );\n   *\n   *\t\t// Convert an HTML string to a view document fragment:\n   *\t\tconst viewFragment = htmlDP.toView( htmlString );\n   *\n   *\t\t// Convert the view document fragment to a model document fragment\n   *\t\t// in the context of $root. This conversion takes the schema into\n   *\t\t// account so if, for example, the view document fragment contained a bare text node,\n   *\t\t// this text node cannot be a child of $root, so it will be automatically\n   *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n   *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n   *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n   *\t\t// which has a loosened schema.\n   *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n   *\n   *\t\teditor.model.insertContent( modelFragment );\n   *\n   * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n   *\n   *\t\t// Insert text at the current document selection position.\n   *\t\teditor.model.change( writer => {\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n   *\t\t} );\n   *\n   *\t\t// Insert text at a given position - the document selection will not be modified.\n   *\t\teditor.model.change( writer => {\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n   *\n   *\t\t\t// Which is a shorthand for:\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n   *\t\t} );\n   *\n   * If you want the document selection to be moved to the inserted content, use the\n   * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting\n   * the content:\n   *\n   *\t\teditor.model.change( writer => {\n   *\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\n   *\t\t\t// Insert an empty paragraph at the beginning of the root.\n   *\t\t\teditor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );\n   *\n   *\t\t\t// Move the document selection to the inserted paragraph.\n   *\t\t\twriter.setSelection( paragraph, 'in' );\n   *\t\t} );\n   *\n   * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,\n   * the new content will be inserted at the passed selection (instead of document selection):\n   *\n   *\t\teditor.model.change( writer => {\n   *\t\t\t// Create a selection in a paragraph that will be used as a place of insertion.\n   *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t\t// Insert the new text at the created selection.\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n   *\n   *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n   *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n   *\t\t\twriter.setSelection( selection );\n   *\t\t} );\n   *\n   * @fires insertContent\n   * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n   * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n   * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n   * This param defines a position in relation to that item.\n   * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n   * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n   * at the insertion position.\n   */\n  insertContent(content, selectable, placeOrOffset) {\n    return insertContent(this, content, selectable, placeOrOffset);\n  }\n  /**\n   * Inserts an {@glink framework/guides/deep-dive/schema#object-elements object element} at a specific position in the editor content.\n   *\n   * This is a high-level API:\n   * * It takes the {@link #schema schema} into consideration,\n   * * It clears the content of passed `selectable` before inserting,\n   * * It can move the selection at the end of the process,\n   * * It will copy the selected block's attributes to preserve them upon insertion,\n   * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,\n   * * etc.\n   *\n   * # Notes\n   *\n   * * If you want to insert a non-object content, see {@link #insertContent} instead.\n   * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.\n   * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside\n   * a {@link #change `change()` block}.\n   * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.\n   * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does\n   * is only adding nodes to the model. Additionally, you need to define\n   * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n   * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n   *\n   * # Examples\n   *\n   * Use the following code to insert an object at the current selection and keep the selection on the inserted element:\n   *\n   *\t\tconst rawHtmlEmbedElement = writer.createElement( 'rawHtml' );\n   *\n   *\t\tmodel.insertObject( rawHtmlEmbedElement, null, null, {\n   *\t\t\tsetSelection: 'on'\n   *\t\t} );\n   *\n   * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:\n   *\n   *\t\tconst pageBreakElement = writer.createElement( 'pageBreak' );\n   *\n   *\t\tmodel.insertObject( pageBreakElement, null, null, {\n   *\t\t\tsetSelection: 'after'\n   *\t\t} );\n   *\n   * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):\n   *\n   *\t\tconst tableElement = writer.createElement( 'table' );\n   *\n   *\t\tmodel.insertObject( tableElement, null, null, {\n   *\t\t\tfindOptimalPosition: 'auto'\n   *\t\t} );\n   *\n   * Use the following code to insert an object at the specific range (also: replace the content of the range):\n   *\n   *\t\tconst tableElement = writer.createElement( 'table' );\n   *\t\tconst range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );\n   *\n   *\t\tmodel.insertObject( tableElement, range );\n   *\n   * @param {module:engine/model/element~Element} object An object to be inserted into the model document.\n   * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n   * A selectable where the content should be inserted. If not specified, the current\n   * {@link module:engine/model/document~Document#selection document selection} will be used instead.\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} placeOrOffset Specifies the exact place or offset for the insertion to take place,\n   * relative to `selectable`.\n   * @param {Object} [options] Additional options.\n   * @param {'auto'|'before'|'after'} [options.findOptimalPosition] An option that, when set, adjusts the insertion position (relative to\n   * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).\n   * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.\n   * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.\n   * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.\n   *\n   * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.\n   * @param {'on'|'after'} [options.setSelection] An option that, when set, moves the\n   * {@link module:engine/model/document~Document#selection document selection} after inserting the object.\n   * * When `'on'`, the document selection will be set on the inserted object.\n   * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no\n   * such text node, a paragraph will be created and the document selection will be moved inside it.\n   * @returns {module:engine/model/range~Range} A range which contains all the performed changes. This is a range that, if removed,\n   * would return the model to the state before the insertion. If no changes were preformed by `insertObject()`, returns a range collapsed\n   * at the insertion position.\n   */\n  insertObject(object, selectable, placeOrOffset, options) {\n    return insertObject(this, object, selectable, placeOrOffset, options);\n  }\n  /**\n   * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n   *\n   * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n   * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n   * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n   * then that behavior should be implemented in the view's listener. At the same time, the table feature\n   * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n   * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n   * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n   *\n   * @fires deleteContent\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * Selection of which the content should be deleted.\n   * @param {Object} [options]\n   * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n   *\n   * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n   *\n   * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n   * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n   *\n   * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n   * elements will not be merged.\n   *\n   * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n   * paragraph when the entire content was selected.\n   *\n   * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n   *\n   * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n   * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n   *\n   * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n   * to a place where text cannot be inserted.\n   *\n   * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n   *\n   * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n   * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n   *\n   * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n   *\n   * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n   *\n   * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.\n   * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to\n   * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.\n   */\n  deleteContent(selection, options) {\n    deleteContent(this, selection, options);\n  }\n  /**\n   * Modifies the selection. Currently, the supported modifications are:\n   *\n   * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n   * Possible values for `unit` are:\n   *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n   *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n   *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n   *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n   *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n   *  why `'character'` value is most natural and common method of modifying selection.\n   *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n   *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n   *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n   *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n   *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n   *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n   *  extension will include whole \"surrogate pair\".\n   *  * `'word'` - moves selection by a whole word.\n   *\n   * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n   *\n   * @fires modifySelection\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * The selection to modify.\n   * @param {Object} [options]\n   * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n   * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n   * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n   */\n  modifySelection(selection, options) {\n    modifySelection(this, selection, options);\n  }\n  /**\n   * Gets a clone of the selected content.\n   *\n   * For example, for the following selection:\n   *\n   * ```html\n   * <paragraph>x</paragraph>\n   * <blockQuote>\n   *\t<paragraph>y</paragraph>\n   *\t<heading1>fir[st</heading1>\n   * </blockQuote>\n   * <paragraph>se]cond</paragraph>\n   * <paragraph>z</paragraph>\n   * ```\n   *\n   * It will return a document fragment with such a content:\n   *\n   * ```html\n   * <blockQuote>\n   *\t<heading1>st</heading1>\n   * </blockQuote>\n   * <paragraph>se</paragraph>\n   * ```\n   *\n   * @fires getSelectedContent\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * The selection of which content will be returned.\n   * @returns {module:engine/model/documentfragment~DocumentFragment}\n   */\n  getSelectedContent(selection) {\n    return getSelectedContent(this, selection);\n  }\n  /**\n   * Checks whether the given {@link module:engine/model/range~Range range} or\n   * {@link module:engine/model/element~Element element} has any meaningful content.\n   *\n   * Meaningful content is:\n   *\n   * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n   * any non-whitespace characters),\n   * * or any {@link module:engine/model/schema~Schema#isContent content element},\n   * * or any {@link module:engine/model/markercollection~Marker marker} which\n   * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n   *\n   * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n   * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)\n   * is considered non-empty.\n   *\n   * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n   * @param {Object} [options]\n   * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n   * @param {Boolean} [options.ignoreMarkers] Whether markers should be ignored.\n   * @returns {Boolean}\n   */\n  hasContent(rangeOrElement) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const range = rangeOrElement instanceof ModelRange ? rangeOrElement : ModelRange._createIn(rangeOrElement);\n    if (range.isCollapsed) {\n      return false;\n    }\n    const {\n      ignoreWhitespaces = false,\n      ignoreMarkers = false\n    } = options;\n    // Check if there are any markers which affects data in this given range.\n    if (!ignoreMarkers) {\n      for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range)) {\n        if (intersectingMarker.affectsData) {\n          return true;\n        }\n      }\n    }\n    for (const item of range.getItems()) {\n      if (this.schema.isContent(item)) {\n        if (item.is('$textProxy')) {\n          if (!ignoreWhitespaces) {\n            return true;\n          } else if (item.data.search(/\\S/) !== -1) {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Creates a position from the given root and path in that root.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   * @returns {module:engine/model/position~Position}\n   */\n  createPositionFromPath(root, path, stickiness) {\n    return new ModelPosition(root, path, stickiness);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/model/position~Position position},\n   * * a parent element and offset in that element,\n   * * a parent element and `'end'` (the position will be set at the end of that element),\n   * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n   * (the position will be set before or after the given model item).\n   *\n   * This method is a shortcut to other factory methods such as:\n   *\n   * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n   * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  createPositionAt(itemOrPosition, offset) {\n    return ModelPosition._createAt(itemOrPosition, offset);\n  }\n  /**\n   * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n  createPositionAfter(item) {\n    return ModelPosition._createAfter(item);\n  }\n  /**\n   * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n  createPositionBefore(item) {\n    return ModelPosition._createBefore(item);\n  }\n  /**\n   * Creates a range spanning from the `start` position to the `end` position.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconst range = writer.createRange( start, end );\n   *\t\t} );\n   *\n   * @param {module:engine/model/position~Position} start Start position.\n   * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n   * to the `start` position.\n   * @returns {module:engine/model/range~Range}\n   */\n  createRange(start, end) {\n    return new ModelRange(start, end);\n  }\n  /**\n   * Creates a range inside the given element which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconst range = writer.createRangeIn( paragraph );\n   *\t\t} );\n   *\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n  createRangeIn(element) {\n    return ModelRange._createIn(element);\n  }\n  /**\n   * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n   *\n   * Note: This method is also available on `writer` instance as\n   * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconst range = writer.createRangeOn( paragraph );\n   *\t\t} );\n   *\n   * @param {module:engine/model/item~Item} item\n   * @returns {module:engine/model/range~Range}\n   */\n  createRangeOn(item) {\n    return ModelRange._createOn(item);\n  }\n  /**\n   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n   * or creates an empty selection if no arguments were passed.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n   *\n   *\t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the given document selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst documentSelection = model.document.selection;\n   *\t\tconst selection = writer.createSelection( documentSelection );\n   *\n   *\t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates selection at the given offset in the given element.\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [optionsOrPlaceOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @returns {module:engine/model/selection~Selection}\n   */\n  createSelection() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new ModelSelection(...args);\n  }\n  /**\n   * Creates a {@link module:engine/model/batch~Batch} instance.\n   *\n   * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n   *\n   * * {@link #change `change()`},\n   * * {@link #enqueueChange `enqueueChange()`}.\n   *\n   * @param {Object} [type] {@link module:engine/model/batch~Batch#constructor The type} of the batch.\n   * @returns {module:engine/model/batch~Batch}\n   */\n  createBatch(type) {\n    return new Batch(type);\n  }\n  /**\n   * Creates an operation instance from a JSON object (parsed JSON string).\n   *\n   * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.\n   *\n   * @param {Object} json Deserialized JSON object.\n   * @returns {module:engine/model/operation/operation~Operation}\n   */\n  createOperationFromJSON(json) {\n    return OperationFactory.fromJSON(json, this.document);\n  }\n  /**\n   * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n   */\n  destroy() {\n    this.document.destroy();\n    this.stopListening();\n  }\n  /**\n   * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n   * which calls callbacks and returns array of values returned by these callbacks.\n   *\n   * @private\n   * @returns {Array.<*>} Array of values returned by callbacks.\n   */\n  _runPendingChanges() {\n    const ret = [];\n    this.fire('_beforeChanges');\n    try {\n      while (this._pendingChanges.length) {\n        // Create a new writer using batch instance created for this chain of changes.\n        const currentBatch = this._pendingChanges[0].batch;\n        this._currentWriter = new Writer(this, currentBatch);\n        // Execute changes callback and gather the returned value.\n        const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);\n        ret.push(callbackReturnValue);\n        this.document._handleChangeBlock(this._currentWriter);\n        this._pendingChanges.shift();\n        this._currentWriter = null;\n      }\n    } finally {\n      this._pendingChanges.length = 0;\n      this._currentWriter = null;\n      this.fire('_afterChanges');\n    }\n    return ret;\n  }\n}","map":{"version":3,"names":["Batch","Document","MarkerCollection","ModelPosition","ModelRange","ModelSelection","OperationFactory","Schema","Writer","autoParagraphEmptyRoots","injectSelectionPostFixer","deleteContent","getSelectedContent","insertContent","insertObject","modifySelection","CKEditorError","Observable","Model","constructor","markers","document","schema","_pendingChanges","_currentWriter","forEach","methodName","decorate","on","evt","args","operation","_validate","priority","register","isLimit","allowIn","isBlock","allowWhere","isObject","allowAttributesOf","isInline","isContent","allowContentOf","allowChildren","addChildCheck","context","childDefinition","name","registerPostFixer","change","callback","length","push","batch","_runPendingChanges","err","rethrowUnexpectedError","enqueueChange","batchOrType","applyOperation","_execute","content","selectable","placeOrOffset","object","options","selection","hasContent","rangeOrElement","range","_createIn","isCollapsed","ignoreWhitespaces","ignoreMarkers","intersectingMarker","getMarkersIntersectingRange","affectsData","item","getItems","is","data","search","createPositionFromPath","root","path","stickiness","createPositionAt","itemOrPosition","offset","_createAt","createPositionAfter","_createAfter","createPositionBefore","_createBefore","createRange","start","end","createRangeIn","element","createRangeOn","_createOn","createSelection","createBatch","type","createOperationFromJSON","json","fromJSON","destroy","stopListening","ret","fire","currentBatch","callbackReturnValue","_handleChangeBlock","shift"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/model\n */\nimport Batch from './batch';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ModelPosition from './position';\nimport ModelRange from './range';\nimport ModelSelection from './selection';\nimport OperationFactory from './operation/operationfactory';\nimport Schema from './schema';\nimport Writer from './writer';\nimport { autoParagraphEmptyRoots } from './utils/autoparagraphing';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport deleteContent from './utils/deletecontent';\nimport getSelectedContent from './utils/getselectedcontent';\nimport insertContent from './utils/insertcontent';\nimport insertObject from './utils/insertobject';\nimport modifySelection from './utils/modifyselection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\n// @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Model extends Observable {\n    constructor() {\n        super();\n        /**\n         * Model's marker collection.\n         *\n         * @readonly\n         * @member {module:engine/model/markercollection~MarkerCollection}\n         */\n        this.markers = new MarkerCollection();\n        /**\n         * Model's document.\n         *\n         * @readonly\n         * @member {module:engine/model/document~Document}\n         */\n        this.document = new Document(this);\n        /**\n         * Model's schema.\n         *\n         * @readonly\n         * @member {module:engine/model/schema~Schema}\n         */\n        this.schema = new Schema();\n        /**\n         * All callbacks added by {@link module:engine/model/model~Model#change} or\n         * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n         *\n         * @private\n         * @type {Array.<Function>}\n         */\n        this._pendingChanges = [];\n        /**\n         * The last created and currently used writer instance.\n         *\n         * @private\n         * @member {module:engine/model/writer~Writer}\n         */\n        this._currentWriter = null;\n        ['insertContent', 'insertObject', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation']\n            .forEach(methodName => this.decorate(methodName));\n        // Adding operation validation with `highest` priority, so it is called before any other feature would like\n        // to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n        this.on('applyOperation', (evt, args) => {\n            const operation = args[0];\n            operation._validate();\n        }, { priority: 'highest' });\n        // Register some default abstract entities.\n        this.schema.register('$root', {\n            isLimit: true\n        });\n        this.schema.register('$container', {\n            allowIn: ['$root', '$container']\n        });\n        this.schema.register('$block', {\n            allowIn: ['$root', '$container'],\n            isBlock: true\n        });\n        this.schema.register('$blockObject', {\n            allowWhere: '$block',\n            isBlock: true,\n            isObject: true\n        });\n        this.schema.register('$inlineObject', {\n            allowWhere: '$text',\n            allowAttributesOf: '$text',\n            isInline: true,\n            isObject: true\n        });\n        this.schema.register('$text', {\n            allowIn: '$block',\n            isInline: true,\n            isContent: true\n        });\n        this.schema.register('$clipboardHolder', {\n            allowContentOf: '$root',\n            allowChildren: '$text',\n            isLimit: true\n        });\n        this.schema.register('$documentFragment', {\n            allowContentOf: '$root',\n            allowChildren: '$text',\n            isLimit: true\n        });\n        // An element needed by the `upcastElementToMarker` converter.\n        // This element temporarily represents a marker boundary during the conversion process and is removed\n        // at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n        // better place for this registration but both know nothing about `Schema`.\n        this.schema.register('$marker');\n        this.schema.addChildCheck((context, childDefinition) => {\n            if (childDefinition.name === '$marker') {\n                return true;\n            }\n        });\n        injectSelectionPostFixer(this);\n        // Post-fixer which takes care of adding empty paragraph elements to the empty roots.\n        this.document.registerPostFixer(autoParagraphEmptyRoots);\n        // @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n        // @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n        // @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n    }\n    /**\n     * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n     * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n     * the {@link module:engine/model/document~Document#selection document's selection}, and\n     * {@link module:engine/model/model~Model#markers model markers}.\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t} );\n     *\n     * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n     * into a single undo step.\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n     *\n     *\t\t\tmodel.change( writer => {\n     *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n     *\t\t\t} );\n     *\n     * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n     *\t\t} );\n     *\n     * The callback of the `change()` block is executed synchronously.\n     *\n     * You can also return a value from the change block.\n     *\n     *\t\tconst img = model.change( writer => {\n     *\t\t\treturn writer.createElement( 'img' );\n     *\t\t} );\n     *\n     * @see #enqueueChange\n     * @param {Function} callback Callback function which may modify the model.\n     * @returns {*} Value returned by the callback.\n     */\n    change(callback) {\n        try {\n            if (this._pendingChanges.length === 0) {\n                // If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n                this._pendingChanges.push({ batch: new Batch(), callback });\n                return this._runPendingChanges()[0];\n            }\n            else {\n                // If this is not the outermost block, just execute the callback.\n                return callback(this._currentWriter);\n            }\n        }\n        catch (err) {\n            // @if CK_DEBUG // throw err;\n            /* istanbul ignore next */\n            CKEditorError.rethrowUnexpectedError(err, this);\n        }\n    }\n    /**\n     * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n     *\n     * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n     * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n     * it will be delayed and executed after the outermost block.\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconsole.log( 1 );\n     *\n     *\t\t\tmodel.enqueueChange( writer => {\n     *\t\t\t\tconsole.log( 2 );\n     *\t\t\t} );\n     *\n     * \t\t\tconsole.log( 3 );\n     *\t\t} ); // Will log: 1, 3, 2.\n     *\n     * In addition to that, the changes enqueued with `enqueueChange()` will be converted separately from the changes\n     * done in the outer `change()` block.\n     *\n     * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n     * By default, a new batch with the default {@link module:engine/model/batch~Batch#constructor batch type} is created.\n     * In the sample above, the `change` and `enqueueChange` blocks will use a different batch (and a different\n     * {@link module:engine/model/writer~Writer} instance since each of them operates on a separate batch).\n     *\n     *\t\tmodel.enqueueChange( { isUndoable: false }, writer => {\n     *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t} );\n     *\n     * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n     *\n     *\t\tmodel.enqueueChange( batch, writer => {\n     *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t} );\n     *\n     * In order to make a nested `enqueueChange()` create a single undo step together with the changes done in the outer `change()`\n     * block, you can obtain the batch instance from the  {@link module:engine/model/writer~Writer#batch writer} of the outer block.\n     *\n     * @param {module:engine/model/batch~Batch|Object} [batchOrType] A batch or a\n     * {@link module:engine/model/batch~Batch#constructor batch type} that should be used in the callback. If not defined, a new batch with\n     * the default type will be created.\n     * @param {Function} callback Callback function which may modify the model.\n     */\n    enqueueChange(batchOrType, callback) {\n        try {\n            if (!batchOrType) {\n                batchOrType = new Batch();\n            }\n            else if (typeof batchOrType === 'function') {\n                callback = batchOrType;\n                batchOrType = new Batch();\n            }\n            else if (!(batchOrType instanceof Batch)) {\n                batchOrType = new Batch(batchOrType);\n            }\n            this._pendingChanges.push({ batch: batchOrType, callback });\n            if (this._pendingChanges.length == 1) {\n                this._runPendingChanges();\n            }\n        }\n        catch (err) {\n            // @if CK_DEBUG // throw err;\n            /* istanbul ignore next */\n            CKEditorError.rethrowUnexpectedError(err, this);\n        }\n    }\n    /**\n     * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n     * {@link module:engine/model/operation/operation~Operation operations} to the model.\n     *\n     * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n     * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n     * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n     * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n     */\n    applyOperation(operation) {\n        // @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n        // @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n        // @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n        // @if CK_DEBUG_ENGINE // }\n        // @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n        // @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n        // @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n        // @if CK_DEBUG_ENGINE //}\n        // @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n        operation._execute();\n    }\n    // @if CK_DEBUG_ENGINE // getAppliedOperation() {\n    // @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n    // @if CK_DEBUG_ENGINE //\t\treturn '';\n    // @if CK_DEBUG_ENGINE //\t}\n    // @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n    // @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n    // @if CK_DEBUG_ENGINE // }\n    /**\n     * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n     * functionality to work.\n     *\n     * **Note**: If you want to insert an {@glink framework/guides/deep-dive/schema#object-elements object element}\n     * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.\n     *\n     * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n     * the content, clears the given selection's content before inserting nodes and moves the selection\n     * to its target position at the end of the process.\n     * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n     * pasting feature should do.\n     *\n     * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n     *\n     * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n     * inside a {@link #change `change()` block}.\n     *\n     * # Conversion and schema\n     *\n     * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n     * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n     * is only adding nodes to the model. Additionally, you need to define\n     * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n     * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n     *\n     * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n     * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n     * unless converters are defined for all elements and attributes in that HTML.\n     *\n     * # Examples\n     *\n     * Using `insertContent()` with a manually created model structure:\n     *\n     *\t\t// Let's create a document fragment containing such content as:\n     *\t\t//\n     *\t\t// <paragraph>foo</paragraph>\n     *\t\t// <blockQuote>\n     *\t\t//    <paragraph>bar</paragraph>\n     *\t\t// </blockQuote>\n     *\t\tconst docFrag = editor.model.change( writer => {\n     *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n     *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n     *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n     *\t\t\tconst docFrag = writer.createDocumentFragment();\n     *\n     *\t\t\twriter.append( p1, docFrag );\n     *\t\t\twriter.append( blockQuote, docFrag );\n     *\t\t\twriter.append( p2, blockQuote );\n     *\t\t\twriter.insertText( 'foo', p1 );\n     *\t\t\twriter.insertText( 'bar', p2 );\n     *\n     *\t\t\treturn docFrag;\n     *\t\t} );\n     *\n     *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n     *\t\t// so this code could be moved to the callback defined above.\n     *\t\teditor.model.insertContent( docFrag );\n     *\n     * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n     *\n     *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n     *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n     *\t\tconst htmlDP = new HtmlDataProcessor( viewDocument );\n     *\n     *\t\t// Convert an HTML string to a view document fragment:\n     *\t\tconst viewFragment = htmlDP.toView( htmlString );\n     *\n     *\t\t// Convert the view document fragment to a model document fragment\n     *\t\t// in the context of $root. This conversion takes the schema into\n     *\t\t// account so if, for example, the view document fragment contained a bare text node,\n     *\t\t// this text node cannot be a child of $root, so it will be automatically\n     *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n     *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n     *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n     *\t\t// which has a loosened schema.\n     *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n     *\n     *\t\teditor.model.insertContent( modelFragment );\n     *\n     * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n     *\n     *\t\t// Insert text at the current document selection position.\n     *\t\teditor.model.change( writer => {\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n     *\t\t} );\n     *\n     *\t\t// Insert text at a given position - the document selection will not be modified.\n     *\t\teditor.model.change( writer => {\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n     *\n     *\t\t\t// Which is a shorthand for:\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n     *\t\t} );\n     *\n     * If you want the document selection to be moved to the inserted content, use the\n     * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting\n     * the content:\n     *\n     *\t\teditor.model.change( writer => {\n     *\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\n     *\t\t\t// Insert an empty paragraph at the beginning of the root.\n     *\t\t\teditor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );\n     *\n     *\t\t\t// Move the document selection to the inserted paragraph.\n     *\t\t\twriter.setSelection( paragraph, 'in' );\n     *\t\t} );\n     *\n     * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,\n     * the new content will be inserted at the passed selection (instead of document selection):\n     *\n     *\t\teditor.model.change( writer => {\n     *\t\t\t// Create a selection in a paragraph that will be used as a place of insertion.\n     *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t\t// Insert the new text at the created selection.\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n     *\n     *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n     *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n     *\t\t\twriter.setSelection( selection );\n     *\t\t} );\n     *\n     * @fires insertContent\n     * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n     * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n     * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n     * This param defines a position in relation to that item.\n     * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n     * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n     * at the insertion position.\n     */\n    insertContent(content, selectable, placeOrOffset) {\n        return insertContent(this, content, selectable, placeOrOffset);\n    }\n    /**\n     * Inserts an {@glink framework/guides/deep-dive/schema#object-elements object element} at a specific position in the editor content.\n     *\n     * This is a high-level API:\n     * * It takes the {@link #schema schema} into consideration,\n     * * It clears the content of passed `selectable` before inserting,\n     * * It can move the selection at the end of the process,\n     * * It will copy the selected block's attributes to preserve them upon insertion,\n     * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,\n     * * etc.\n     *\n     * # Notes\n     *\n     * * If you want to insert a non-object content, see {@link #insertContent} instead.\n     * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.\n     * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside\n     * a {@link #change `change()` block}.\n     * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.\n     * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does\n     * is only adding nodes to the model. Additionally, you need to define\n     * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n     * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n     *\n     * # Examples\n     *\n     * Use the following code to insert an object at the current selection and keep the selection on the inserted element:\n     *\n     *\t\tconst rawHtmlEmbedElement = writer.createElement( 'rawHtml' );\n     *\n     *\t\tmodel.insertObject( rawHtmlEmbedElement, null, null, {\n     *\t\t\tsetSelection: 'on'\n     *\t\t} );\n     *\n     * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:\n     *\n     *\t\tconst pageBreakElement = writer.createElement( 'pageBreak' );\n     *\n     *\t\tmodel.insertObject( pageBreakElement, null, null, {\n     *\t\t\tsetSelection: 'after'\n     *\t\t} );\n     *\n     * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):\n     *\n     *\t\tconst tableElement = writer.createElement( 'table' );\n     *\n     *\t\tmodel.insertObject( tableElement, null, null, {\n     *\t\t\tfindOptimalPosition: 'auto'\n     *\t\t} );\n     *\n     * Use the following code to insert an object at the specific range (also: replace the content of the range):\n     *\n     *\t\tconst tableElement = writer.createElement( 'table' );\n     *\t\tconst range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );\n     *\n     *\t\tmodel.insertObject( tableElement, range );\n     *\n     * @param {module:engine/model/element~Element} object An object to be inserted into the model document.\n     * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n     * A selectable where the content should be inserted. If not specified, the current\n     * {@link module:engine/model/document~Document#selection document selection} will be used instead.\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} placeOrOffset Specifies the exact place or offset for the insertion to take place,\n     * relative to `selectable`.\n     * @param {Object} [options] Additional options.\n     * @param {'auto'|'before'|'after'} [options.findOptimalPosition] An option that, when set, adjusts the insertion position (relative to\n     * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).\n     * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.\n     * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.\n     * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.\n     *\n     * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.\n     * @param {'on'|'after'} [options.setSelection] An option that, when set, moves the\n     * {@link module:engine/model/document~Document#selection document selection} after inserting the object.\n     * * When `'on'`, the document selection will be set on the inserted object.\n     * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no\n     * such text node, a paragraph will be created and the document selection will be moved inside it.\n     * @returns {module:engine/model/range~Range} A range which contains all the performed changes. This is a range that, if removed,\n     * would return the model to the state before the insertion. If no changes were preformed by `insertObject()`, returns a range collapsed\n     * at the insertion position.\n     */\n    insertObject(object, selectable, placeOrOffset, options) {\n        return insertObject(this, object, selectable, placeOrOffset, options);\n    }\n    /**\n     * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n     *\n     * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n     * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n     * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n     * then that behavior should be implemented in the view's listener. At the same time, the table feature\n     * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n     * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n     * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n     *\n     * @fires deleteContent\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * Selection of which the content should be deleted.\n     * @param {Object} [options]\n     * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n     *\n     * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n     *\n     * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n     * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n     *\n     * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n     * elements will not be merged.\n     *\n     * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n     * paragraph when the entire content was selected.\n     *\n     * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n     *\n     * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n     * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n     *\n     * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n     * to a place where text cannot be inserted.\n     *\n     * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n     *\n     * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n     * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n     *\n     * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n     *\n     * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n     *\n     * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.\n     * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to\n     * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.\n     */\n    deleteContent(selection, options) {\n        deleteContent(this, selection, options);\n    }\n    /**\n     * Modifies the selection. Currently, the supported modifications are:\n     *\n     * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n     * Possible values for `unit` are:\n     *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n     *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n     *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n     *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n     *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n     *  why `'character'` value is most natural and common method of modifying selection.\n     *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n     *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n     *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n     *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n     *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n     *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n     *  extension will include whole \"surrogate pair\".\n     *  * `'word'` - moves selection by a whole word.\n     *\n     * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n     *\n     * @fires modifySelection\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * The selection to modify.\n     * @param {Object} [options]\n     * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n     * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n     * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n     */\n    modifySelection(selection, options) {\n        modifySelection(this, selection, options);\n    }\n    /**\n     * Gets a clone of the selected content.\n     *\n     * For example, for the following selection:\n     *\n     * ```html\n     * <paragraph>x</paragraph>\n     * <blockQuote>\n     *\t<paragraph>y</paragraph>\n     *\t<heading1>fir[st</heading1>\n     * </blockQuote>\n     * <paragraph>se]cond</paragraph>\n     * <paragraph>z</paragraph>\n     * ```\n     *\n     * It will return a document fragment with such a content:\n     *\n     * ```html\n     * <blockQuote>\n     *\t<heading1>st</heading1>\n     * </blockQuote>\n     * <paragraph>se</paragraph>\n     * ```\n     *\n     * @fires getSelectedContent\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * The selection of which content will be returned.\n     * @returns {module:engine/model/documentfragment~DocumentFragment}\n     */\n    getSelectedContent(selection) {\n        return getSelectedContent(this, selection);\n    }\n    /**\n     * Checks whether the given {@link module:engine/model/range~Range range} or\n     * {@link module:engine/model/element~Element element} has any meaningful content.\n     *\n     * Meaningful content is:\n     *\n     * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n     * any non-whitespace characters),\n     * * or any {@link module:engine/model/schema~Schema#isContent content element},\n     * * or any {@link module:engine/model/markercollection~Marker marker} which\n     * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n     *\n     * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n     * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)\n     * is considered non-empty.\n     *\n     * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n     * @param {Object} [options]\n     * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n     * @param {Boolean} [options.ignoreMarkers] Whether markers should be ignored.\n     * @returns {Boolean}\n     */\n    hasContent(rangeOrElement, options = {}) {\n        const range = rangeOrElement instanceof ModelRange ? rangeOrElement : ModelRange._createIn(rangeOrElement);\n        if (range.isCollapsed) {\n            return false;\n        }\n        const { ignoreWhitespaces = false, ignoreMarkers = false } = options;\n        // Check if there are any markers which affects data in this given range.\n        if (!ignoreMarkers) {\n            for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range)) {\n                if (intersectingMarker.affectsData) {\n                    return true;\n                }\n            }\n        }\n        for (const item of range.getItems()) {\n            if (this.schema.isContent(item)) {\n                if (item.is('$textProxy')) {\n                    if (!ignoreWhitespaces) {\n                        return true;\n                    }\n                    else if (item.data.search(/\\S/) !== -1) {\n                        return true;\n                    }\n                }\n                else {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Creates a position from the given root and path in that root.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * See {@link module:engine/model/position~PositionStickiness}.\n     * @returns {module:engine/model/position~Position}\n     */\n    createPositionFromPath(root, path, stickiness) {\n        return new ModelPosition(root, path, stickiness);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/model/position~Position position},\n     * * a parent element and offset in that element,\n     * * a parent element and `'end'` (the position will be set at the end of that element),\n     * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n     * (the position will be set before or after the given model item).\n     *\n     * This method is a shortcut to other factory methods such as:\n     *\n     * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n     * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    createPositionAt(itemOrPosition, offset) {\n        return ModelPosition._createAt(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n    createPositionAfter(item) {\n        return ModelPosition._createAfter(item);\n    }\n    /**\n     * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n    createPositionBefore(item) {\n        return ModelPosition._createBefore(item);\n    }\n    /**\n     * Creates a range spanning from the `start` position to the `end` position.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRange( start, end );\n     *\t\t} );\n     *\n     * @param {module:engine/model/position~Position} start Start position.\n     * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n     * to the `start` position.\n     * @returns {module:engine/model/range~Range}\n     */\n    createRange(start, end) {\n        return new ModelRange(start, end);\n    }\n    /**\n     * Creates a range inside the given element which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRangeIn( paragraph );\n     *\t\t} );\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n    createRangeIn(element) {\n        return ModelRange._createIn(element);\n    }\n    /**\n     * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n     *\n     * Note: This method is also available on `writer` instance as\n     * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRangeOn( paragraph );\n     *\t\t} );\n     *\n     * @param {module:engine/model/item~Item} item\n     * @returns {module:engine/model/range~Range}\n     */\n    createRangeOn(item) {\n        return ModelRange._createOn(item);\n    }\n    /**\n     * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n     * or creates an empty selection if no arguments were passed.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n     *\n     *\t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the given document selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst documentSelection = model.document.selection;\n     *\t\tconst selection = writer.createSelection( documentSelection );\n     *\n     *\t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates selection at the given offset in the given element.\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [optionsOrPlaceOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @returns {module:engine/model/selection~Selection}\n     */\n    createSelection(...args) {\n        return new ModelSelection(...args);\n    }\n    /**\n     * Creates a {@link module:engine/model/batch~Batch} instance.\n     *\n     * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n     *\n     * * {@link #change `change()`},\n     * * {@link #enqueueChange `enqueueChange()`}.\n     *\n     * @param {Object} [type] {@link module:engine/model/batch~Batch#constructor The type} of the batch.\n     * @returns {module:engine/model/batch~Batch}\n     */\n    createBatch(type) {\n        return new Batch(type);\n    }\n    /**\n     * Creates an operation instance from a JSON object (parsed JSON string).\n     *\n     * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @returns {module:engine/model/operation/operation~Operation}\n     */\n    createOperationFromJSON(json) {\n        return OperationFactory.fromJSON(json, this.document);\n    }\n    /**\n     * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n     */\n    destroy() {\n        this.document.destroy();\n        this.stopListening();\n    }\n    /**\n     * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n     * which calls callbacks and returns array of values returned by these callbacks.\n     *\n     * @private\n     * @returns {Array.<*>} Array of values returned by callbacks.\n     */\n    _runPendingChanges() {\n        const ret = [];\n        this.fire('_beforeChanges');\n        try {\n            while (this._pendingChanges.length) {\n                // Create a new writer using batch instance created for this chain of changes.\n                const currentBatch = this._pendingChanges[0].batch;\n                this._currentWriter = new Writer(this, currentBatch);\n                // Execute changes callback and gather the returned value.\n                const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);\n                ret.push(callbackReturnValue);\n                this.document._handleChangeBlock(this._currentWriter);\n                this._pendingChanges.shift();\n                this._currentWriter = null;\n            }\n        }\n        finally {\n            this._pendingChanges.length = 0;\n            this._currentWriter = null;\n            this.fire('_afterChanges');\n        }\n        return ret;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAK,MAAM,SAAS;AAC3B,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,aAAa,MAAM,YAAY;AACtC,OAAOC,UAAU,MAAM,SAAS;AAChC,OAAOC,cAAc,MAAM,aAAa;AACxC,OAAOC,gBAAgB,MAAM,8BAA8B;AAC3D,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAOC,MAAM,MAAM,UAAU;AAC7B,SAASC,uBAAuB,QAAQ,0BAA0B;AAClE,SAASC,wBAAwB,QAAQ,8BAA8B;AACvE,OAAOC,aAAa,MAAM,uBAAuB;AACjD,OAAOC,kBAAkB,MAAM,4BAA4B;AAC3D,OAAOC,aAAa,MAAM,uBAAuB;AACjD,OAAOC,YAAY,MAAM,sBAAsB;AAC/C,OAAOC,eAAe,MAAM,yBAAyB;AACrD,OAAOC,aAAa,MAAM,6CAA6C;AACvE,SAASC,UAAU,QAAQ,+CAA+C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,KAAK,SAASD,UAAU,CAAC;EAC1CE,WAAW,GAAG;IACV,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,IAAIlB,gBAAgB,EAAE;IACrC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACmB,QAAQ,GAAG,IAAIpB,QAAQ,CAAC,IAAI,CAAC;IAClC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACqB,MAAM,GAAG,IAAIf,MAAM,EAAE;IAC1B;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACgB,eAAe,GAAG,EAAE;IACzB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,CAAC,eAAe,EAAE,cAAc,EAAE,eAAe,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,gBAAgB,CAAC,CACxGC,OAAO,CAACC,UAAU,IAAI,IAAI,CAACC,QAAQ,CAACD,UAAU,CAAC,CAAC;IACrD;IACA;IACA,IAAI,CAACE,EAAE,CAAC,gBAAgB,EAAE,CAACC,GAAG,EAAEC,IAAI,KAAK;MACrC,MAAMC,SAAS,GAAGD,IAAI,CAAC,CAAC,CAAC;MACzBC,SAAS,CAACC,SAAS,EAAE;IACzB,CAAC,EAAE;MAAEC,QAAQ,EAAE;IAAU,CAAC,CAAC;IAC3B;IACA,IAAI,CAACX,MAAM,CAACY,QAAQ,CAAC,OAAO,EAAE;MAC1BC,OAAO,EAAE;IACb,CAAC,CAAC;IACF,IAAI,CAACb,MAAM,CAACY,QAAQ,CAAC,YAAY,EAAE;MAC/BE,OAAO,EAAE,CAAC,OAAO,EAAE,YAAY;IACnC,CAAC,CAAC;IACF,IAAI,CAACd,MAAM,CAACY,QAAQ,CAAC,QAAQ,EAAE;MAC3BE,OAAO,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC;MAChCC,OAAO,EAAE;IACb,CAAC,CAAC;IACF,IAAI,CAACf,MAAM,CAACY,QAAQ,CAAC,cAAc,EAAE;MACjCI,UAAU,EAAE,QAAQ;MACpBD,OAAO,EAAE,IAAI;MACbE,QAAQ,EAAE;IACd,CAAC,CAAC;IACF,IAAI,CAACjB,MAAM,CAACY,QAAQ,CAAC,eAAe,EAAE;MAClCI,UAAU,EAAE,OAAO;MACnBE,iBAAiB,EAAE,OAAO;MAC1BC,QAAQ,EAAE,IAAI;MACdF,QAAQ,EAAE;IACd,CAAC,CAAC;IACF,IAAI,CAACjB,MAAM,CAACY,QAAQ,CAAC,OAAO,EAAE;MAC1BE,OAAO,EAAE,QAAQ;MACjBK,QAAQ,EAAE,IAAI;MACdC,SAAS,EAAE;IACf,CAAC,CAAC;IACF,IAAI,CAACpB,MAAM,CAACY,QAAQ,CAAC,kBAAkB,EAAE;MACrCS,cAAc,EAAE,OAAO;MACvBC,aAAa,EAAE,OAAO;MACtBT,OAAO,EAAE;IACb,CAAC,CAAC;IACF,IAAI,CAACb,MAAM,CAACY,QAAQ,CAAC,mBAAmB,EAAE;MACtCS,cAAc,EAAE,OAAO;MACvBC,aAAa,EAAE,OAAO;MACtBT,OAAO,EAAE;IACb,CAAC,CAAC;IACF;IACA;IACA;IACA;IACA,IAAI,CAACb,MAAM,CAACY,QAAQ,CAAC,SAAS,CAAC;IAC/B,IAAI,CAACZ,MAAM,CAACuB,aAAa,CAAC,CAACC,OAAO,EAAEC,eAAe,KAAK;MACpD,IAAIA,eAAe,CAACC,IAAI,KAAK,SAAS,EAAE;QACpC,OAAO,IAAI;MACf;IACJ,CAAC,CAAC;IACFtC,wBAAwB,CAAC,IAAI,CAAC;IAC9B;IACA,IAAI,CAACW,QAAQ,CAAC4B,iBAAiB,CAACxC,uBAAuB,CAAC;IACxD;IACA;IACA;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIyC,MAAM,CAACC,QAAQ,EAAE;IACb,IAAI;MACA,IAAI,IAAI,CAAC5B,eAAe,CAAC6B,MAAM,KAAK,CAAC,EAAE;QACnC;QACA,IAAI,CAAC7B,eAAe,CAAC8B,IAAI,CAAC;UAAEC,KAAK,EAAE,IAAItD,KAAK,EAAE;UAAEmD;QAAS,CAAC,CAAC;QAC3D,OAAO,IAAI,CAACI,kBAAkB,EAAE,CAAC,CAAC,CAAC;MACvC,CAAC,MACI;QACD;QACA,OAAOJ,QAAQ,CAAC,IAAI,CAAC3B,cAAc,CAAC;MACxC;IACJ,CAAC,CACD,OAAOgC,GAAG,EAAE;MACR;MACA;MACAxC,aAAa,CAACyC,sBAAsB,CAACD,GAAG,EAAE,IAAI,CAAC;IACnD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,aAAa,CAACC,WAAW,EAAER,QAAQ,EAAE;IACjC,IAAI;MACA,IAAI,CAACQ,WAAW,EAAE;QACdA,WAAW,GAAG,IAAI3D,KAAK,EAAE;MAC7B,CAAC,MACI,IAAI,OAAO2D,WAAW,KAAK,UAAU,EAAE;QACxCR,QAAQ,GAAGQ,WAAW;QACtBA,WAAW,GAAG,IAAI3D,KAAK,EAAE;MAC7B,CAAC,MACI,IAAI,EAAE2D,WAAW,YAAY3D,KAAK,CAAC,EAAE;QACtC2D,WAAW,GAAG,IAAI3D,KAAK,CAAC2D,WAAW,CAAC;MACxC;MACA,IAAI,CAACpC,eAAe,CAAC8B,IAAI,CAAC;QAAEC,KAAK,EAAEK,WAAW;QAAER;MAAS,CAAC,CAAC;MAC3D,IAAI,IAAI,CAAC5B,eAAe,CAAC6B,MAAM,IAAI,CAAC,EAAE;QAClC,IAAI,CAACG,kBAAkB,EAAE;MAC7B;IACJ,CAAC,CACD,OAAOC,GAAG,EAAE;MACR;MACA;MACAxC,aAAa,CAACyC,sBAAsB,CAACD,GAAG,EAAE,IAAI,CAAC;IACnD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,cAAc,CAAC7B,SAAS,EAAE;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAA,SAAS,CAAC8B,QAAQ,EAAE;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIhD,aAAa,CAACiD,OAAO,EAAEC,UAAU,EAAEC,aAAa,EAAE;IAC9C,OAAOnD,aAAa,CAAC,IAAI,EAAEiD,OAAO,EAAEC,UAAU,EAAEC,aAAa,CAAC;EAClE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIlD,YAAY,CAACmD,MAAM,EAAEF,UAAU,EAAEC,aAAa,EAAEE,OAAO,EAAE;IACrD,OAAOpD,YAAY,CAAC,IAAI,EAAEmD,MAAM,EAAEF,UAAU,EAAEC,aAAa,EAAEE,OAAO,CAAC;EACzE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIvD,aAAa,CAACwD,SAAS,EAAED,OAAO,EAAE;IAC9BvD,aAAa,CAAC,IAAI,EAAEwD,SAAS,EAAED,OAAO,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACInD,eAAe,CAACoD,SAAS,EAAED,OAAO,EAAE;IAChCnD,eAAe,CAAC,IAAI,EAAEoD,SAAS,EAAED,OAAO,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItD,kBAAkB,CAACuD,SAAS,EAAE;IAC1B,OAAOvD,kBAAkB,CAAC,IAAI,EAAEuD,SAAS,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAU,CAACC,cAAc,EAAgB;IAAA,IAAdH,OAAO,uEAAG,CAAC,CAAC;IACnC,MAAMI,KAAK,GAAGD,cAAc,YAAYjE,UAAU,GAAGiE,cAAc,GAAGjE,UAAU,CAACmE,SAAS,CAACF,cAAc,CAAC;IAC1G,IAAIC,KAAK,CAACE,WAAW,EAAE;MACnB,OAAO,KAAK;IAChB;IACA,MAAM;MAAEC,iBAAiB,GAAG,KAAK;MAAEC,aAAa,GAAG;IAAM,CAAC,GAAGR,OAAO;IACpE;IACA,IAAI,CAACQ,aAAa,EAAE;MAChB,KAAK,MAAMC,kBAAkB,IAAI,IAAI,CAACvD,OAAO,CAACwD,2BAA2B,CAACN,KAAK,CAAC,EAAE;QAC9E,IAAIK,kBAAkB,CAACE,WAAW,EAAE;UAChC,OAAO,IAAI;QACf;MACJ;IACJ;IACA,KAAK,MAAMC,IAAI,IAAIR,KAAK,CAACS,QAAQ,EAAE,EAAE;MACjC,IAAI,IAAI,CAACzD,MAAM,CAACoB,SAAS,CAACoC,IAAI,CAAC,EAAE;QAC7B,IAAIA,IAAI,CAACE,EAAE,CAAC,YAAY,CAAC,EAAE;UACvB,IAAI,CAACP,iBAAiB,EAAE;YACpB,OAAO,IAAI;UACf,CAAC,MACI,IAAIK,IAAI,CAACG,IAAI,CAACC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YACpC,OAAO,IAAI;UACf;QACJ,CAAC,MACI;UACD,OAAO,IAAI;QACf;MACJ;IACJ;IACA,OAAO,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,sBAAsB,CAACC,IAAI,EAAEC,IAAI,EAAEC,UAAU,EAAE;IAC3C,OAAO,IAAInF,aAAa,CAACiF,IAAI,EAAEC,IAAI,EAAEC,UAAU,CAAC;EACpD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgB,CAACC,cAAc,EAAEC,MAAM,EAAE;IACrC,OAAOtF,aAAa,CAACuF,SAAS,CAACF,cAAc,EAAEC,MAAM,CAAC;EAC1D;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,mBAAmB,CAACb,IAAI,EAAE;IACtB,OAAO3E,aAAa,CAACyF,YAAY,CAACd,IAAI,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIe,oBAAoB,CAACf,IAAI,EAAE;IACvB,OAAO3E,aAAa,CAAC2F,aAAa,CAAChB,IAAI,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIiB,WAAW,CAACC,KAAK,EAAEC,GAAG,EAAE;IACpB,OAAO,IAAI7F,UAAU,CAAC4F,KAAK,EAAEC,GAAG,CAAC;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,CAACC,OAAO,EAAE;IACnB,OAAO/F,UAAU,CAACmE,SAAS,CAAC4B,OAAO,CAAC;EACxC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,CAACtB,IAAI,EAAE;IAChB,OAAO1E,UAAU,CAACiG,SAAS,CAACvB,IAAI,CAAC;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIwB,eAAe,GAAU;IAAA,kCAANxE,IAAI;MAAJA,IAAI;IAAA;IACnB,OAAO,IAAIzB,cAAc,CAAC,GAAGyB,IAAI,CAAC;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIyE,WAAW,CAACC,IAAI,EAAE;IACd,OAAO,IAAIxG,KAAK,CAACwG,IAAI,CAAC;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,uBAAuB,CAACC,IAAI,EAAE;IAC1B,OAAOpG,gBAAgB,CAACqG,QAAQ,CAACD,IAAI,EAAE,IAAI,CAACrF,QAAQ,CAAC;EACzD;EACA;AACJ;AACA;EACIuF,OAAO,GAAG;IACN,IAAI,CAACvF,QAAQ,CAACuF,OAAO,EAAE;IACvB,IAAI,CAACC,aAAa,EAAE;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACItD,kBAAkB,GAAG;IACjB,MAAMuD,GAAG,GAAG,EAAE;IACd,IAAI,CAACC,IAAI,CAAC,gBAAgB,CAAC;IAC3B,IAAI;MACA,OAAO,IAAI,CAACxF,eAAe,CAAC6B,MAAM,EAAE;QAChC;QACA,MAAM4D,YAAY,GAAG,IAAI,CAACzF,eAAe,CAAC,CAAC,CAAC,CAAC+B,KAAK;QAClD,IAAI,CAAC9B,cAAc,GAAG,IAAIhB,MAAM,CAAC,IAAI,EAAEwG,YAAY,CAAC;QACpD;QACA,MAAMC,mBAAmB,GAAG,IAAI,CAAC1F,eAAe,CAAC,CAAC,CAAC,CAAC4B,QAAQ,CAAC,IAAI,CAAC3B,cAAc,CAAC;QACjFsF,GAAG,CAACzD,IAAI,CAAC4D,mBAAmB,CAAC;QAC7B,IAAI,CAAC5F,QAAQ,CAAC6F,kBAAkB,CAAC,IAAI,CAAC1F,cAAc,CAAC;QACrD,IAAI,CAACD,eAAe,CAAC4F,KAAK,EAAE;QAC5B,IAAI,CAAC3F,cAAc,GAAG,IAAI;MAC9B;IACJ,CAAC,SACO;MACJ,IAAI,CAACD,eAAe,CAAC6B,MAAM,GAAG,CAAC;MAC/B,IAAI,CAAC5B,cAAc,GAAG,IAAI;MAC1B,IAAI,CAACuF,IAAI,CAAC,eAAe,CAAC;IAC9B;IACA,OAAOD,GAAG;EACd;AACJ"},"metadata":{},"sourceType":"module"}