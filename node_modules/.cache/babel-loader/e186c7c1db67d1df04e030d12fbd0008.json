{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageutils\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { findOptimalInsertionRange, isWidget, toWidget } from 'ckeditor5/src/widget';\nimport { determineImageTypeForInsertionAtSelection } from './image/utils';\n\n/**\n * A set of helpers related to images.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUtils extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'ImageUtils';\n  }\n\n  /**\n   * Checks if the provided model element is an `image` or `imageInline`.\n   *\n   * @param {module:engine/model/element~Element} modelElement\n   * @returns {Boolean}\n   */\n  isImage(modelElement) {\n    return this.isInlineImage(modelElement) || this.isBlockImage(modelElement);\n  }\n\n  /**\n   * Checks if the provided view element represents an inline image.\n   *\n   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n   *\n   * @param {module:engine/view/element~Element} element\n   * @returns {Boolean}\n   */\n  isInlineImageView(element) {\n    return !!element && element.is('element', 'img');\n  }\n\n  /**\n   * Checks if the provided view element represents a block image.\n   *\n   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n   *\n   * @param {module:engine/view/element~Element} element\n   * @returns {Boolean}\n   */\n  isBlockImageView(element) {\n    return !!element && element.is('element', 'figure') && element.hasClass('image');\n  }\n\n  /**\n   * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}\n   * method.\n   *\n   *\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n   *\n   *\t\timageUtils.insertImage( { src: 'path/to/image.jpg' } );\n   *\n   * @param {Object} [attributes={}] Attributes of the inserted image.\n   * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.\n   * @param {module:engine/model/selection~Selectable} [selectable] Place to insert the image. If not specified,\n   * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images\n   * and `model.document.selection` for the inline images.\n   *\n   * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)\n   * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.\n   *\n   * @param {'imageBlock'|'imageInline'} [imageType] Image type of inserted image. If not specified,\n   * it will be determined automatically depending of editor config or place of the insertion.\n   * @return {module:engine/view/element~Element|null} The inserted model image element.\n   */\n  insertImage() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let selectable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let imageType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const editor = this.editor;\n    const model = editor.model;\n    const selection = model.document.selection;\n    imageType = determineImageTypeForInsertion(editor, selectable || selection, imageType);\n\n    // Mix declarative attributes with selection attributes because the new image should \"inherit\"\n    // the latter for best UX. For instance, inline images inserted into existing links\n    // should not split them. To do that, they need to have \"linkHref\" inherited from the selection.\n    attributes = {\n      ...Object.fromEntries(selection.getAttributes()),\n      ...attributes\n    };\n    for (const attributeName in attributes) {\n      if (!model.schema.checkAttribute(imageType, attributeName)) {\n        delete attributes[attributeName];\n      }\n    }\n    return model.change(writer => {\n      const imageElement = writer.createElement(imageType, attributes);\n      model.insertObject(imageElement, selectable, null, {\n        setSelection: 'on',\n        // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.\n        // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).\n        findOptimalPosition: !selectable && imageType != 'imageInline'\n      });\n\n      // Inserting an image might've failed due to schema regulations.\n      if (imageElement.parent) {\n        return imageElement;\n      }\n      return null;\n    });\n  }\n\n  /**\n   * Returns an image widget editing view element if one is selected or is among the selection's ancestors.\n   *\n   * @protected\n   * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n   * @returns {module:engine/view/element~Element|null}\n   */\n  getClosestSelectedImageWidget(selection) {\n    const selectionPosition = selection.getFirstPosition();\n    if (!selectionPosition) {\n      return null;\n    }\n    const viewElement = selection.getSelectedElement();\n    if (viewElement && this.isImageWidget(viewElement)) {\n      return viewElement;\n    }\n    let parent = selectionPosition.parent;\n    while (parent) {\n      if (parent.is('element') && this.isImageWidget(parent)) {\n        return parent;\n      }\n      parent = parent.parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns a image model element if one is selected or is among the selection's ancestors.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * @returns {module:engine/model/element~Element|null}\n   */\n  getClosestSelectedImageElement(selection) {\n    const selectedElement = selection.getSelectedElement();\n    return this.isImage(selectedElement) ? selectedElement : selection.getFirstPosition().findAncestor('imageBlock');\n  }\n\n  /**\n   * Checks if image can be inserted at current model selection.\n   *\n   * @protected\n   * @returns {Boolean}\n   */\n  isImageAllowed() {\n    const model = this.editor.model;\n    const selection = model.document.selection;\n    return isImageAllowedInParent(this.editor, selection) && isNotInsideImage(selection);\n  }\n\n  /**\n   * Converts a given {@link module:engine/view/element~Element} to an image widget:\n   * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget\n   * element.\n   * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n   *\n   * @protected\n   * @param {module:engine/view/element~Element} viewElement\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n   * @param {String} label The element's label. It will be concatenated with the image `alt` attribute if one is present.\n   * @returns {module:engine/view/element~Element}\n   */\n  toImageWidget(viewElement, writer, label) {\n    writer.setCustomProperty('image', true, viewElement);\n    const labelCreator = () => {\n      const imgElement = this.findViewImgElement(viewElement);\n      const altText = imgElement.getAttribute('alt');\n      return altText ? `${altText} ${label}` : label;\n    };\n    return toWidget(viewElement, writer, {\n      label: labelCreator\n    });\n  }\n\n  /**\n   * Checks if a given view element is an image widget.\n   *\n   * @protected\n   * @param {module:engine/view/element~Element} viewElement\n   * @returns {Boolean}\n   */\n  isImageWidget(viewElement) {\n    return !!viewElement.getCustomProperty('image') && isWidget(viewElement);\n  }\n\n  /**\n   * Checks if the provided model element is an `image`.\n   *\n   * @param {module:engine/model/element~Element} modelElement\n   * @returns {Boolean}\n   */\n  isBlockImage(modelElement) {\n    return !!modelElement && modelElement.is('element', 'imageBlock');\n  }\n\n  /**\n   * Checks if the provided model element is an `imageInline`.\n   *\n   * @param {module:engine/model/element~Element} modelElement\n   * @returns {Boolean}\n   */\n  isInlineImage(modelElement) {\n    return !!modelElement && modelElement.is('element', 'imageInline');\n  }\n\n  /**\n   * Get the view `<img>` from another view element, e.g. a widget (`<figure class=\"image\">`), a link (`<a>`).\n   *\n   * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.\n   *\n   * @param {module:engine/view/element~Element} figureView\n   * @returns {module:engine/view/element~Element}\n   */\n  findViewImgElement(figureView) {\n    if (this.isInlineImageView(figureView)) {\n      return figureView;\n    }\n    const editingView = this.editor.editing.view;\n    for (const {\n      item\n    } of editingView.createRangeIn(figureView)) {\n      if (this.isInlineImageView(item)) {\n        return item;\n      }\n    }\n  }\n}\n\n// Checks if image is allowed by schema in optimal insertion parent.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selection} selection\n// @returns {Boolean}\nfunction isImageAllowedInParent(editor, selection) {\n  const imageType = determineImageTypeForInsertion(editor, selection);\n  if (imageType == 'imageBlock') {\n    const parent = getInsertImageParent(selection, editor.model);\n    if (editor.model.schema.checkChild(parent, 'imageBlock')) {\n      return true;\n    }\n  } else if (editor.model.schema.checkChild(selection.focus, 'imageInline')) {\n    return true;\n  }\n  return false;\n}\n\n// Checks if selection is not placed inside an image (e.g. its caption).\n//\n// @private\n// @param {module:engine/model/selection~Selectable} selection\n// @returns {Boolean}\nfunction isNotInsideImage(selection) {\n  return [...selection.focus.getAncestors()].every(ancestor => !ancestor.is('element', 'imageBlock'));\n}\n\n// Returns a node that will be used to insert image with `model.insertContent`.\n//\n// @private\n// @param {module:engine/model/selection~Selection} selection\n// @param {module:engine/model/model~Model} model\n// @returns {module:engine/model/element~Element}\nfunction getInsertImageParent(selection, model) {\n  const insertionRange = findOptimalInsertionRange(selection, model);\n  const parent = insertionRange.start.parent;\n  if (parent.isEmpty && !parent.is('element', '$root')) {\n    return parent.parent;\n  }\n  return parent;\n}\n\n// Determine image element type name depending on editor config or place of insertion.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selectable} selectable\n// @param {'imageBlock'|'imageInline'} [imageType] Image element type name. Used to force return of provided element name,\n// but only if there is proper plugin enabled.\n// @returns {'imageBlock'|'imageInline'} imageType\nfunction determineImageTypeForInsertion(editor, selectable, imageType) {\n  const schema = editor.model.schema;\n  const configImageInsertType = editor.config.get('image.insert.type');\n  if (!editor.plugins.has('ImageBlockEditing')) {\n    return 'imageInline';\n  }\n  if (!editor.plugins.has('ImageInlineEditing')) {\n    return 'imageBlock';\n  }\n  if (imageType) {\n    return imageType;\n  }\n  if (configImageInsertType === 'inline') {\n    return 'imageInline';\n  }\n  if (configImageInsertType === 'block') {\n    return 'imageBlock';\n  }\n\n  // Try to replace the selected widget (e.g. another image).\n  if (selectable.is('selection')) {\n    return determineImageTypeForInsertionAtSelection(schema, selectable);\n  }\n  return schema.checkChild(selectable, 'imageInline') ? 'imageInline' : 'imageBlock';\n}","map":{"version":3,"names":["Plugin","findOptimalInsertionRange","isWidget","toWidget","determineImageTypeForInsertionAtSelection","ImageUtils","pluginName","isImage","modelElement","isInlineImage","isBlockImage","isInlineImageView","element","is","isBlockImageView","hasClass","insertImage","attributes","selectable","imageType","editor","model","selection","document","determineImageTypeForInsertion","Object","fromEntries","getAttributes","attributeName","schema","checkAttribute","change","writer","imageElement","createElement","insertObject","setSelection","findOptimalPosition","parent","getClosestSelectedImageWidget","selectionPosition","getFirstPosition","viewElement","getSelectedElement","isImageWidget","getClosestSelectedImageElement","selectedElement","findAncestor","isImageAllowed","isImageAllowedInParent","isNotInsideImage","toImageWidget","label","setCustomProperty","labelCreator","imgElement","findViewImgElement","altText","getAttribute","getCustomProperty","figureView","editingView","editing","view","item","createRangeIn","getInsertImageParent","checkChild","focus","getAncestors","every","ancestor","insertionRange","start","isEmpty","configImageInsertType","config","get","plugins","has"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-image/src/imageutils.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageutils\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { findOptimalInsertionRange, isWidget, toWidget } from 'ckeditor5/src/widget';\nimport { determineImageTypeForInsertionAtSelection } from './image/utils';\n\n/**\n * A set of helpers related to images.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUtils extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ImageUtils';\n\t}\n\n\t/**\n\t * Checks if the provided model element is an `image` or `imageInline`.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement\n\t * @returns {Boolean}\n\t */\n\tisImage( modelElement ) {\n\t\treturn this.isInlineImage( modelElement ) || this.isBlockImage( modelElement );\n\t}\n\n\t/**\n\t * Checks if the provided view element represents an inline image.\n\t *\n\t * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n\t *\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean}\n\t */\n\tisInlineImageView( element ) {\n\t\treturn !!element && element.is( 'element', 'img' );\n\t}\n\n\t/**\n\t * Checks if the provided view element represents a block image.\n\t *\n\t * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n\t *\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean}\n\t */\n\tisBlockImageView( element ) {\n\t\treturn !!element && element.is( 'element', 'figure' ) && element.hasClass( 'image' );\n\t}\n\n\t/**\n\t * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}\n\t * method.\n\t *\n\t *\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t *\n\t *\t\timageUtils.insertImage( { src: 'path/to/image.jpg' } );\n\t *\n\t * @param {Object} [attributes={}] Attributes of the inserted image.\n\t * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.\n\t * @param {module:engine/model/selection~Selectable} [selectable] Place to insert the image. If not specified,\n\t * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images\n\t * and `model.document.selection` for the inline images.\n\t *\n\t * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)\n\t * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.\n\t *\n\t * @param {'imageBlock'|'imageInline'} [imageType] Image type of inserted image. If not specified,\n\t * it will be determined automatically depending of editor config or place of the insertion.\n\t * @return {module:engine/view/element~Element|null} The inserted model image element.\n\t */\n\tinsertImage( attributes = {}, selectable = null, imageType = null ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\timageType = determineImageTypeForInsertion( editor, selectable || selection, imageType );\n\n\t\t// Mix declarative attributes with selection attributes because the new image should \"inherit\"\n\t\t// the latter for best UX. For instance, inline images inserted into existing links\n\t\t// should not split them. To do that, they need to have \"linkHref\" inherited from the selection.\n\t\tattributes = {\n\t\t\t...Object.fromEntries( selection.getAttributes() ),\n\t\t\t...attributes\n\t\t};\n\n\t\tfor ( const attributeName in attributes ) {\n\t\t\tif ( !model.schema.checkAttribute( imageType, attributeName ) ) {\n\t\t\t\tdelete attributes[ attributeName ];\n\t\t\t}\n\t\t}\n\n\t\treturn model.change( writer => {\n\t\t\tconst imageElement = writer.createElement( imageType, attributes );\n\n\t\t\tmodel.insertObject( imageElement, selectable, null, {\n\t\t\t\tsetSelection: 'on',\n\t\t\t\t// If we want to insert a block image (for whatever reason) then we don't want to split text blocks.\n\t\t\t\t// This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).\n\t\t\t\tfindOptimalPosition: !selectable && imageType != 'imageInline'\n\t\t\t} );\n\n\t\t\t// Inserting an image might've failed due to schema regulations.\n\t\t\tif ( imageElement.parent ) {\n\t\t\t\treturn imageElement;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} );\n\t}\n\n\t/**\n\t * Returns an image widget editing view element if one is selected or is among the selection's ancestors.\n\t *\n\t * @protected\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetClosestSelectedImageWidget( selection ) {\n\t\tconst selectionPosition = selection.getFirstPosition();\n\n\t\tif ( !selectionPosition ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst viewElement = selection.getSelectedElement();\n\n\t\tif ( viewElement && this.isImageWidget( viewElement ) ) {\n\t\t\treturn viewElement;\n\t\t}\n\n\t\tlet parent = selectionPosition.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( parent.is( 'element' ) && this.isImageWidget( parent ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a image model element if one is selected or is among the selection's ancestors.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetClosestSelectedImageElement( selection ) {\n\t\tconst selectedElement = selection.getSelectedElement();\n\n\t\treturn this.isImage( selectedElement ) ? selectedElement : selection.getFirstPosition().findAncestor( 'imageBlock' );\n\t}\n\n\t/**\n\t * Checks if image can be inserted at current model selection.\n\t *\n\t * @protected\n\t * @returns {Boolean}\n\t */\n\tisImageAllowed() {\n\t\tconst model = this.editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\treturn isImageAllowedInParent( this.editor, selection ) && isNotInsideImage( selection );\n\t}\n\n\t/**\n\t * Converts a given {@link module:engine/view/element~Element} to an image widget:\n\t * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget\n\t * element.\n\t * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} viewElement\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n\t * @param {String} label The element's label. It will be concatenated with the image `alt` attribute if one is present.\n\t * @returns {module:engine/view/element~Element}\n\t */\n\ttoImageWidget( viewElement, writer, label ) {\n\t\twriter.setCustomProperty( 'image', true, viewElement );\n\n\t\tconst labelCreator = () => {\n\t\t\tconst imgElement = this.findViewImgElement( viewElement );\n\t\t\tconst altText = imgElement.getAttribute( 'alt' );\n\n\t\t\treturn altText ? `${ altText } ${ label }` : label;\n\t\t};\n\n\t\treturn toWidget( viewElement, writer, { label: labelCreator } );\n\t}\n\n\t/**\n\t * Checks if a given view element is an image widget.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} viewElement\n\t * @returns {Boolean}\n\t */\n\tisImageWidget( viewElement ) {\n\t\treturn !!viewElement.getCustomProperty( 'image' ) && isWidget( viewElement );\n\t}\n\n\t/**\n\t * Checks if the provided model element is an `image`.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement\n\t * @returns {Boolean}\n\t */\n\tisBlockImage( modelElement ) {\n\t\treturn !!modelElement && modelElement.is( 'element', 'imageBlock' );\n\t}\n\n\t/**\n\t * Checks if the provided model element is an `imageInline`.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement\n\t * @returns {Boolean}\n\t */\n\tisInlineImage( modelElement ) {\n\t\treturn !!modelElement && modelElement.is( 'element', 'imageInline' );\n\t}\n\n\t/**\n\t * Get the view `<img>` from another view element, e.g. a widget (`<figure class=\"image\">`), a link (`<a>`).\n\t *\n\t * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.\n\t *\n\t * @param {module:engine/view/element~Element} figureView\n\t * @returns {module:engine/view/element~Element}\n\t */\n\tfindViewImgElement( figureView ) {\n\t\tif ( this.isInlineImageView( figureView ) ) {\n\t\t\treturn figureView;\n\t\t}\n\n\t\tconst editingView = this.editor.editing.view;\n\n\t\tfor ( const { item } of editingView.createRangeIn( figureView ) ) {\n\t\t\tif ( this.isInlineImageView( item ) ) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Checks if image is allowed by schema in optimal insertion parent.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selection} selection\n// @returns {Boolean}\nfunction isImageAllowedInParent( editor, selection ) {\n\tconst imageType = determineImageTypeForInsertion( editor, selection );\n\n\tif ( imageType == 'imageBlock' ) {\n\t\tconst parent = getInsertImageParent( selection, editor.model );\n\n\t\tif ( editor.model.schema.checkChild( parent, 'imageBlock' ) ) {\n\t\t\treturn true;\n\t\t}\n\t} else if ( editor.model.schema.checkChild( selection.focus, 'imageInline' ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// Checks if selection is not placed inside an image (e.g. its caption).\n//\n// @private\n// @param {module:engine/model/selection~Selectable} selection\n// @returns {Boolean}\nfunction isNotInsideImage( selection ) {\n\treturn [ ...selection.focus.getAncestors() ].every( ancestor => !ancestor.is( 'element', 'imageBlock' ) );\n}\n\n// Returns a node that will be used to insert image with `model.insertContent`.\n//\n// @private\n// @param {module:engine/model/selection~Selection} selection\n// @param {module:engine/model/model~Model} model\n// @returns {module:engine/model/element~Element}\nfunction getInsertImageParent( selection, model ) {\n\tconst insertionRange = findOptimalInsertionRange( selection, model );\n\tconst parent = insertionRange.start.parent;\n\n\tif ( parent.isEmpty && !parent.is( 'element', '$root' ) ) {\n\t\treturn parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Determine image element type name depending on editor config or place of insertion.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selectable} selectable\n// @param {'imageBlock'|'imageInline'} [imageType] Image element type name. Used to force return of provided element name,\n// but only if there is proper plugin enabled.\n// @returns {'imageBlock'|'imageInline'} imageType\nfunction determineImageTypeForInsertion( editor, selectable, imageType ) {\n\tconst schema = editor.model.schema;\n\tconst configImageInsertType = editor.config.get( 'image.insert.type' );\n\n\tif ( !editor.plugins.has( 'ImageBlockEditing' ) ) {\n\t\treturn 'imageInline';\n\t}\n\n\tif ( !editor.plugins.has( 'ImageInlineEditing' ) ) {\n\t\treturn 'imageBlock';\n\t}\n\n\tif ( imageType ) {\n\t\treturn imageType;\n\t}\n\n\tif ( configImageInsertType === 'inline' ) {\n\t\treturn 'imageInline';\n\t}\n\n\tif ( configImageInsertType === 'block' ) {\n\t\treturn 'imageBlock';\n\t}\n\n\t// Try to replace the selected widget (e.g. another image).\n\tif ( selectable.is( 'selection' ) ) {\n\t\treturn determineImageTypeForInsertionAtSelection( schema, selectable );\n\t}\n\n\treturn schema.checkChild( selectable, 'imageInline' ) ? 'imageInline' : 'imageBlock';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}