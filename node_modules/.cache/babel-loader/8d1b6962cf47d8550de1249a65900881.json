{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { isPlainObject } from 'lodash-es';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\nexport default class Matcher {\n  /**\n   * Creates new instance of Matcher.\n   *\n   * @param {String|RegExp|Object|Function} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n   * more information.\n   */\n  constructor() {\n    /**\n     * @private\n     * @type {Array<Object|Function>}\n     */\n    this._patterns = [];\n    this.add(...arguments);\n  }\n  /**\n   * Adds pattern or patterns to matcher instance.\n   *\n   *\t\t// String.\n   *\t\tmatcher.add( 'div' );\n   *\n   *\t\t// Regular expression.\n   *\t\tmatcher.add( /^\\w/ );\n   *\n   *\t\t// Single class.\n   *\t\tmatcher.add( {\n   *\t\t\tclasses: 'foobar'\n   *\t\t} );\n   *\n   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n   *\n   * Multiple patterns can be added in one call:\n   *\n   * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n   *\n   * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n   * is provided it will be used to match element's name. Pattern can be also provided in a form\n   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n   * Function's return value will be stored under `match` key of the object returned from\n   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n   * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n   * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n   * represents attribute name. Value under that key can be either:\n   * * `true` - then attribute is just required (can be empty),\n   * * a string - then attribute has to be equal, or\n   * * a regular expression - then attribute has to match the expression.\n   * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n   * provided in a form of string or regular expression.\n   * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n   * represents style name. Value under that key can be either a string or a regular expression and it will be used\n   * to match style value.\n   */\n  add() {\n    for (var _len = arguments.length, pattern = new Array(_len), _key = 0; _key < _len; _key++) {\n      pattern[_key] = arguments[_key];\n    }\n    for (let item of pattern) {\n      // String or RegExp pattern is used as element's name.\n      if (typeof item == 'string' || item instanceof RegExp) {\n        item = {\n          name: item\n        };\n      }\n      this._patterns.push(item);\n    }\n  }\n  /**\n   * Matches elements for currently stored patterns. Returns match information about first found\n   * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n   *\n   * Example of returned object:\n   *\n   *\t\t{\n   *\t\t\telement: <instance of found element>,\n   *\t\t\tpattern: <pattern used to match found element>,\n   *\t\t\tmatch: {\n   *\t\t\t\tname: true,\n   *\t\t\t\tattributes: [ 'title', 'href' ],\n   *\t\t\t\tclasses: [ 'foo' ],\n   *\t\t\t\tstyles: [ 'color', 'position' ]\n   *\t\t\t}\n   *\t\t}\n   *\n   * @see module:engine/view/matcher~Matcher#add\n   * @see module:engine/view/matcher~Matcher#matchAll\n   * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n   * @returns {Object|null} result\n   * @returns {module:engine/view/element~Element} result.element Matched view element.\n   * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n   * @returns {Object} result.match Object representing matched element parts.\n   * @returns {Boolean} [result.match.name] True if name of the element was matched.\n   * @returns {Array} [result.match.attributes] Array with matched attribute names.\n   * @returns {Array} [result.match.classes] Array with matched class names.\n   * @returns {Array} [result.match.styles] Array with matched style names.\n   */\n  match() {\n    for (var _len2 = arguments.length, element = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      element[_key2] = arguments[_key2];\n    }\n    for (const singleElement of element) {\n      for (const pattern of this._patterns) {\n        const match = isElementMatching(singleElement, pattern);\n        if (match) {\n          return {\n            element: singleElement,\n            pattern,\n            match\n          };\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Matches elements for currently stored patterns. Returns array of match information with all found\n   * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n   *\n   * @see module:engine/view/matcher~Matcher#add\n   * @see module:engine/view/matcher~Matcher#match\n   * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n   * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n   * see {@link module:engine/view/matcher~Matcher#match match method} description.\n   */\n  matchAll() {\n    const results = [];\n    for (var _len3 = arguments.length, element = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      element[_key3] = arguments[_key3];\n    }\n    for (const singleElement of element) {\n      for (const pattern of this._patterns) {\n        const match = isElementMatching(singleElement, pattern);\n        if (match) {\n          results.push({\n            element: singleElement,\n            pattern,\n            match\n          });\n        }\n      }\n    }\n    return results.length > 0 ? results : null;\n  }\n  /**\n   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n   *\n   * @returns {String|null} Element name trying to match.\n   */\n  getElementName() {\n    if (this._patterns.length !== 1) {\n      return null;\n    }\n    const pattern = this._patterns[0];\n    const name = pattern.name;\n    return typeof pattern != 'function' && name && !(name instanceof RegExp) ? name : null;\n  }\n}\n// Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\nfunction isElementMatching(element, pattern) {\n  // If pattern is provided as function - return result of that function;\n  if (typeof pattern == 'function') {\n    return pattern(element);\n  }\n  const match = {};\n  // Check element's name.\n  if (pattern.name) {\n    match.name = matchName(pattern.name, element.name);\n    if (!match.name) {\n      return null;\n    }\n  }\n  // Check element's attributes.\n  if (pattern.attributes) {\n    match.attributes = matchAttributes(pattern.attributes, element);\n    if (!match.attributes) {\n      return null;\n    }\n  }\n  // Check element's classes.\n  if (pattern.classes) {\n    match.classes = matchClasses(pattern.classes, element);\n    if (!match.classes) {\n      return null;\n    }\n  }\n  // Check element's styles.\n  if (pattern.styles) {\n    match.styles = matchStyles(pattern.styles, element);\n    if (!match.styles) {\n      return null;\n    }\n  }\n  return match;\n}\n// Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\nfunction matchName(pattern, name) {\n  // If pattern is provided as RegExp - test against this regexp.\n  if (pattern instanceof RegExp) {\n    return !!name.match(pattern);\n  }\n  return pattern === name;\n}\n// Checks if an array of key/value pairs can be matched against provided patterns.\n//\n// Patterns can be provided in a following ways:\n// \t- a boolean value matches any attribute with any value (or no value):\n//\n//\t\t\tpattern: true\n//\n//\t- a RegExp expression or object matches any attribute name:\n//\n//\t\t\tpattern: /h[1-6]/\n//\n//\t- an object matches any attribute that has the same name as the object item's key, where object item's value is:\n//\t\t- equal to `true`, which matches any attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trequired: true\n//\t\t\t}\n//\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trel: 'nofollow'\n//\t\t\t}\n//\n//\t\t- a regular expression that matches attribute value,\n//\n//\t\t\tpattern: {\n//\t\t\t\tsrc: /https.*/\n//\t\t\t}\n//\n//\t- an array with items, where the item is:\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: [ 'data-property-1', 'data-property-2' ],\n//\n//\t\t- an object with `key` and `value` property, where `key` is a regular expression matching attribute name and\n//\t\t  `value` is either regular expression matching attribute value or a string equal to attribute value:\n//\n//\t\t\tpattern: [\n//\t\t\t\t{ key: /data-property-.*/, value: true },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: 'foobar' },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: /foo.*/ }\n//\t\t\t]\n//\n// @param {Object} patterns Object with information about attributes to match.\n// @param {Iterable.<String>} keys Attribute, style or class keys.\n// @param {Function} valueGetter A function providing value for a given item key.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchPatterns(patterns, keys, valueGetter) {\n  const normalizedPatterns = normalizePatterns(patterns);\n  const normalizedItems = Array.from(keys);\n  const match = [];\n  normalizedPatterns.forEach(_ref => {\n    let [patternKey, patternValue] = _ref;\n    normalizedItems.forEach(itemKey => {\n      if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {\n        match.push(itemKey);\n      }\n    });\n  });\n  // Return matches only if there are at least as many of them as there are patterns.\n  // The RegExp pattern can match more than one item.\n  if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {\n    return undefined;\n  }\n  return match;\n}\n// Bring all the possible pattern forms to an array of arrays where first item is a key and second is a value.\n//\n// Examples:\n//\n// Boolean pattern value:\n//\n//\t\ttrue\n//\n// to\n//\n//\t\t[ [ true, true ] ]\n//\n// Textual pattern value:\n//\n//\t\t'attribute-name-or-class-or-style'\n//\n// to\n//\n//\t\t[ [ 'attribute-name-or-class-or-style', true ] ]\n//\n// Regular expression:\n//\n//\t\t/^data-.*$/\n//\n// to\n//\n//\t\t[ [ /^data-.*$/, true ] ]\n//\n// Objects (plain or with `key` and `value` specified explicitly):\n//\n//\t\t{\n//\t\t\tsrc: /^https:.*$/\n//\t\t}\n//\n// or\n//\n//\t\t[ {\n//\t\t\tkey: 'src',\n//\t\t\tvalue: /^https:.*$/\n//\t\t} ]\n//\n// to:\n//\n//\t\t[ [ 'src', /^https:.*$/ ] ]\n//\n// @param {Object|Array} patterns\n// @returns {Array|null} Returns an array of objects or null if provided patterns were not in an expected form.\nfunction normalizePatterns(patterns) {\n  if (Array.isArray(patterns)) {\n    return patterns.map(pattern => {\n      if (isPlainObject(pattern)) {\n        if (pattern.key === undefined || pattern.value === undefined) {\n          // Documented at the end of matcher.js.\n          logWarning('matcher-pattern-missing-key-or-value', pattern);\n        }\n        return [pattern.key, pattern.value];\n      }\n      // Assume the pattern is either String or RegExp.\n      return [pattern, true];\n    });\n  }\n  if (isPlainObject(patterns)) {\n    return Object.entries(patterns);\n  }\n  // Other cases (true, string or regexp).\n  return [[patterns, true]];\n}\n// @param {String|RegExp} patternKey A pattern representing a key we want to match.\n// @param {String} itemKey An actual item key (e.g. `'src'`, `'background-color'`, `'ck-widget'`) we're testing against pattern.\n// @returns {Boolean}\nfunction isKeyMatched(patternKey, itemKey) {\n  return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);\n}\n// @param {String|RegExp} patternValue A pattern representing a value we want to match.\n// @param {String} itemKey An item key, e.g. `background`, `href`, 'rel', etc.\n// @param {Function} valueGetter A function used to provide a value for a given `itemKey`.\n// @returns {Boolean}\nfunction isValueMatched(patternValue, itemKey, valueGetter) {\n  if (patternValue === true) {\n    return true;\n  }\n  const itemValue = valueGetter(itemKey);\n  // For now, the reducers are not returning the full tree of properties.\n  // Casting to string preserves the old behavior until the root cause is fixed.\n  // More can be found in https://github.com/ckeditor/ckeditor5/issues/10399.\n  return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);\n}\n// Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchAttributes(patterns, element) {\n  const attributeKeys = new Set(element.getAttributeKeys());\n  // `style` and `class` attribute keys are deprecated. Only allow them in object pattern\n  // for backward compatibility.\n  if (isPlainObject(patterns)) {\n    if (patterns.style !== undefined) {\n      // Documented at the end of matcher.js.\n      logWarning('matcher-pattern-deprecated-attributes-style-key', patterns);\n    }\n    if (patterns.class !== undefined) {\n      // Documented at the end of matcher.js.\n      logWarning('matcher-pattern-deprecated-attributes-class-key', patterns);\n    }\n  } else {\n    attributeKeys.delete('style');\n    attributeKeys.delete('class');\n  }\n  return matchPatterns(patterns, attributeKeys, key => element.getAttribute(key));\n}\n// Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\nfunction matchClasses(patterns, element) {\n  // We don't need `getter` here because patterns for classes are always normalized to `[ className, true ]`.\n  return matchPatterns(patterns, element.getClassNames(), /* istanbul ignore next */() => {});\n}\n// Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\nfunction matchStyles(patterns, element) {\n  return matchPatterns(patterns, element.getStyleNames(true), key => element.getStyle(key));\n}\n/**\n * The key-value matcher pattern is missing key or value. Both must be present.\n * Refer the documentation: {@link module:engine/view/matcher~MatcherPattern}.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-missing-key-or-value\n */\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `style` key.\n *\n * Use `styles` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tstyle: /^border.*$/\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tstyles: /^border.*$/\n * \t\t}\n *\n * Refer to the {@glink updating/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-style-key\n */\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `class` key.\n *\n * Use `classes` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tclass: 'foobar'\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tclasses: 'foobar'\n * \t\t}\n *\n * Refer to the {@glink updating/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and the {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-class-key\n */","map":{"version":3,"names":["isPlainObject","logWarning","Matcher","constructor","_patterns","add","pattern","item","RegExp","name","push","match","element","singleElement","isElementMatching","matchAll","results","length","getElementName","matchName","attributes","matchAttributes","classes","matchClasses","styles","matchStyles","matchPatterns","patterns","keys","valueGetter","normalizedPatterns","normalizePatterns","normalizedItems","Array","from","forEach","patternKey","patternValue","itemKey","isKeyMatched","isValueMatched","undefined","isArray","map","key","value","Object","entries","itemValue","String","attributeKeys","Set","getAttributeKeys","style","class","delete","getAttribute","getClassNames","getStyleNames","getStyle"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { isPlainObject } from 'lodash-es';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\nexport default class Matcher {\n    /**\n     * Creates new instance of Matcher.\n     *\n     * @param {String|RegExp|Object|Function} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n     * more information.\n     */\n    constructor(...pattern) {\n        /**\n         * @private\n         * @type {Array<Object|Function>}\n         */\n        this._patterns = [];\n        this.add(...pattern);\n    }\n    /**\n     * Adds pattern or patterns to matcher instance.\n     *\n     *\t\t// String.\n     *\t\tmatcher.add( 'div' );\n     *\n     *\t\t// Regular expression.\n     *\t\tmatcher.add( /^\\w/ );\n     *\n     *\t\t// Single class.\n     *\t\tmatcher.add( {\n     *\t\t\tclasses: 'foobar'\n     *\t\t} );\n     *\n     * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n     *\n     * Multiple patterns can be added in one call:\n     *\n     * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n     *\n     * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n     * is provided it will be used to match element's name. Pattern can be also provided in a form\n     * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n     * Function's return value will be stored under `match` key of the object returned from\n     * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n     * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n     * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n     * represents attribute name. Value under that key can be either:\n     * * `true` - then attribute is just required (can be empty),\n     * * a string - then attribute has to be equal, or\n     * * a regular expression - then attribute has to match the expression.\n     * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n     * provided in a form of string or regular expression.\n     * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n     * represents style name. Value under that key can be either a string or a regular expression and it will be used\n     * to match style value.\n     */\n    add(...pattern) {\n        for (let item of pattern) {\n            // String or RegExp pattern is used as element's name.\n            if (typeof item == 'string' || item instanceof RegExp) {\n                item = { name: item };\n            }\n            this._patterns.push(item);\n        }\n    }\n    /**\n     * Matches elements for currently stored patterns. Returns match information about first found\n     * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n     *\n     * Example of returned object:\n     *\n     *\t\t{\n     *\t\t\telement: <instance of found element>,\n     *\t\t\tpattern: <pattern used to match found element>,\n     *\t\t\tmatch: {\n     *\t\t\t\tname: true,\n     *\t\t\t\tattributes: [ 'title', 'href' ],\n     *\t\t\t\tclasses: [ 'foo' ],\n     *\t\t\t\tstyles: [ 'color', 'position' ]\n     *\t\t\t}\n     *\t\t}\n     *\n     * @see module:engine/view/matcher~Matcher#add\n     * @see module:engine/view/matcher~Matcher#matchAll\n     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n     * @returns {Object|null} result\n     * @returns {module:engine/view/element~Element} result.element Matched view element.\n     * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n     * @returns {Object} result.match Object representing matched element parts.\n     * @returns {Boolean} [result.match.name] True if name of the element was matched.\n     * @returns {Array} [result.match.attributes] Array with matched attribute names.\n     * @returns {Array} [result.match.classes] Array with matched class names.\n     * @returns {Array} [result.match.styles] Array with matched style names.\n     */\n    match(...element) {\n        for (const singleElement of element) {\n            for (const pattern of this._patterns) {\n                const match = isElementMatching(singleElement, pattern);\n                if (match) {\n                    return {\n                        element: singleElement,\n                        pattern,\n                        match\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Matches elements for currently stored patterns. Returns array of match information with all found\n     * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n     *\n     * @see module:engine/view/matcher~Matcher#add\n     * @see module:engine/view/matcher~Matcher#match\n     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n     * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n     * see {@link module:engine/view/matcher~Matcher#match match method} description.\n     */\n    matchAll(...element) {\n        const results = [];\n        for (const singleElement of element) {\n            for (const pattern of this._patterns) {\n                const match = isElementMatching(singleElement, pattern);\n                if (match) {\n                    results.push({\n                        element: singleElement,\n                        pattern,\n                        match\n                    });\n                }\n            }\n        }\n        return results.length > 0 ? results : null;\n    }\n    /**\n     * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n     * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n     *\n     * @returns {String|null} Element name trying to match.\n     */\n    getElementName() {\n        if (this._patterns.length !== 1) {\n            return null;\n        }\n        const pattern = this._patterns[0];\n        const name = pattern.name;\n        return (typeof pattern != 'function' && name && !(name instanceof RegExp)) ? name : null;\n    }\n}\n// Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\nfunction isElementMatching(element, pattern) {\n    // If pattern is provided as function - return result of that function;\n    if (typeof pattern == 'function') {\n        return pattern(element);\n    }\n    const match = {};\n    // Check element's name.\n    if (pattern.name) {\n        match.name = matchName(pattern.name, element.name);\n        if (!match.name) {\n            return null;\n        }\n    }\n    // Check element's attributes.\n    if (pattern.attributes) {\n        match.attributes = matchAttributes(pattern.attributes, element);\n        if (!match.attributes) {\n            return null;\n        }\n    }\n    // Check element's classes.\n    if (pattern.classes) {\n        match.classes = matchClasses(pattern.classes, element);\n        if (!match.classes) {\n            return null;\n        }\n    }\n    // Check element's styles.\n    if (pattern.styles) {\n        match.styles = matchStyles(pattern.styles, element);\n        if (!match.styles) {\n            return null;\n        }\n    }\n    return match;\n}\n// Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\nfunction matchName(pattern, name) {\n    // If pattern is provided as RegExp - test against this regexp.\n    if (pattern instanceof RegExp) {\n        return !!name.match(pattern);\n    }\n    return pattern === name;\n}\n// Checks if an array of key/value pairs can be matched against provided patterns.\n//\n// Patterns can be provided in a following ways:\n// \t- a boolean value matches any attribute with any value (or no value):\n//\n//\t\t\tpattern: true\n//\n//\t- a RegExp expression or object matches any attribute name:\n//\n//\t\t\tpattern: /h[1-6]/\n//\n//\t- an object matches any attribute that has the same name as the object item's key, where object item's value is:\n//\t\t- equal to `true`, which matches any attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trequired: true\n//\t\t\t}\n//\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trel: 'nofollow'\n//\t\t\t}\n//\n//\t\t- a regular expression that matches attribute value,\n//\n//\t\t\tpattern: {\n//\t\t\t\tsrc: /https.*/\n//\t\t\t}\n//\n//\t- an array with items, where the item is:\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: [ 'data-property-1', 'data-property-2' ],\n//\n//\t\t- an object with `key` and `value` property, where `key` is a regular expression matching attribute name and\n//\t\t  `value` is either regular expression matching attribute value or a string equal to attribute value:\n//\n//\t\t\tpattern: [\n//\t\t\t\t{ key: /data-property-.*/, value: true },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: 'foobar' },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: /foo.*/ }\n//\t\t\t]\n//\n// @param {Object} patterns Object with information about attributes to match.\n// @param {Iterable.<String>} keys Attribute, style or class keys.\n// @param {Function} valueGetter A function providing value for a given item key.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchPatterns(patterns, keys, valueGetter) {\n    const normalizedPatterns = normalizePatterns(patterns);\n    const normalizedItems = Array.from(keys);\n    const match = [];\n    normalizedPatterns.forEach(([patternKey, patternValue]) => {\n        normalizedItems.forEach(itemKey => {\n            if (isKeyMatched(patternKey, itemKey) &&\n                isValueMatched(patternValue, itemKey, valueGetter)) {\n                match.push(itemKey);\n            }\n        });\n    });\n    // Return matches only if there are at least as many of them as there are patterns.\n    // The RegExp pattern can match more than one item.\n    if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {\n        return undefined;\n    }\n    return match;\n}\n// Bring all the possible pattern forms to an array of arrays where first item is a key and second is a value.\n//\n// Examples:\n//\n// Boolean pattern value:\n//\n//\t\ttrue\n//\n// to\n//\n//\t\t[ [ true, true ] ]\n//\n// Textual pattern value:\n//\n//\t\t'attribute-name-or-class-or-style'\n//\n// to\n//\n//\t\t[ [ 'attribute-name-or-class-or-style', true ] ]\n//\n// Regular expression:\n//\n//\t\t/^data-.*$/\n//\n// to\n//\n//\t\t[ [ /^data-.*$/, true ] ]\n//\n// Objects (plain or with `key` and `value` specified explicitly):\n//\n//\t\t{\n//\t\t\tsrc: /^https:.*$/\n//\t\t}\n//\n// or\n//\n//\t\t[ {\n//\t\t\tkey: 'src',\n//\t\t\tvalue: /^https:.*$/\n//\t\t} ]\n//\n// to:\n//\n//\t\t[ [ 'src', /^https:.*$/ ] ]\n//\n// @param {Object|Array} patterns\n// @returns {Array|null} Returns an array of objects or null if provided patterns were not in an expected form.\nfunction normalizePatterns(patterns) {\n    if (Array.isArray(patterns)) {\n        return patterns.map((pattern) => {\n            if (isPlainObject(pattern)) {\n                if (pattern.key === undefined || pattern.value === undefined) {\n                    // Documented at the end of matcher.js.\n                    logWarning('matcher-pattern-missing-key-or-value', pattern);\n                }\n                return [pattern.key, pattern.value];\n            }\n            // Assume the pattern is either String or RegExp.\n            return [pattern, true];\n        });\n    }\n    if (isPlainObject(patterns)) {\n        return Object.entries(patterns);\n    }\n    // Other cases (true, string or regexp).\n    return [[patterns, true]];\n}\n// @param {String|RegExp} patternKey A pattern representing a key we want to match.\n// @param {String} itemKey An actual item key (e.g. `'src'`, `'background-color'`, `'ck-widget'`) we're testing against pattern.\n// @returns {Boolean}\nfunction isKeyMatched(patternKey, itemKey) {\n    return patternKey === true ||\n        patternKey === itemKey ||\n        patternKey instanceof RegExp && itemKey.match(patternKey);\n}\n// @param {String|RegExp} patternValue A pattern representing a value we want to match.\n// @param {String} itemKey An item key, e.g. `background`, `href`, 'rel', etc.\n// @param {Function} valueGetter A function used to provide a value for a given `itemKey`.\n// @returns {Boolean}\nfunction isValueMatched(patternValue, itemKey, valueGetter) {\n    if (patternValue === true) {\n        return true;\n    }\n    const itemValue = valueGetter(itemKey);\n    // For now, the reducers are not returning the full tree of properties.\n    // Casting to string preserves the old behavior until the root cause is fixed.\n    // More can be found in https://github.com/ckeditor/ckeditor5/issues/10399.\n    return patternValue === itemValue ||\n        patternValue instanceof RegExp && !!String(itemValue).match(patternValue);\n}\n// Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchAttributes(patterns, element) {\n    const attributeKeys = new Set(element.getAttributeKeys());\n    // `style` and `class` attribute keys are deprecated. Only allow them in object pattern\n    // for backward compatibility.\n    if (isPlainObject(patterns)) {\n        if (patterns.style !== undefined) {\n            // Documented at the end of matcher.js.\n            logWarning('matcher-pattern-deprecated-attributes-style-key', patterns);\n        }\n        if (patterns.class !== undefined) {\n            // Documented at the end of matcher.js.\n            logWarning('matcher-pattern-deprecated-attributes-class-key', patterns);\n        }\n    }\n    else {\n        attributeKeys.delete('style');\n        attributeKeys.delete('class');\n    }\n    return matchPatterns(patterns, attributeKeys, key => element.getAttribute(key));\n}\n// Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\nfunction matchClasses(patterns, element) {\n    // We don't need `getter` here because patterns for classes are always normalized to `[ className, true ]`.\n    return matchPatterns(patterns, element.getClassNames(), /* istanbul ignore next */ () => { });\n}\n// Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\nfunction matchStyles(patterns, element) {\n    return matchPatterns(patterns, element.getStyleNames(true), key => element.getStyle(key));\n}\n/**\n * The key-value matcher pattern is missing key or value. Both must be present.\n * Refer the documentation: {@link module:engine/view/matcher~MatcherPattern}.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-missing-key-or-value\n */\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `style` key.\n *\n * Use `styles` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tstyle: /^border.*$/\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tstyles: /^border.*$/\n * \t\t}\n *\n * Refer to the {@glink updating/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-style-key\n */\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `class` key.\n *\n * Use `classes` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tclass: 'foobar'\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tclasses: 'foobar'\n * \t\t}\n *\n * Refer to the {@glink updating/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and the {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-class-key\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,aAAa,QAAQ,WAAW;AACzC,SAASC,UAAU,QAAQ,6CAA6C;AACxE;AACA;AACA;AACA;AACA,eAAe,MAAMC,OAAO,CAAC;EACzB;AACJ;AACA;AACA;AACA;AACA;EACIC,WAAW,GAAa;IACpB;AACR;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,GAAG,CAAC,YAAU,CAAC;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIA,GAAG,GAAa;IAAA,kCAATC,OAAO;MAAPA,OAAO;IAAA;IACV,KAAK,IAAIC,IAAI,IAAID,OAAO,EAAE;MACtB;MACA,IAAI,OAAOC,IAAI,IAAI,QAAQ,IAAIA,IAAI,YAAYC,MAAM,EAAE;QACnDD,IAAI,GAAG;UAAEE,IAAI,EAAEF;QAAK,CAAC;MACzB;MACA,IAAI,CAACH,SAAS,CAACM,IAAI,CAACH,IAAI,CAAC;IAC7B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,KAAK,GAAa;IAAA,mCAATC,OAAO;MAAPA,OAAO;IAAA;IACZ,KAAK,MAAMC,aAAa,IAAID,OAAO,EAAE;MACjC,KAAK,MAAMN,OAAO,IAAI,IAAI,CAACF,SAAS,EAAE;QAClC,MAAMO,KAAK,GAAGG,iBAAiB,CAACD,aAAa,EAAEP,OAAO,CAAC;QACvD,IAAIK,KAAK,EAAE;UACP,OAAO;YACHC,OAAO,EAAEC,aAAa;YACtBP,OAAO;YACPK;UACJ,CAAC;QACL;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA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"},"metadata":{},"sourceType":"module"}