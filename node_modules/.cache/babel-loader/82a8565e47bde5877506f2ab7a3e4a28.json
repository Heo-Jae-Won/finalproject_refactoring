{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/template\n */\n\n/* global document */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport View from './view';\nimport ViewCollection from './viewcollection';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport { isObject, cloneDeepWith } from 'lodash-es';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nconst xhtmlNs = 'http://www.w3.org/1999/xhtml';\n\n/**\n * A basic Template class. It renders a DOM HTML element or text from a\n * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,\n * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.\n *\n * A simple template can look like this:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tclass: 'foo',\n *\t\t\t\tstyle: {\n *\t\t\t\t\tbackgroundColor: 'yellow'\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t'A paragraph.'\n *\t\t\t]\n *\t\t} ).render();\n *\n * and it will render the following HTML element:\n *\n *\t\t<p class=\"foo\" style=\"background-color: yellow;\">A paragraph.</p>\n *\n * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.\n *\n * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex\n * template definitions.\n *\n* @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Template {\n  /**\n   * Creates an instance of the {@link ~Template} class.\n   *\n   * @param {module:ui/template~TemplateDefinition} def The definition of the template.\n   */\n  constructor(def) {\n    Object.assign(this, normalize(clone(def)));\n\n    /**\n     * Indicates whether this particular Template instance has been\n     * {@link #render rendered}.\n     *\n     * @readonly\n     * @protected\n     * @member {Boolean}\n     */\n    this._isRendered = false;\n\n    /**\n     * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template\n     * renders to an HTML element.\n     *\n     * @member {String} #tag\n     */\n\n    /**\n     * The text of the template. It also indicates that the template renders to a DOM text node.\n     *\n     * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text\n     */\n\n    /**\n     * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with\n     * the attributes of an HTML element.\n     *\n     * **Note**: This property only makes sense when {@link #tag} is defined.\n     *\n     * @member {Object} #attributes\n     */\n\n    /**\n     * The children of the template. They can be either:\n     * * independent instances of {@link ~Template} (subâ€“templates),\n     * * native DOM Nodes.\n     *\n     * **Note**: This property only makes sense when {@link #tag} is defined.\n     *\n     * @member {Array.<module:ui/template~Template|Node>} #children\n     */\n\n    /**\n     * The DOM event listeners of the template.\n     *\n     * @member {Object} #eventListeners\n     */\n\n    /**\n     * The data used by the {@link #revert} method to restore a node to its original state.\n     *\n     * See: {@link #apply}.\n     *\n     * @readonly\n     * @protected\n     * @member {module:ui/template~RenderData}\n     */\n    this._revertData = null;\n  }\n\n  /**\n   * Renders a DOM Node (an HTML element or text) out of the template.\n   *\n   *\t\tconst domNode = new Template( { ... } ).render();\n   *\n   * See: {@link #apply}.\n   *\n   * @returns {HTMLElement|Text}\n   */\n  render() {\n    const node = this._renderNode({\n      intoFragment: true\n    });\n    this._isRendered = true;\n    return node;\n  }\n\n  /**\n   * Applies the template to an existing DOM Node, either HTML element or text.\n   *\n   * **Note:** No new DOM nodes will be created. Applying extends:\n   *\n   * {@link module:ui/template~TemplateDefinition attributes},\n   * {@link module:ui/template~TemplateDefinition event listeners}, and\n   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.\n   *\n   * **Note:** Existing `class` and `style` attributes are extended when a template\n   * is applied to an HTML element, while other attributes and `textContent` are overridden.\n   *\n   * **Note:** The process of applying a template can be easily reverted using the\n   * {@link module:ui/template~Template#revert} method.\n   *\n   *\t\tconst element = document.createElement( 'div' );\n   *\t\tconst observable = new Model( { divClass: 'my-div' } );\n   *\t\tconst emitter = Object.create( EmitterMixin );\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tnew Template( {\n   *\t\t\tattributes: {\n   *\t\t\t\tid: 'first-div',\n   *\t\t\t\tclass: bind.to( 'divClass' )\n   *\t\t\t},\n   *\t\t\ton: {\n   *\t\t\t\tclick: bind( 'elementClicked' ) // Will be fired by the observable.\n   *\t\t\t},\n   *\t\t\tchildren: [\n   *\t\t\t\t'Div text.'\n   *\t\t\t]\n   *\t\t} ).apply( element );\n   *\n   *\t\tconsole.log( element.outerHTML ); // -> '<div id=\"first-div\" class=\"my-div\"></div>'\n   *\n   * @see module:ui/template~Template#render\n   * @see module:ui/template~Template#revert\n   * @param {Node} node Root node for the template to apply.\n   */\n  apply(node) {\n    this._revertData = getEmptyRevertData();\n    this._renderNode({\n      node,\n      isApplying: true,\n      revertData: this._revertData\n    });\n    return node;\n  }\n\n  /**\n   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.\n   *\n   * @param {Node} node The root node for the template to revert. In most of the cases, it is the\n   * same node used by {@link module:ui/template~Template#apply}.\n   */\n  revert(node) {\n    if (!this._revertData) {\n      /**\n       * Attempting to revert a template which has not been applied yet.\n       *\n       * @error ui-template-revert-not-applied\n       */\n      throw new CKEditorError('ui-template-revert-not-applied', [this, node]);\n    }\n    this._revertTemplateFromNode(node, this._revertData);\n  }\n\n  /**\n   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}\n   * instances and returns them one by one.\n   *\n   *\t\tconst viewFoo = new View();\n   *\t\tconst viewBar = new View();\n   *\t\tconst viewBaz = new View();\n   *\t\tconst template = new Template( {\n   *\t\t\ttag: 'div',\n   *\t\t\tchildren: [\n   *\t\t\t\tviewFoo,\n   *\t\t\t\t{\n   *\t\t\t\t\ttag: 'div',\n   *\t\t\t\t\tchildren: [\n   *\t\t\t\t\t\tviewBar\n   *\t\t\t\t\t]\n   *\t\t\t\t},\n   *\t\t\t\tviewBaz\n   *\t\t\t]\n   *\t\t} );\n   *\n   *\t\t// Logs: viewFoo, viewBar, viewBaz\n   *\t\tfor ( const view of template.getViews() ) {\n   *\t\t\tconsole.log( view );\n   *\t\t}\n   *\n   * @returns {Iterable.<module:ui/view~View>}\n   */\n  *getViews() {\n    function* search(def) {\n      if (def.children) {\n        for (const child of def.children) {\n          if (isView(child)) {\n            yield child;\n          } else if (isTemplate(child)) {\n            yield* search(child);\n          }\n        }\n      }\n    }\n    yield* search(this);\n  }\n\n  /**\n   * An entry point to the interface which binds DOM nodes to\n   * {@link module:utils/observablemixin~Observable observables}.\n   * There are two types of bindings:\n   *\n   * * HTML element attributes or text `textContent` synchronized with attributes of an\n   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}\n   * and {@link module:ui/template~BindChain#if}.\n   *\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tnew Template( {\n   *\t\t\tattributes: {\n   *\t\t\t\t// Binds the element \"class\" attribute to observable#classAttribute.\n   *\t\t\t\tclass: bind.to( 'classAttribute' )\n   *\t\t\t}\n   *\t\t} ).render();\n   *\n   * * DOM events fired on HTML element propagated through\n   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.\n   *\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tnew Template( {\n   *\t\t\ton: {\n   *\t\t\t\t// Will be fired by the observable.\n   *\t\t\t\tclick: bind( 'elementClicked' )\n   *\t\t\t}\n   *\t\t} ).render();\n   *\n   * Also see {@link module:ui/view~View#bindTemplate}.\n   *\n   * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.\n   * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute\n   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.\n   * @returns {module:ui/template~BindChain}\n   */\n  static bind(observable, emitter) {\n    return {\n      to(eventNameOrFunctionOrAttribute, callback) {\n        return new TemplateToBinding({\n          eventNameOrFunction: eventNameOrFunctionOrAttribute,\n          attribute: eventNameOrFunctionOrAttribute,\n          observable,\n          emitter,\n          callback\n        });\n      },\n      if(attribute, valueIfTrue, callback) {\n        return new TemplateIfBinding({\n          observable,\n          emitter,\n          attribute,\n          valueIfTrue,\n          callback\n        });\n      }\n    };\n  }\n\n  /**\n   * Extends an existing {@link module:ui/template~Template} instance with some additional content\n   * from another {@link module:ui/template~TemplateDefinition}.\n   *\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tconst template = new Template( {\n   *\t\t\ttag: 'p',\n   *\t\t\tattributes: {\n   *\t\t\t\tclass: 'a',\n   *\t\t\t\tdata-x: bind.to( 'foo' )\n   *\t\t\t},\n   *\t\t\tchildren: [\n   *\t\t\t\t{\n   *\t\t\t\t\ttag: 'span',\n   *\t\t\t\t\tattributes: {\n   *\t\t\t\t\t\tclass: 'b'\n   *\t\t\t\t\t},\n   *\t\t\t\t\tchildren: [\n   *\t\t\t\t\t\t'Span'\n   *\t\t\t\t\t]\n   *\t\t\t\t}\n   *\t\t\t]\n   *\t\t } );\n   *\n   *\t\t// Instance-level extension.\n   *\t\tTemplate.extend( template, {\n   *\t\t\tattributes: {\n   *\t\t\t\tclass: 'b',\n   *\t\t\t\tdata-x: bind.to( 'bar' )\n   *\t\t\t},\n   *\t\t\tchildren: [\n   *\t\t\t\t{\n   *\t\t\t\t\tattributes: {\n   *\t\t\t\t\t\tclass: 'c'\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t]\n   *\t\t} );\n   *\n   *\t\t// Child extension.\n   *\t\tTemplate.extend( template.children[ 0 ], {\n   *\t\t\tattributes: {\n   *\t\t\t\tclass: 'd'\n   *\t\t\t}\n   *\t\t} );\n   *\n   * the `outerHTML` of `template.render()` is:\n   *\n   *\t\t<p class=\"a b\" data-x=\"{ observable.foo } { observable.bar }\">\n   *\t\t\t<span class=\"b c d\">Span</span>\n   *\t\t</p>\n   *\n   * @param {module:ui/template~Template} template An existing template instance to be extended.\n   * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.\n   */\n  static extend(template, def) {\n    if (template._isRendered) {\n      /**\n       * Extending a template after rendering may not work as expected. To make sure\n       * the {@link module:ui/template~Template.extend extending} works for an element,\n       * make sure it happens before {@link #render} is called.\n       *\n       * @error template-extend-render\n       */\n      throw new CKEditorError('template-extend-render', [this, template]);\n    }\n    extendTemplate(template, normalize(clone(def)));\n  }\n\n  /**\n   * Renders a DOM Node (either an HTML element or text) out of the template.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n  _renderNode(data) {\n    let isInvalid;\n    if (data.node) {\n      // When applying, a definition cannot have \"tag\" and \"text\" at the same time.\n      isInvalid = this.tag && this.text;\n    } else {\n      // When rendering, a definition must have either \"tag\" or \"text\": XOR( this.tag, this.text ).\n      isInvalid = this.tag ? this.text : !this.text;\n    }\n    if (isInvalid) {\n      /**\n       * Node definition cannot have the \"tag\" and \"text\" properties at the same time.\n       * Node definition must have either \"tag\" or \"text\" when rendering a new Node.\n       *\n       * @error ui-template-wrong-syntax\n       */\n      throw new CKEditorError('ui-template-wrong-syntax', this);\n    }\n    if (this.text) {\n      return this._renderText(data);\n    } else {\n      return this._renderElement(data);\n    }\n  }\n\n  /**\n   * Renders an HTML element out of the template.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n  _renderElement(data) {\n    let node = data.node;\n    if (!node) {\n      node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);\n    }\n    this._renderAttributes(data);\n    this._renderElementChildren(data);\n    this._setUpListeners(data);\n    return node;\n  }\n\n  /**\n   * Renders a text node out of {@link module:ui/template~Template#text}.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n  _renderText(data) {\n    let node = data.node;\n\n    // Save the original textContent to revert it in #revert().\n    if (node) {\n      data.revertData.text = node.textContent;\n    } else {\n      node = data.node = document.createTextNode('');\n    }\n\n    // Check if this Text Node is bound to Observable. Cases:\n    //\n    //\t\ttext: [ Template.bind( ... ).to( ... ) ]\n    //\n    //\t\ttext: [\n    //\t\t\t'foo',\n    //\t\t\tTemplate.bind( ... ).to( ... ),\n    //\t\t\t...\n    //\t\t]\n    //\n    if (hasTemplateBinding(this.text)) {\n      this._bindToObservable({\n        schema: this.text,\n        updater: getTextUpdater(node),\n        data\n      });\n    }\n    // Simply set text. Cases:\n    //\n    //\t\ttext: [ 'all', 'are', 'static' ]\n    //\n    //\t\ttext: [ 'foo' ]\n    //\n    else {\n      node.textContent = this.text.join('');\n    }\n    return node;\n  }\n\n  /**\n   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n  _renderAttributes(data) {\n    let attrName, attrValue, domAttrValue, attrNs;\n    if (!this.attributes) {\n      return;\n    }\n    const node = data.node;\n    const revertData = data.revertData;\n    for (attrName in this.attributes) {\n      // Current attribute value in DOM.\n      domAttrValue = node.getAttribute(attrName);\n\n      // The value to be set.\n      attrValue = this.attributes[attrName];\n\n      // Save revert data.\n      if (revertData) {\n        revertData.attributes[attrName] = domAttrValue;\n      }\n\n      // Detect custom namespace:\n      //\n      //\t\tclass: {\n      //\t\t\tns: 'abc',\n      //\t\t\tvalue: Template.bind( ... ).to( ... )\n      //\t\t}\n      //\n      attrNs = isObject(attrValue[0]) && attrValue[0].ns ? attrValue[0].ns : null;\n\n      // Activate binding if one is found. Cases:\n      //\n      //\t\tclass: [\n      //\t\t\tTemplate.bind( ... ).to( ... )\n      //\t\t]\n      //\n      //\t\tclass: [\n      //\t\t\t'bar',\n      //\t\t\tTemplate.bind( ... ).to( ... ),\n      //\t\t\t'baz'\n      //\t\t]\n      //\n      //\t\tclass: {\n      //\t\t\tns: 'abc',\n      //\t\t\tvalue: Template.bind( ... ).to( ... )\n      //\t\t}\n      //\n      if (hasTemplateBinding(attrValue)) {\n        // Normalize attributes with additional data like namespace:\n        //\n        //\t\tclass: {\n        //\t\t\tns: 'abc',\n        //\t\t\tvalue: [ ... ]\n        //\t\t}\n        //\n        const valueToBind = attrNs ? attrValue[0].value : attrValue;\n\n        // Extend the original value of attributes like \"style\" and \"class\",\n        // don't override them.\n        if (revertData && shouldExtend(attrName)) {\n          valueToBind.unshift(domAttrValue);\n        }\n        this._bindToObservable({\n          schema: valueToBind,\n          updater: getAttributeUpdater(node, attrName, attrNs),\n          data\n        });\n      }\n\n      // Style attribute could be an Object so it needs to be parsed in a specific way.\n      //\n      //\t\tstyle: {\n      //\t\t\twidth: '100px',\n      //\t\t\theight: Template.bind( ... ).to( ... )\n      //\t\t}\n      //\n      else if (attrName == 'style' && typeof attrValue[0] !== 'string') {\n        this._renderStyleAttribute(attrValue[0], data);\n      }\n\n      // Otherwise simply set the static attribute:\n      //\n      //\t\tclass: [ 'foo' ]\n      //\n      //\t\tclass: [ 'all', 'are', 'static' ]\n      //\n      //\t\tclass: [\n      //\t\t\t{\n      //\t\t\t\tns: 'abc',\n      //\t\t\t\tvalue: [ 'foo' ]\n      //\t\t\t}\n      //\t\t]\n      //\n      else {\n        // Extend the original value of attributes like \"style\" and \"class\",\n        // don't override them.\n        if (revertData && domAttrValue && shouldExtend(attrName)) {\n          attrValue.unshift(domAttrValue);\n        }\n        attrValue = attrValue\n        // Retrieve \"values\" from:\n        //\n        //\t\tclass: [\n        //\t\t\t{\n        //\t\t\t\tns: 'abc',\n        //\t\t\t\tvalue: [ ... ]\n        //\t\t\t}\n        //\t\t]\n        //\n        .map(val => val ? val.value || val : val)\n        // Flatten the array.\n        .reduce((prev, next) => prev.concat(next), [])\n        // Convert into string.\n        .reduce(arrayValueReducer, '');\n        if (!isFalsy(attrValue)) {\n          node.setAttributeNS(attrNs, attrName, attrValue);\n        }\n      }\n    }\n  }\n\n  /**\n   * Renders the `style` attribute of an HTML element based on\n   * {@link module:ui/template~Template#attributes}.\n   *\n   * A style attribute is an {Object} with static values:\n   *\n   *\t\tattributes: {\n   *\t\t\tstyle: {\n   *\t\t\t\tcolor: 'red'\n   *\t\t\t}\n   *\t\t}\n   *\n   * or values bound to {@link module:ui/model~Model} properties:\n   *\n   *\t\tattributes: {\n   *\t\t\tstyle: {\n   *\t\t\t\tcolor: bind.to( ... )\n   *\t\t\t}\n   *\t\t}\n   *\n   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be\n   * needed.\n   *\n   * @private\n   * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n  _renderStyleAttribute(styles, data) {\n    const node = data.node;\n    for (const styleName in styles) {\n      const styleValue = styles[styleName];\n\n      // Cases:\n      //\n      //\t\tstyle: {\n      //\t\t\tcolor: bind.to( 'attribute' )\n      //\t\t}\n      //\n      if (hasTemplateBinding(styleValue)) {\n        this._bindToObservable({\n          schema: [styleValue],\n          updater: getStyleUpdater(node, styleName),\n          data\n        });\n      }\n\n      // Cases:\n      //\n      //\t\tstyle: {\n      //\t\t\tcolor: 'red'\n      //\t\t}\n      //\n      else {\n        node.style[styleName] = styleValue;\n      }\n    }\n  }\n\n  /**\n   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n  _renderElementChildren(data) {\n    const node = data.node;\n    const container = data.intoFragment ? document.createDocumentFragment() : node;\n    const isApplying = data.isApplying;\n    let childIndex = 0;\n    for (const child of this.children) {\n      if (isViewCollection(child)) {\n        if (!isApplying) {\n          child.setParent(node);\n\n          // Note: ViewCollection renders its children.\n          for (const view of child) {\n            container.appendChild(view.element);\n          }\n        }\n      } else if (isView(child)) {\n        if (!isApplying) {\n          if (!child.isRendered) {\n            child.render();\n          }\n          container.appendChild(child.element);\n        }\n      } else if (isNode(child)) {\n        container.appendChild(child);\n      } else {\n        if (isApplying) {\n          const revertData = data.revertData;\n          const childRevertData = getEmptyRevertData();\n          revertData.children.push(childRevertData);\n          child._renderNode({\n            node: container.childNodes[childIndex++],\n            isApplying: true,\n            revertData: childRevertData\n          });\n        } else {\n          container.appendChild(child.render());\n        }\n      }\n    }\n    if (data.intoFragment) {\n      node.appendChild(container);\n    }\n  }\n\n  /**\n   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}\n   * on an HTML element.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n  _setUpListeners(data) {\n    if (!this.eventListeners) {\n      return;\n    }\n    for (const key in this.eventListeners) {\n      const revertBindings = this.eventListeners[key].map(schemaItem => {\n        const [domEvtName, domSelector] = key.split('@');\n        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);\n      });\n      if (data.revertData) {\n        data.revertData.bindings.push(revertBindings);\n      }\n    }\n  }\n\n  /**\n   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}\n   * activates the binding and sets its initial value.\n   *\n   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or\n   * text node `textContent`.\n   *\n   * @protected\n   * @param {Object} options Binding options.\n   * @param {module:ui/template~TemplateValueSchema} options.schema\n   * @param {Function} options.updater A function which updates the DOM (like attribute or text).\n   * @param {module:ui/template~RenderData} options.data Rendering data.\n   */\n  _bindToObservable(_ref) {\n    let {\n      schema,\n      updater,\n      data\n    } = _ref;\n    const revertData = data.revertData;\n\n    // Set initial values.\n    syncValueSchemaValue(schema, updater, data);\n    const revertBindings = schema\n    // Filter \"falsy\" (false, undefined, null, '') value schema components out.\n    .filter(item => !isFalsy(item))\n    // Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.\n    .filter(item => item.observable)\n    // Once only the actual binding are left, let the emitter listen to observable change:attribute event.\n    // TODO: Reduce the number of listeners attached as many bindings may listen\n    // to the same observable attribute.\n    .map(templateBinding => templateBinding.activateAttributeListener(schema, updater, data));\n    if (revertData) {\n      revertData.bindings.push(revertBindings);\n    }\n  }\n\n  /**\n   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to\n   * return it to the original state.\n   *\n   * @protected\n   * @param {HTMLElement|Text} node A node to be reverted.\n   * @param {Object} revertData An object that stores information about what changes have been made by\n   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.\n   */\n  _revertTemplateFromNode(node, revertData) {\n    for (const binding of revertData.bindings) {\n      // Each binding may consist of several observable+observable#attribute.\n      // like the following has 2:\n      //\n      //\t\tclass: [\n      //\t\t\t'x',\n      //\t\t\tbind.to( 'foo' ),\n      //\t\t\t'y',\n      //\t\t\tbind.to( 'bar' )\n      //\t\t]\n      //\n      for (const revertBinding of binding) {\n        revertBinding();\n      }\n    }\n    if (revertData.text) {\n      node.textContent = revertData.text;\n      return;\n    }\n    for (const attrName in revertData.attributes) {\n      const attrValue = revertData.attributes[attrName];\n\n      // When the attribute has **not** been set before #apply().\n      if (attrValue === null) {\n        node.removeAttribute(attrName);\n      } else {\n        node.setAttribute(attrName, attrValue);\n      }\n    }\n    for (let i = 0; i < revertData.children.length; ++i) {\n      this._revertTemplateFromNode(node.childNodes[i], revertData.children[i]);\n    }\n  }\n}\nmix(Template, EmitterMixin);\n\n/**\n * Describes a binding created by the {@link module:ui/template~Template.bind} interface.\n *\n * @protected\n */\nexport class TemplateBinding {\n  /**\n   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.\n   *\n   * @param {module:ui/template~TemplateDefinition} def The definition of the binding.\n   */\n  constructor(def) {\n    Object.assign(this, def);\n\n    /**\n     * An observable instance of the binding. It either:\n     *\n     * * provides the attribute with the value,\n     * * or passes the event when a corresponding DOM event is fired.\n     *\n     * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable\n     */\n\n    /**\n     * An {@link module:utils/emittermixin~Emitter} used by the binding to:\n     *\n     * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},\n     * * or listen to the event in the DOM.\n     *\n     * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter\n     */\n\n    /**\n     * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.\n     *\n     * @member {String} module:ui/template~TemplateBinding#attribute\n     */\n\n    /**\n     * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.\n     *\n     * @member {Function} [module:ui/template~TemplateBinding#callback]\n     */\n  }\n\n  /**\n   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the\n   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.\n   *\n   * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.\n   * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}.\n   */\n  getValue(node) {\n    const value = this.observable[this.attribute];\n    return this.callback ? this.callback(value, node) : value;\n  }\n\n  /**\n   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated\n   * value of {@link module:ui/template~TemplateValueSchema}.\n   *\n   * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.\n   * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.\n   * @param {module:ui/template~RenderData} data Rendering data.\n   * @returns {Function} A function to sever the listener binding.\n   */\n  activateAttributeListener(schema, updater, data) {\n    const callback = () => syncValueSchemaValue(schema, updater, data);\n    this.emitter.listenTo(this.observable, 'change:' + this.attribute, callback);\n\n    // Allows revert of the listener.\n    return () => {\n      this.emitter.stopListening(this.observable, 'change:' + this.attribute, callback);\n    };\n  }\n}\n\n/**\n * Describes either:\n *\n * * a binding to an {@link module:utils/observablemixin~Observable},\n * * or a native DOM event binding.\n *\n * It is created by the {@link module:ui/template~BindChain#to} method.\n *\n * @protected\n */\nexport class TemplateToBinding extends TemplateBinding {\n  /**\n   * Activates the listener for the native DOM event, which when fired, is propagated by\n   * the {@link module:ui/template~TemplateBinding#emitter}.\n   *\n   * @param {String} domEvtName The name of the native DOM event.\n   * @param {String} domSelector The selector in the DOM to filter delegated events.\n   * @param {module:ui/template~RenderData} data Rendering data.\n   * @returns {Function} A function to sever the listener binding.\n   */\n  activateDomEventListener(domEvtName, domSelector, data) {\n    const callback = (evt, domEvt) => {\n      if (!domSelector || domEvt.target.matches(domSelector)) {\n        if (typeof this.eventNameOrFunction == 'function') {\n          this.eventNameOrFunction(domEvt);\n        } else {\n          this.observable.fire(this.eventNameOrFunction, domEvt);\n        }\n      }\n    };\n    this.emitter.listenTo(data.node, domEvtName, callback);\n\n    // Allows revert of the listener.\n    return () => {\n      this.emitter.stopListening(data.node, domEvtName, callback);\n    };\n  }\n}\n\n/**\n * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}\n * method.\n *\n * @protected\n */\nexport class TemplateIfBinding extends TemplateBinding {\n  /**\n   * @inheritDoc\n   */\n  getValue(node) {\n    const value = super.getValue(node);\n    return isFalsy(value) ? false : this.valueIfTrue || true;\n  }\n\n  /**\n   * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable} is `true`.\n   *\n   * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]\n   */\n}\n\n// Checks whether given {@link module:ui/template~TemplateValueSchema} contains a\n// {@link module:ui/template~TemplateBinding}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @returns {Boolean}\nfunction hasTemplateBinding(schema) {\n  if (!schema) {\n    return false;\n  }\n\n  // Normalize attributes with additional data like namespace:\n  //\n  //\t\tclass: {\n  //\t\t\tns: 'abc',\n  //\t\t\tvalue: [ ... ]\n  //\t\t}\n  //\n  if (schema.value) {\n    schema = schema.value;\n  }\n  if (Array.isArray(schema)) {\n    return schema.some(hasTemplateBinding);\n  } else if (schema instanceof TemplateBinding) {\n    return true;\n  }\n  return false;\n}\n\n// Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of\n// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}\n// items.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n// @returns {Array}\nfunction getValueSchemaValue(schema, node) {\n  return schema.map(schemaItem => {\n    // Process {@link module:ui/template~TemplateBinding} bindings.\n    if (schemaItem instanceof TemplateBinding) {\n      return schemaItem.getValue(node);\n    }\n\n    // All static values like strings, numbers, and \"falsy\" values (false, null, undefined, '', etc.) just pass.\n    return schemaItem;\n  });\n}\n\n// A function executed each time the bound Observable attribute changes, which updates the DOM with a value\n// constructed from {@link module:ui/template~TemplateValueSchema}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Function} updater A function which updates the DOM (like attribute or text).\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\nfunction syncValueSchemaValue(schema, updater, _ref2) {\n  let {\n    node\n  } = _ref2;\n  let value = getValueSchemaValue(schema, node);\n\n  // Check if schema is a single Template.bind.if, like:\n  //\n  //\t\tclass: Template.bind.if( 'foo' )\n  //\n  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {\n    value = value[0];\n  } else {\n    value = value.reduce(arrayValueReducer, '');\n  }\n  if (isFalsy(value)) {\n    updater.remove();\n  } else {\n    updater.set(value);\n  }\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset `textContent`.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @returns {Object}\nfunction getTextUpdater(node) {\n  return {\n    set(value) {\n      node.textContent = value;\n    },\n    remove() {\n      node.textContent = '';\n    }\n  };\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset an attribute.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} attrName Name of the attribute to be modified.\n// @param {String} [ns=null] Namespace to use.\n// @returns {Object}\nfunction getAttributeUpdater(el, attrName, ns) {\n  return {\n    set(value) {\n      el.setAttributeNS(ns, attrName, value);\n    },\n    remove() {\n      el.removeAttributeNS(ns, attrName);\n    }\n  };\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of CSSStyleDeclaration to set or remove a style.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} styleName Name of the style to be modified.\n// @returns {Object}\nfunction getStyleUpdater(el, styleName) {\n  return {\n    set(value) {\n      el.style[styleName] = value;\n    },\n    remove() {\n      el.style[styleName] = null;\n    }\n  };\n}\n\n// Clones definition of the template.\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition}\nfunction clone(def) {\n  const clone = cloneDeepWith(def, value => {\n    // Don't clone the `Template.bind`* bindings because of the references to Observable\n    // and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy\n    // cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins\n    // along with the definition.\n    //\n    // Don't clone Template instances if provided as a child. They're simply #render()ed\n    // and nothing should interfere.\n    //\n    // Also don't clone View instances if provided as a child of the Template. The template\n    // instance will be extracted from the View during the normalization and there's no need\n    // to clone it.\n    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {\n      return value;\n    }\n  });\n  return clone;\n}\n\n// Normalizes given {@link module:ui/template~TemplateDefinition}.\n//\n// See:\n//  * {@link normalizeAttributes}\n//  * {@link normalizeListeners}\n//  * {@link normalizePlainTextDefinition}\n//  * {@link normalizeTextDefinition}\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition} Normalized definition.\nfunction normalize(def) {\n  if (typeof def == 'string') {\n    def = normalizePlainTextDefinition(def);\n  } else if (def.text) {\n    normalizeTextDefinition(def);\n  }\n  if (def.on) {\n    def.eventListeners = normalizeListeners(def.on);\n\n    // Template mixes EmitterMixin, so delete #on to avoid collision.\n    delete def.on;\n  }\n  if (!def.text) {\n    if (def.attributes) {\n      normalizeAttributes(def.attributes);\n    }\n    const children = [];\n    if (def.children) {\n      if (isViewCollection(def.children)) {\n        children.push(def.children);\n      } else {\n        for (const child of def.children) {\n          if (isTemplate(child) || isView(child) || isNode(child)) {\n            children.push(child);\n          } else {\n            children.push(new Template(child));\n          }\n        }\n      }\n    }\n    def.children = children;\n  }\n  return def;\n}\n\n// Normalizes \"attributes\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tattributes: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: {\n//\t\t\t\tvalue: 'bar'\n//\t\t\t}\n//\t\t}\n//\n// becomes\n//\n//\t\tattributes: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: {\n//\t\t\t\tvalue: [ 'bar' ]\n//\t\t\t}\n//\t\t}\n//\n// @param {Object} attributes\nfunction normalizeAttributes(attributes) {\n  for (const a in attributes) {\n    if (attributes[a].value) {\n      attributes[a].value = toArray(attributes[a].value);\n    }\n    arrayify(attributes, a);\n  }\n}\n\n// Normalizes \"on\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\ton: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// becomes\n//\n//\t\ton: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// @param {Object} listeners\n// @returns {Object} Object containing normalized listeners.\nfunction normalizeListeners(listeners) {\n  for (const l in listeners) {\n    arrayify(listeners, l);\n  }\n  return listeners;\n}\n\n// Normalizes \"string\" {@link module:ui/template~TemplateDefinition}.\n//\n//\t\t\"foo\"\n//\n// becomes\n//\n//\t\t{ text: [ 'foo' ] },\n//\n// @param {String} def\n// @returns {module:ui/template~TemplateDefinition} Normalized template definition.\nfunction normalizePlainTextDefinition(def) {\n  return {\n    text: [def]\n  };\n}\n\n// Normalizes text {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tchildren: [\n//\t\t\t{ text: 'def' },\n//\t\t\t{ text: {@link module:ui/template~TemplateBinding} }\n//\t\t]\n//\n// becomes\n//\n//\t\tchildren: [\n//\t\t\t{ text: [ 'def' ] },\n//\t\t\t{ text: [ {@link module:ui/template~TemplateBinding} ] }\n//\t\t]\n//\n// @param {module:ui/template~TemplateDefinition} def\nfunction normalizeTextDefinition(def) {\n  def.text = toArray(def.text);\n}\n\n// Wraps an entry in Object in an Array, if not already one.\n//\n//\t\t{\n//\t\t\tx: 'y',\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// becomes\n//\n//\t\t{\n//\t\t\tx: [ 'y' ],\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// @param {Object} obj\n// @param {String} key\nfunction arrayify(obj, key) {\n  obj[key] = toArray(obj[key]);\n}\n\n// A helper which concatenates the value avoiding unwanted\n// leading white spaces.\n//\n// @param {String} prev\n// @param {String} cur\n// @returns {String}\nfunction arrayValueReducer(prev, cur) {\n  if (isFalsy(cur)) {\n    return prev;\n  } else if (isFalsy(prev)) {\n    return cur;\n  } else {\n    return `${prev} ${cur}`;\n  }\n}\n\n// Extends one object defined in the following format:\n//\n//\t\t{\n//\t\t\tkey1: [Array1],\n//\t\t\tkey2: [Array2],\n//\t\t\t...\n//\t\t\tkeyN: [ArrayN]\n//\t\t}\n//\n// with another object of the same data format.\n//\n// @param {Object} obj Base object.\n// @param {Object} ext Object extending base.\n// @returns {String}\nfunction extendObjectValueArray(obj, ext) {\n  for (const a in ext) {\n    if (obj[a]) {\n      obj[a].push(...ext[a]);\n    } else {\n      obj[a] = ext[a];\n    }\n  }\n}\n\n// A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance\n// with content from {@link module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.\n//\n// @param {module:ui/template~Template} def A template instance to be extended.\n// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.\n// @param {Object} Error context.\nfunction extendTemplate(template, def) {\n  if (def.attributes) {\n    if (!template.attributes) {\n      template.attributes = {};\n    }\n    extendObjectValueArray(template.attributes, def.attributes);\n  }\n  if (def.eventListeners) {\n    if (!template.eventListeners) {\n      template.eventListeners = {};\n    }\n    extendObjectValueArray(template.eventListeners, def.eventListeners);\n  }\n  if (def.text) {\n    template.text.push(...def.text);\n  }\n  if (def.children && def.children.length) {\n    if (template.children.length != def.children.length) {\n      /**\n       * The number of children in extended definition does not match.\n       *\n       * @error ui-template-extend-children-mismatch\n       */\n      throw new CKEditorError('ui-template-extend-children-mismatch', template);\n    }\n    let childIndex = 0;\n    for (const childDef of def.children) {\n      extendTemplate(template.children[childIndex++], childDef);\n    }\n  }\n}\n\n// Checks if value is \"falsy\".\n// Note: 0 (Number) is not \"falsy\" in this context.\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isFalsy(value) {\n  return !value && value !== 0;\n}\n\n// Checks if the item is an instance of {@link module:ui/view~View}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isView(item) {\n  return item instanceof View;\n}\n\n// Checks if the item is an instance of {@link module:ui/template~Template}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isTemplate(item) {\n  return item instanceof Template;\n}\n\n// Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isViewCollection(item) {\n  return item instanceof ViewCollection;\n}\n\n// Creates an empty skeleton for {@link module:ui/template~Template#revert}\n// data.\n//\n// @private\nfunction getEmptyRevertData() {\n  return {\n    children: [],\n    bindings: [],\n    attributes: {}\n  };\n}\n\n// Checks whether an attribute should be extended when\n// {@link module:ui/template~Template#apply} is called.\n//\n// @private\n// @param {String} attrName Attribute name to check.\nfunction shouldExtend(attrName) {\n  return attrName == 'class' || attrName == 'style';\n}\n\n/**\n * A definition of the {@link module:ui/template~Template}. It describes what kind of\n * node a template will render (HTML element or text), attributes of an element, DOM event\n * listeners and children.\n *\n * Also see:\n * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,\n * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.\n *\n * A sample definition on an HTML element can look like this:\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\ttag: 'span',\n *\t\t\t\t\tattributes: { ... },\n *\t\t\t\t\tchildren: [ ... ],\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\ttext: 'staticâ€“text'\n *\t\t\t\t},\n *\t\t\t\t'also-staticâ€“text',\n *\t\t\t],\n *\t\t\tattributes: {\n *\t\t\t\tclass: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tid: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tstyle: {@link module:ui/template~TemplateValueSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\t'click': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// Document.querySelector format is also accepted.\n *\t\t\t\t'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t}\n *\t\t} );\n *\n * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node\n * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:\n *\n *\t\tconst view = new SomeView();\n *\t\tconst childTemplate = new Template( { ... } );\n *\t\tconst childNode = document.createElement( 'b' );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: [\n *\t\t\t\t// view#element will be added as a child of this <p>.\n *\t\t\t\tview,\n *\n * \t\t\t\t// The output of childTemplate.render() will be added here.\n *\t\t\t\tchildTemplate,\n *\n *\t\t\t\t// Native DOM nodes are included directly in the rendered output.\n *\t\t\t\tchildNode\n *\t\t\t]\n *\t\t} );\n *\n * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:\n *\n *\t\tconst collection = new ViewCollection();\n *\t\tcollection.add( someView );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: collection\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateDefinition\n * @type Object\n *\n * @property {String} tag See the template {@link module:ui/template~Template#tag} property.\n *\n * @property {Array.<module:ui/template~TemplateDefinition>} [children]\n * See the template {@link module:ui/template~Template#children} property.\n *\n * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]\n * See the template {@link module:ui/template~Template#attributes} property.\n *\n * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]\n * See the template {@link module:ui/template~Template#text} property.\n *\n * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]\n * See the template {@link module:ui/template~Template#eventListeners} property.\n */\n\n/**\n * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple\n * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn where to use it,\n * * {@link module:ui/template~Template.bind} to learn how to configure\n * {@link module:utils/observablemixin~Observable} attribute bindings,\n * * {@link module:ui/template~Template#render} to learn how to render a template,\n * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}\n * methods to learn more about bindings.\n *\n * Attribute values can be described in many different ways:\n *\n *\t\t// Bind helper will create bindings to attributes of the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// A plain string schema.\n *\t\t\t\t'class': 'static-text',\n *\n *\t\t\t\t// An object schema, binds to the \"foo\" attribute of the\n *\t\t\t\t// observable and follows its value.\n *\t\t\t\t'class': bind.to( 'foo' ),\n *\n *\t\t\t\t// An array schema, combines the above.\n *\t\t\t\t'class': [\n *\t\t\t\t\t'static-text',\n *\t\t\t\t\tbind.to( 'bar', () => { ... } ),\n *\n * \t\t\t\t\t// Bindings can also be conditional.\n *\t\t\t\t\tbind.if( 'baz', 'class-when-baz-is-true' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema, with a custom namespace, e.g. useful for creating SVGs.\n *\t\t\t\t'class': {\n *\t\t\t\t\tns: 'http://ns.url',\n *\t\t\t\t\tvalue: [\n *\t\t\t\t\t\tbind.if( 'baz', 'value-when-true' ),\n *\t\t\t\t\t\t'static-text'\n *\t\t\t\t\t]\n *\t\t\t\t},\n *\n *\t\t\t\t// An object schema, specific for styles.\n *\t\t\t\tstyle: {\n *\t\t\t\t\tcolor: 'red',\n *\t\t\t\t\tbackgroundColor: bind.to( 'qux', () => { ... } )\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * Text nodes can also have complex values:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\t// Will render a \"foo\" text node.\n *\t\tnew Template( {\n *\t\t\ttext: 'foo'\n *\t\t} );\n *\n *\t\t// Will render a \"static text: {observable.foo}\" text node.\n *\t\t// The text of the node will be updated as the \"foo\" attribute changes.\n *\t\tnew Template( {\n *\t\t\ttext: [\n *\t\t\t\t'static text: ',\n *\t\t\t\tbind.to( 'foo', () => { ... } )\n *\t\t\t]\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateValueSchema\n * @type {Object|String|Array}\n */\n\n/**\n * Describes an event listener attached to an HTML element. Such listener can propagate DOM events\n * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks\n * or both, if necessary.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,\n * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.\n *\n * Check out different ways of attaching event listeners below:\n *\n *\t\t// Bind helper will propagate events through the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\ton: {\n *\t\t\t\t// An object schema. The observable will fire the \"clicked\" event upon DOM \"click\".\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\n *\t\t\t\t// An object schema. It will work for \"click\" event on \"a.foo\" children only.\n *\t\t\t\t'click@a.foo': bind.to( 'clicked' )\n *\n *\t\t\t\t// An array schema, makes the observable propagate multiple events.\n *\t\t\t\tclick: [\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( 'executed' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema with a custom callback.\n *\t\t\t\t'click@a.foo': {\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( evt => {\n *\t\t\t\t\t\tconsole.log( `${ evt.target } has been clicked!` );\n *\t\t\t\t\t} }\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateListenerSchema\n * @type {Object|String|Array}\n */\n\n/**\n * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`\n * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.\n *\n * @interface module:ui/template~BindChain\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to either:\n *\n * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable\n * attribute as it changes,\n * * or an HTML element DOM event, so the DOM events are propagated through an observable.\n *\n * Some common use cases of `to()` bindings are presented below:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// class=\"...\" attribute gets bound to `observable#a`\n *\t\t\t\tclass: bind.to( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t// <p>...</p> gets bound to observable#b; always `toUpperCase()`.\n *\t\t\t\t{\n *\t\t\t\t\ttext: bind.to( 'b', ( value, node ) => value.toUpperCase() )\n *\t\t\t\t}\n *\t\t\t],\n *\t\t\ton: {\n *\t\t\t\tclick: [\n *\t\t\t\t\t// An observable will fire \"clicked\" upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\n *\t\t\t\t\t// A custom callback will be executed upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( () => {\n *\t\t\t\t\t\t...\n *\t\t\t\t\t} )\n *\t\t\t\t]\n *\t\t\t}\n *\t\t} ).render();\n *\n * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and\n * {@link module:ui/template~TemplateListenerSchema}.\n *\n * @method #to\n * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of\n * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text\n * node `textContent` so it remains in sync with the observable attribute as it changes.\n *\n * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`\n * depending on the \"falseness\" of an {@link module:utils/observablemixin~Observable} attribute.\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'input',\n *\t\t\tattributes: {\n *\t\t\t\t// <input checked> when `observable#a` is not undefined/null/false/''\n *\t\t\t\t// <input> when `observable#a` is undefined/null/false\n *\t\t\t\tchecked: bind.if( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\t// <input>\"b-is-not-set\"</input> when `observable#b` is undefined/null/false/''\n *\t\t\t\t\t// <input></input> when `observable#b` is not \"falsy\"\n *\t\t\t\t\ttext: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )\n *\t\t\t\t}\n *\t\t\t]\n *\t\t} ).render();\n *\n * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.\n *\n * @method #if\n * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.\n * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not\n * undefined/null/false/'' (empty string).\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * The {@link module:ui/template~Template#_renderNode} configuration.\n *\n * @private\n * @interface module:ui/template~RenderData\n */\n\n/**\n * Tells {@link module:ui/template~Template#_renderNode} to render\n * children into `DocumentFragment` first and then append the fragment\n * to the parent element. It is a speed optimization.\n *\n * @member {Boolean} #intoFragment\n */\n\n/**\n * A node which is being rendered.\n *\n * @member {HTMLElement|Text} #node\n */\n\n/**\n * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has\n * been provided by {@module:ui/template~Template#apply}.\n *\n * @member {Boolean} #isApplying\n */\n\n/**\n * An object storing the data that helps {@module:ui/template~Template#revert}\n * bringing back an element to its initial state, i.e. before\n * {@module:ui/template~Template#apply} was called.\n *\n * @member {Object} #revertData\n */","map":{"version":3,"names":["CKEditorError","mix","EmitterMixin","View","ViewCollection","isNode","isObject","cloneDeepWith","toArray","xhtmlNs","Template","constructor","def","Object","assign","normalize","clone","_isRendered","_revertData","render","node","_renderNode","intoFragment","apply","getEmptyRevertData","isApplying","revertData","revert","_revertTemplateFromNode","getViews","search","children","child","isView","isTemplate","bind","observable","emitter","to","eventNameOrFunctionOrAttribute","callback","TemplateToBinding","eventNameOrFunction","attribute","if","valueIfTrue","TemplateIfBinding","extend","template","extendTemplate","data","isInvalid","tag","text","_renderText","_renderElement","document","createElementNS","ns","_renderAttributes","_renderElementChildren","_setUpListeners","textContent","createTextNode","hasTemplateBinding","_bindToObservable","schema","updater","getTextUpdater","join","attrName","attrValue","domAttrValue","attrNs","attributes","getAttribute","valueToBind","value","shouldExtend","unshift","getAttributeUpdater","_renderStyleAttribute","map","val","reduce","prev","next","concat","arrayValueReducer","isFalsy","setAttributeNS","styles","styleName","styleValue","getStyleUpdater","style","container","createDocumentFragment","childIndex","isViewCollection","setParent","view","appendChild","element","isRendered","childRevertData","push","childNodes","eventListeners","key","revertBindings","schemaItem","domEvtName","domSelector","split","activateDomEventListener","bindings","syncValueSchemaValue","filter","item","templateBinding","activateAttributeListener","binding","revertBinding","removeAttribute","setAttribute","i","length","TemplateBinding","getValue","listenTo","stopListening","evt","domEvt","target","matches","fire","Array","isArray","some","getValueSchemaValue","remove","set","el","removeAttributeNS","normalizePlainTextDefinition","normalizeTextDefinition","on","normalizeListeners","normalizeAttributes","a","arrayify","listeners","l","obj","cur","extendObjectValueArray","ext","childDef"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-ui/src/template.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/template\n */\n\n/* global document */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport View from './view';\nimport ViewCollection from './viewcollection';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport { isObject, cloneDeepWith } from 'lodash-es';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n\nconst xhtmlNs = 'http://www.w3.org/1999/xhtml';\n\n/**\n * A basic Template class. It renders a DOM HTML element or text from a\n * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,\n * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.\n *\n * A simple template can look like this:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tclass: 'foo',\n *\t\t\t\tstyle: {\n *\t\t\t\t\tbackgroundColor: 'yellow'\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t'A paragraph.'\n *\t\t\t]\n *\t\t} ).render();\n *\n * and it will render the following HTML element:\n *\n *\t\t<p class=\"foo\" style=\"background-color: yellow;\">A paragraph.</p>\n *\n * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.\n *\n * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex\n * template definitions.\n *\n* @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Template {\n\t/**\n\t * Creates an instance of the {@link ~Template} class.\n\t *\n\t * @param {module:ui/template~TemplateDefinition} def The definition of the template.\n\t */\n\tconstructor( def ) {\n\t\tObject.assign( this, normalize( clone( def ) ) );\n\n\t\t/**\n\t\t * Indicates whether this particular Template instance has been\n\t\t * {@link #render rendered}.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._isRendered = false;\n\n\t\t/**\n\t\t * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template\n\t\t * renders to an HTML element.\n\t\t *\n\t\t * @member {String} #tag\n\t\t */\n\n\t\t/**\n\t\t * The text of the template. It also indicates that the template renders to a DOM text node.\n\t\t *\n\t\t * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text\n\t\t */\n\n\t\t/**\n\t\t * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with\n\t\t * the attributes of an HTML element.\n\t\t *\n\t\t * **Note**: This property only makes sense when {@link #tag} is defined.\n\t\t *\n\t\t * @member {Object} #attributes\n\t\t */\n\n\t\t/**\n\t\t * The children of the template. They can be either:\n\t\t * * independent instances of {@link ~Template} (subâ€“templates),\n\t\t * * native DOM Nodes.\n\t\t *\n\t\t * **Note**: This property only makes sense when {@link #tag} is defined.\n\t\t *\n\t\t * @member {Array.<module:ui/template~Template|Node>} #children\n\t\t */\n\n\t\t/**\n\t\t * The DOM event listeners of the template.\n\t\t *\n\t\t * @member {Object} #eventListeners\n\t\t */\n\n\t\t/**\n\t\t * The data used by the {@link #revert} method to restore a node to its original state.\n\t\t *\n\t\t * See: {@link #apply}.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {module:ui/template~RenderData}\n\t\t */\n\t\tthis._revertData = null;\n\t}\n\n\t/**\n\t * Renders a DOM Node (an HTML element or text) out of the template.\n\t *\n\t *\t\tconst domNode = new Template( { ... } ).render();\n\t *\n\t * See: {@link #apply}.\n\t *\n\t * @returns {HTMLElement|Text}\n\t */\n\trender() {\n\t\tconst node = this._renderNode( {\n\t\t\tintoFragment: true\n\t\t} );\n\n\t\tthis._isRendered = true;\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Applies the template to an existing DOM Node, either HTML element or text.\n\t *\n\t * **Note:** No new DOM nodes will be created. Applying extends:\n\t *\n\t * {@link module:ui/template~TemplateDefinition attributes},\n\t * {@link module:ui/template~TemplateDefinition event listeners}, and\n\t * `textContent` of {@link module:ui/template~TemplateDefinition children} only.\n\t *\n\t * **Note:** Existing `class` and `style` attributes are extended when a template\n\t * is applied to an HTML element, while other attributes and `textContent` are overridden.\n\t *\n\t * **Note:** The process of applying a template can be easily reverted using the\n\t * {@link module:ui/template~Template#revert} method.\n\t *\n\t *\t\tconst element = document.createElement( 'div' );\n\t *\t\tconst observable = new Model( { divClass: 'my-div' } );\n\t *\t\tconst emitter = Object.create( EmitterMixin );\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tid: 'first-div',\n\t *\t\t\t\tclass: bind.to( 'divClass' )\n\t *\t\t\t},\n\t *\t\t\ton: {\n\t *\t\t\t\tclick: bind( 'elementClicked' ) // Will be fired by the observable.\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t'Div text.'\n\t *\t\t\t]\n\t *\t\t} ).apply( element );\n\t *\n\t *\t\tconsole.log( element.outerHTML ); // -> '<div id=\"first-div\" class=\"my-div\"></div>'\n\t *\n\t * @see module:ui/template~Template#render\n\t * @see module:ui/template~Template#revert\n\t * @param {Node} node Root node for the template to apply.\n\t */\n\tapply( node ) {\n\t\tthis._revertData = getEmptyRevertData();\n\n\t\tthis._renderNode( {\n\t\t\tnode,\n\t\t\tisApplying: true,\n\t\t\trevertData: this._revertData\n\t\t} );\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.\n\t *\n\t * @param {Node} node The root node for the template to revert. In most of the cases, it is the\n\t * same node used by {@link module:ui/template~Template#apply}.\n\t */\n\trevert( node ) {\n\t\tif ( !this._revertData ) {\n\t\t\t/**\n\t\t\t * Attempting to revert a template which has not been applied yet.\n\t\t\t *\n\t\t\t * @error ui-template-revert-not-applied\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-revert-not-applied',\n\t\t\t\t[ this, node ]\n\t\t\t);\n\t\t}\n\n\t\tthis._revertTemplateFromNode( node, this._revertData );\n\t}\n\n\t/**\n\t * Returns an iterator which traverses the template in search of {@link module:ui/view~View}\n\t * instances and returns them one by one.\n\t *\n\t *\t\tconst viewFoo = new View();\n\t *\t\tconst viewBar = new View();\n\t *\t\tconst viewBaz = new View();\n\t *\t\tconst template = new Template( {\n\t *\t\t\ttag: 'div',\n\t *\t\t\tchildren: [\n\t *\t\t\t\tviewFoo,\n\t *\t\t\t\t{\n\t *\t\t\t\t\ttag: 'div',\n\t *\t\t\t\t\tchildren: [\n\t *\t\t\t\t\t\tviewBar\n\t *\t\t\t\t\t]\n\t *\t\t\t\t},\n\t *\t\t\t\tviewBaz\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Logs: viewFoo, viewBar, viewBaz\n\t *\t\tfor ( const view of template.getViews() ) {\n\t *\t\t\tconsole.log( view );\n\t *\t\t}\n\t *\n\t * @returns {Iterable.<module:ui/view~View>}\n\t */\n\t* getViews() {\n\t\tfunction* search( def ) {\n\t\t\tif ( def.children ) {\n\t\t\t\tfor ( const child of def.children ) {\n\t\t\t\t\tif ( isView( child ) ) {\n\t\t\t\t\t\tyield child;\n\t\t\t\t\t} else if ( isTemplate( child ) ) {\n\t\t\t\t\t\tyield* search( child );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tyield* search( this );\n\t}\n\n\t/**\n\t * An entry point to the interface which binds DOM nodes to\n\t * {@link module:utils/observablemixin~Observable observables}.\n\t * There are two types of bindings:\n\t *\n\t * * HTML element attributes or text `textContent` synchronized with attributes of an\n\t * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}\n\t * and {@link module:ui/template~BindChain#if}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\tattributes: {\n\t *\t\t\t\t// Binds the element \"class\" attribute to observable#classAttribute.\n\t *\t\t\t\tclass: bind.to( 'classAttribute' )\n\t *\t\t\t}\n\t *\t\t} ).render();\n\t *\n\t * * DOM events fired on HTML element propagated through\n\t * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\ton: {\n\t *\t\t\t\t// Will be fired by the observable.\n\t *\t\t\t\tclick: bind( 'elementClicked' )\n\t *\t\t\t}\n\t *\t\t} ).render();\n\t *\n\t * Also see {@link module:ui/view~View#bindTemplate}.\n\t *\n\t * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.\n\t * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute\n\t * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.\n\t * @returns {module:ui/template~BindChain}\n\t */\n\tstatic bind( observable, emitter ) {\n\t\treturn {\n\t\t\tto( eventNameOrFunctionOrAttribute, callback ) {\n\t\t\t\treturn new TemplateToBinding( {\n\t\t\t\t\teventNameOrFunction: eventNameOrFunctionOrAttribute,\n\t\t\t\t\tattribute: eventNameOrFunctionOrAttribute,\n\t\t\t\t\tobservable, emitter, callback\n\t\t\t\t} );\n\t\t\t},\n\n\t\t\tif( attribute, valueIfTrue, callback ) {\n\t\t\t\treturn new TemplateIfBinding( {\n\t\t\t\t\tobservable, emitter, attribute, valueIfTrue, callback\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Extends an existing {@link module:ui/template~Template} instance with some additional content\n\t * from another {@link module:ui/template~TemplateDefinition}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tconst template = new Template( {\n\t *\t\t\ttag: 'p',\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'a',\n\t *\t\t\t\tdata-x: bind.to( 'foo' )\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t{\n\t *\t\t\t\t\ttag: 'span',\n\t *\t\t\t\t\tattributes: {\n\t *\t\t\t\t\t\tclass: 'b'\n\t *\t\t\t\t\t},\n\t *\t\t\t\t\tchildren: [\n\t *\t\t\t\t\t\t'Span'\n\t *\t\t\t\t\t]\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t } );\n\t *\n\t *\t\t// Instance-level extension.\n\t *\t\tTemplate.extend( template, {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'b',\n\t *\t\t\t\tdata-x: bind.to( 'bar' )\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t{\n\t *\t\t\t\t\tattributes: {\n\t *\t\t\t\t\t\tclass: 'c'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Child extension.\n\t *\t\tTemplate.extend( template.children[ 0 ], {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'd'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * the `outerHTML` of `template.render()` is:\n\t *\n\t *\t\t<p class=\"a b\" data-x=\"{ observable.foo } { observable.bar }\">\n\t *\t\t\t<span class=\"b c d\">Span</span>\n\t *\t\t</p>\n\t *\n\t * @param {module:ui/template~Template} template An existing template instance to be extended.\n\t * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.\n\t */\n\tstatic extend( template, def ) {\n\t\tif ( template._isRendered ) {\n\t\t\t/**\n\t\t\t * Extending a template after rendering may not work as expected. To make sure\n\t\t\t * the {@link module:ui/template~Template.extend extending} works for an element,\n\t\t\t * make sure it happens before {@link #render} is called.\n\t\t\t *\n\t\t\t * @error template-extend-render\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'template-extend-render',\n\t\t\t\t[ this, template ]\n\t\t\t);\n\t\t}\n\n\t\textendTemplate( template, normalize( clone( def ) ) );\n\t}\n\n\t/**\n\t * Renders a DOM Node (either an HTML element or text) out of the template.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderNode( data ) {\n\t\tlet isInvalid;\n\n\t\tif ( data.node ) {\n\t\t\t// When applying, a definition cannot have \"tag\" and \"text\" at the same time.\n\t\t\tisInvalid = this.tag && this.text;\n\t\t} else {\n\t\t\t// When rendering, a definition must have either \"tag\" or \"text\": XOR( this.tag, this.text ).\n\t\t\tisInvalid = this.tag ? this.text : !this.text;\n\t\t}\n\n\t\tif ( isInvalid ) {\n\t\t\t/**\n\t\t\t * Node definition cannot have the \"tag\" and \"text\" properties at the same time.\n\t\t\t * Node definition must have either \"tag\" or \"text\" when rendering a new Node.\n\t\t\t *\n\t\t\t * @error ui-template-wrong-syntax\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-wrong-syntax',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tif ( this.text ) {\n\t\t\treturn this._renderText( data );\n\t\t} else {\n\t\t\treturn this._renderElement( data );\n\t\t}\n\t}\n\n\t/**\n\t * Renders an HTML element out of the template.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderElement( data ) {\n\t\tlet node = data.node;\n\n\t\tif ( !node ) {\n\t\t\tnode = data.node = document.createElementNS( this.ns || xhtmlNs, this.tag );\n\t\t}\n\n\t\tthis._renderAttributes( data );\n\t\tthis._renderElementChildren( data );\n\t\tthis._setUpListeners( data );\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Renders a text node out of {@link module:ui/template~Template#text}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderText( data ) {\n\t\tlet node = data.node;\n\n\t\t// Save the original textContent to revert it in #revert().\n\t\tif ( node ) {\n\t\t\tdata.revertData.text = node.textContent;\n\t\t} else {\n\t\t\tnode = data.node = document.createTextNode( '' );\n\t\t}\n\n\t\t// Check if this Text Node is bound to Observable. Cases:\n\t\t//\n\t\t//\t\ttext: [ Template.bind( ... ).to( ... ) ]\n\t\t//\n\t\t//\t\ttext: [\n\t\t//\t\t\t'foo',\n\t\t//\t\t\tTemplate.bind( ... ).to( ... ),\n\t\t//\t\t\t...\n\t\t//\t\t]\n\t\t//\n\t\tif ( hasTemplateBinding( this.text ) ) {\n\t\t\tthis._bindToObservable( {\n\t\t\t\tschema: this.text,\n\t\t\t\tupdater: getTextUpdater( node ),\n\t\t\t\tdata\n\t\t\t} );\n\t\t}\n\t\t// Simply set text. Cases:\n\t\t//\n\t\t//\t\ttext: [ 'all', 'are', 'static' ]\n\t\t//\n\t\t//\t\ttext: [ 'foo' ]\n\t\t//\n\t\telse {\n\t\t\tnode.textContent = this.text.join( '' );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderAttributes( data ) {\n\t\tlet attrName, attrValue, domAttrValue, attrNs;\n\n\t\tif ( !this.attributes ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = data.node;\n\t\tconst revertData = data.revertData;\n\n\t\tfor ( attrName in this.attributes ) {\n\t\t\t// Current attribute value in DOM.\n\t\t\tdomAttrValue = node.getAttribute( attrName );\n\n\t\t\t// The value to be set.\n\t\t\tattrValue = this.attributes[ attrName ];\n\n\t\t\t// Save revert data.\n\t\t\tif ( revertData ) {\n\t\t\t\trevertData.attributes[ attrName ] = domAttrValue;\n\t\t\t}\n\n\t\t\t// Detect custom namespace:\n\t\t\t//\n\t\t\t//\t\tclass: {\n\t\t\t//\t\t\tns: 'abc',\n\t\t\t//\t\t\tvalue: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tattrNs = ( isObject( attrValue[ 0 ] ) && attrValue[ 0 ].ns ) ? attrValue[ 0 ].ns : null;\n\n\t\t\t// Activate binding if one is found. Cases:\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\tTemplate.bind( ... ).to( ... )\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t'bar',\n\t\t\t//\t\t\tTemplate.bind( ... ).to( ... ),\n\t\t\t//\t\t\t'baz'\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\t//\t\tclass: {\n\t\t\t//\t\t\tns: 'abc',\n\t\t\t//\t\t\tvalue: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tif ( hasTemplateBinding( attrValue ) ) {\n\t\t\t\t// Normalize attributes with additional data like namespace:\n\t\t\t\t//\n\t\t\t\t//\t\tclass: {\n\t\t\t\t//\t\t\tns: 'abc',\n\t\t\t\t//\t\t\tvalue: [ ... ]\n\t\t\t\t//\t\t}\n\t\t\t\t//\n\t\t\t\tconst valueToBind = attrNs ? attrValue[ 0 ].value : attrValue;\n\n\t\t\t\t// Extend the original value of attributes like \"style\" and \"class\",\n\t\t\t\t// don't override them.\n\t\t\t\tif ( revertData && shouldExtend( attrName ) ) {\n\t\t\t\t\tvalueToBind.unshift( domAttrValue );\n\t\t\t\t}\n\n\t\t\t\tthis._bindToObservable( {\n\t\t\t\t\tschema: valueToBind,\n\t\t\t\t\tupdater: getAttributeUpdater( node, attrName, attrNs ),\n\t\t\t\t\tdata\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Style attribute could be an Object so it needs to be parsed in a specific way.\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\twidth: '100px',\n\t\t\t//\t\t\theight: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\telse if ( attrName == 'style' && typeof attrValue[ 0 ] !== 'string' ) {\n\t\t\t\tthis._renderStyleAttribute( attrValue[ 0 ], data );\n\t\t\t}\n\n\t\t\t// Otherwise simply set the static attribute:\n\t\t\t//\n\t\t\t//\t\tclass: [ 'foo' ]\n\t\t\t//\n\t\t\t//\t\tclass: [ 'all', 'are', 'static' ]\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t{\n\t\t\t//\t\t\t\tns: 'abc',\n\t\t\t//\t\t\t\tvalue: [ 'foo' ]\n\t\t\t//\t\t\t}\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\telse {\n\t\t\t\t// Extend the original value of attributes like \"style\" and \"class\",\n\t\t\t\t// don't override them.\n\t\t\t\tif ( revertData && domAttrValue && shouldExtend( attrName ) ) {\n\t\t\t\t\tattrValue.unshift( domAttrValue );\n\t\t\t\t}\n\n\t\t\t\tattrValue = attrValue\n\t\t\t\t\t// Retrieve \"values\" from:\n\t\t\t\t\t//\n\t\t\t\t\t//\t\tclass: [\n\t\t\t\t\t//\t\t\t{\n\t\t\t\t\t//\t\t\t\tns: 'abc',\n\t\t\t\t\t//\t\t\t\tvalue: [ ... ]\n\t\t\t\t\t//\t\t\t}\n\t\t\t\t\t//\t\t]\n\t\t\t\t\t//\n\t\t\t\t\t.map( val => val ? ( val.value || val ) : val )\n\t\t\t\t\t// Flatten the array.\n\t\t\t\t\t.reduce( ( prev, next ) => prev.concat( next ), [] )\n\t\t\t\t\t// Convert into string.\n\t\t\t\t\t.reduce( arrayValueReducer, '' );\n\n\t\t\t\tif ( !isFalsy( attrValue ) ) {\n\t\t\t\t\tnode.setAttributeNS( attrNs, attrName, attrValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders the `style` attribute of an HTML element based on\n\t * {@link module:ui/template~Template#attributes}.\n\t *\n\t * A style attribute is an {Object} with static values:\n\t *\n\t *\t\tattributes: {\n\t *\t\t\tstyle: {\n\t *\t\t\t\tcolor: 'red'\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * or values bound to {@link module:ui/model~Model} properties:\n\t *\n\t *\t\tattributes: {\n\t *\t\t\tstyle: {\n\t *\t\t\t\tcolor: bind.to( ... )\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be\n\t * needed.\n\t *\n\t * @private\n\t * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderStyleAttribute( styles, data ) {\n\t\tconst node = data.node;\n\n\t\tfor ( const styleName in styles ) {\n\t\t\tconst styleValue = styles[ styleName ];\n\n\t\t\t// Cases:\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\tcolor: bind.to( 'attribute' )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tif ( hasTemplateBinding( styleValue ) ) {\n\t\t\t\tthis._bindToObservable( {\n\t\t\t\t\tschema: [ styleValue ],\n\t\t\t\t\tupdater: getStyleUpdater( node, styleName ),\n\t\t\t\t\tdata\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Cases:\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\tcolor: 'red'\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\telse {\n\t\t\t\tnode.style[ styleName ] = styleValue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderElementChildren( data ) {\n\t\tconst node = data.node;\n\t\tconst container = data.intoFragment ? document.createDocumentFragment() : node;\n\t\tconst isApplying = data.isApplying;\n\t\tlet childIndex = 0;\n\n\t\tfor ( const child of this.children ) {\n\t\t\tif ( isViewCollection( child ) ) {\n\t\t\t\tif ( !isApplying ) {\n\t\t\t\t\tchild.setParent( node );\n\n\t\t\t\t\t// Note: ViewCollection renders its children.\n\t\t\t\t\tfor ( const view of child ) {\n\t\t\t\t\t\tcontainer.appendChild( view.element );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( isView( child ) ) {\n\t\t\t\tif ( !isApplying ) {\n\t\t\t\t\tif ( !child.isRendered ) {\n\t\t\t\t\t\tchild.render();\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer.appendChild( child.element );\n\t\t\t\t}\n\t\t\t} else if ( isNode( child ) ) {\n\t\t\t\tcontainer.appendChild( child );\n\t\t\t} else {\n\t\t\t\tif ( isApplying ) {\n\t\t\t\t\tconst revertData = data.revertData;\n\t\t\t\t\tconst childRevertData = getEmptyRevertData();\n\n\t\t\t\t\trevertData.children.push( childRevertData );\n\n\t\t\t\t\tchild._renderNode( {\n\t\t\t\t\t\tnode: container.childNodes[ childIndex++ ],\n\t\t\t\t\t\tisApplying: true,\n\t\t\t\t\t\trevertData: childRevertData\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\tcontainer.appendChild( child.render() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( data.intoFragment ) {\n\t\t\tnode.appendChild( container );\n\t\t}\n\t}\n\n\t/**\n\t * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}\n\t * on an HTML element.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_setUpListeners( data ) {\n\t\tif ( !this.eventListeners ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const key in this.eventListeners ) {\n\t\t\tconst revertBindings = this.eventListeners[ key ].map( schemaItem => {\n\t\t\t\tconst [ domEvtName, domSelector ] = key.split( '@' );\n\n\t\t\t\treturn schemaItem.activateDomEventListener( domEvtName, domSelector, data );\n\t\t\t} );\n\n\t\t\tif ( data.revertData ) {\n\t\t\t\tdata.revertData.bindings.push( revertBindings );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}\n\t * activates the binding and sets its initial value.\n\t *\n\t * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or\n\t * text node `textContent`.\n\t *\n\t * @protected\n\t * @param {Object} options Binding options.\n\t * @param {module:ui/template~TemplateValueSchema} options.schema\n\t * @param {Function} options.updater A function which updates the DOM (like attribute or text).\n\t * @param {module:ui/template~RenderData} options.data Rendering data.\n\t */\n\t_bindToObservable( { schema, updater, data } ) {\n\t\tconst revertData = data.revertData;\n\n\t\t// Set initial values.\n\t\tsyncValueSchemaValue( schema, updater, data );\n\n\t\tconst revertBindings = schema\n\t\t\t// Filter \"falsy\" (false, undefined, null, '') value schema components out.\n\t\t\t.filter( item => !isFalsy( item ) )\n\t\t\t// Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.\n\t\t\t.filter( item => item.observable )\n\t\t\t// Once only the actual binding are left, let the emitter listen to observable change:attribute event.\n\t\t\t// TODO: Reduce the number of listeners attached as many bindings may listen\n\t\t\t// to the same observable attribute.\n\t\t\t.map( templateBinding => templateBinding.activateAttributeListener( schema, updater, data ) );\n\n\t\tif ( revertData ) {\n\t\t\trevertData.bindings.push( revertBindings );\n\t\t}\n\t}\n\n\t/**\n\t * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to\n\t * return it to the original state.\n\t *\n\t * @protected\n\t * @param {HTMLElement|Text} node A node to be reverted.\n\t * @param {Object} revertData An object that stores information about what changes have been made by\n\t * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.\n\t */\n\t_revertTemplateFromNode( node, revertData ) {\n\t\tfor ( const binding of revertData.bindings ) {\n\t\t\t// Each binding may consist of several observable+observable#attribute.\n\t\t\t// like the following has 2:\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t'x',\n\t\t\t//\t\t\tbind.to( 'foo' ),\n\t\t\t//\t\t\t'y',\n\t\t\t//\t\t\tbind.to( 'bar' )\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\tfor ( const revertBinding of binding ) {\n\t\t\t\trevertBinding();\n\t\t\t}\n\t\t}\n\n\t\tif ( revertData.text ) {\n\t\t\tnode.textContent = revertData.text;\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const attrName in revertData.attributes ) {\n\t\t\tconst attrValue = revertData.attributes[ attrName ];\n\n\t\t\t// When the attribute has **not** been set before #apply().\n\t\t\tif ( attrValue === null ) {\n\t\t\t\tnode.removeAttribute( attrName );\n\t\t\t} else {\n\t\t\t\tnode.setAttribute( attrName, attrValue );\n\t\t\t}\n\t\t}\n\n\t\tfor ( let i = 0; i < revertData.children.length; ++i ) {\n\t\t\tthis._revertTemplateFromNode( node.childNodes[ i ], revertData.children[ i ] );\n\t\t}\n\t}\n}\n\nmix( Template, EmitterMixin );\n\n/**\n * Describes a binding created by the {@link module:ui/template~Template.bind} interface.\n *\n * @protected\n */\nexport class TemplateBinding {\n\t/**\n\t * Creates an instance of the {@link module:ui/template~TemplateBinding} class.\n\t *\n\t * @param {module:ui/template~TemplateDefinition} def The definition of the binding.\n\t */\n\tconstructor( def ) {\n\t\tObject.assign( this, def );\n\n\t\t/**\n\t\t * An observable instance of the binding. It either:\n\t\t *\n\t\t * * provides the attribute with the value,\n\t\t * * or passes the event when a corresponding DOM event is fired.\n\t\t *\n\t\t * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable\n\t\t */\n\n\t\t/**\n\t\t * An {@link module:utils/emittermixin~Emitter} used by the binding to:\n\t\t *\n\t\t * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},\n\t\t * * or listen to the event in the DOM.\n\t\t *\n\t\t * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter\n\t\t */\n\n\t\t/**\n\t\t * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.\n\t\t *\n\t\t * @member {String} module:ui/template~TemplateBinding#attribute\n\t\t */\n\n\t\t/**\n\t\t * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.\n\t\t *\n\t\t * @member {Function} [module:ui/template~TemplateBinding#callback]\n\t\t */\n\t}\n\n\t/**\n\t * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the\n\t * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.\n\t *\n\t * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.\n\t * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}.\n\t */\n\tgetValue( node ) {\n\t\tconst value = this.observable[ this.attribute ];\n\n\t\treturn this.callback ? this.callback( value, node ) : value;\n\t}\n\n\t/**\n\t * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated\n\t * value of {@link module:ui/template~TemplateValueSchema}.\n\t *\n\t * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.\n\t * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t * @returns {Function} A function to sever the listener binding.\n\t */\n\tactivateAttributeListener( schema, updater, data ) {\n\t\tconst callback = () => syncValueSchemaValue( schema, updater, data );\n\n\t\tthis.emitter.listenTo( this.observable, 'change:' + this.attribute, callback );\n\n\t\t// Allows revert of the listener.\n\t\treturn () => {\n\t\t\tthis.emitter.stopListening( this.observable, 'change:' + this.attribute, callback );\n\t\t};\n\t}\n}\n\n/**\n * Describes either:\n *\n * * a binding to an {@link module:utils/observablemixin~Observable},\n * * or a native DOM event binding.\n *\n * It is created by the {@link module:ui/template~BindChain#to} method.\n *\n * @protected\n */\nexport class TemplateToBinding extends TemplateBinding {\n\t/**\n\t * Activates the listener for the native DOM event, which when fired, is propagated by\n\t * the {@link module:ui/template~TemplateBinding#emitter}.\n\t *\n\t * @param {String} domEvtName The name of the native DOM event.\n\t * @param {String} domSelector The selector in the DOM to filter delegated events.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t * @returns {Function} A function to sever the listener binding.\n\t */\n\tactivateDomEventListener( domEvtName, domSelector, data ) {\n\t\tconst callback = ( evt, domEvt ) => {\n\t\t\tif ( !domSelector || domEvt.target.matches( domSelector ) ) {\n\t\t\t\tif ( typeof this.eventNameOrFunction == 'function' ) {\n\t\t\t\t\tthis.eventNameOrFunction( domEvt );\n\t\t\t\t} else {\n\t\t\t\t\tthis.observable.fire( this.eventNameOrFunction, domEvt );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.emitter.listenTo( data.node, domEvtName, callback );\n\n\t\t// Allows revert of the listener.\n\t\treturn () => {\n\t\t\tthis.emitter.stopListening( data.node, domEvtName, callback );\n\t\t};\n\t}\n}\n\n/**\n * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}\n * method.\n *\n * @protected\n */\nexport class TemplateIfBinding extends TemplateBinding {\n\t/**\n\t * @inheritDoc\n\t */\n\tgetValue( node ) {\n\t\tconst value = super.getValue( node );\n\n\t\treturn isFalsy( value ) ? false : ( this.valueIfTrue || true );\n\t}\n\n\t/**\n\t * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable} is `true`.\n\t *\n\t * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]\n\t */\n}\n\n// Checks whether given {@link module:ui/template~TemplateValueSchema} contains a\n// {@link module:ui/template~TemplateBinding}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @returns {Boolean}\nfunction hasTemplateBinding( schema ) {\n\tif ( !schema ) {\n\t\treturn false;\n\t}\n\n\t// Normalize attributes with additional data like namespace:\n\t//\n\t//\t\tclass: {\n\t//\t\t\tns: 'abc',\n\t//\t\t\tvalue: [ ... ]\n\t//\t\t}\n\t//\n\tif ( schema.value ) {\n\t\tschema = schema.value;\n\t}\n\n\tif ( Array.isArray( schema ) ) {\n\t\treturn schema.some( hasTemplateBinding );\n\t} else if ( schema instanceof TemplateBinding ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of\n// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}\n// items.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n// @returns {Array}\nfunction getValueSchemaValue( schema, node ) {\n\treturn schema.map( schemaItem => {\n\t\t// Process {@link module:ui/template~TemplateBinding} bindings.\n\t\tif ( schemaItem instanceof TemplateBinding ) {\n\t\t\treturn schemaItem.getValue( node );\n\t\t}\n\n\t\t// All static values like strings, numbers, and \"falsy\" values (false, null, undefined, '', etc.) just pass.\n\t\treturn schemaItem;\n\t} );\n}\n\n// A function executed each time the bound Observable attribute changes, which updates the DOM with a value\n// constructed from {@link module:ui/template~TemplateValueSchema}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Function} updater A function which updates the DOM (like attribute or text).\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\nfunction syncValueSchemaValue( schema, updater, { node } ) {\n\tlet value = getValueSchemaValue( schema, node );\n\n\t// Check if schema is a single Template.bind.if, like:\n\t//\n\t//\t\tclass: Template.bind.if( 'foo' )\n\t//\n\tif ( schema.length == 1 && schema[ 0 ] instanceof TemplateIfBinding ) {\n\t\tvalue = value[ 0 ];\n\t} else {\n\t\tvalue = value.reduce( arrayValueReducer, '' );\n\t}\n\n\tif ( isFalsy( value ) ) {\n\t\tupdater.remove();\n\t} else {\n\t\tupdater.set( value );\n\t}\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset `textContent`.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @returns {Object}\nfunction getTextUpdater( node ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tnode.textContent = value;\n\t\t},\n\n\t\tremove() {\n\t\t\tnode.textContent = '';\n\t\t}\n\t};\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset an attribute.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} attrName Name of the attribute to be modified.\n// @param {String} [ns=null] Namespace to use.\n// @returns {Object}\nfunction getAttributeUpdater( el, attrName, ns ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tel.setAttributeNS( ns, attrName, value );\n\t\t},\n\n\t\tremove() {\n\t\t\tel.removeAttributeNS( ns, attrName );\n\t\t}\n\t};\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of CSSStyleDeclaration to set or remove a style.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} styleName Name of the style to be modified.\n// @returns {Object}\nfunction getStyleUpdater( el, styleName ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tel.style[ styleName ] = value;\n\t\t},\n\n\t\tremove() {\n\t\t\tel.style[ styleName ] = null;\n\t\t}\n\t};\n}\n\n// Clones definition of the template.\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition}\nfunction clone( def ) {\n\tconst clone = cloneDeepWith( def, value => {\n\t\t// Don't clone the `Template.bind`* bindings because of the references to Observable\n\t\t// and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy\n\t\t// cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins\n\t\t// along with the definition.\n\t\t//\n\t\t// Don't clone Template instances if provided as a child. They're simply #render()ed\n\t\t// and nothing should interfere.\n\t\t//\n\t\t// Also don't clone View instances if provided as a child of the Template. The template\n\t\t// instance will be extracted from the View during the normalization and there's no need\n\t\t// to clone it.\n\t\tif ( value && ( value instanceof TemplateBinding || isTemplate( value ) || isView( value ) || isViewCollection( value ) ) ) {\n\t\t\treturn value;\n\t\t}\n\t} );\n\n\treturn clone;\n}\n\n// Normalizes given {@link module:ui/template~TemplateDefinition}.\n//\n// See:\n//  * {@link normalizeAttributes}\n//  * {@link normalizeListeners}\n//  * {@link normalizePlainTextDefinition}\n//  * {@link normalizeTextDefinition}\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition} Normalized definition.\nfunction normalize( def ) {\n\tif ( typeof def == 'string' ) {\n\t\tdef = normalizePlainTextDefinition( def );\n\t} else if ( def.text ) {\n\t\tnormalizeTextDefinition( def );\n\t}\n\n\tif ( def.on ) {\n\t\tdef.eventListeners = normalizeListeners( def.on );\n\n\t\t// Template mixes EmitterMixin, so delete #on to avoid collision.\n\t\tdelete def.on;\n\t}\n\n\tif ( !def.text ) {\n\t\tif ( def.attributes ) {\n\t\t\tnormalizeAttributes( def.attributes );\n\t\t}\n\n\t\tconst children = [];\n\n\t\tif ( def.children ) {\n\t\t\tif ( isViewCollection( def.children ) ) {\n\t\t\t\tchildren.push( def.children );\n\t\t\t} else {\n\t\t\t\tfor ( const child of def.children ) {\n\t\t\t\t\tif ( isTemplate( child ) || isView( child ) || isNode( child ) ) {\n\t\t\t\t\t\tchildren.push( child );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildren.push( new Template( child ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdef.children = children;\n\t}\n\n\treturn def;\n}\n\n// Normalizes \"attributes\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tattributes: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: {\n//\t\t\t\tvalue: 'bar'\n//\t\t\t}\n//\t\t}\n//\n// becomes\n//\n//\t\tattributes: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: {\n//\t\t\t\tvalue: [ 'bar' ]\n//\t\t\t}\n//\t\t}\n//\n// @param {Object} attributes\nfunction normalizeAttributes( attributes ) {\n\tfor ( const a in attributes ) {\n\t\tif ( attributes[ a ].value ) {\n\t\t\tattributes[ a ].value = toArray( attributes[ a ].value );\n\t\t}\n\n\t\tarrayify( attributes, a );\n\t}\n}\n\n// Normalizes \"on\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\ton: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// becomes\n//\n//\t\ton: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// @param {Object} listeners\n// @returns {Object} Object containing normalized listeners.\nfunction normalizeListeners( listeners ) {\n\tfor ( const l in listeners ) {\n\t\tarrayify( listeners, l );\n\t}\n\n\treturn listeners;\n}\n\n// Normalizes \"string\" {@link module:ui/template~TemplateDefinition}.\n//\n//\t\t\"foo\"\n//\n// becomes\n//\n//\t\t{ text: [ 'foo' ] },\n//\n// @param {String} def\n// @returns {module:ui/template~TemplateDefinition} Normalized template definition.\nfunction normalizePlainTextDefinition( def ) {\n\treturn {\n\t\ttext: [ def ]\n\t};\n}\n\n// Normalizes text {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tchildren: [\n//\t\t\t{ text: 'def' },\n//\t\t\t{ text: {@link module:ui/template~TemplateBinding} }\n//\t\t]\n//\n// becomes\n//\n//\t\tchildren: [\n//\t\t\t{ text: [ 'def' ] },\n//\t\t\t{ text: [ {@link module:ui/template~TemplateBinding} ] }\n//\t\t]\n//\n// @param {module:ui/template~TemplateDefinition} def\nfunction normalizeTextDefinition( def ) {\n\tdef.text = toArray( def.text );\n}\n\n// Wraps an entry in Object in an Array, if not already one.\n//\n//\t\t{\n//\t\t\tx: 'y',\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// becomes\n//\n//\t\t{\n//\t\t\tx: [ 'y' ],\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// @param {Object} obj\n// @param {String} key\nfunction arrayify( obj, key ) {\n\tobj[ key ] = toArray( obj[ key ] );\n}\n\n// A helper which concatenates the value avoiding unwanted\n// leading white spaces.\n//\n// @param {String} prev\n// @param {String} cur\n// @returns {String}\nfunction arrayValueReducer( prev, cur ) {\n\tif ( isFalsy( cur ) ) {\n\t\treturn prev;\n\t} else if ( isFalsy( prev ) ) {\n\t\treturn cur;\n\t} else {\n\t\treturn `${ prev } ${ cur }`;\n\t}\n}\n\n// Extends one object defined in the following format:\n//\n//\t\t{\n//\t\t\tkey1: [Array1],\n//\t\t\tkey2: [Array2],\n//\t\t\t...\n//\t\t\tkeyN: [ArrayN]\n//\t\t}\n//\n// with another object of the same data format.\n//\n// @param {Object} obj Base object.\n// @param {Object} ext Object extending base.\n// @returns {String}\nfunction extendObjectValueArray( obj, ext ) {\n\tfor ( const a in ext ) {\n\t\tif ( obj[ a ] ) {\n\t\t\tobj[ a ].push( ...ext[ a ] );\n\t\t} else {\n\t\t\tobj[ a ] = ext[ a ];\n\t\t}\n\t}\n}\n\n// A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance\n// with content from {@link module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.\n//\n// @param {module:ui/template~Template} def A template instance to be extended.\n// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.\n// @param {Object} Error context.\nfunction extendTemplate( template, def ) {\n\tif ( def.attributes ) {\n\t\tif ( !template.attributes ) {\n\t\t\ttemplate.attributes = {};\n\t\t}\n\n\t\textendObjectValueArray( template.attributes, def.attributes );\n\t}\n\n\tif ( def.eventListeners ) {\n\t\tif ( !template.eventListeners ) {\n\t\t\ttemplate.eventListeners = {};\n\t\t}\n\n\t\textendObjectValueArray( template.eventListeners, def.eventListeners );\n\t}\n\n\tif ( def.text ) {\n\t\ttemplate.text.push( ...def.text );\n\t}\n\n\tif ( def.children && def.children.length ) {\n\t\tif ( template.children.length != def.children.length ) {\n\t\t\t/**\n\t\t\t * The number of children in extended definition does not match.\n\t\t\t *\n\t\t\t * @error ui-template-extend-children-mismatch\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-extend-children-mismatch',\n\t\t\t\ttemplate\n\t\t\t);\n\t\t}\n\n\t\tlet childIndex = 0;\n\n\t\tfor ( const childDef of def.children ) {\n\t\t\textendTemplate( template.children[ childIndex++ ], childDef );\n\t\t}\n\t}\n}\n\n// Checks if value is \"falsy\".\n// Note: 0 (Number) is not \"falsy\" in this context.\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isFalsy( value ) {\n\treturn !value && value !== 0;\n}\n\n// Checks if the item is an instance of {@link module:ui/view~View}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isView( item ) {\n\treturn item instanceof View;\n}\n\n// Checks if the item is an instance of {@link module:ui/template~Template}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isTemplate( item ) {\n\treturn item instanceof Template;\n}\n\n// Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isViewCollection( item ) {\n\treturn item instanceof ViewCollection;\n}\n\n// Creates an empty skeleton for {@link module:ui/template~Template#revert}\n// data.\n//\n// @private\nfunction getEmptyRevertData() {\n\treturn {\n\t\tchildren: [],\n\t\tbindings: [],\n\t\tattributes: {}\n\t};\n}\n\n// Checks whether an attribute should be extended when\n// {@link module:ui/template~Template#apply} is called.\n//\n// @private\n// @param {String} attrName Attribute name to check.\nfunction shouldExtend( attrName ) {\n\treturn attrName == 'class' || attrName == 'style';\n}\n\n/**\n * A definition of the {@link module:ui/template~Template}. It describes what kind of\n * node a template will render (HTML element or text), attributes of an element, DOM event\n * listeners and children.\n *\n * Also see:\n * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,\n * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.\n *\n * A sample definition on an HTML element can look like this:\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\ttag: 'span',\n *\t\t\t\t\tattributes: { ... },\n *\t\t\t\t\tchildren: [ ... ],\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\ttext: 'staticâ€“text'\n *\t\t\t\t},\n *\t\t\t\t'also-staticâ€“text',\n *\t\t\t],\n *\t\t\tattributes: {\n *\t\t\t\tclass: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tid: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tstyle: {@link module:ui/template~TemplateValueSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\t'click': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// Document.querySelector format is also accepted.\n *\t\t\t\t'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t}\n *\t\t} );\n *\n * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node\n * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:\n *\n *\t\tconst view = new SomeView();\n *\t\tconst childTemplate = new Template( { ... } );\n *\t\tconst childNode = document.createElement( 'b' );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: [\n *\t\t\t\t// view#element will be added as a child of this <p>.\n *\t\t\t\tview,\n *\n * \t\t\t\t// The output of childTemplate.render() will be added here.\n *\t\t\t\tchildTemplate,\n *\n *\t\t\t\t// Native DOM nodes are included directly in the rendered output.\n *\t\t\t\tchildNode\n *\t\t\t]\n *\t\t} );\n *\n * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:\n *\n *\t\tconst collection = new ViewCollection();\n *\t\tcollection.add( someView );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: collection\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateDefinition\n * @type Object\n *\n * @property {String} tag See the template {@link module:ui/template~Template#tag} property.\n *\n * @property {Array.<module:ui/template~TemplateDefinition>} [children]\n * See the template {@link module:ui/template~Template#children} property.\n *\n * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]\n * See the template {@link module:ui/template~Template#attributes} property.\n *\n * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]\n * See the template {@link module:ui/template~Template#text} property.\n *\n * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]\n * See the template {@link module:ui/template~Template#eventListeners} property.\n */\n\n/**\n * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple\n * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn where to use it,\n * * {@link module:ui/template~Template.bind} to learn how to configure\n * {@link module:utils/observablemixin~Observable} attribute bindings,\n * * {@link module:ui/template~Template#render} to learn how to render a template,\n * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}\n * methods to learn more about bindings.\n *\n * Attribute values can be described in many different ways:\n *\n *\t\t// Bind helper will create bindings to attributes of the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// A plain string schema.\n *\t\t\t\t'class': 'static-text',\n *\n *\t\t\t\t// An object schema, binds to the \"foo\" attribute of the\n *\t\t\t\t// observable and follows its value.\n *\t\t\t\t'class': bind.to( 'foo' ),\n *\n *\t\t\t\t// An array schema, combines the above.\n *\t\t\t\t'class': [\n *\t\t\t\t\t'static-text',\n *\t\t\t\t\tbind.to( 'bar', () => { ... } ),\n *\n * \t\t\t\t\t// Bindings can also be conditional.\n *\t\t\t\t\tbind.if( 'baz', 'class-when-baz-is-true' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema, with a custom namespace, e.g. useful for creating SVGs.\n *\t\t\t\t'class': {\n *\t\t\t\t\tns: 'http://ns.url',\n *\t\t\t\t\tvalue: [\n *\t\t\t\t\t\tbind.if( 'baz', 'value-when-true' ),\n *\t\t\t\t\t\t'static-text'\n *\t\t\t\t\t]\n *\t\t\t\t},\n *\n *\t\t\t\t// An object schema, specific for styles.\n *\t\t\t\tstyle: {\n *\t\t\t\t\tcolor: 'red',\n *\t\t\t\t\tbackgroundColor: bind.to( 'qux', () => { ... } )\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * Text nodes can also have complex values:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\t// Will render a \"foo\" text node.\n *\t\tnew Template( {\n *\t\t\ttext: 'foo'\n *\t\t} );\n *\n *\t\t// Will render a \"static text: {observable.foo}\" text node.\n *\t\t// The text of the node will be updated as the \"foo\" attribute changes.\n *\t\tnew Template( {\n *\t\t\ttext: [\n *\t\t\t\t'static text: ',\n *\t\t\t\tbind.to( 'foo', () => { ... } )\n *\t\t\t]\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateValueSchema\n * @type {Object|String|Array}\n */\n\n/**\n * Describes an event listener attached to an HTML element. Such listener can propagate DOM events\n * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks\n * or both, if necessary.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,\n * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.\n *\n * Check out different ways of attaching event listeners below:\n *\n *\t\t// Bind helper will propagate events through the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\ton: {\n *\t\t\t\t// An object schema. The observable will fire the \"clicked\" event upon DOM \"click\".\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\n *\t\t\t\t// An object schema. It will work for \"click\" event on \"a.foo\" children only.\n *\t\t\t\t'click@a.foo': bind.to( 'clicked' )\n *\n *\t\t\t\t// An array schema, makes the observable propagate multiple events.\n *\t\t\t\tclick: [\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( 'executed' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema with a custom callback.\n *\t\t\t\t'click@a.foo': {\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( evt => {\n *\t\t\t\t\t\tconsole.log( `${ evt.target } has been clicked!` );\n *\t\t\t\t\t} }\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateListenerSchema\n * @type {Object|String|Array}\n */\n\n/**\n * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`\n * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.\n *\n * @interface module:ui/template~BindChain\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to either:\n *\n * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable\n * attribute as it changes,\n * * or an HTML element DOM event, so the DOM events are propagated through an observable.\n *\n * Some common use cases of `to()` bindings are presented below:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// class=\"...\" attribute gets bound to `observable#a`\n *\t\t\t\tclass: bind.to( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t// <p>...</p> gets bound to observable#b; always `toUpperCase()`.\n *\t\t\t\t{\n *\t\t\t\t\ttext: bind.to( 'b', ( value, node ) => value.toUpperCase() )\n *\t\t\t\t}\n *\t\t\t],\n *\t\t\ton: {\n *\t\t\t\tclick: [\n *\t\t\t\t\t// An observable will fire \"clicked\" upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\n *\t\t\t\t\t// A custom callback will be executed upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( () => {\n *\t\t\t\t\t\t...\n *\t\t\t\t\t} )\n *\t\t\t\t]\n *\t\t\t}\n *\t\t} ).render();\n *\n * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and\n * {@link module:ui/template~TemplateListenerSchema}.\n *\n * @method #to\n * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of\n * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text\n * node `textContent` so it remains in sync with the observable attribute as it changes.\n *\n * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`\n * depending on the \"falseness\" of an {@link module:utils/observablemixin~Observable} attribute.\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'input',\n *\t\t\tattributes: {\n *\t\t\t\t// <input checked> when `observable#a` is not undefined/null/false/''\n *\t\t\t\t// <input> when `observable#a` is undefined/null/false\n *\t\t\t\tchecked: bind.if( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\t// <input>\"b-is-not-set\"</input> when `observable#b` is undefined/null/false/''\n *\t\t\t\t\t// <input></input> when `observable#b` is not \"falsy\"\n *\t\t\t\t\ttext: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )\n *\t\t\t\t}\n *\t\t\t]\n *\t\t} ).render();\n *\n * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.\n *\n * @method #if\n * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.\n * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not\n * undefined/null/false/'' (empty string).\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * The {@link module:ui/template~Template#_renderNode} configuration.\n *\n * @private\n * @interface module:ui/template~RenderData\n */\n\n/**\n * Tells {@link module:ui/template~Template#_renderNode} to render\n * children into `DocumentFragment` first and then append the fragment\n * to the parent element. It is a speed optimization.\n *\n * @member {Boolean} #intoFragment\n */\n\n/**\n * A node which is being rendered.\n *\n * @member {HTMLElement|Text} #node\n */\n\n/**\n * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has\n * been provided by {@module:ui/template~Template#apply}.\n *\n * @member {Boolean} #isApplying\n */\n\n/**\n * An object storing the data that helps {@module:ui/template~Template#revert}\n * bringing back an element to its initial state, i.e. before\n * {@module:ui/template~Template#apply} was called.\n *\n * @member {Object} #revertData\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAOA,aAAa,MAAM,6CAA6C;AACvE,OAAOC,GAAG,MAAM,mCAAmC;AACnD,OAAOC,YAAY,MAAM,4CAA4C;AACrE,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,cAAc,MAAM,kBAAkB;AAC7C,OAAOC,MAAM,MAAM,0CAA0C;AAC7D,SAASC,QAAQ,EAAEC,aAAa,QAAQ,WAAW;AACnD,OAAOC,OAAO,MAAM,uCAAuC;AAE3D,MAAMC,OAAO,GAAG,8BAA8B;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,QAAQ,CAAC;EAC7B;AACD;AACA;AACA;AACA;EACCC,WAAW,CAAEC,GAAG,EAAG;IAClBC,MAAM,CAACC,MAAM,CAAE,IAAI,EAAEC,SAAS,CAAEC,KAAK,CAAEJ,GAAG,CAAE,CAAE,CAAE;;IAEhD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACK,WAAW,GAAG,KAAK;;IAExB;AACF;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,IAAI;EACxB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,MAAM,GAAG;IACR,MAAMC,IAAI,GAAG,IAAI,CAACC,WAAW,CAAE;MAC9BC,YAAY,EAAE;IACf,CAAC,CAAE;IAEH,IAAI,CAACL,WAAW,GAAG,IAAI;IAEvB,OAAOG,IAAI;EACZ;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCG,KAAK,CAAEH,IAAI,EAAG;IACb,IAAI,CAACF,WAAW,GAAGM,kBAAkB,EAAE;IAEvC,IAAI,CAACH,WAAW,CAAE;MACjBD,IAAI;MACJK,UAAU,EAAE,IAAI;MAChBC,UAAU,EAAE,IAAI,CAACR;IAClB,CAAC,CAAE;IAEH,OAAOE,IAAI;EACZ;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCO,MAAM,CAAEP,IAAI,EAAG;IACd,IAAK,CAAC,IAAI,CAACF,WAAW,EAAG;MACxB;AACH;AACA;AACA;AACA;MACG,MAAM,IAAIlB,aAAa,CACtB,gCAAgC,EAChC,CAAE,IAAI,EAAEoB,IAAI,CAAE,CACd;IACF;IAEA,IAAI,CAACQ,uBAAuB,CAAER,IAAI,EAAE,IAAI,CAACF,WAAW,CAAE;EACvD;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,CAAEW,QAAQ,GAAG;IACZ,UAAUC,MAAM,CAAElB,GAAG,EAAG;MACvB,IAAKA,GAAG,CAACmB,QAAQ,EAAG;QACnB,KAAM,MAAMC,KAAK,IAAIpB,GAAG,CAACmB,QAAQ,EAAG;UACnC,IAAKE,MAAM,CAAED,KAAK,CAAE,EAAG;YACtB,MAAMA,KAAK;UACZ,CAAC,MAAM,IAAKE,UAAU,CAAEF,KAAK,CAAE,EAAG;YACjC,OAAOF,MAAM,CAAEE,KAAK,CAAE;UACvB;QACD;MACD;IACD;IAEA,OAAOF,MAAM,CAAE,IAAI,CAAE;EACtB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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A;AACA;AACA,SAAS+B,UAAU,CAAEqF,IAAI,EAAG;EAC3B,OAAOA,IAAI,YAAY7G,QAAQ;AAChC;;AAEA;AACA;AACA;AACA;AACA,SAASyF,gBAAgB,CAAEoB,IAAI,EAAG;EACjC,OAAOA,IAAI,YAAYnH,cAAc;AACtC;;AAEA;AACA;AACA;AACA;AACA,SAASoB,kBAAkB,GAAG;EAC7B,OAAO;IACNO,QAAQ,EAAE,EAAE;IACZqF,QAAQ,EAAE,EAAE;IACZ1C,UAAU,EAAE,CAAC;EACd,CAAC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASI,YAAY,CAAER,QAAQ,EAAG;EACjC,OAAOA,QAAQ,IAAI,OAAO,IAAIA,QAAQ,IAAI,OAAO;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}