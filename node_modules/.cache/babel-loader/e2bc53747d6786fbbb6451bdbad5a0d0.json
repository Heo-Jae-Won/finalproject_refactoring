{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injectunsafekeystrokeshandling\n */\n\nimport { getCode } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { isShiftDeleteOnNonCollapsedSelection } from './utils';\n\n/**\n * Handles keystrokes which are unsafe for typing. This handler's logic is explained\n * in https://github.com/ckeditor/ckeditor5-typing/issues/83#issuecomment-398690251.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport default function injectUnsafeKeystrokesHandling(editor) {\n  let latestCompositionSelection = null;\n  const model = editor.model;\n  const view = editor.editing.view;\n  const inputCommand = editor.commands.get('input');\n\n  // For Android, we want to handle keystrokes on `beforeinput` to be sure that code in `DeleteObserver` already had a chance to be fired.\n  if (env.isAndroid) {\n    view.document.on('beforeinput', (evt, evtData) => handleUnsafeKeystroke(evtData), {\n      priority: 'lowest'\n    });\n  } else {\n    view.document.on('keydown', (evt, evtData) => handleUnsafeKeystroke(evtData), {\n      priority: 'lowest'\n    });\n  }\n  view.document.on('compositionstart', handleCompositionStart, {\n    priority: 'lowest'\n  });\n  view.document.on('compositionend', () => {\n    latestCompositionSelection = model.createSelection(model.document.selection);\n  }, {\n    priority: 'lowest'\n  });\n\n  // Handles the keydown event. We need to guess whether such keystroke is going to result\n  // in typing. If so, then before character insertion happens, any selected content needs\n  // to be deleted. Otherwise the default browser deletion mechanism would be\n  // triggered, resulting in:\n  //\n  // * Hundreds of mutations which could not be handled.\n  // * But most importantly, loss of control over how the content is being deleted.\n  //\n  // The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)\n  // to handle the event.\n  //\n  // @param {module:engine/view/observer/keyobserver~KeyEventData} evtData\n  function handleUnsafeKeystroke(evtData) {\n    // Do not delete the content, if Shift + Delete key combination was pressed on a non-collapsed selection on Windows.\n    //\n    // The Shift + Delete key combination should work in the same way as the `cut` event on a non-collapsed selection on Windows.\n    // In fact, the native `cut` event is actually emitted in this case, but with lower priority. Therefore, in order to handle the\n    // Shift + Delete key combination correctly, it is enough to prevent the content deletion here.\n    if (env.isWindows && isShiftDeleteOnNonCollapsedSelection(evtData, view.document)) {\n      return;\n    }\n    const doc = model.document;\n    const isComposing = view.document.isComposing;\n    const isSelectionUnchanged = latestCompositionSelection && latestCompositionSelection.isEqual(doc.selection);\n\n    // Reset stored composition selection.\n    latestCompositionSelection = null;\n\n    // By relying on the state of the input command we allow disabling the entire input easily\n    // by just disabling the input command. We could’ve used here the delete command but that\n    // would mean requiring the delete feature which would block loading one without the other.\n    // We could also check the editor.isReadOnly property, but that wouldn't allow to block\n    // the input without blocking other features.\n    if (!inputCommand.isEnabled) {\n      return;\n    }\n    if (isNonTypingKeystroke(evtData) || doc.selection.isCollapsed) {\n      return;\n    }\n\n    // If during composition, deletion should be prevented as it may remove composed sequence (#83).\n    if (isComposing && evtData.keyCode === 229) {\n      return;\n    }\n\n    // If there is a `keydown` event fired with '229' keycode it might be related\n    // to recent composition. Check if selection is the same as upon ending recent composition,\n    // if so do not remove selected content as it will remove composed sequence (#83).\n    if (!isComposing && evtData.keyCode === 229 && isSelectionUnchanged) {\n      return;\n    }\n    deleteSelectionContent();\n  }\n\n  // Handles the `compositionstart` event. It is used only in special cases to remove the contents\n  // of a non-collapsed selection so composition itself does not result in complex mutations.\n  //\n  // The special case mentioned above is a situation in which the `keydown` event is fired after\n  // `compositionstart` event. In such cases {@link #handleKeydown} cannot clear current selection\n  // contents (because it is too late and will break the composition) so the composition handler takes care of it.\n  function handleCompositionStart() {\n    const doc = model.document;\n    const isFlatSelection = doc.selection.rangeCount === 1 ? doc.selection.getFirstRange().isFlat : true;\n\n    // If on `compositionstart` there is a non-collapsed selection which start and end have different parents\n    // it means the `handleKeydown()` method did not remove its contents. It happens usually because\n    // of different order of events (`compositionstart` before `keydown` - in Safari). In such cases\n    // we need to remove selection contents on composition start (#83).\n    if (doc.selection.isCollapsed || isFlatSelection) {\n      return;\n    }\n    deleteSelectionContent();\n  }\n  function deleteSelectionContent() {\n    const buffer = inputCommand.buffer;\n    buffer.lock();\n    const batch = buffer.batch;\n    model.enqueueChange(batch, () => {\n      model.deleteContent(model.document.selection);\n    });\n    buffer.unlock();\n  }\n}\nconst safeKeycodes = [getCode('arrowUp'), getCode('arrowRight'), getCode('arrowDown'), getCode('arrowLeft'), 9,\n// Tab\n16,\n// Shift\n17,\n// Ctrl\n18,\n// Alt\n19,\n// Pause\n20,\n// CapsLock\n27,\n// Escape\n33,\n// PageUp\n34,\n// PageDown\n35,\n// Home\n36,\n// End,\n45,\n// Insert,\n91,\n// Windows,\n93,\n// Menu key,\n144,\n// NumLock\n145,\n// ScrollLock,\n173,\n// Mute/Unmute\n174,\n// Volume up\n175,\n// Volume down,\n176,\n// Next song,\n177,\n// Previous song,\n178,\n// Stop,\n179,\n// Play/Pause,\n255 // Display brightness (increase and decrease)\n];\n\n// Function keys.\nfor (let code = 112; code <= 135; code++) {\n  safeKeycodes.push(code);\n}\n\n/**\n * Returns `true` if a keystroke will **not** result in \"typing\".\n *\n * For instance, keystrokes that result in typing are letters \"a-zA-Z\", numbers \"0-9\", delete, backspace, etc.\n *\n * Keystrokes that do not cause typing are, for instance, Fn keys (F5, F8, etc.), arrow keys (←, →, ↑, ↓),\n * Tab (↹), \"Windows logo key\" (⊞ Win), etc.\n *\n * Note: This implementation is very simple and will need to be refined with time.\n *\n * @param {module:engine/view/observer/keyobserver~KeyEventData} keyData\n * @returns {Boolean}\n */\nexport function isNonTypingKeystroke(keyData) {\n  // Keystrokes which contain Ctrl or Cmd don't represent typing.\n  if (keyData.ctrlKey || keyData.metaKey) {\n    return true;\n  }\n  return safeKeycodes.includes(keyData.keyCode);\n}","map":{"version":3,"names":["getCode","env","isShiftDeleteOnNonCollapsedSelection","injectUnsafeKeystrokesHandling","editor","latestCompositionSelection","model","view","editing","inputCommand","commands","get","isAndroid","document","on","evt","evtData","handleUnsafeKeystroke","priority","handleCompositionStart","createSelection","selection","isWindows","doc","isComposing","isSelectionUnchanged","isEqual","isEnabled","isNonTypingKeystroke","isCollapsed","keyCode","deleteSelectionContent","isFlatSelection","rangeCount","getFirstRange","isFlat","buffer","lock","batch","enqueueChange","deleteContent","unlock","safeKeycodes","code","push","keyData","ctrlKey","metaKey","includes"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injectunsafekeystrokeshandling\n */\n\nimport { getCode } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { isShiftDeleteOnNonCollapsedSelection } from './utils';\n\n/**\n * Handles keystrokes which are unsafe for typing. This handler's logic is explained\n * in https://github.com/ckeditor/ckeditor5-typing/issues/83#issuecomment-398690251.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport default function injectUnsafeKeystrokesHandling( editor ) {\n\tlet latestCompositionSelection = null;\n\n\tconst model = editor.model;\n\tconst view = editor.editing.view;\n\tconst inputCommand = editor.commands.get( 'input' );\n\n\t// For Android, we want to handle keystrokes on `beforeinput` to be sure that code in `DeleteObserver` already had a chance to be fired.\n\tif ( env.isAndroid ) {\n\t\tview.document.on( 'beforeinput', ( evt, evtData ) => handleUnsafeKeystroke( evtData ), { priority: 'lowest' } );\n\t} else {\n\t\tview.document.on( 'keydown', ( evt, evtData ) => handleUnsafeKeystroke( evtData ), { priority: 'lowest' } );\n\t}\n\n\tview.document.on( 'compositionstart', handleCompositionStart, { priority: 'lowest' } );\n\n\tview.document.on( 'compositionend', () => {\n\t\tlatestCompositionSelection = model.createSelection( model.document.selection );\n\t}, { priority: 'lowest' } );\n\n\t// Handles the keydown event. We need to guess whether such keystroke is going to result\n\t// in typing. If so, then before character insertion happens, any selected content needs\n\t// to be deleted. Otherwise the default browser deletion mechanism would be\n\t// triggered, resulting in:\n\t//\n\t// * Hundreds of mutations which could not be handled.\n\t// * But most importantly, loss of control over how the content is being deleted.\n\t//\n\t// The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)\n\t// to handle the event.\n\t//\n\t// @param {module:engine/view/observer/keyobserver~KeyEventData} evtData\n\tfunction handleUnsafeKeystroke( evtData ) {\n\t\t// Do not delete the content, if Shift + Delete key combination was pressed on a non-collapsed selection on Windows.\n\t\t//\n\t\t// The Shift + Delete key combination should work in the same way as the `cut` event on a non-collapsed selection on Windows.\n\t\t// In fact, the native `cut` event is actually emitted in this case, but with lower priority. Therefore, in order to handle the\n\t\t// Shift + Delete key combination correctly, it is enough to prevent the content deletion here.\n\t\tif ( env.isWindows && isShiftDeleteOnNonCollapsedSelection( evtData, view.document ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst doc = model.document;\n\t\tconst isComposing = view.document.isComposing;\n\t\tconst isSelectionUnchanged = latestCompositionSelection && latestCompositionSelection.isEqual( doc.selection );\n\n\t\t// Reset stored composition selection.\n\t\tlatestCompositionSelection = null;\n\n\t\t// By relying on the state of the input command we allow disabling the entire input easily\n\t\t// by just disabling the input command. We could’ve used here the delete command but that\n\t\t// would mean requiring the delete feature which would block loading one without the other.\n\t\t// We could also check the editor.isReadOnly property, but that wouldn't allow to block\n\t\t// the input without blocking other features.\n\t\tif ( !inputCommand.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( isNonTypingKeystroke( evtData ) || doc.selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If during composition, deletion should be prevented as it may remove composed sequence (#83).\n\t\tif ( isComposing && evtData.keyCode === 229 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is a `keydown` event fired with '229' keycode it might be related\n\t\t// to recent composition. Check if selection is the same as upon ending recent composition,\n\t\t// if so do not remove selected content as it will remove composed sequence (#83).\n\t\tif ( !isComposing && evtData.keyCode === 229 && isSelectionUnchanged ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeleteSelectionContent();\n\t}\n\n\t// Handles the `compositionstart` event. It is used only in special cases to remove the contents\n\t// of a non-collapsed selection so composition itself does not result in complex mutations.\n\t//\n\t// The special case mentioned above is a situation in which the `keydown` event is fired after\n\t// `compositionstart` event. In such cases {@link #handleKeydown} cannot clear current selection\n\t// contents (because it is too late and will break the composition) so the composition handler takes care of it.\n\tfunction handleCompositionStart() {\n\t\tconst doc = model.document;\n\t\tconst isFlatSelection = doc.selection.rangeCount === 1 ? doc.selection.getFirstRange().isFlat : true;\n\n\t\t// If on `compositionstart` there is a non-collapsed selection which start and end have different parents\n\t\t// it means the `handleKeydown()` method did not remove its contents. It happens usually because\n\t\t// of different order of events (`compositionstart` before `keydown` - in Safari). In such cases\n\t\t// we need to remove selection contents on composition start (#83).\n\t\tif ( doc.selection.isCollapsed || isFlatSelection ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeleteSelectionContent();\n\t}\n\n\tfunction deleteSelectionContent() {\n\t\tconst buffer = inputCommand.buffer;\n\n\t\tbuffer.lock();\n\n\t\tconst batch = buffer.batch;\n\n\t\tmodel.enqueueChange( batch, () => {\n\t\t\tmodel.deleteContent( model.document.selection );\n\t\t} );\n\n\t\tbuffer.unlock();\n\t}\n}\n\nconst safeKeycodes = [\n\tgetCode( 'arrowUp' ),\n\tgetCode( 'arrowRight' ),\n\tgetCode( 'arrowDown' ),\n\tgetCode( 'arrowLeft' ),\n\t9, // Tab\n\t16, // Shift\n\t17, // Ctrl\n\t18, // Alt\n\t19, // Pause\n\t20, // CapsLock\n\t27, // Escape\n\t33, // PageUp\n\t34, // PageDown\n\t35, // Home\n\t36, // End,\n\t45, // Insert,\n\t91, // Windows,\n\t93, // Menu key,\n\t144, // NumLock\n\t145, // ScrollLock,\n\t173, // Mute/Unmute\n\t174, // Volume up\n\t175, // Volume down,\n\t176, // Next song,\n\t177, // Previous song,\n\t178, // Stop,\n\t179, // Play/Pause,\n\t255 // Display brightness (increase and decrease)\n];\n\n// Function keys.\nfor ( let code = 112; code <= 135; code++ ) {\n\tsafeKeycodes.push( code );\n}\n\n/**\n * Returns `true` if a keystroke will **not** result in \"typing\".\n *\n * For instance, keystrokes that result in typing are letters \"a-zA-Z\", numbers \"0-9\", delete, backspace, etc.\n *\n * Keystrokes that do not cause typing are, for instance, Fn keys (F5, F8, etc.), arrow keys (←, →, ↑, ↓),\n * Tab (↹), \"Windows logo key\" (⊞ Win), etc.\n *\n * Note: This implementation is very simple and will need to be refined with time.\n *\n * @param {module:engine/view/observer/keyobserver~KeyEventData} keyData\n * @returns {Boolean}\n */\nexport function isNonTypingKeystroke( keyData ) {\n\t// Keystrokes which contain Ctrl or Cmd don't represent typing.\n\tif ( keyData.ctrlKey || keyData.metaKey ) {\n\t\treturn true;\n\t}\n\n\treturn safeKeycodes.includes( keyData.keyCode );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}