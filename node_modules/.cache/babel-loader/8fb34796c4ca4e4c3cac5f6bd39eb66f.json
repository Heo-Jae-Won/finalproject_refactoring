{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/element\n */\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n// @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends module:engine/model/node~Node\n */\nexport default class Element extends Node {\n  /**\n   * Creates a model element.\n   *\n   * **Note:** Constructor of this class shouldn't be used directly in the code.\n   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n   *\n   * @protected\n   * @param {String} name Element's name.\n   * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n   * One or more nodes to be inserted as children of created element.\n   */\n  constructor(name, attrs, children) {\n    super(attrs);\n    /**\n     * Element name.\n     *\n     * @readonly\n     * @member {String} module:engine/model/element~Element#name\n     */\n    this.name = name;\n    /**\n     * List of children nodes.\n     *\n     * @private\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n     */\n    this._children = new NodeList();\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Number of this element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get maxOffset() {\n    return this._children.maxOffset;\n  }\n  /**\n   * Is `true` if there are no nodes inside this element, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isEmpty() {\n    return this.childCount === 0;\n  }\n  /**\n   * Gets the child at the given index.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/model/node~Node|null} Child node.\n   */\n  getChild(index) {\n    return this._children.getNode(index);\n  }\n  /**\n   * Returns an iterator that iterates over all of this element's children.\n   *\n   * @returns {Iterable.<module:engine/model/node~Node>}\n   */\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number|null} Child node's index in this element.\n   */\n  getChildIndex(node) {\n    return this._children.getNodeIndex(node);\n  }\n  /**\n   * Returns the starting offset of given child. Starting offset is equal to the sum of\n   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n   * given node is not a child of this element.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number|null} Child node's starting offset.\n   */\n  getChildStartOffset(node) {\n    return this._children.getNodeStartOffset(node);\n  }\n  /**\n   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n   * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n   *\n   *\t\tconst textNode = new Text( 'foo' );\n   *\t\tconst pElement = new Element( 'p' );\n   *\t\tconst divElement = new Element( [ textNode, pElement ] );\n   *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n   *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n   *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n   *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n   *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n   *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n   *\n   * @param {Number} offset Offset to look for.\n   * @returns {Number}\n   */\n  offsetToIndex(offset) {\n    return this._children.offsetToIndex(offset);\n  }\n  /**\n   * Returns a descendant node by its path relative to this element.\n   *\n   *\t\t// <this>a<b>c</b></this>\n   *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n   *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n   *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n   *\n   * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n   * @returns {module:engine/model/node~Node}\n   */\n  getNodeByPath(relativePath) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n    let node = this;\n    for (const index of relativePath) {\n      node = node.getChild(node.offsetToIndex(index));\n    }\n    return node;\n  }\n  /**\n   * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.\n   *\n   * @param {String} parentName The name of the parent element to find.\n   * @param {Object} [options] Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included while searching.\n   * @returns {module:engine/model/element~Element|null}\n   */\n  findAncestor(parentName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parent = options.includeSelf ? this : this.parent;\n    while (parent) {\n      if (parent.name === parentName) {\n        return parent;\n      }\n      parent = parent.parent;\n    }\n    return null;\n  }\n  /**\n   * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n   *\n   * @returns {Object} `Element` instance converted to plain object.\n   */\n  toJSON() {\n    const json = super.toJSON();\n    json.name = this.name;\n    if (this._children.length > 0) {\n      json.children = [];\n      for (const node of this._children) {\n        json.children.push(node.toJSON());\n      }\n    }\n    return json;\n  }\n  /**\n   * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n   *\n   * @internal\n   * @protected\n   * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n   * element will be cloned without any child.\n   */\n  _clone() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const children = deep ? Array.from(this._children).map(node => node._clone(true)) : undefined;\n    return new Element(this.name, this.getAttributes(), children);\n  }\n  /**\n   * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n   *\n   * @see module:engine/model/writer~Writer#append\n   * @internal\n   * @protected\n   * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} nodes Nodes to be inserted.\n   */\n  _appendChild(nodes) {\n    this._insertChild(this.childCount, nodes);\n  }\n  /**\n   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n   * to this element.\n   *\n   * @see module:engine/model/writer~Writer#insert\n   * @internal\n   * @protected\n   * @param {Number} index Index at which nodes should be inserted.\n   * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} items Items to be inserted.\n   */\n  _insertChild(index, items) {\n    const nodes = normalize(items);\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n      node.parent = this;\n    }\n    this._children._insertNodes(index, nodes);\n  }\n  /**\n   * Removes one or more nodes starting at the given index and sets\n   * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n   *\n   * @see module:engine/model/writer~Writer#remove\n   * @protected\n   * @param {Number} index Index of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n   */\n  _removeChildren(index) {\n    let howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const nodes = this._children._removeNodes(index, howMany);\n    for (const node of nodes) {\n      node.parent = null;\n    }\n    return nodes;\n  }\n  /**\n   * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n   * Converts `Element` children to proper nodes.\n   *\n   * @param {Object} json Plain object to be converted to `Element`.\n   * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n   */\n  static fromJSON(json) {\n    let children;\n    if (json.children) {\n      children = [];\n      for (const child of json.children) {\n        if (child.name) {\n          // If child has name property, it is an Element.\n          children.push(Element.fromJSON(child));\n        } else {\n          // Otherwise, it is a Text node.\n          children.push(Text.fromJSON(child));\n        }\n      }\n    }\n    return new Element(json.name, json.attributes, children);\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\telement.is( 'element' ); // -> true\n *\t\telement.is( 'node' ); // -> true\n *\t\telement.is( 'model:element' ); // -> true\n *\t\telement.is( 'model:node' ); // -> true\n *\n *\t\telement.is( 'view:element' ); // -> false\n *\t\telement.is( 'documentSelection' ); // -> false\n *\n * Assuming that the object being checked is an element, you can also check its\n * {@link module:engine/model/element~Element#name name}:\n *\n *\t\telement.is( 'element', 'imageBlock' ); // -> true if this is an <imageBlock> element\n *\t\telement.is( 'element', 'imageBlock' ); // -> same as above\n *\t\ttext.is( 'element', 'imageBlock' ); -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nElement.prototype.is = function (type, name) {\n  if (!name) {\n    return type === 'element' || type === 'model:element' ||\n    // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n    type === 'node' || type === 'model:node';\n  }\n  return name === this.name && (type === 'element' || type === 'model:element');\n};\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  }\n  // Array.from to enable .map() on non-arrays.\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n    if (node instanceof TextProxy) {\n      return new Text(node.data, node.getAttributes());\n    }\n    return node;\n  });\n}","map":{"version":3,"names":["Node","NodeList","Text","TextProxy","isIterable","Element","constructor","name","attrs","children","_children","_insertChild","childCount","length","maxOffset","isEmpty","getChild","index","getNode","getChildren","Symbol","iterator","getChildIndex","node","getNodeIndex","getChildStartOffset","getNodeStartOffset","offsetToIndex","offset","getNodeByPath","relativePath","findAncestor","parentName","options","parent","includeSelf","toJSON","json","push","_clone","deep","Array","from","map","undefined","getAttributes","_appendChild","nodes","items","normalize","_remove","_insertNodes","_removeChildren","howMany","_removeNodes","fromJSON","child","attributes","prototype","is","type","data"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/element.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/element\n */\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n// @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends module:engine/model/node~Node\n */\nexport default class Element extends Node {\n    /**\n     * Creates a model element.\n     *\n     * **Note:** Constructor of this class shouldn't be used directly in the code.\n     * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n     *\n     * @protected\n     * @param {String} name Element's name.\n     * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n     * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n     * One or more nodes to be inserted as children of created element.\n     */\n    constructor(name, attrs, children) {\n        super(attrs);\n        /**\n         * Element name.\n         *\n         * @readonly\n         * @member {String} module:engine/model/element~Element#name\n         */\n        this.name = name;\n        /**\n         * List of children nodes.\n         *\n         * @private\n         * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n         */\n        this._children = new NodeList();\n        if (children) {\n            this._insertChild(0, children);\n        }\n    }\n    /**\n     * Number of this element's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get childCount() {\n        return this._children.length;\n    }\n    /**\n     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get maxOffset() {\n        return this._children.maxOffset;\n    }\n    /**\n     * Is `true` if there are no nodes inside this element, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isEmpty() {\n        return this.childCount === 0;\n    }\n    /**\n     * Gets the child at the given index.\n     *\n     * @param {Number} index Index of child.\n     * @returns {module:engine/model/node~Node|null} Child node.\n     */\n    getChild(index) {\n        return this._children.getNode(index);\n    }\n    /**\n     * Returns an iterator that iterates over all of this element's children.\n     *\n     * @returns {Iterable.<module:engine/model/node~Node>}\n     */\n    getChildren() {\n        return this._children[Symbol.iterator]();\n    }\n    /**\n     * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number|null} Child node's index in this element.\n     */\n    getChildIndex(node) {\n        return this._children.getNodeIndex(node);\n    }\n    /**\n     * Returns the starting offset of given child. Starting offset is equal to the sum of\n     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n     * given node is not a child of this element.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number|null} Child node's starting offset.\n     */\n    getChildStartOffset(node) {\n        return this._children.getNodeStartOffset(node);\n    }\n    /**\n     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n     * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n     *\n     *\t\tconst textNode = new Text( 'foo' );\n     *\t\tconst pElement = new Element( 'p' );\n     *\t\tconst divElement = new Element( [ textNode, pElement ] );\n     *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n     *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n     *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n     *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n     *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n     *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n     *\n     * @param {Number} offset Offset to look for.\n     * @returns {Number}\n     */\n    offsetToIndex(offset) {\n        return this._children.offsetToIndex(offset);\n    }\n    /**\n     * Returns a descendant node by its path relative to this element.\n     *\n     *\t\t// <this>a<b>c</b></this>\n     *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n     *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n     *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n     *\n     * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n     * @returns {module:engine/model/node~Node}\n     */\n    getNodeByPath(relativePath) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let node = this;\n        for (const index of relativePath) {\n            node = node.getChild(node.offsetToIndex(index));\n        }\n        return node;\n    }\n    /**\n     * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.\n     *\n     * @param {String} parentName The name of the parent element to find.\n     * @param {Object} [options] Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included while searching.\n     * @returns {module:engine/model/element~Element|null}\n     */\n    findAncestor(parentName, options = {}) {\n        let parent = options.includeSelf ? this : this.parent;\n        while (parent) {\n            if (parent.name === parentName) {\n                return parent;\n            }\n            parent = parent.parent;\n        }\n        return null;\n    }\n    /**\n     * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n     *\n     * @returns {Object} `Element` instance converted to plain object.\n     */\n    toJSON() {\n        const json = super.toJSON();\n        json.name = this.name;\n        if (this._children.length > 0) {\n            json.children = [];\n            for (const node of this._children) {\n                json.children.push(node.toJSON());\n            }\n        }\n        return json;\n    }\n    /**\n     * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n     * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n     *\n     * @internal\n     * @protected\n     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any child.\n     */\n    _clone(deep = false) {\n        const children = deep ? Array.from(this._children).map(node => node._clone(true)) : undefined;\n        return new Element(this.name, this.getAttributes(), children);\n    }\n    /**\n     * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n     *\n     * @see module:engine/model/writer~Writer#append\n     * @internal\n     * @protected\n     * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} nodes Nodes to be inserted.\n     */\n    _appendChild(nodes) {\n        this._insertChild(this.childCount, nodes);\n    }\n    /**\n     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n     * to this element.\n     *\n     * @see module:engine/model/writer~Writer#insert\n     * @internal\n     * @protected\n     * @param {Number} index Index at which nodes should be inserted.\n     * @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>} items Items to be inserted.\n     */\n    _insertChild(index, items) {\n        const nodes = normalize(items);\n        for (const node of nodes) {\n            // If node that is being added to this element is already inside another element, first remove it from the old parent.\n            if (node.parent !== null) {\n                node._remove();\n            }\n            node.parent = this;\n        }\n        this._children._insertNodes(index, nodes);\n    }\n    /**\n     * Removes one or more nodes starting at the given index and sets\n     * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n     *\n     * @see module:engine/model/writer~Writer#remove\n     * @protected\n     * @param {Number} index Index of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n     */\n    _removeChildren(index, howMany = 1) {\n        const nodes = this._children._removeNodes(index, howMany);\n        for (const node of nodes) {\n            node.parent = null;\n        }\n        return nodes;\n    }\n    /**\n     * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n     * Converts `Element` children to proper nodes.\n     *\n     * @param {Object} json Plain object to be converted to `Element`.\n     * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n     */\n    static fromJSON(json) {\n        let children;\n        if (json.children) {\n            children = [];\n            for (const child of json.children) {\n                if (child.name) {\n                    // If child has name property, it is an Element.\n                    children.push(Element.fromJSON(child));\n                }\n                else {\n                    // Otherwise, it is a Text node.\n                    children.push(Text.fromJSON(child));\n                }\n            }\n        }\n        return new Element(json.name, json.attributes, children);\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\telement.is( 'element' ); // -> true\n *\t\telement.is( 'node' ); // -> true\n *\t\telement.is( 'model:element' ); // -> true\n *\t\telement.is( 'model:node' ); // -> true\n *\n *\t\telement.is( 'view:element' ); // -> false\n *\t\telement.is( 'documentSelection' ); // -> false\n *\n * Assuming that the object being checked is an element, you can also check its\n * {@link module:engine/model/element~Element#name name}:\n *\n *\t\telement.is( 'element', 'imageBlock' ); // -> true if this is an <imageBlock> element\n *\t\telement.is( 'element', 'imageBlock' ); // -> same as above\n *\t\ttext.is( 'element', 'imageBlock' ); -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nElement.prototype.is = function (type, name) {\n    if (!name) {\n        return type === 'element' || type === 'model:element' ||\n            // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n            type === 'node' || type === 'model:node';\n    }\n    return name === this.name && (type === 'element' || type === 'model:element');\n};\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize(nodes) {\n    // Separate condition because string is iterable.\n    if (typeof nodes == 'string') {\n        return [new Text(nodes)];\n    }\n    if (!isIterable(nodes)) {\n        nodes = [nodes];\n    }\n    // Array.from to enable .map() on non-arrays.\n    return Array.from(nodes)\n        .map(node => {\n        if (typeof node == 'string') {\n            return new Text(node);\n        }\n        if (node instanceof TextProxy) {\n            return new Text(node.data, node.getAttributes());\n        }\n        return node;\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}