{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/dom/rect\n */\nimport isRange from './isrange';\nimport isWindow from './iswindow';\nimport getBorderWidths from './getborderwidths';\nimport isText from './istext';\nconst rectProperties = ['top', 'right', 'bottom', 'left', 'width', 'height'];\n/**\n * A helper class representing a `ClientRect` object, e.g. value returned by\n * the native `object.getBoundingClientRect()` method. Provides a set of methods\n * to manipulate the rect and compare it against other rect instances.\n */\nexport default class Rect {\n  /**\n   * Creates an instance of rect.\n   *\n   *\t\t// Rect of an HTMLElement.\n   *\t\tconst rectA = new Rect( document.body );\n   *\n   *\t\t// Rect of a DOM Range.\n   *\t\tconst rectB = new Rect( document.getSelection().getRangeAt( 0 ) );\n   *\n   *\t\t// Rect of a window (web browser viewport).\n   *\t\tconst rectC = new Rect( window );\n   *\n   *\t\t// Rect out of an object.\n   *\t\tconst rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );\n   *\n   *\t\t// Rect out of another Rect instance.\n   *\t\tconst rectE = new Rect( rectD );\n   *\n   *\t\t// Rect out of a ClientRect.\n   *\t\tconst rectF = new Rect( document.body.getClientRects().item( 0 ) );\n   *\n   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)\n   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}\n   * to get the inner part of the rect.\n   *\n   * @param {module:utils/dom/rect~RectSource} source A source object to create the rect.\n   */\n  constructor(source) {\n    const isSourceRange = isRange(source);\n    Object.defineProperty(this, '_source', {\n      // If the source is a Rect instance, copy it's #_source.\n      value: source._source || source,\n      writable: true,\n      enumerable: false\n    });\n    if (isDomElement(source) || isSourceRange) {\n      // The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods. If the source\n      // of a rect in an HTML element or a DOM range but it does not belong to any rendered DOM tree, these methods\n      // will fail to obtain the geometry and the rect instance makes little sense to the features using it.\n      // To get rid of this warning make sure the source passed to the constructor is a descendant of `window.document.body`.\n      // @if CK_DEBUG // const sourceNode = isSourceRange ? source.startContainer : source;\n      // @if CK_DEBUG // if ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {\n      // @if CK_DEBUG // \tconsole.warn(\n      // @if CK_DEBUG // \t\t'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',\n      // @if CK_DEBUG // \t\t{ source } );\n      // @if CK_DEBUG // }\n      if (isSourceRange) {\n        const rangeRects = Rect.getDomRangeRects(source);\n        copyRectProperties(this, Rect.getBoundingRect(rangeRects));\n      } else {\n        copyRectProperties(this, source.getBoundingClientRect());\n      }\n    } else if (isWindow(source)) {\n      const {\n        innerWidth,\n        innerHeight\n      } = source;\n      copyRectProperties(this, {\n        top: 0,\n        right: innerWidth,\n        bottom: innerHeight,\n        left: 0,\n        width: innerWidth,\n        height: innerHeight\n      });\n    } else {\n      copyRectProperties(this, source);\n    }\n  }\n  /**\n   * Returns a clone of the rect.\n   *\n   * @returns {module:utils/dom/rect~Rect} A cloned rect.\n   */\n  clone() {\n    return new Rect(this);\n  }\n  /**\n   * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.\n   *\n   * @param {Number} x Desired horizontal location.\n   * @param {Number} y Desired vertical location.\n   * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n   */\n  moveTo(x, y) {\n    this.top = y;\n    this.right = x + this.width;\n    this.bottom = y + this.height;\n    this.left = x;\n    return this;\n  }\n  /**\n   * Moves the rect in–place by a dedicated offset.\n   *\n   * @param {Number} x A horizontal offset.\n   * @param {Number} y A vertical offset\n   * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n   */\n  moveBy(x, y) {\n    this.top += y;\n    this.right += x;\n    this.left += x;\n    this.bottom += y;\n    return this;\n  }\n  /**\n   * Returns a new rect a a result of intersection with another rect.\n   *\n   * @param {module:utils/dom/rect~Rect} anotherRect\n   * @returns {module:utils/dom/rect~Rect|null}\n   */\n  getIntersection(anotherRect) {\n    const rect = {\n      top: Math.max(this.top, anotherRect.top),\n      right: Math.min(this.right, anotherRect.right),\n      bottom: Math.min(this.bottom, anotherRect.bottom),\n      left: Math.max(this.left, anotherRect.left),\n      width: 0,\n      height: 0\n    };\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n    if (rect.width < 0 || rect.height < 0) {\n      return null;\n    } else {\n      return new Rect(rect);\n    }\n  }\n  /**\n   * Returns the area of intersection with another rect.\n   *\n   * @param {module:utils/dom/rect~Rect} anotherRect\n   * @returns {Number} Area of intersection.\n   */\n  getIntersectionArea(anotherRect) {\n    const rect = this.getIntersection(anotherRect);\n    if (rect) {\n      return rect.getArea();\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Returns the area of the rect.\n   *\n   * @returns {Number}\n   */\n  getArea() {\n    return this.width * this.height;\n  }\n  /**\n   * Returns a new rect, a part of the original rect, which is actually visible to the user,\n   * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS\n   * other than `\"visible\"`.\n   *\n   * If there's no such visible rect, which is when the rect is limited by one or many of\n   * the ancestors, `null` is returned.\n   *\n   * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.\n   */\n  getVisible() {\n    const source = this._source;\n    let visibleRect = this.clone();\n    // There's no ancestor to crop <body> with the overflow.\n    if (!isBody(source)) {\n      let parent = source.parentNode || source.commonAncestorContainer;\n      // Check the ancestors all the way up to the <body>.\n      while (parent && !isBody(parent)) {\n        const parentRect = new Rect(parent);\n        const intersectionRect = visibleRect.getIntersection(parentRect);\n        if (intersectionRect) {\n          if (intersectionRect.getArea() < visibleRect.getArea()) {\n            // Reduce the visible rect to the intersection.\n            visibleRect = intersectionRect;\n          }\n        } else {\n          // There's no intersection, the rect is completely invisible.\n          return null;\n        }\n        parent = parent.parentNode;\n      }\n    }\n    return visibleRect;\n  }\n  /**\n   * Checks if all property values ({@link #top}, {@link #left}, {@link #right},\n   * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect\n   * instances.\n   *\n   * @param {module:utils/dom/rect~Rect} anotherRect A rect instance to compare with.\n   * @returns {Boolean} `true` when Rects are equal. `false` otherwise.\n   */\n  isEqual(anotherRect) {\n    for (const prop of rectProperties) {\n      if (this[prop] !== anotherRect[prop]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Checks whether a rect fully contains another rect instance.\n   *\n   * @param {module:utils/dom/rect~Rect} anotherRect\n   * @returns {Boolean} `true` if contains, `false` otherwise.\n   */\n  contains(anotherRect) {\n    const intersectRect = this.getIntersection(anotherRect);\n    return !!(intersectRect && intersectRect.isEqual(anotherRect));\n  }\n  /**\n   * Excludes scrollbars and CSS borders from the rect.\n   *\n   * * Borders are removed when {@link #_source} is an HTML element.\n   * * Scrollbars are excluded from HTML elements and the `window`.\n   *\n   * @returns {module:utils/dom/rect~Rect} A rect which has been updated.\n   */\n  excludeScrollbarsAndBorders() {\n    const source = this._source;\n    let scrollBarWidth, scrollBarHeight, direction;\n    if (isWindow(source)) {\n      scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;\n      scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;\n      direction = source.getComputedStyle(source.document.documentElement).direction;\n    } else {\n      const borderWidths = getBorderWidths(source);\n      scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;\n      scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;\n      direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;\n      this.left += borderWidths.left;\n      this.top += borderWidths.top;\n      this.right -= borderWidths.right;\n      this.bottom -= borderWidths.bottom;\n      this.width = this.right - this.left;\n      this.height = this.bottom - this.top;\n    }\n    this.width -= scrollBarWidth;\n    if (direction === 'ltr') {\n      this.right -= scrollBarWidth;\n    } else {\n      this.left += scrollBarWidth;\n    }\n    this.height -= scrollBarHeight;\n    this.bottom -= scrollBarHeight;\n    return this;\n  }\n  /**\n   * Returns an array of rects of the given native DOM Range.\n   *\n   * @param {Range} range A native DOM range.\n   * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.\n   */\n  static getDomRangeRects(range) {\n    const rects = [];\n    // Safari does not iterate over ClientRectList using for...of loop.\n    const clientRects = Array.from(range.getClientRects());\n    if (clientRects.length) {\n      for (const rect of clientRects) {\n        rects.push(new Rect(rect));\n      }\n    }\n    // If there's no client rects for the Range, use parent container's bounding rect\n    // instead and adjust rect's width to simulate the actual geometry of such range.\n    // https://github.com/ckeditor/ckeditor5-utils/issues/153\n    // https://github.com/ckeditor/ckeditor5-ui/issues/317\n    else {\n      let startContainer = range.startContainer;\n      if (isText(startContainer)) {\n        startContainer = startContainer.parentNode;\n      }\n      const rect = new Rect(startContainer.getBoundingClientRect());\n      rect.right = rect.left;\n      rect.width = 0;\n      rects.push(rect);\n    }\n    return rects;\n  }\n  /**\n   * Returns a bounding rectangle that contains all the given `rects`.\n   *\n   * @param {Iterable.<module:utils/dom/rect~Rect>} rects A list of rectangles that should be contained in the result rectangle.\n   * @returns {module:utils/dom/rect~Rect|null} Bounding rectangle or `null` if no `rects` were given.\n   */\n  static getBoundingRect(rects) {\n    const boundingRectData = {\n      left: Number.POSITIVE_INFINITY,\n      top: Number.POSITIVE_INFINITY,\n      right: Number.NEGATIVE_INFINITY,\n      bottom: Number.NEGATIVE_INFINITY,\n      width: 0,\n      height: 0\n    };\n    let rectangleCount = 0;\n    for (const rect of rects) {\n      rectangleCount++;\n      boundingRectData.left = Math.min(boundingRectData.left, rect.left);\n      boundingRectData.top = Math.min(boundingRectData.top, rect.top);\n      boundingRectData.right = Math.max(boundingRectData.right, rect.right);\n      boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);\n    }\n    if (rectangleCount == 0) {\n      return null;\n    }\n    boundingRectData.width = boundingRectData.right - boundingRectData.left;\n    boundingRectData.height = boundingRectData.bottom - boundingRectData.top;\n    return new Rect(boundingRectData);\n  }\n}\n// Acquires all the rect properties from the passed source.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect\n// @param {module:utils/dom/rect~RectLike} source\nfunction copyRectProperties(rect, source) {\n  for (const p of rectProperties) {\n    rect[p] = source[p];\n  }\n}\n// Checks if provided object is a <body> HTML element.\n//\n// @private\n// @param {*} value\n// @returns {Boolean}\nfunction isBody(value) {\n  if (!isDomElement(value)) {\n    return false;\n  }\n  return value === value.ownerDocument.body;\n}\n// Checks if provided object \"looks like\" a DOM Element and has API required by `Rect` class.\n//\n// @private\n// @param {*} value\n// @returns {Boolean}\nfunction isDomElement(value) {\n  // Note: earlier we used `isElement()` from lodash library, however that function is less performant because\n  // it makes complicated checks to make sure that given value is a DOM element.\n  return value !== null && typeof value === 'object' && value.nodeType === 1 && typeof value.getBoundingClientRect === 'function';\n}","map":{"version":3,"names":["isRange","isWindow","getBorderWidths","isText","rectProperties","Rect","constructor","source","isSourceRange","Object","defineProperty","value","_source","writable","enumerable","isDomElement","rangeRects","getDomRangeRects","copyRectProperties","getBoundingRect","getBoundingClientRect","innerWidth","innerHeight","top","right","bottom","left","width","height","clone","moveTo","x","y","moveBy","getIntersection","anotherRect","rect","Math","max","min","getIntersectionArea","getArea","getVisible","visibleRect","isBody","parent","parentNode","commonAncestorContainer","parentRect","intersectionRect","isEqual","prop","contains","intersectRect","excludeScrollbarsAndBorders","scrollBarWidth","scrollBarHeight","direction","document","documentElement","clientWidth","clientHeight","getComputedStyle","borderWidths","offsetWidth","offsetHeight","ownerDocument","defaultView","range","rects","clientRects","Array","from","getClientRects","length","push","startContainer","boundingRectData","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","rectangleCount","p","body","nodeType"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/dom/rect.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/dom/rect\n */\nimport isRange from './isrange';\nimport isWindow from './iswindow';\nimport getBorderWidths from './getborderwidths';\nimport isText from './istext';\nconst rectProperties = ['top', 'right', 'bottom', 'left', 'width', 'height'];\n/**\n * A helper class representing a `ClientRect` object, e.g. value returned by\n * the native `object.getBoundingClientRect()` method. Provides a set of methods\n * to manipulate the rect and compare it against other rect instances.\n */\nexport default class Rect {\n    /**\n     * Creates an instance of rect.\n     *\n     *\t\t// Rect of an HTMLElement.\n     *\t\tconst rectA = new Rect( document.body );\n     *\n     *\t\t// Rect of a DOM Range.\n     *\t\tconst rectB = new Rect( document.getSelection().getRangeAt( 0 ) );\n     *\n     *\t\t// Rect of a window (web browser viewport).\n     *\t\tconst rectC = new Rect( window );\n     *\n     *\t\t// Rect out of an object.\n     *\t\tconst rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );\n     *\n     *\t\t// Rect out of another Rect instance.\n     *\t\tconst rectE = new Rect( rectD );\n     *\n     *\t\t// Rect out of a ClientRect.\n     *\t\tconst rectF = new Rect( document.body.getClientRects().item( 0 ) );\n     *\n     * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)\n     * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}\n     * to get the inner part of the rect.\n     *\n     * @param {module:utils/dom/rect~RectSource} source A source object to create the rect.\n     */\n    constructor(source) {\n        const isSourceRange = isRange(source);\n        Object.defineProperty(this, '_source', {\n            // If the source is a Rect instance, copy it's #_source.\n            value: source._source || source,\n            writable: true,\n            enumerable: false\n        });\n        if (isDomElement(source) || isSourceRange) {\n            // The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods. If the source\n            // of a rect in an HTML element or a DOM range but it does not belong to any rendered DOM tree, these methods\n            // will fail to obtain the geometry and the rect instance makes little sense to the features using it.\n            // To get rid of this warning make sure the source passed to the constructor is a descendant of `window.document.body`.\n            // @if CK_DEBUG // const sourceNode = isSourceRange ? source.startContainer : source;\n            // @if CK_DEBUG // if ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {\n            // @if CK_DEBUG // \tconsole.warn(\n            // @if CK_DEBUG // \t\t'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',\n            // @if CK_DEBUG // \t\t{ source } );\n            // @if CK_DEBUG // }\n            if (isSourceRange) {\n                const rangeRects = Rect.getDomRangeRects(source);\n                copyRectProperties(this, Rect.getBoundingRect(rangeRects));\n            }\n            else {\n                copyRectProperties(this, source.getBoundingClientRect());\n            }\n        }\n        else if (isWindow(source)) {\n            const { innerWidth, innerHeight } = source;\n            copyRectProperties(this, {\n                top: 0,\n                right: innerWidth,\n                bottom: innerHeight,\n                left: 0,\n                width: innerWidth,\n                height: innerHeight\n            });\n        }\n        else {\n            copyRectProperties(this, source);\n        }\n    }\n    /**\n     * Returns a clone of the rect.\n     *\n     * @returns {module:utils/dom/rect~Rect} A cloned rect.\n     */\n    clone() {\n        return new Rect(this);\n    }\n    /**\n     * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.\n     *\n     * @param {Number} x Desired horizontal location.\n     * @param {Number} y Desired vertical location.\n     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n     */\n    moveTo(x, y) {\n        this.top = y;\n        this.right = x + this.width;\n        this.bottom = y + this.height;\n        this.left = x;\n        return this;\n    }\n    /**\n     * Moves the rect in–place by a dedicated offset.\n     *\n     * @param {Number} x A horizontal offset.\n     * @param {Number} y A vertical offset\n     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n     */\n    moveBy(x, y) {\n        this.top += y;\n        this.right += x;\n        this.left += x;\n        this.bottom += y;\n        return this;\n    }\n    /**\n     * Returns a new rect a a result of intersection with another rect.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect\n     * @returns {module:utils/dom/rect~Rect|null}\n     */\n    getIntersection(anotherRect) {\n        const rect = {\n            top: Math.max(this.top, anotherRect.top),\n            right: Math.min(this.right, anotherRect.right),\n            bottom: Math.min(this.bottom, anotherRect.bottom),\n            left: Math.max(this.left, anotherRect.left),\n            width: 0,\n            height: 0\n        };\n        rect.width = rect.right - rect.left;\n        rect.height = rect.bottom - rect.top;\n        if (rect.width < 0 || rect.height < 0) {\n            return null;\n        }\n        else {\n            return new Rect(rect);\n        }\n    }\n    /**\n     * Returns the area of intersection with another rect.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect\n     * @returns {Number} Area of intersection.\n     */\n    getIntersectionArea(anotherRect) {\n        const rect = this.getIntersection(anotherRect);\n        if (rect) {\n            return rect.getArea();\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * Returns the area of the rect.\n     *\n     * @returns {Number}\n     */\n    getArea() {\n        return this.width * this.height;\n    }\n    /**\n     * Returns a new rect, a part of the original rect, which is actually visible to the user,\n     * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS\n     * other than `\"visible\"`.\n     *\n     * If there's no such visible rect, which is when the rect is limited by one or many of\n     * the ancestors, `null` is returned.\n     *\n     * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.\n     */\n    getVisible() {\n        const source = this._source;\n        let visibleRect = this.clone();\n        // There's no ancestor to crop <body> with the overflow.\n        if (!isBody(source)) {\n            let parent = source.parentNode || source.commonAncestorContainer;\n            // Check the ancestors all the way up to the <body>.\n            while (parent && !isBody(parent)) {\n                const parentRect = new Rect(parent);\n                const intersectionRect = visibleRect.getIntersection(parentRect);\n                if (intersectionRect) {\n                    if (intersectionRect.getArea() < visibleRect.getArea()) {\n                        // Reduce the visible rect to the intersection.\n                        visibleRect = intersectionRect;\n                    }\n                }\n                else {\n                    // There's no intersection, the rect is completely invisible.\n                    return null;\n                }\n                parent = parent.parentNode;\n            }\n        }\n        return visibleRect;\n    }\n    /**\n     * Checks if all property values ({@link #top}, {@link #left}, {@link #right},\n     * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect\n     * instances.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect A rect instance to compare with.\n     * @returns {Boolean} `true` when Rects are equal. `false` otherwise.\n     */\n    isEqual(anotherRect) {\n        for (const prop of rectProperties) {\n            if (this[prop] !== anotherRect[prop]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks whether a rect fully contains another rect instance.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect\n     * @returns {Boolean} `true` if contains, `false` otherwise.\n     */\n    contains(anotherRect) {\n        const intersectRect = this.getIntersection(anotherRect);\n        return !!(intersectRect && intersectRect.isEqual(anotherRect));\n    }\n    /**\n     * Excludes scrollbars and CSS borders from the rect.\n     *\n     * * Borders are removed when {@link #_source} is an HTML element.\n     * * Scrollbars are excluded from HTML elements and the `window`.\n     *\n     * @returns {module:utils/dom/rect~Rect} A rect which has been updated.\n     */\n    excludeScrollbarsAndBorders() {\n        const source = this._source;\n        let scrollBarWidth, scrollBarHeight, direction;\n        if (isWindow(source)) {\n            scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;\n            scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;\n            direction = source.getComputedStyle(source.document.documentElement).direction;\n        }\n        else {\n            const borderWidths = getBorderWidths(source);\n            scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;\n            scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;\n            direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;\n            this.left += borderWidths.left;\n            this.top += borderWidths.top;\n            this.right -= borderWidths.right;\n            this.bottom -= borderWidths.bottom;\n            this.width = this.right - this.left;\n            this.height = this.bottom - this.top;\n        }\n        this.width -= scrollBarWidth;\n        if (direction === 'ltr') {\n            this.right -= scrollBarWidth;\n        }\n        else {\n            this.left += scrollBarWidth;\n        }\n        this.height -= scrollBarHeight;\n        this.bottom -= scrollBarHeight;\n        return this;\n    }\n    /**\n     * Returns an array of rects of the given native DOM Range.\n     *\n     * @param {Range} range A native DOM range.\n     * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.\n     */\n    static getDomRangeRects(range) {\n        const rects = [];\n        // Safari does not iterate over ClientRectList using for...of loop.\n        const clientRects = Array.from(range.getClientRects());\n        if (clientRects.length) {\n            for (const rect of clientRects) {\n                rects.push(new Rect(rect));\n            }\n        }\n        // If there's no client rects for the Range, use parent container's bounding rect\n        // instead and adjust rect's width to simulate the actual geometry of such range.\n        // https://github.com/ckeditor/ckeditor5-utils/issues/153\n        // https://github.com/ckeditor/ckeditor5-ui/issues/317\n        else {\n            let startContainer = range.startContainer;\n            if (isText(startContainer)) {\n                startContainer = startContainer.parentNode;\n            }\n            const rect = new Rect(startContainer.getBoundingClientRect());\n            rect.right = rect.left;\n            rect.width = 0;\n            rects.push(rect);\n        }\n        return rects;\n    }\n    /**\n     * Returns a bounding rectangle that contains all the given `rects`.\n     *\n     * @param {Iterable.<module:utils/dom/rect~Rect>} rects A list of rectangles that should be contained in the result rectangle.\n     * @returns {module:utils/dom/rect~Rect|null} Bounding rectangle or `null` if no `rects` were given.\n     */\n    static getBoundingRect(rects) {\n        const boundingRectData = {\n            left: Number.POSITIVE_INFINITY,\n            top: Number.POSITIVE_INFINITY,\n            right: Number.NEGATIVE_INFINITY,\n            bottom: Number.NEGATIVE_INFINITY,\n            width: 0,\n            height: 0\n        };\n        let rectangleCount = 0;\n        for (const rect of rects) {\n            rectangleCount++;\n            boundingRectData.left = Math.min(boundingRectData.left, rect.left);\n            boundingRectData.top = Math.min(boundingRectData.top, rect.top);\n            boundingRectData.right = Math.max(boundingRectData.right, rect.right);\n            boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);\n        }\n        if (rectangleCount == 0) {\n            return null;\n        }\n        boundingRectData.width = boundingRectData.right - boundingRectData.left;\n        boundingRectData.height = boundingRectData.bottom - boundingRectData.top;\n        return new Rect(boundingRectData);\n    }\n}\n// Acquires all the rect properties from the passed source.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect\n// @param {module:utils/dom/rect~RectLike} source\nfunction copyRectProperties(rect, source) {\n    for (const p of rectProperties) {\n        rect[p] = source[p];\n    }\n}\n// Checks if provided object is a <body> HTML element.\n//\n// @private\n// @param {*} value\n// @returns {Boolean}\nfunction isBody(value) {\n    if (!isDomElement(value)) {\n        return false;\n    }\n    return value === value.ownerDocument.body;\n}\n// Checks if provided object \"looks like\" a DOM Element and has API required by `Rect` class.\n//\n// @private\n// @param {*} value\n// @returns {Boolean}\nfunction isDomElement(value) {\n    // Note: earlier we used `isElement()` from lodash library, however that function is less performant because\n    // it makes complicated checks to make sure that given value is a DOM element.\n    return value !== null && typeof value === 'object' && value.nodeType === 1 && typeof value.getBoundingClientRect === 'function';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}