{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/treewalker\n */\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n  /**\n   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n   *\n   * @constructor\n   * @param {TODO ~TreeWalkerOptions} options Object with configuration.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!options.boundaries && !options.startPosition) {\n      /**\n       * Neither boundaries nor starting position have been defined.\n       *\n       * @error view-tree-walker-no-start-position\n       */\n      throw new CKEditorError('view-tree-walker-no-start-position', null);\n    }\n    if (options.direction && options.direction != 'forward' && options.direction != 'backward') {\n      /**\n       * Only `backward` and `forward` direction allowed.\n       *\n       * @error view-tree-walker-unknown-direction\n       */\n      throw new CKEditorError('view-tree-walker-unknown-direction', options.startPosition, {\n        direction: options.direction\n      });\n    }\n    /**\n     * Iterator boundaries.\n     *\n     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n     * on the start of boundary, then `{ done: true }` is returned.\n     *\n     * If boundaries are not defined they are set before first and after last child of the root node.\n     *\n     * @readonly\n     * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries\n     */\n    this.boundaries = options.boundaries || null;\n    /**\n     * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is\n     * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position\n     */\n    if (options.startPosition) {\n      this.position = Position._createAt(options.startPosition);\n    } else {\n      this.position = Position._createAt(options.boundaries[options.direction == 'backward' ? 'end' : 'start']);\n    }\n    /**\n     * Walking direction. Defaults `'forward'`.\n     *\n     * @readonly\n     * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction\n     */\n    this.direction = options.direction || 'forward';\n    /**\n     * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one\n     * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters\n     */\n    this.singleCharacters = !!options.singleCharacters;\n    /**\n     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n     * iterated node will not be returned along with `elementEnd` tag.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow\n     */\n    this.shallow = !!options.shallow;\n    /**\n     * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not\n     * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.\n     * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd\n     */\n    this.ignoreElementEnd = !!options.ignoreElementEnd;\n    /**\n     * Start boundary parent.\n     *\n     * @private\n     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent\n     */\n    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n    /**\n     * End boundary parent.\n     *\n     * @private\n     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent\n     */\n    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n   */\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n   *\n   * For example:\n   *\n   * \t\twalker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n   * \t\twalker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]\n   * \t\twalker.skip( value => false ); // Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   */\n  skip(skip) {\n    let done, value, prevPosition;\n    do {\n      prevPosition = this.position;\n      ({\n        done,\n        value\n      } = this.next());\n    } while (!done && skip(value));\n    if (!done) {\n      this.position = prevPosition;\n    }\n  }\n  /**\n   * Gets the next tree walker's value.\n   *\n   * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning\n   * information about taken step.\n   */\n  next() {\n    if (this.direction == 'forward') {\n      return this._next();\n    } else {\n      return this._previous();\n    }\n  }\n  /**\n   * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.\n   * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n   */\n  _next() {\n    let position = this.position.clone();\n    const previousPosition = this.position;\n    const parent = position.parent;\n    // We are at the end of the root.\n    if (parent.parent === null && position.offset === parent.childCount) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // We reached the walker boundary.\n    if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // Get node just after current position.\n    let node;\n    // Text is a specific parent because it contains string instead of child nodes.\n    if (parent instanceof Text) {\n      if (position.isAtEnd) {\n        // Prevent returning \"elementEnd\" for Text node. Skip that value and return the next walker step.\n        this.position = Position._createAfter(parent);\n        return this._next();\n      }\n      node = parent.data[position.offset];\n    } else {\n      node = parent.getChild(position.offset);\n    }\n    if (node instanceof Element) {\n      if (!this.shallow) {\n        position = new Position(node, 0);\n      } else {\n        position.offset++;\n      }\n      this.position = position;\n      return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n    } else if (node instanceof Text) {\n      if (this.singleCharacters) {\n        position = new Position(node, 0);\n        this.position = position;\n        return this._next();\n      } else {\n        let charactersCount = node.data.length;\n        let item;\n        // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n        if (node == this._boundaryEndParent) {\n          charactersCount = this.boundaries.end.offset;\n          item = new TextProxy(node, 0, charactersCount);\n          position = Position._createAfter(item);\n        } else {\n          item = new TextProxy(node, 0, node.data.length);\n          // If not just keep moving forward.\n          position.offset++;\n        }\n        this.position = position;\n        return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n      }\n    } else if (typeof node == 'string') {\n      let textLength;\n      if (this.singleCharacters) {\n        textLength = 1;\n      } else {\n        // Check if text stick out of walker range.\n        const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;\n        textLength = endOffset - position.offset;\n      }\n      const textProxy = new TextProxy(parent, position.offset, textLength);\n      position.offset += textLength;\n      this.position = position;\n      return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n    } else {\n      // `node` is not set, we reached the end of current `parent`.\n      position = Position._createAfter(parent);\n      this.position = position;\n      if (this.ignoreElementEnd) {\n        return this._next();\n      } else {\n        return this._formatReturnValue('elementEnd', parent, previousPosition, position);\n      }\n    }\n  }\n  /**\n   * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done True if iterator is done.\n   * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n   */\n  _previous() {\n    let position = this.position.clone();\n    const previousPosition = this.position;\n    const parent = position.parent;\n    // We are at the beginning of the root.\n    if (parent.parent === null && position.offset === 0) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // We reached the walker boundary.\n    if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    // Get node just before current position.\n    let node;\n    // Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.\n    if (parent instanceof Text) {\n      if (position.isAtStart) {\n        // Prevent returning \"elementStart\" for Text node. Skip that value and return the next walker step.\n        this.position = Position._createBefore(parent);\n        return this._previous();\n      }\n      node = parent.data[position.offset - 1];\n    } else {\n      node = parent.getChild(position.offset - 1);\n    }\n    if (node instanceof Element) {\n      if (!this.shallow) {\n        position = new Position(node, node.childCount);\n        this.position = position;\n        if (this.ignoreElementEnd) {\n          return this._previous();\n        } else {\n          return this._formatReturnValue('elementEnd', node, previousPosition, position);\n        }\n      } else {\n        position.offset--;\n        this.position = position;\n        return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n      }\n    } else if (node instanceof Text) {\n      if (this.singleCharacters) {\n        position = new Position(node, node.data.length);\n        this.position = position;\n        return this._previous();\n      } else {\n        let charactersCount = node.data.length;\n        let item;\n        // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n        if (node == this._boundaryStartParent) {\n          const offset = this.boundaries.start.offset;\n          item = new TextProxy(node, offset, node.data.length - offset);\n          charactersCount = item.data.length;\n          position = Position._createBefore(item);\n        } else {\n          item = new TextProxy(node, 0, node.data.length);\n          // If not just keep moving backward.\n          position.offset--;\n        }\n        this.position = position;\n        return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n      }\n    } else if (typeof node == 'string') {\n      let textLength;\n      if (!this.singleCharacters) {\n        // Check if text stick out of walker range.\n        const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;\n        textLength = position.offset - startOffset;\n      } else {\n        textLength = 1;\n      }\n      position.offset -= textLength;\n      const textProxy = new TextProxy(parent, position.offset, textLength);\n      this.position = position;\n      return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n    } else {\n      // `node` is not set, we reached the beginning of current `parent`.\n      position = Position._createBefore(parent);\n      this.position = position;\n      return this._formatReturnValue('elementStart', parent, previousPosition, position, 1);\n    }\n  }\n  /**\n   * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.\n   *\n   * @private\n   * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.\n   * @param {module:engine/view/item~Item} item Item between old and new position.\n   * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.\n   * @param {module:engine/view/position~Position} nextPosition Next position of iterator.\n   * @param {Number} [length] Length of the item.\n   * @returns {module:engine/view/treewalker~TreeWalkerValue}\n   */\n  _formatReturnValue(type, item, previousPosition, nextPosition, length) {\n    // Text is a specific parent, because contains string instead of children.\n    // Walker doesn't enter to the Text except situations when walker is iterating over every single character,\n    // or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text\n    // we move it just before or just after Text.\n    if (item instanceof TextProxy) {\n      // Position is at the end of Text.\n      if (item.offsetInText + item.data.length == item.textNode.data.length) {\n        if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {\n          nextPosition = Position._createAfter(item.textNode);\n          // When we change nextPosition of returned value we need also update walker current position.\n          this.position = nextPosition;\n        } else {\n          previousPosition = Position._createAfter(item.textNode);\n        }\n      }\n      // Position is at the begining ot the text.\n      if (item.offsetInText === 0) {\n        if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {\n          nextPosition = Position._createBefore(item.textNode);\n          // When we change nextPosition of returned value we need also update walker current position.\n          this.position = nextPosition;\n        } else {\n          previousPosition = Position._createBefore(item.textNode);\n        }\n      }\n    }\n    return {\n      done: false,\n      value: {\n        type,\n        item,\n        previousPosition,\n        nextPosition,\n        length\n      }\n    };\n  }\n}","map":{"version":3,"names":["Element","Text","TextProxy","Position","CKEditorError","TreeWalker","constructor","options","boundaries","startPosition","direction","position","_createAt","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","start","parent","_boundaryEndParent","end","Symbol","iterator","skip","done","value","prevPosition","next","_next","_previous","clone","previousPosition","offset","childCount","undefined","node","isAtEnd","_createAfter","data","getChild","_formatReturnValue","charactersCount","length","item","textLength","endOffset","textProxy","isAtStart","_createBefore","startOffset","type","nextPosition","offsetInText","textNode","isEqual"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/treewalker\n */\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n    /**\n     * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n     *\n     * @constructor\n     * @param {TODO ~TreeWalkerOptions} options Object with configuration.\n     */\n    constructor(options = {}) {\n        if (!options.boundaries && !options.startPosition) {\n            /**\n             * Neither boundaries nor starting position have been defined.\n             *\n             * @error view-tree-walker-no-start-position\n             */\n            throw new CKEditorError('view-tree-walker-no-start-position', null);\n        }\n        if (options.direction && options.direction != 'forward' && options.direction != 'backward') {\n            /**\n             * Only `backward` and `forward` direction allowed.\n             *\n             * @error view-tree-walker-unknown-direction\n             */\n            throw new CKEditorError('view-tree-walker-unknown-direction', options.startPosition, { direction: options.direction });\n        }\n        /**\n         * Iterator boundaries.\n         *\n         * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n         * on the start of boundary, then `{ done: true }` is returned.\n         *\n         * If boundaries are not defined they are set before first and after last child of the root node.\n         *\n         * @readonly\n         * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries\n         */\n        this.boundaries = options.boundaries || null;\n        /**\n         * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is\n         * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.\n         *\n         * @readonly\n         * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position\n         */\n        if (options.startPosition) {\n            this.position = Position._createAt(options.startPosition);\n        }\n        else {\n            this.position = Position._createAt(options.boundaries[options.direction == 'backward' ? 'end' : 'start']);\n        }\n        /**\n         * Walking direction. Defaults `'forward'`.\n         *\n         * @readonly\n         * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction\n         */\n        this.direction = options.direction || 'forward';\n        /**\n         * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one\n         * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.\n         *\n         * @readonly\n         * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters\n         */\n        this.singleCharacters = !!options.singleCharacters;\n        /**\n         * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n         * iterated node will not be returned along with `elementEnd` tag.\n         *\n         * @readonly\n         * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow\n         */\n        this.shallow = !!options.shallow;\n        /**\n         * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not\n         * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.\n         * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.\n         *\n         * @readonly\n         * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd\n         */\n        this.ignoreElementEnd = !!options.ignoreElementEnd;\n        /**\n         * Start boundary parent.\n         *\n         * @private\n         * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent\n         */\n        this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n        /**\n         * End boundary parent.\n         *\n         * @private\n         * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent\n         */\n        this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n    }\n    /**\n     * Iterable interface.\n     *\n     * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n     */\n    [Symbol.iterator]() {\n        return this;\n    }\n    /**\n     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n     *\n     * For example:\n     *\n     * \t\twalker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n     * \t\twalker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]\n     * \t\twalker.skip( value => false ); // Do not move the position.\n     *\n     * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n     * return `true` if the value should be skipped or `false` if not.\n     */\n    skip(skip) {\n        let done, value, prevPosition;\n        do {\n            prevPosition = this.position;\n            ({ done, value } = this.next());\n        } while (!done && skip(value));\n        if (!done) {\n            this.position = prevPosition;\n        }\n    }\n    /**\n     * Gets the next tree walker's value.\n     *\n     * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning\n     * information about taken step.\n     */\n    next() {\n        if (this.direction == 'forward') {\n            return this._next();\n        }\n        else {\n            return this._previous();\n        }\n    }\n    /**\n     * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.\n     * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n     */\n    _next() {\n        let position = this.position.clone();\n        const previousPosition = this.position;\n        const parent = position.parent;\n        // We are at the end of the root.\n        if (parent.parent === null && position.offset === parent.childCount) {\n            return { done: true, value: undefined };\n        }\n        // We reached the walker boundary.\n        if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n            return { done: true, value: undefined };\n        }\n        // Get node just after current position.\n        let node;\n        // Text is a specific parent because it contains string instead of child nodes.\n        if (parent instanceof Text) {\n            if (position.isAtEnd) {\n                // Prevent returning \"elementEnd\" for Text node. Skip that value and return the next walker step.\n                this.position = Position._createAfter(parent);\n                return this._next();\n            }\n            node = parent.data[position.offset];\n        }\n        else {\n            node = parent.getChild(position.offset);\n        }\n        if (node instanceof Element) {\n            if (!this.shallow) {\n                position = new Position(node, 0);\n            }\n            else {\n                position.offset++;\n            }\n            this.position = position;\n            return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n        }\n        else if (node instanceof Text) {\n            if (this.singleCharacters) {\n                position = new Position(node, 0);\n                this.position = position;\n                return this._next();\n            }\n            else {\n                let charactersCount = node.data.length;\n                let item;\n                // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n                if (node == this._boundaryEndParent) {\n                    charactersCount = this.boundaries.end.offset;\n                    item = new TextProxy(node, 0, charactersCount);\n                    position = Position._createAfter(item);\n                }\n                else {\n                    item = new TextProxy(node, 0, node.data.length);\n                    // If not just keep moving forward.\n                    position.offset++;\n                }\n                this.position = position;\n                return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n            }\n        }\n        else if (typeof node == 'string') {\n            let textLength;\n            if (this.singleCharacters) {\n                textLength = 1;\n            }\n            else {\n                // Check if text stick out of walker range.\n                const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;\n                textLength = endOffset - position.offset;\n            }\n            const textProxy = new TextProxy(parent, position.offset, textLength);\n            position.offset += textLength;\n            this.position = position;\n            return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n        }\n        else {\n            // `node` is not set, we reached the end of current `parent`.\n            position = Position._createAfter(parent);\n            this.position = position;\n            if (this.ignoreElementEnd) {\n                return this._next();\n            }\n            else {\n                return this._formatReturnValue('elementEnd', parent, previousPosition, position);\n            }\n        }\n    }\n    /**\n     * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done True if iterator is done.\n     * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n     */\n    _previous() {\n        let position = this.position.clone();\n        const previousPosition = this.position;\n        const parent = position.parent;\n        // We are at the beginning of the root.\n        if (parent.parent === null && position.offset === 0) {\n            return { done: true, value: undefined };\n        }\n        // We reached the walker boundary.\n        if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n            return { done: true, value: undefined };\n        }\n        // Get node just before current position.\n        let node;\n        // Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.\n        if (parent instanceof Text) {\n            if (position.isAtStart) {\n                // Prevent returning \"elementStart\" for Text node. Skip that value and return the next walker step.\n                this.position = Position._createBefore(parent);\n                return this._previous();\n            }\n            node = parent.data[position.offset - 1];\n        }\n        else {\n            node = parent.getChild(position.offset - 1);\n        }\n        if (node instanceof Element) {\n            if (!this.shallow) {\n                position = new Position(node, node.childCount);\n                this.position = position;\n                if (this.ignoreElementEnd) {\n                    return this._previous();\n                }\n                else {\n                    return this._formatReturnValue('elementEnd', node, previousPosition, position);\n                }\n            }\n            else {\n                position.offset--;\n                this.position = position;\n                return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n            }\n        }\n        else if (node instanceof Text) {\n            if (this.singleCharacters) {\n                position = new Position(node, node.data.length);\n                this.position = position;\n                return this._previous();\n            }\n            else {\n                let charactersCount = node.data.length;\n                let item;\n                // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n                if (node == this._boundaryStartParent) {\n                    const offset = this.boundaries.start.offset;\n                    item = new TextProxy(node, offset, node.data.length - offset);\n                    charactersCount = item.data.length;\n                    position = Position._createBefore(item);\n                }\n                else {\n                    item = new TextProxy(node, 0, node.data.length);\n                    // If not just keep moving backward.\n                    position.offset--;\n                }\n                this.position = position;\n                return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n            }\n        }\n        else if (typeof node == 'string') {\n            let textLength;\n            if (!this.singleCharacters) {\n                // Check if text stick out of walker range.\n                const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;\n                textLength = position.offset - startOffset;\n            }\n            else {\n                textLength = 1;\n            }\n            position.offset -= textLength;\n            const textProxy = new TextProxy(parent, position.offset, textLength);\n            this.position = position;\n            return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n        }\n        else {\n            // `node` is not set, we reached the beginning of current `parent`.\n            position = Position._createBefore(parent);\n            this.position = position;\n            return this._formatReturnValue('elementStart', parent, previousPosition, position, 1);\n        }\n    }\n    /**\n     * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.\n     *\n     * @private\n     * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.\n     * @param {module:engine/view/item~Item} item Item between old and new position.\n     * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.\n     * @param {module:engine/view/position~Position} nextPosition Next position of iterator.\n     * @param {Number} [length] Length of the item.\n     * @returns {module:engine/view/treewalker~TreeWalkerValue}\n     */\n    _formatReturnValue(type, item, previousPosition, nextPosition, length) {\n        // Text is a specific parent, because contains string instead of children.\n        // Walker doesn't enter to the Text except situations when walker is iterating over every single character,\n        // or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text\n        // we move it just before or just after Text.\n        if (item instanceof TextProxy) {\n            // Position is at the end of Text.\n            if (item.offsetInText + item.data.length == item.textNode.data.length) {\n                if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {\n                    nextPosition = Position._createAfter(item.textNode);\n                    // When we change nextPosition of returned value we need also update walker current position.\n                    this.position = nextPosition;\n                }\n                else {\n                    previousPosition = Position._createAfter(item.textNode);\n                }\n            }\n            // Position is at the begining ot the text.\n            if (item.offsetInText === 0) {\n                if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {\n                    nextPosition = Position._createBefore(item.textNode);\n                    // When we change nextPosition of returned value we need also update walker current position.\n                    this.position = nextPosition;\n                }\n                else {\n                    previousPosition = Position._createBefore(item.textNode);\n                }\n            }\n        }\n        return {\n            done: false,\n            value: {\n                type,\n                item,\n                previousPosition,\n                nextPosition,\n                length\n            }\n        };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}