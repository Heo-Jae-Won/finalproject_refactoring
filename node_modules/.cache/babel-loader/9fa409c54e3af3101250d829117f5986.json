{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/model/selection\n */\nimport TypeCheckable from './typecheckable';\nimport Node from './node';\nimport Position from './position';\nimport Range from './range';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n/**\n * Selection is a set of {@link module:engine/model/range~Range ranges}. It has a direction specified by its\n * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}\n * (it can be {@link module:engine/model/selection~Selection#isBackward forward or backward}).\n * Additionally, selection may have its own attributes (think – whether text typed in in this selection\n * should have those attributes – e.g. whether you type a bolded text).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Selection extends EmitterMixin(TypeCheckable) {\n  /**\n   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n   * or creates an empty selection if no arguments were passed.\n   *\n   *\t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the given document selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst documentSelection = model.document.selection;\n   *\t\tconst selection = writer.createSelection( documentSelection );\n   *\n   *\t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates selection at the given offset in the given element.\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * Selection's constructor allow passing additional options (`'backward'`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * @param {module:engine/model/selection~Selectable} [selectable]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n  constructor() {\n    super();\n    /**\n     * Specifies whether the last added range was added as a backward or forward range.\n     *\n     * @private\n     * @type {Boolean}\n     */\n    this._lastRangeBackward = false;\n    /**\n     * Stores selection ranges.\n     *\n     * @protected\n     * @type {Array.<module:engine/model/range~Range>}\n     */\n    this._ranges = [];\n    /**\n     * List of attributes set on current selection.\n     *\n     * @protected\n     * @type {Map.<String,*>}\n     */\n    this._attrs = new Map();\n    if (arguments.length) {\n      this.setTo(...arguments);\n    }\n  }\n  /**\n   * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection\n   * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).\n   *\n   * Anchor and {@link #focus} define the direction of the selection, which is important\n   * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.\n   *\n   * Anchor is always set to the {@link module:engine/model/range~Range#start start} or\n   * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is\n   * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.\n   *\n   * May be set to `null` if there are no ranges in the selection.\n   *\n   * @see #focus\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n  get anchor() {\n    if (this._ranges.length > 0) {\n      const range = this._ranges[this._ranges.length - 1];\n      return this._lastRangeBackward ? range.end : range.start;\n    }\n    return null;\n  }\n  /**\n   * Selection focus. Focus is the position where the selection ends. If a user is making a selection\n   * by dragging the mouse, the focus is where the mouse cursor is.\n   *\n   * May be set to `null` if there are no ranges in the selection.\n   *\n   * @see #anchor\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n  get focus() {\n    if (this._ranges.length > 0) {\n      const range = this._ranges[this._ranges.length - 1];\n      return this._lastRangeBackward ? range.start : range.end;\n    }\n    return null;\n  }\n  /**\n   * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it\n   * and it is collapsed.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isCollapsed() {\n    const length = this._ranges.length;\n    if (length === 1) {\n      return this._ranges[0].isCollapsed;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Returns the number of ranges in the selection.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get rangeCount() {\n    return this._ranges.length;\n  }\n  /**\n   * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isBackward() {\n    return !this.isCollapsed && this._lastRangeBackward;\n  }\n  /**\n   * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,\n   * the same number of ranges and all ranges from one selection equal to ranges from the another selection.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection\n   * Selection to compare with.\n   * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n   */\n  isEqual(otherSelection) {\n    if (this.rangeCount != otherSelection.rangeCount) {\n      return false;\n    } else if (this.rangeCount === 0) {\n      return true;\n    }\n    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n      return false;\n    }\n    for (const thisRange of this._ranges) {\n      let found = false;\n      for (const otherRange of otherSelection._ranges) {\n        if (thisRange.isEqual(otherRange)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Returns an iterable object that iterates over copies of selection ranges.\n   *\n   * @returns {Iterable.<module:engine/model/range~Range>}\n   */\n  *getRanges() {\n    for (const range of this._ranges) {\n      yield new Range(range.start, range.end);\n    }\n  }\n  /**\n   * Returns a copy of the first range in the selection.\n   * First range is the one which {@link module:engine/model/range~Range#start start} position\n   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n   * (not to confuse with the first range added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n  getFirstRange() {\n    let first = null;\n    for (const range of this._ranges) {\n      if (!first || range.start.isBefore(first.start)) {\n        first = range;\n      }\n    }\n    return first ? new Range(first.start, first.end) : null;\n  }\n  /**\n   * Returns a copy of the last range in the selection.\n   * Last range is the one which {@link module:engine/model/range~Range#end end} position\n   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n   * recently added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n  getLastRange() {\n    let last = null;\n    for (const range of this._ranges) {\n      if (!last || range.end.isAfter(last.end)) {\n        last = range;\n      }\n    }\n    return last ? new Range(last.start, last.end) : null;\n  }\n  /**\n   * Returns the first position in the selection.\n   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n  getFirstPosition() {\n    const first = this.getFirstRange();\n    return first ? first.start.clone() : null;\n  }\n  /**\n   * Returns the last position in the selection.\n   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n  getLastPosition() {\n    const lastRange = this.getLastRange();\n    return lastRange ? lastRange.end.clone() : null;\n  }\n  /**\n   * Sets this selection's ranges and direction to the specified location based on the given\n   * {@link module:engine/model/selection~Selectable selectable}.\n   *\n   *\t\t// Removes all selection's ranges.\n   *\t\tselection.setTo( null );\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tselection.setTo( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tselection.setTo( ranges );\n   *\n   *\t\t// Sets selection to other selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tselection.setTo( otherSelection );\n   *\n   *\t\t// Sets selection to the given document selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst documentSelection = new DocumentSelection( doc );\n   *\t\tselection.setTo( documentSelection );\n   *\n   *\t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tselection.setTo( position );\n   *\n   *\t\t// Sets collapsed selection at the position of the given node and an offset.\n   *\t\tselection.setTo( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   *\t\tselection.setTo( paragraph, 'in' );\n   *\n   * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\tselection.setTo( paragraph, 'on' );\n   *\n   * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.\n   *\n   *\t\t// Sets backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n  setTo() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    let [selectable, placeOrOffset, options] = args;\n    if (typeof placeOrOffset == 'object') {\n      options = placeOrOffset;\n      placeOrOffset = undefined;\n    }\n    if (selectable === null) {\n      this._setRanges([]);\n    } else if (selectable instanceof Selection) {\n      this._setRanges(selectable.getRanges(), selectable.isBackward);\n    } else if (selectable && typeof selectable.getRanges == 'function') {\n      // We assume that the selectable is a DocumentSelection.\n      // It can't be imported here, because it would lead to circular imports.\n      this._setRanges(selectable.getRanges(), selectable.isBackward);\n    } else if (selectable instanceof Range) {\n      this._setRanges([selectable], !!options && !!options.backward);\n    } else if (selectable instanceof Position) {\n      this._setRanges([new Range(selectable)]);\n    } else if (selectable instanceof Node) {\n      const backward = !!options && !!options.backward;\n      let range;\n      if (placeOrOffset == 'in') {\n        range = Range._createIn(selectable);\n      } else if (placeOrOffset == 'on') {\n        range = Range._createOn(selectable);\n      } else if (placeOrOffset !== undefined) {\n        range = new Range(Position._createAt(selectable, placeOrOffset));\n      } else {\n        /**\n         * selection.setTo requires the second parameter when the first parameter is a node.\n         *\n         * @error model-selection-setto-required-second-parameter\n         */\n        throw new CKEditorError('model-selection-setto-required-second-parameter', [this, selectable]);\n      }\n      this._setRanges([range], backward);\n    } else if (isIterable(selectable)) {\n      // We assume that the selectable is an iterable of ranges.\n      this._setRanges(selectable, options && !!options.backward);\n    } else {\n      /**\n       * Cannot set the selection to the given place.\n       *\n       * Invalid parameters were specified when setting the selection. Common issues:\n       *\n       * * A {@link module:engine/model/textproxy~TextProxy} instance was passed instead of\n       * a real {@link module:engine/model/text~Text}.\n       * * View nodes were passed instead of model nodes.\n       * * `null`/`undefined` was passed.\n       *\n       * @error model-selection-setto-not-selectable\n       */\n      throw new CKEditorError('model-selection-setto-not-selectable', [this, selectable]);\n    }\n  }\n  /**\n   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n   * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and\n   * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.\n   *\n   * @protected\n   * @fires change:range\n   * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.\n   * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)\n   * or backward - from end to start (`true`).\n   */\n  _setRanges(newRanges) {\n    let isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const ranges = Array.from(newRanges);\n    // Check whether there is any range in new ranges set that is different than all already added ranges.\n    const anyNewRange = ranges.some(newRange => {\n      if (!(newRange instanceof Range)) {\n        /**\n         * Selection range set to an object that is not an instance of {@link module:engine/model/range~Range}.\n         *\n         * Only {@link module:engine/model/range~Range} instances can be used to set a selection.\n         * Common mistakes leading to this error are:\n         *\n         * * using DOM `Range` object,\n         * * incorrect CKEditor 5 installation with multiple `ckeditor5-engine` packages having different versions.\n         *\n         * @error model-selection-set-ranges-not-range\n         */\n        throw new CKEditorError('model-selection-set-ranges-not-range', [this, newRanges]);\n      }\n      return this._ranges.every(oldRange => {\n        return !oldRange.isEqual(newRange);\n      });\n    });\n    // Don't do anything if nothing changed.\n    if (ranges.length === this._ranges.length && !anyNewRange) {\n      return;\n    }\n    this._replaceAllRanges(ranges);\n    this._lastRangeBackward = !!isLastBackward;\n    this.fire('change:range', {\n      directChange: true\n    });\n  }\n  /**\n   * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.\n   *\n   * The location can be specified in the same form as\n   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n   *\n   * @fires change:range\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  setFocus(itemOrPosition, offset) {\n    if (this.anchor === null) {\n      /**\n       * Cannot set selection focus if there are no ranges in selection.\n       *\n       * @error model-selection-setfocus-no-ranges\n       */\n      throw new CKEditorError('model-selection-setfocus-no-ranges', [this, itemOrPosition]);\n    }\n    const newFocus = Position._createAt(itemOrPosition, offset);\n    if (newFocus.compareWith(this.focus) == 'same') {\n      return;\n    }\n    const anchor = this.anchor;\n    if (this._ranges.length) {\n      this._popRange();\n    }\n    if (newFocus.compareWith(anchor) == 'before') {\n      this._pushRange(new Range(newFocus, anchor));\n      this._lastRangeBackward = true;\n    } else {\n      this._pushRange(new Range(anchor, newFocus));\n      this._lastRangeBackward = false;\n    }\n    this.fire('change:range', {\n      directChange: true\n    });\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n  getAttribute(key) {\n    return this._attrs.get(key);\n  }\n  /**\n   * Returns iterable that iterates over this selection's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n  getAttributes() {\n    return this._attrs.entries();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n  getAttributeKeys() {\n    return this._attrs.keys();\n  }\n  /**\n   * Checks if the selection has an attribute for given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n   */\n  hasAttribute(key) {\n    return this._attrs.has(key);\n  }\n  /**\n   * Removes an attribute with given key from the selection.\n   *\n   * If given attribute was set on the selection, fires the {@link #event:change:range} event with\n   * removed attribute key.\n   *\n   * @fires change:attribute\n   * @param {String} key Key of attribute to remove.\n   */\n  removeAttribute(key) {\n    if (this.hasAttribute(key)) {\n      this._attrs.delete(key);\n      this.fire('change:attribute', {\n        attributeKeys: [key],\n        directChange: true\n      });\n    }\n  }\n  /**\n   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n   *\n   * If the attribute value has changed, fires the {@link #event:change:range} event with\n   * the attribute key.\n   *\n   * @fires change:attribute\n   * @param {String} key Key of attribute to set.\n   * @param {*} value Attribute value.\n   */\n  setAttribute(key, value) {\n    if (this.getAttribute(key) !== value) {\n      this._attrs.set(key, value);\n      this.fire('change:attribute', {\n        attributeKeys: [key],\n        directChange: true\n      });\n    }\n  }\n  /**\n   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n   * one range in the selection, and that range contains exactly one element.\n   * Returns `null` if there is no selected element.\n   *\n   * @returns {module:engine/model/element~Element|null}\n   */\n  getSelectedElement() {\n    if (this.rangeCount !== 1) {\n      return null;\n    }\n    return this.getFirstRange().getContainedElement();\n  }\n  /**\n   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n   *\n   * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n   *\n   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n   * but will not return blocks nested in other blocks.\n   *\n   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<blockQuote>\n   *\t\t\t<paragraph>b</paragraph>\n   *\t\t</blockQuote>\n   *\t\t<paragraph>c]d</paragraph>\n   *\n   * In this case the paragraph will also be returned, despite the collapsed selection:\n   *\n   *\t\t<paragraph>[]a</paragraph>\n   *\n   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n   *\n   *\t\t[<blockA></blockA>\n   *\t\t<blockB>\n   *\t\t\t<blockC></blockC>\n   *\t\t\t<blockD></blockD>\n   *\t\t</blockB>\n   *\t\t<blockE></blockE>]\n   *\n   * If the selection is inside a block all the inner blocks (A & B) are returned:\n   *\n   * \t\t<block>\n   *\t\t\t<blockA>[a</blockA>\n   * \t\t\t<blockB>b]</blockB>\n   * \t\t</block>\n   *\n   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<paragraph>b</paragraph>\n   *\t\t<paragraph>]c</paragraph> // this block will not be returned\n   *\n   * @returns {Iterable.<module:engine/model/element~Element>}\n   */\n  *getSelectedBlocks() {\n    const visited = new WeakSet();\n    for (const range of this.getRanges()) {\n      // Get start block of range in case of a collapsed range.\n      const startBlock = getParentBlock(range.start, visited);\n      if (startBlock && isTopBlockInRange(startBlock, range)) {\n        yield startBlock;\n      }\n      for (const value of range.getWalker()) {\n        const block = value.item;\n        if (value.type == 'elementEnd' && isUnvisitedTopBlock(block, visited, range)) {\n          yield block;\n        }\n      }\n      const endBlock = getParentBlock(range.end, visited);\n      // #984. Don't return the end block if the range ends right at its beginning.\n      if (endBlock && !range.end.isTouching(Position._createAt(endBlock, 0)) && isTopBlockInRange(endBlock, range)) {\n        yield endBlock;\n      }\n    }\n  }\n  /**\n   * Checks whether the selection contains the entire content of the given element. This means that selection must start\n   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n   * touching the element's end.\n   *\n   * By default, this method will check whether the entire content of the selection's current root is selected.\n   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n   *\n   * @param {module:engine/model/element~Element} [element=this.anchor.root]\n   * @returns {Boolean}\n   */\n  containsEntireContent() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.anchor.root;\n    const limitStartPosition = Position._createAt(element, 0);\n    const limitEndPosition = Position._createAt(element, 'end');\n    return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());\n  }\n  /**\n   * Adds given range to internal {@link #_ranges ranges array}. Throws an error\n   * if given range is intersecting with any range that is already stored in this selection.\n   *\n   * @protected\n   * @param {module:engine/model/range~Range} range Range to add.\n   */\n  _pushRange(range) {\n    this._checkRange(range);\n    this._ranges.push(new Range(range.start, range.end));\n  }\n  /**\n   * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.\n   *\n   * @protected\n   * @param {module:engine/model/range~Range} range Range to check.\n   */\n  _checkRange(range) {\n    for (let i = 0; i < this._ranges.length; i++) {\n      if (range.isIntersecting(this._ranges[i])) {\n        /**\n         * Trying to add a range that intersects with another range in the selection.\n         *\n         * @error model-selection-range-intersects\n         * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.\n         * @param {module:engine/model/range~Range} intersectingRange Range in the selection that intersects with `addedRange`.\n         */\n        throw new CKEditorError('model-selection-range-intersects', [this, range], {\n          addedRange: range,\n          intersectingRange: this._ranges[i]\n        });\n      }\n    }\n  }\n  /**\n   * Replaces all the ranges by the given ones.\n   * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.\n   *\n   * @param {Array.<module:engine/model/range~Range>} ranges\n   * @protected\n   */\n  _replaceAllRanges(ranges) {\n    this._removeAllRanges();\n    for (const range of ranges) {\n      this._pushRange(range);\n    }\n  }\n  /**\n   * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to\n   * ensure proper ranges removal.\n   *\n   * @protected\n   */\n  _removeAllRanges() {\n    while (this._ranges.length > 0) {\n      this._popRange();\n    }\n  }\n  /**\n   * Removes most recently added range from the selection.\n   *\n   * @protected\n   */\n  _popRange() {\n    this._ranges.pop();\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tselection.is( 'selection' ); // -> true\n *\t\tselection.is( 'model:selection' ); // -> true\n *\n *\t\tselection.is( 'view:selection' ); // -> false\n *\t\tselection.is( 'range' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nSelection.prototype.is = function (type) {\n  return type === 'selection' || type === 'model:selection';\n};\n// Checks whether the given element extends $block in the schema and has a parent (is not a root).\n// Marks it as already visited.\nfunction isUnvisitedBlock(element, visited) {\n  if (visited.has(element)) {\n    return false;\n  }\n  visited.add(element);\n  return element.root.document.model.schema.isBlock(element) && element.parent;\n}\n// Checks if the given element is a $block was not previously visited and is a top block in a range.\nfunction isUnvisitedTopBlock(element, visited, range) {\n  return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);\n}\n// Finds the lowest element in position's ancestors which is a block.\n// It will search until first ancestor that is a limit element.\n// Marks all ancestors as already visited to not include any of them later on.\nfunction getParentBlock(position, visited) {\n  const element = position.parent;\n  const schema = element.root.document.model.schema;\n  const ancestors = position.parent.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n  let hasParentLimit = false;\n  const block = ancestors.find(element => {\n    // Stop searching after first parent node that is limit element.\n    if (hasParentLimit) {\n      return false;\n    }\n    hasParentLimit = schema.isLimit(element);\n    return !hasParentLimit && isUnvisitedBlock(element, visited);\n  });\n  // Mark all ancestors of this position's parent, because find() might've stopped early and\n  // the found block may be a child of another block.\n  ancestors.forEach(element => visited.add(element));\n  return block;\n}\n// Checks if the blocks is not nested in other block inside a range.\n//\n// @param {module:engine/model/element~Element} block Block to check.\n// @param {module:engine/model/range~Range} range Range to check.\nfunction isTopBlockInRange(block, range) {\n  const parentBlock = findAncestorBlock(block);\n  if (!parentBlock) {\n    return true;\n  }\n  // Add loose flag to check as parentRange can be equal to range.\n  const isParentInRange = range.containsRange(Range._createOn(parentBlock), true);\n  return !isParentInRange;\n}\n// Returns first ancestor block of a node.\n//\n// @param {module:engine/model/node~Node} node\n// @returns {module:engine/model/node~Node|undefined}\nfunction findAncestorBlock(node) {\n  const schema = node.root.document.model.schema;\n  let parent = node.parent;\n  while (parent) {\n    if (schema.isBlock(parent)) {\n      return parent;\n    }\n    parent = parent.parent;\n  }\n}","map":{"version":3,"names":["TypeCheckable","Node","Position","Range","CKEditorError","EmitterMixin","isIterable","Selection","constructor","_lastRangeBackward","_ranges","_attrs","Map","length","setTo","anchor","range","end","start","focus","isCollapsed","rangeCount","isBackward","isEqual","otherSelection","thisRange","found","otherRange","getRanges","getFirstRange","first","isBefore","getLastRange","last","isAfter","getFirstPosition","clone","getLastPosition","lastRange","args","selectable","placeOrOffset","options","undefined","_setRanges","backward","_createIn","_createOn","_createAt","newRanges","isLastBackward","ranges","Array","from","anyNewRange","some","newRange","every","oldRange","_replaceAllRanges","fire","directChange","setFocus","itemOrPosition","offset","newFocus","compareWith","_popRange","_pushRange","getAttribute","key","get","getAttributes","entries","getAttributeKeys","keys","hasAttribute","has","removeAttribute","delete","attributeKeys","setAttribute","value","set","getSelectedElement","getContainedElement","getSelectedBlocks","visited","WeakSet","startBlock","getParentBlock","isTopBlockInRange","getWalker","block","item","type","isUnvisitedTopBlock","endBlock","isTouching","containsEntireContent","element","root","limitStartPosition","limitEndPosition","_checkRange","push","i","isIntersecting","addedRange","intersectingRange","_removeAllRanges","pop","prototype","is","isUnvisitedBlock","add","document","model","schema","isBlock","parent","position","ancestors","getAncestors","parentFirst","includeSelf","hasParentLimit","find","isLimit","forEach","parentBlock","findAncestorBlock","isParentInRange","containsRange","node"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/selection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/model/selection\n */\nimport TypeCheckable from './typecheckable';\nimport Node from './node';\nimport Position from './position';\nimport Range from './range';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n/**\n * Selection is a set of {@link module:engine/model/range~Range ranges}. It has a direction specified by its\n * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}\n * (it can be {@link module:engine/model/selection~Selection#isBackward forward or backward}).\n * Additionally, selection may have its own attributes (think – whether text typed in in this selection\n * should have those attributes – e.g. whether you type a bolded text).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Selection extends EmitterMixin(TypeCheckable) {\n    /**\n     * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n     * or creates an empty selection if no arguments were passed.\n     *\n     *\t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the given document selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst documentSelection = model.document.selection;\n     *\t\tconst selection = writer.createSelection( documentSelection );\n     *\n     *\t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates selection at the given offset in the given element.\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     * Selection's constructor allow passing additional options (`'backward'`) as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * @param {module:engine/model/selection~Selectable} [selectable]\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Specifies whether the last added range was added as a backward or forward range.\n         *\n         * @private\n         * @type {Boolean}\n         */\n        this._lastRangeBackward = false;\n        /**\n         * Stores selection ranges.\n         *\n         * @protected\n         * @type {Array.<module:engine/model/range~Range>}\n         */\n        this._ranges = [];\n        /**\n         * List of attributes set on current selection.\n         *\n         * @protected\n         * @type {Map.<String,*>}\n         */\n        this._attrs = new Map();\n        if (args.length) {\n            this.setTo(...args);\n        }\n    }\n    /**\n     * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection\n     * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).\n     *\n     * Anchor and {@link #focus} define the direction of the selection, which is important\n     * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.\n     *\n     * Anchor is always set to the {@link module:engine/model/range~Range#start start} or\n     * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is\n     * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.\n     *\n     * May be set to `null` if there are no ranges in the selection.\n     *\n     * @see #focus\n     * @readonly\n     * @type {module:engine/model/position~Position|null}\n     */\n    get anchor() {\n        if (this._ranges.length > 0) {\n            const range = this._ranges[this._ranges.length - 1];\n            return this._lastRangeBackward ? range.end : range.start;\n        }\n        return null;\n    }\n    /**\n     * Selection focus. Focus is the position where the selection ends. If a user is making a selection\n     * by dragging the mouse, the focus is where the mouse cursor is.\n     *\n     * May be set to `null` if there are no ranges in the selection.\n     *\n     * @see #anchor\n     * @readonly\n     * @type {module:engine/model/position~Position|null}\n     */\n    get focus() {\n        if (this._ranges.length > 0) {\n            const range = this._ranges[this._ranges.length - 1];\n            return this._lastRangeBackward ? range.start : range.end;\n        }\n        return null;\n    }\n    /**\n     * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it\n     * and it is collapsed.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isCollapsed() {\n        const length = this._ranges.length;\n        if (length === 1) {\n            return this._ranges[0].isCollapsed;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Returns the number of ranges in the selection.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get rangeCount() {\n        return this._ranges.length;\n    }\n    /**\n     * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isBackward() {\n        return !this.isCollapsed && this._lastRangeBackward;\n    }\n    /**\n     * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,\n     * the same number of ranges and all ranges from one selection equal to ranges from the another selection.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n     */\n    isEqual(otherSelection) {\n        if (this.rangeCount != otherSelection.rangeCount) {\n            return false;\n        }\n        else if (this.rangeCount === 0) {\n            return true;\n        }\n        if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n            return false;\n        }\n        for (const thisRange of this._ranges) {\n            let found = false;\n            for (const otherRange of otherSelection._ranges) {\n                if (thisRange.isEqual(otherRange)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns an iterable object that iterates over copies of selection ranges.\n     *\n     * @returns {Iterable.<module:engine/model/range~Range>}\n     */\n    *getRanges() {\n        for (const range of this._ranges) {\n            yield new Range(range.start, range.end);\n        }\n    }\n    /**\n     * Returns a copy of the first range in the selection.\n     * First range is the one which {@link module:engine/model/range~Range#start start} position\n     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n     * (not to confuse with the first range added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n    getFirstRange() {\n        let first = null;\n        for (const range of this._ranges) {\n            if (!first || range.start.isBefore(first.start)) {\n                first = range;\n            }\n        }\n        return first ? new Range(first.start, first.end) : null;\n    }\n    /**\n     * Returns a copy of the last range in the selection.\n     * Last range is the one which {@link module:engine/model/range~Range#end end} position\n     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n     * recently added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n    getLastRange() {\n        let last = null;\n        for (const range of this._ranges) {\n            if (!last || range.end.isAfter(last.end)) {\n                last = range;\n            }\n        }\n        return last ? new Range(last.start, last.end) : null;\n    }\n    /**\n     * Returns the first position in the selection.\n     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n    getFirstPosition() {\n        const first = this.getFirstRange();\n        return first ? first.start.clone() : null;\n    }\n    /**\n     * Returns the last position in the selection.\n     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n    getLastPosition() {\n        const lastRange = this.getLastRange();\n        return lastRange ? lastRange.end.clone() : null;\n    }\n    /**\n     * Sets this selection's ranges and direction to the specified location based on the given\n     * {@link module:engine/model/selection~Selectable selectable}.\n     *\n     *\t\t// Removes all selection's ranges.\n     *\t\tselection.setTo( null );\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tselection.setTo( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tselection.setTo( ranges );\n     *\n     *\t\t// Sets selection to other selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tselection.setTo( otherSelection );\n     *\n     *\t\t// Sets selection to the given document selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst documentSelection = new DocumentSelection( doc );\n     *\t\tselection.setTo( documentSelection );\n     *\n     *\t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tselection.setTo( position );\n     *\n     *\t\t// Sets collapsed selection at the position of the given node and an offset.\n     *\t\tselection.setTo( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     *\t\tselection.setTo( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\tselection.setTo( paragraph, 'on' );\n     *\n     * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.\n     *\n     *\t\t// Sets backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n    setTo(...args) {\n        let [selectable, placeOrOffset, options] = args;\n        if (typeof placeOrOffset == 'object') {\n            options = placeOrOffset;\n            placeOrOffset = undefined;\n        }\n        if (selectable === null) {\n            this._setRanges([]);\n        }\n        else if (selectable instanceof Selection) {\n            this._setRanges(selectable.getRanges(), selectable.isBackward);\n        }\n        else if (selectable && typeof selectable.getRanges == 'function') {\n            // We assume that the selectable is a DocumentSelection.\n            // It can't be imported here, because it would lead to circular imports.\n            this._setRanges(selectable.getRanges(), selectable.isBackward);\n        }\n        else if (selectable instanceof Range) {\n            this._setRanges([selectable], !!options && !!options.backward);\n        }\n        else if (selectable instanceof Position) {\n            this._setRanges([new Range(selectable)]);\n        }\n        else if (selectable instanceof Node) {\n            const backward = !!options && !!options.backward;\n            let range;\n            if (placeOrOffset == 'in') {\n                range = Range._createIn(selectable);\n            }\n            else if (placeOrOffset == 'on') {\n                range = Range._createOn(selectable);\n            }\n            else if (placeOrOffset !== undefined) {\n                range = new Range(Position._createAt(selectable, placeOrOffset));\n            }\n            else {\n                /**\n                 * selection.setTo requires the second parameter when the first parameter is a node.\n                 *\n                 * @error model-selection-setto-required-second-parameter\n                 */\n                throw new CKEditorError('model-selection-setto-required-second-parameter', [this, selectable]);\n            }\n            this._setRanges([range], backward);\n        }\n        else if (isIterable(selectable)) {\n            // We assume that the selectable is an iterable of ranges.\n            this._setRanges(selectable, options && !!options.backward);\n        }\n        else {\n            /**\n             * Cannot set the selection to the given place.\n             *\n             * Invalid parameters were specified when setting the selection. Common issues:\n             *\n             * * A {@link module:engine/model/textproxy~TextProxy} instance was passed instead of\n             * a real {@link module:engine/model/text~Text}.\n             * * View nodes were passed instead of model nodes.\n             * * `null`/`undefined` was passed.\n             *\n             * @error model-selection-setto-not-selectable\n             */\n            throw new CKEditorError('model-selection-setto-not-selectable', [this, selectable]);\n        }\n    }\n    /**\n     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n     * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and\n     * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.\n     *\n     * @protected\n     * @fires change:range\n     * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.\n     * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)\n     * or backward - from end to start (`true`).\n     */\n    _setRanges(newRanges, isLastBackward = false) {\n        const ranges = Array.from(newRanges);\n        // Check whether there is any range in new ranges set that is different than all already added ranges.\n        const anyNewRange = ranges.some(newRange => {\n            if (!(newRange instanceof Range)) {\n                /**\n                 * Selection range set to an object that is not an instance of {@link module:engine/model/range~Range}.\n                 *\n                 * Only {@link module:engine/model/range~Range} instances can be used to set a selection.\n                 * Common mistakes leading to this error are:\n                 *\n                 * * using DOM `Range` object,\n                 * * incorrect CKEditor 5 installation with multiple `ckeditor5-engine` packages having different versions.\n                 *\n                 * @error model-selection-set-ranges-not-range\n                 */\n                throw new CKEditorError('model-selection-set-ranges-not-range', [this, newRanges]);\n            }\n            return this._ranges.every(oldRange => {\n                return !oldRange.isEqual(newRange);\n            });\n        });\n        // Don't do anything if nothing changed.\n        if (ranges.length === this._ranges.length && !anyNewRange) {\n            return;\n        }\n        this._replaceAllRanges(ranges);\n        this._lastRangeBackward = !!isLastBackward;\n        this.fire('change:range', { directChange: true });\n    }\n    /**\n     * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.\n     *\n     * The location can be specified in the same form as\n     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n     *\n     * @fires change:range\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    setFocus(itemOrPosition, offset) {\n        if (this.anchor === null) {\n            /**\n             * Cannot set selection focus if there are no ranges in selection.\n             *\n             * @error model-selection-setfocus-no-ranges\n             */\n            throw new CKEditorError('model-selection-setfocus-no-ranges', [this, itemOrPosition]);\n        }\n        const newFocus = Position._createAt(itemOrPosition, offset);\n        if (newFocus.compareWith(this.focus) == 'same') {\n            return;\n        }\n        const anchor = this.anchor;\n        if (this._ranges.length) {\n            this._popRange();\n        }\n        if (newFocus.compareWith(anchor) == 'before') {\n            this._pushRange(new Range(newFocus, anchor));\n            this._lastRangeBackward = true;\n        }\n        else {\n            this._pushRange(new Range(anchor, newFocus));\n            this._lastRangeBackward = false;\n        }\n        this.fire('change:range', { directChange: true });\n    }\n    /**\n     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n     *\n     * @param {String} key Key of attribute to look for.\n     * @returns {*} Attribute value or `undefined`.\n     */\n    getAttribute(key) {\n        return this._attrs.get(key);\n    }\n    /**\n     * Returns iterable that iterates over this selection's attributes.\n     *\n     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n    getAttributes() {\n        return this._attrs.entries();\n    }\n    /**\n     * Returns iterable that iterates over this selection's attribute keys.\n     *\n     * @returns {Iterable.<String>}\n     */\n    getAttributeKeys() {\n        return this._attrs.keys();\n    }\n    /**\n     * Checks if the selection has an attribute for given key.\n     *\n     * @param {String} key Key of attribute to check.\n     * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n     */\n    hasAttribute(key) {\n        return this._attrs.has(key);\n    }\n    /**\n     * Removes an attribute with given key from the selection.\n     *\n     * If given attribute was set on the selection, fires the {@link #event:change:range} event with\n     * removed attribute key.\n     *\n     * @fires change:attribute\n     * @param {String} key Key of attribute to remove.\n     */\n    removeAttribute(key) {\n        if (this.hasAttribute(key)) {\n            this._attrs.delete(key);\n            this.fire('change:attribute', { attributeKeys: [key], directChange: true });\n        }\n    }\n    /**\n     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n     *\n     * If the attribute value has changed, fires the {@link #event:change:range} event with\n     * the attribute key.\n     *\n     * @fires change:attribute\n     * @param {String} key Key of attribute to set.\n     * @param {*} value Attribute value.\n     */\n    setAttribute(key, value) {\n        if (this.getAttribute(key) !== value) {\n            this._attrs.set(key, value);\n            this.fire('change:attribute', { attributeKeys: [key], directChange: true });\n        }\n    }\n    /**\n     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n     * one range in the selection, and that range contains exactly one element.\n     * Returns `null` if there is no selected element.\n     *\n     * @returns {module:engine/model/element~Element|null}\n     */\n    getSelectedElement() {\n        if (this.rangeCount !== 1) {\n            return null;\n        }\n        return this.getFirstRange().getContainedElement();\n    }\n    /**\n     * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n     *\n     * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n     *\n     * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n     * but will not return blocks nested in other blocks.\n     *\n     * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<blockQuote>\n     *\t\t\t<paragraph>b</paragraph>\n     *\t\t</blockQuote>\n     *\t\t<paragraph>c]d</paragraph>\n     *\n     * In this case the paragraph will also be returned, despite the collapsed selection:\n     *\n     *\t\t<paragraph>[]a</paragraph>\n     *\n     * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n     *\n     *\t\t[<blockA></blockA>\n     *\t\t<blockB>\n     *\t\t\t<blockC></blockC>\n     *\t\t\t<blockD></blockD>\n     *\t\t</blockB>\n     *\t\t<blockE></blockE>]\n     *\n     * If the selection is inside a block all the inner blocks (A & B) are returned:\n     *\n     * \t\t<block>\n     *\t\t\t<blockA>[a</blockA>\n     * \t\t\t<blockB>b]</blockB>\n     * \t\t</block>\n     *\n     * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n     * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<paragraph>b</paragraph>\n     *\t\t<paragraph>]c</paragraph> // this block will not be returned\n     *\n     * @returns {Iterable.<module:engine/model/element~Element>}\n     */\n    *getSelectedBlocks() {\n        const visited = new WeakSet();\n        for (const range of this.getRanges()) {\n            // Get start block of range in case of a collapsed range.\n            const startBlock = getParentBlock(range.start, visited);\n            if (startBlock && isTopBlockInRange(startBlock, range)) {\n                yield startBlock;\n            }\n            for (const value of range.getWalker()) {\n                const block = value.item;\n                if (value.type == 'elementEnd' && isUnvisitedTopBlock(block, visited, range)) {\n                    yield block;\n                }\n            }\n            const endBlock = getParentBlock(range.end, visited);\n            // #984. Don't return the end block if the range ends right at its beginning.\n            if (endBlock && !range.end.isTouching(Position._createAt(endBlock, 0)) && isTopBlockInRange(endBlock, range)) {\n                yield endBlock;\n            }\n        }\n    }\n    /**\n     * Checks whether the selection contains the entire content of the given element. This means that selection must start\n     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n     * touching the element's end.\n     *\n     * By default, this method will check whether the entire content of the selection's current root is selected.\n     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n     *\n     * @param {module:engine/model/element~Element} [element=this.anchor.root]\n     * @returns {Boolean}\n     */\n    containsEntireContent(element = this.anchor.root) {\n        const limitStartPosition = Position._createAt(element, 0);\n        const limitEndPosition = Position._createAt(element, 'end');\n        return limitStartPosition.isTouching(this.getFirstPosition()) &&\n            limitEndPosition.isTouching(this.getLastPosition());\n    }\n    /**\n     * Adds given range to internal {@link #_ranges ranges array}. Throws an error\n     * if given range is intersecting with any range that is already stored in this selection.\n     *\n     * @protected\n     * @param {module:engine/model/range~Range} range Range to add.\n     */\n    _pushRange(range) {\n        this._checkRange(range);\n        this._ranges.push(new Range(range.start, range.end));\n    }\n    /**\n     * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.\n     *\n     * @protected\n     * @param {module:engine/model/range~Range} range Range to check.\n     */\n    _checkRange(range) {\n        for (let i = 0; i < this._ranges.length; i++) {\n            if (range.isIntersecting(this._ranges[i])) {\n                /**\n                 * Trying to add a range that intersects with another range in the selection.\n                 *\n                 * @error model-selection-range-intersects\n                 * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.\n                 * @param {module:engine/model/range~Range} intersectingRange Range in the selection that intersects with `addedRange`.\n                 */\n                throw new CKEditorError('model-selection-range-intersects', [this, range], { addedRange: range, intersectingRange: this._ranges[i] });\n            }\n        }\n    }\n    /**\n     * Replaces all the ranges by the given ones.\n     * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.\n     *\n     * @param {Array.<module:engine/model/range~Range>} ranges\n     * @protected\n     */\n    _replaceAllRanges(ranges) {\n        this._removeAllRanges();\n        for (const range of ranges) {\n            this._pushRange(range);\n        }\n    }\n    /**\n     * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to\n     * ensure proper ranges removal.\n     *\n     * @protected\n     */\n    _removeAllRanges() {\n        while (this._ranges.length > 0) {\n            this._popRange();\n        }\n    }\n    /**\n     * Removes most recently added range from the selection.\n     *\n     * @protected\n     */\n    _popRange() {\n        this._ranges.pop();\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tselection.is( 'selection' ); // -> true\n *\t\tselection.is( 'model:selection' ); // -> true\n *\n *\t\tselection.is( 'view:selection' ); // -> false\n *\t\tselection.is( 'range' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nSelection.prototype.is = function (type) {\n    return type === 'selection' || type === 'model:selection';\n};\n// Checks whether the given element extends $block in the schema and has a parent (is not a root).\n// Marks it as already visited.\nfunction isUnvisitedBlock(element, visited) {\n    if (visited.has(element)) {\n        return false;\n    }\n    visited.add(element);\n    return element.root.document.model.schema.isBlock(element) && element.parent;\n}\n// Checks if the given element is a $block was not previously visited and is a top block in a range.\nfunction isUnvisitedTopBlock(element, visited, range) {\n    return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);\n}\n// Finds the lowest element in position's ancestors which is a block.\n// It will search until first ancestor that is a limit element.\n// Marks all ancestors as already visited to not include any of them later on.\nfunction getParentBlock(position, visited) {\n    const element = position.parent;\n    const schema = element.root.document.model.schema;\n    const ancestors = position.parent.getAncestors({ parentFirst: true, includeSelf: true });\n    let hasParentLimit = false;\n    const block = ancestors.find(element => {\n        // Stop searching after first parent node that is limit element.\n        if (hasParentLimit) {\n            return false;\n        }\n        hasParentLimit = schema.isLimit(element);\n        return !hasParentLimit && isUnvisitedBlock(element, visited);\n    });\n    // Mark all ancestors of this position's parent, because find() might've stopped early and\n    // the found block may be a child of another block.\n    ancestors.forEach(element => visited.add(element));\n    return block;\n}\n// Checks if the blocks is not nested in other block inside a range.\n//\n// @param {module:engine/model/element~Element} block Block to check.\n// @param {module:engine/model/range~Range} range Range to check.\nfunction isTopBlockInRange(block, range) {\n    const parentBlock = findAncestorBlock(block);\n    if (!parentBlock) {\n        return true;\n    }\n    // Add loose flag to check as parentRange can be equal to range.\n    const isParentInRange = range.containsRange(Range._createOn(parentBlock), true);\n    return !isParentInRange;\n}\n// Returns first ancestor block of a node.\n//\n// @param {module:engine/model/node~Node} node\n// @returns {module:engine/model/node~Node|undefined}\nfunction findAncestorBlock(node) {\n    const schema = node.root.document.model.schema;\n    let parent = node.parent;\n    while (parent) {\n        if (schema.isBlock(parent)) {\n            return parent;\n        }\n        parent = parent.parent;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,aAAa,MAAM,6CAA6C;AACvE,OAAOC,YAAY,MAAM,4CAA4C;AACrE,OAAOC,UAAU,MAAM,0CAA0C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,SAAS,SAASF,YAAY,CAACL,aAAa,CAAC,CAAC;EAC/D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,WAAW,GAAU;IACjB,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,MAAM,GAAG,IAAIC,GAAG,EAAE;IACvB,IAAI,UAAKC,MAAM,EAAE;MACb,IAAI,CAACC,KAAK,CAAC,YAAO,CAAC;IACvB;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,MAAM,GAAG;IACT,IAAI,IAAI,CAACL,OAAO,CAACG,MAAM,GAAG,CAAC,EAAE;MACzB,MAAMG,KAAK,GAAG,IAAI,CAACN,OAAO,CAAC,IAAI,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC;MACnD,OAAO,IAAI,CAACJ,kBAAkB,GAAGO,KAAK,CAACC,GAAG,GAAGD,KAAK,CAACE,KAAK;IAC5D;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,KAAK,GAAG;IACR,IAAI,IAAI,CAACT,OAAO,CAACG,MAAM,GAAG,CAAC,EAAE;MACzB,MAAMG,KAAK,GAAG,IAAI,CAACN,OAAO,CAAC,IAAI,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC;MACnD,OAAO,IAAI,CAACJ,kBAAkB,GAAGO,KAAK,CAACE,KAAK,GAAGF,KAAK,CAACC,GAAG;IAC5D;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIG,WAAW,GAAG;IACd,MAAMP,MAAM,GAAG,IAAI,CAACH,OAAO,CAACG,MAAM;IAClC,IAAIA,MAAM,KAAK,CAAC,EAAE;MACd,OAAO,IAAI,CAACH,OAAO,CAAC,CAAC,CAAC,CAACU,WAAW;IACtC,CAAC,MACI;MACD,OAAO,KAAK;IAChB;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAG;IACb,OAAO,IAAI,CAACX,OAAO,CAACG,MAAM;EAC9B;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIS,UAAU,GAAG;IACb,OAAO,CAAC,IAAI,CAACF,WAAW,IAAI,IAAI,CAACX,kBAAkB;EACvD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIc,OAAO,CAACC,cAAc,EAAE;IACpB,IAAI,IAAI,CAACH,UAAU,IAAIG,cAAc,CAACH,UAAU,EAAE;MAC9C,OAAO,KAAK;IAChB,CAAC,MACI,IAAI,IAAI,CAACA,UAAU,KAAK,CAAC,EAAE;MAC5B,OAAO,IAAI;IACf;IACA,IAAI,CAAC,IAAI,CAACN,MAAM,CAACQ,OAAO,CAACC,cAAc,CAACT,MAAM,CAAC,IAAI,CAAC,IAAI,CAACI,KAAK,CAACI,OAAO,CAACC,cAAc,CAACL,KAAK,CAAC,EAAE;MAC1F,OAAO,KAAK;IAChB;IACA,KAAK,MAAMM,SAAS,IAAI,IAAI,CAACf,OAAO,EAAE;MAClC,IAAIgB,KAAK,GAAG,KAAK;MACjB,KAAK,MAAMC,UAAU,IAAIH,cAAc,CAACd,OAAO,EAAE;QAC7C,IAAIe,SAAS,CAACF,OAAO,CAACI,UAAU,CAAC,EAAE;UAC/BD,KAAK,GAAG,IAAI;UACZ;QACJ;MACJ;MACA,IAAI,CAACA,KAAK,EAAE;QACR,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;EACI,CAACE,SAAS,GAAG;IACT,KAAK,MAAMZ,KAAK,IAAI,IAAI,CAACN,OAAO,EAAE;MAC9B,MAAM,IAAIP,KAAK,CAACa,KAAK,CAACE,KAAK,EAAEF,KAAK,CAACC,GAAG,CAAC;IAC3C;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIY,aAAa,GAAG;IACZ,IAAIC,KAAK,GAAG,IAAI;IAChB,KAAK,MAAMd,KAAK,IAAI,IAAI,CAACN,OAAO,EAAE;MAC9B,IAAI,CAACoB,KAAK,IAAId,KAAK,CAACE,KAAK,CAACa,QAAQ,CAACD,KAAK,CAACZ,KAAK,CAAC,EAAE;QAC7CY,KAAK,GAAGd,KAAK;MACjB;IACJ;IACA,OAAOc,KAAK,GAAG,IAAI3B,KAAK,CAAC2B,KAAK,CAACZ,KAAK,EAAEY,KAAK,CAACb,GAAG,CAAC,GAAG,IAAI;EAC3D;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIe,YAAY,GAAG;IACX,IAAIC,IAAI,GAAG,IAAI;IACf,KAAK,MAAMjB,KAAK,IAAI,IAAI,CAACN,OAAO,EAAE;MAC9B,IAAI,CAACuB,IAAI,IAAIjB,KAAK,CAACC,GAAG,CAACiB,OAAO,CAACD,IAAI,CAAChB,GAAG,CAAC,EAAE;QACtCgB,IAAI,GAAGjB,KAAK;MAChB;IACJ;IACA,OAAOiB,IAAI,GAAG,IAAI9B,KAAK,CAAC8B,IAAI,CAACf,KAAK,EAAEe,IAAI,CAAChB,GAAG,CAAC,GAAG,IAAI;EACxD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkB,gBAAgB,GAAG;IACf,MAAML,KAAK,GAAG,IAAI,CAACD,aAAa,EAAE;IAClC,OAAOC,KAAK,GAAGA,KAAK,CAACZ,KAAK,CAACkB,KAAK,EAAE,GAAG,IAAI;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,eAAe,GAAG;IACd,MAAMC,SAAS,GAAG,IAAI,CAACN,YAAY,EAAE;IACrC,OAAOM,SAAS,GAAGA,SAAS,CAACrB,GAAG,CAACmB,KAAK,EAAE,GAAG,IAAI;EACnD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItB,KAAK,GAAU;IAAA,kCAANyB,IAAI;MAAJA,IAAI;IAAA;IACT,IAAI,CAACC,UAAU,EAAEC,aAAa,EAAEC,OAAO,CAAC,GAAGH,IAAI;IAC/C,IAAI,OAAOE,aAAa,IAAI,QAAQ,EAAE;MAClCC,OAAO,GAAGD,aAAa;MACvBA,aAAa,GAAGE,SAAS;IAC7B;IACA,IAAIH,UAAU,KAAK,IAAI,EAAE;MACrB,IAAI,CAACI,UAAU,CAAC,EAAE,CAAC;IACvB,CAAC,MACI,IAAIJ,UAAU,YAAYjC,SAAS,EAAE;MACtC,IAAI,CAACqC,UAAU,CAACJ,UAAU,CAACZ,SAAS,EAAE,EAAEY,UAAU,CAAClB,UAAU,CAAC;IAClE,CAAC,MACI,IAAIkB,UAAU,IAAI,OAAOA,UAAU,CAACZ,SAAS,IAAI,UAAU,EAAE;MAC9D;MACA;MACA,IAAI,CAACgB,UAAU,CAACJ,UAAU,CAACZ,SAAS,EAAE,EAAEY,UAAU,CAAClB,UAAU,CAAC;IAClE,CAAC,MACI,IAAIkB,UAAU,YAAYrC,KAAK,EAAE;MAClC,IAAI,CAACyC,UAAU,CAAC,CAACJ,UAAU,CAAC,EAAE,CAAC,CAACE,OAAO,IAAI,CAAC,CAACA,OAAO,CAACG,QAAQ,CAAC;IAClE,CAAC,MACI,IAAIL,UAAU,YAAYtC,QAAQ,EAAE;MACrC,IAAI,CAAC0C,UAAU,CAAC,CAAC,IAAIzC,KAAK,CAACqC,UAAU,CAAC,CAAC,CAAC;IAC5C,CAAC,MACI,IAAIA,UAAU,YAAYvC,IAAI,EAAE;MACjC,MAAM4C,QAAQ,GAAG,CAAC,CAACH,OAAO,IAAI,CAAC,CAACA,OAAO,CAACG,QAAQ;MAChD,IAAI7B,KAAK;MACT,IAAIyB,aAAa,IAAI,IAAI,EAAE;QACvBzB,KAAK,GAAGb,KAAK,CAAC2C,SAAS,CAACN,UAAU,CAAC;MACvC,CAAC,MACI,IAAIC,aAAa,IAAI,IAAI,EAAE;QAC5BzB,KAAK,GAAGb,KAAK,CAAC4C,SAAS,CAACP,UAAU,CAAC;MACvC,CAAC,MACI,IAAIC,aAAa,KAAKE,SAAS,EAAE;QAClC3B,KAAK,GAAG,IAAIb,KAAK,CAACD,QAAQ,CAAC8C,SAAS,CAACR,UAAU,EAAEC,aAAa,CAAC,CAAC;MACpE,CAAC,MACI;QACD;AAChB;AACA;AACA;AACA;QACgB,MAAM,IAAIrC,aAAa,CAAC,iDAAiD,EAAE,CAAC,IAAI,EAAEoC,UAAU,CAAC,CAAC;MAClG;MACA,IAAI,CAACI,UAAU,CAAC,CAAC5B,KAAK,CAAC,EAAE6B,QAAQ,CAAC;IACtC,CAAC,MACI,IAAIvC,UAAU,CAACkC,UAAU,CAAC,EAAE;MAC7B;MACA,IAAI,CAACI,UAAU,CAACJ,UAAU,EAAEE,OAAO,IAAI,CAAC,CAACA,OAAO,CAACG,QAAQ,CAAC;IAC9D,CAAC,MACI;MACD;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACY,MAAM,IAAIzC,aAAa,CAAC,sCAAsC,EAAE,CAAC,IAAI,EAAEoC,UAAU,CAAC,CAAC;IACvF;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,UAAU,CAACK,SAAS,EAA0B;IAAA,IAAxBC,cAAc,uEAAG,KAAK;IACxC,MAAMC,MAAM,GAAGC,KAAK,CAACC,IAAI,CAACJ,SAAS,CAAC;IACpC;IACA,MAAMK,WAAW,GAAGH,MAAM,CAACI,IAAI,CAACC,QAAQ,IAAI;MACxC,IAAI,EAAEA,QAAQ,YAAYrD,KAAK,CAAC,EAAE;QAC9B;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACgB,MAAM,IAAIC,aAAa,CAAC,sCAAsC,EAAE,CAAC,IAAI,EAAE6C,SAAS,CAAC,CAAC;MACtF;MACA,OAAO,IAAI,CAACvC,OAAO,CAAC+C,KAAK,CAACC,QAAQ,IAAI;QAClC,OAAO,CAACA,QAAQ,CAACnC,OAAO,CAACiC,QAAQ,CAAC;MACtC,CAAC,CAAC;IACN,CAAC,CAAC;IACF;IACA,IAAIL,MAAM,CAACtC,MAAM,KAAK,IAAI,CAACH,OAAO,CAACG,MAAM,IAAI,CAACyC,WAAW,EAAE;MACvD;IACJ;IACA,IAAI,CAACK,iBAAiB,CAACR,MAAM,CAAC;IAC9B,IAAI,CAAC1C,kBAAkB,GAAG,CAAC,CAACyC,cAAc;IAC1C,IAAI,CAACU,IAAI,CAAC,cAAc,EAAE;MAAEC,YAAY,EAAE;IAAK,CAAC,CAAC;EACrD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQ,CAACC,cAAc,EAAEC,MAAM,EAAE;IAC7B,IAAI,IAAI,CAACjD,MAAM,KAAK,IAAI,EAAE;MACtB;AACZ;AACA;AACA;AACA;MACY,MAAM,IAAIX,aAAa,CAAC,oCAAoC,EAAE,CAAC,IAAI,EAAE2D,cAAc,CAAC,CAAC;IACzF;IACA,MAAME,QAAQ,GAAG/D,QAAQ,CAAC8C,SAAS,CAACe,cAAc,EAAEC,MAAM,CAAC;IAC3D,IAAIC,QAAQ,CAACC,WAAW,CAAC,IAAI,CAAC/C,KAAK,CAAC,IAAI,MAAM,EAAE;MAC5C;IACJ;IACA,MAAMJ,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAI,IAAI,CAACL,OAAO,CAACG,MAAM,EAAE;MACrB,IAAI,CAACsD,SAAS,EAAE;IACpB;IACA,IAAIF,QAAQ,CAACC,WAAW,CAACnD,MAAM,CAAC,IAAI,QAAQ,EAAE;MAC1C,IAAI,CAACqD,UAAU,CAAC,IAAIjE,KAAK,CAAC8D,QAAQ,EAAElD,MAAM,CAAC,CAAC;MAC5C,IAAI,CAACN,kBAAkB,GAAG,IAAI;IAClC,CAAC,MACI;MACD,IAAI,CAAC2D,UAAU,CAAC,IAAIjE,KAAK,CAACY,MAAM,EAAEkD,QAAQ,CAAC,CAAC;MAC5C,IAAI,CAACxD,kBAAkB,GAAG,KAAK;IACnC;IACA,IAAI,CAACmD,IAAI,CAAC,cAAc,EAAE;MAAEC,YAAY,EAAE;IAAK,CAAC,CAAC;EACrD;EACA;AACJ;AACA;AACA;AACA;AACA;EACIQ,YAAY,CAACC,GAAG,EAAE;IACd,OAAO,IAAI,CAAC3D,MAAM,CAAC4D,GAAG,CAACD,GAAG,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,aAAa,GAAG;IACZ,OAAO,IAAI,CAAC7D,MAAM,CAAC8D,OAAO,EAAE;EAChC;EACA;AACJ;AACA;AACA;AACA;EACIC,gBAAgB,GAAG;IACf,OAAO,IAAI,CAAC/D,MAAM,CAACgE,IAAI,EAAE;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACN,GAAG,EAAE;IACd,OAAO,IAAI,CAAC3D,MAAM,CAACkE,GAAG,CAACP,GAAG,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,eAAe,CAACR,GAAG,EAAE;IACjB,IAAI,IAAI,CAACM,YAAY,CAACN,GAAG,CAAC,EAAE;MACxB,IAAI,CAAC3D,MAAM,CAACoE,MAAM,CAACT,GAAG,CAAC;MACvB,IAAI,CAACV,IAAI,CAAC,kBAAkB,EAAE;QAAEoB,aAAa,EAAE,CAACV,GAAG,CAAC;QAAET,YAAY,EAAE;MAAK,CAAC,CAAC;IAC/E;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoB,YAAY,CAACX,GAAG,EAAEY,KAAK,EAAE;IACrB,IAAI,IAAI,CAACb,YAAY,CAACC,GAAG,CAAC,KAAKY,KAAK,EAAE;MAClC,IAAI,CAACvE,MAAM,CAACwE,GAAG,CAACb,GAAG,EAAEY,KAAK,CAAC;MAC3B,IAAI,CAACtB,IAAI,CAAC,kBAAkB,EAAE;QAAEoB,aAAa,EAAE,CAACV,GAAG,CAAC;QAAET,YAAY,EAAE;MAAK,CAAC,CAAC;IAC/E;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIuB,kBAAkB,GAAG;IACjB,IAAI,IAAI,CAAC/D,UAAU,KAAK,CAAC,EAAE;MACvB,OAAO,IAAI;IACf;IACA,OAAO,IAAI,CAACQ,aAAa,EAAE,CAACwD,mBAAmB,EAAE;EACrD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAACC,iBAAiB,GAAG;IACjB,MAAMC,OAAO,GAAG,IAAIC,OAAO,EAAE;IAC7B,KAAK,MAAMxE,KAAK,IAAI,IAAI,CAACY,SAAS,EAAE,EAAE;MAClC;MACA,MAAM6D,UAAU,GAAGC,cAAc,CAAC1E,KAAK,CAACE,KAAK,EAAEqE,OAAO,CAAC;MACvD,IAAIE,UAAU,IAAIE,iBAAiB,CAACF,UAAU,EAAEzE,KAAK,CAAC,EAAE;QACpD,MAAMyE,UAAU;MACpB;MACA,KAAK,MAAMP,KAAK,IAAIlE,KAAK,CAAC4E,SAAS,EAAE,EAAE;QACnC,MAAMC,KAAK,GAAGX,KAAK,CAACY,IAAI;QACxB,IAAIZ,KAAK,CAACa,IAAI,IAAI,YAAY,IAAIC,mBAAmB,CAACH,KAAK,EAAEN,OAAO,EAAEvE,KAAK,CAAC,EAAE;UAC1E,MAAM6E,KAAK;QACf;MACJ;MACA,MAAMI,QAAQ,GAAGP,cAAc,CAAC1E,KAAK,CAACC,GAAG,EAAEsE,OAAO,CAAC;MACnD;MACA,IAAIU,QAAQ,IAAI,CAACjF,KAAK,CAACC,GAAG,CAACiF,UAAU,CAAChG,QAAQ,CAAC8C,SAAS,CAACiD,QAAQ,EAAE,CAAC,CAAC,CAAC,IAAIN,iBAAiB,CAACM,QAAQ,EAAEjF,KAAK,CAAC,EAAE;QAC1G,MAAMiF,QAAQ;MAClB;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,qBAAqB,GAA6B;IAAA,IAA5BC,OAAO,uEAAG,IAAI,CAACrF,MAAM,CAACsF,IAAI;IAC5C,MAAMC,kBAAkB,GAAGpG,QAAQ,CAAC8C,SAAS,CAACoD,OAAO,EAAE,CAAC,CAAC;IACzD,MAAMG,gBAAgB,GAAGrG,QAAQ,CAAC8C,SAAS,CAACoD,OAAO,EAAE,KAAK,CAAC;IAC3D,OAAOE,kBAAkB,CAACJ,UAAU,CAAC,IAAI,CAAC/D,gBAAgB,EAAE,CAAC,IACzDoE,gBAAgB,CAACL,UAAU,CAAC,IAAI,CAAC7D,eAAe,EAAE,CAAC;EAC3D;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI+B,UAAU,CAACpD,KAAK,EAAE;IACd,IAAI,CAACwF,WAAW,CAACxF,KAAK,CAAC;IACvB,IAAI,CAACN,OAAO,CAAC+F,IAAI,CAAC,IAAItG,KAAK,CAACa,KAAK,CAACE,KAAK,EAAEF,KAAK,CAACC,GAAG,CAAC,CAAC;EACxD;EACA;AACJ;AACA;AACA;AACA;AACA;EACIuF,WAAW,CAACxF,KAAK,EAAE;IACf,KAAK,IAAI0F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChG,OAAO,CAACG,MAAM,EAAE6F,CAAC,EAAE,EAAE;MAC1C,IAAI1F,KAAK,CAAC2F,cAAc,CAAC,IAAI,CAACjG,OAAO,CAACgG,CAAC,CAAC,CAAC,EAAE;QACvC;AAChB;AACA;AACA;AACA;AACA;AACA;QACgB,MAAM,IAAItG,aAAa,CAAC,kCAAkC,EAAE,CAAC,IAAI,EAAEY,KAAK,CAAC,EAAE;UAAE4F,UAAU,EAAE5F,KAAK;UAAE6F,iBAAiB,EAAE,IAAI,CAACnG,OAAO,CAACgG,CAAC;QAAE,CAAC,CAAC;MACzI;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI/C,iBAAiB,CAACR,MAAM,EAAE;IACtB,IAAI,CAAC2D,gBAAgB,EAAE;IACvB,KAAK,MAAM9F,KAAK,IAAImC,MAAM,EAAE;MACxB,IAAI,CAACiB,UAAU,CAACpD,KAAK,CAAC;IAC1B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI8F,gBAAgB,GAAG;IACf,OAAO,IAAI,CAACpG,OAAO,CAACG,MAAM,GAAG,CAAC,EAAE;MAC5B,IAAI,CAACsD,SAAS,EAAE;IACpB;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIA,SAAS,GAAG;IACR,IAAI,CAACzD,OAAO,CAACqG,GAAG,EAAE;EACtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxG,SAAS,CAACyG,SAAS,CAACC,EAAE,GAAG,UAAUlB,IAAI,EAAE;EACrC,OAAOA,IAAI,KAAK,WAAW,IAAIA,IAAI,KAAK,iBAAiB;AAC7D,CAAC;AACD;AACA;AACA,SAASmB,gBAAgB,CAACd,OAAO,EAAEb,OAAO,EAAE;EACxC,IAAIA,OAAO,CAACV,GAAG,CAACuB,OAAO,CAAC,EAAE;IACtB,OAAO,KAAK;EAChB;EACAb,OAAO,CAAC4B,GAAG,CAACf,OAAO,CAAC;EACpB,OAAOA,OAAO,CAACC,IAAI,CAACe,QAAQ,CAACC,KAAK,CAACC,MAAM,CAACC,OAAO,CAACnB,OAAO,CAAC,IAAIA,OAAO,CAACoB,MAAM;AAChF;AACA;AACA,SAASxB,mBAAmB,CAACI,OAAO,EAAEb,OAAO,EAAEvE,KAAK,EAAE;EAClD,OAAOkG,gBAAgB,CAACd,OAAO,EAAEb,OAAO,CAAC,IAAII,iBAAiB,CAACS,OAAO,EAAEpF,KAAK,CAAC;AAClF;AACA;AACA;AACA;AACA,SAAS0E,cAAc,CAAC+B,QAAQ,EAAElC,OAAO,EAAE;EACvC,MAAMa,OAAO,GAAGqB,QAAQ,CAACD,MAAM;EAC/B,MAAMF,MAAM,GAAGlB,OAAO,CAACC,IAAI,CAACe,QAAQ,CAACC,KAAK,CAACC,MAAM;EACjD,MAAMI,SAAS,GAAGD,QAAQ,CAACD,MAAM,CAACG,YAAY,CAAC;IAAEC,WAAW,EAAE,IAAI;IAAEC,WAAW,EAAE;EAAK,CAAC,CAAC;EACxF,IAAIC,cAAc,GAAG,KAAK;EAC1B,MAAMjC,KAAK,GAAG6B,SAAS,CAACK,IAAI,CAAC3B,OAAO,IAAI;IACpC;IACA,IAAI0B,cAAc,EAAE;MAChB,OAAO,KAAK;IAChB;IACAA,cAAc,GAAGR,MAAM,CAACU,OAAO,CAAC5B,OAAO,CAAC;IACxC,OAAO,CAAC0B,cAAc,IAAIZ,gBAAgB,CAACd,OAAO,EAAEb,OAAO,CAAC;EAChE,CAAC,CAAC;EACF;EACA;EACAmC,SAAS,CAACO,OAAO,CAAC7B,OAAO,IAAIb,OAAO,CAAC4B,GAAG,CAACf,OAAO,CAAC,CAAC;EAClD,OAAOP,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA,SAASF,iBAAiB,CAACE,KAAK,EAAE7E,KAAK,EAAE;EACrC,MAAMkH,WAAW,GAAGC,iBAAiB,CAACtC,KAAK,CAAC;EAC5C,IAAI,CAACqC,WAAW,EAAE;IACd,OAAO,IAAI;EACf;EACA;EACA,MAAME,eAAe,GAAGpH,KAAK,CAACqH,aAAa,CAAClI,KAAK,CAAC4C,SAAS,CAACmF,WAAW,CAAC,EAAE,IAAI,CAAC;EAC/E,OAAO,CAACE,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAASD,iBAAiB,CAACG,IAAI,EAAE;EAC7B,MAAMhB,MAAM,GAAGgB,IAAI,CAACjC,IAAI,CAACe,QAAQ,CAACC,KAAK,CAACC,MAAM;EAC9C,IAAIE,MAAM,GAAGc,IAAI,CAACd,MAAM;EACxB,OAAOA,MAAM,EAAE;IACX,IAAIF,MAAM,CAACC,OAAO,CAACC,MAAM,CAAC,EAAE;MACxB,OAAOA,MAAM;IACjB;IACAA,MAAM,GAAGA,MAAM,CAACA,MAAM;EAC1B;AACJ"},"metadata":{},"sourceType":"module"}