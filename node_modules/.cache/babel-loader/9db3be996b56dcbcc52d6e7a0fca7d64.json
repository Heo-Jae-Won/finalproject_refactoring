{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/stylesmap\n */\nimport { get, isObject, merge, set, unset } from 'lodash-es';\n/**\n * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).\n *\n * The styles map is capable of normalizing style names so e.g. the following operations are possible:\n */\nexport default class StylesMap {\n  /**\n   * Creates Styles instance.\n   *\n   * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor\n   */\n  constructor(styleProcessor) {\n    /**\n     * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and\n     * value access model using lodash's get, set, unset, etc methods.\n     *\n     * When no style processor rules are defined it acts as simple key-value storage.\n     *\n     * @private\n     * @type {Object}\n     */\n    this._styles = {};\n    /**\n     * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.\n     *\n     * @private\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n    this._styleProcessor = styleProcessor;\n  }\n  /**\n   * Returns true if style map has no styles set.\n   *\n   * @type {Boolean}\n   */\n  get isEmpty() {\n    const entries = Object.entries(this._styles);\n    const from = Array.from(entries);\n    return !from.length;\n  }\n  /**\n   * Number of styles defined.\n   *\n   * @type {Number}\n   */\n  get size() {\n    if (this.isEmpty) {\n      return 0;\n    }\n    return this.getStyleNames().length;\n  }\n  /**\n   * Set styles map to a new value.\n   *\n   *\t\tstyles.setTo( 'border:1px solid blue;margin-top:1px;' );\n   *\n   * @param {String} inlineStyle\n   */\n  setTo(inlineStyle) {\n    this.clear();\n    const parsedStyles = Array.from(parseInlineStyles(inlineStyle).entries());\n    for (const [key, value] of parsedStyles) {\n      this._styleProcessor.toNormalizedForm(key, value, this._styles);\n    }\n  }\n  /**\n   * Checks if a given style is set.\n   *\n   *\t\tstyles.setTo( 'margin-left:1px;' );\n   *\n   *\t\tstyles.has( 'margin-left' );    // -> true\n   *\t\tstyles.has( 'padding' );        // -> false\n   *\n   * **Note**: This check supports normalized style names.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tstyles.setTo( 'margin:2px;' );\n   *\n   *\t\tstyles.has( 'margin' );         // -> true\n   *\t\tstyles.has( 'margin-top' );     // -> true\n   *\t\tstyles.has( 'margin-left' );    // -> true\n   *\n   *\t\tstyles.remove( 'margin-top' );\n   *\n   *\t\tstyles.has( 'margin' );         // -> false\n   *\t\tstyles.has( 'margin-top' );     // -> false\n   *\t\tstyles.has( 'margin-left' );    // -> true\n   *\n   * @param {String} name Style name.\n   * @returns {Boolean}\n   */\n  has(name) {\n    if (this.isEmpty) {\n      return false;\n    }\n    const styles = this._styleProcessor.getReducedForm(name, this._styles);\n    const propertyDescriptor = styles.find(_ref => {\n      let [property] = _ref;\n      return property === name;\n    });\n    // Only return a value if it is set;\n    return Array.isArray(propertyDescriptor);\n  }\n  set(nameOrObject, valueOrObject) {\n    if (isObject(nameOrObject)) {\n      for (const [key, value] of Object.entries(nameOrObject)) {\n        this._styleProcessor.toNormalizedForm(key, value, this._styles);\n      }\n    } else {\n      this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);\n    }\n  }\n  /**\n   * Removes given style.\n   *\n   *\t\tstyles.setTo( 'background:#f00;margin-right:2px;' );\n   *\n   *\t\tstyles.remove( 'background' );\n   *\n   *\t\tstyles.toString();   // -> 'margin-right:2px;'\n   *\n   * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n   * enabled style processor rules} to normalize passed values.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tstyles.setTo( 'margin:1px' );\n   *\n   *\t\tstyles.remove( 'margin-top' );\n   *\t\tstyles.remove( 'margin-right' );\n   *\n   *\t\tstyles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'\n   *\n   * @param {String} name Style name.\n   */\n  remove(name) {\n    const path = toPath(name);\n    unset(this._styles, path);\n    delete this._styles[name];\n    this._cleanEmptyObjectsOnPath(path);\n  }\n  /**\n   * Returns a normalized style object or a single value.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px 2px 3em;' );\n   *\n   *\t\tstyles.getNormalized( 'margin' );\n   *\t\t// will log:\n   *\t\t// {\n   *\t\t//     top: '1px',\n   *\t\t//     right: '2px',\n   *\t\t//     bottom: '3em',\n   *\t\t//     left: '2px'     // normalized value from margin shorthand\n   *\t\t// }\n   *\n   *\t\tstyles.getNormalized( 'margin-left' ); // -> '2px'\n   *\n   * **Note**: This method will only return normalized styles if a style processor was defined.\n   *\n   * @param {String} name Style name.\n   * @returns {Object|String|undefined}\n   */\n  getNormalized(name) {\n    return this._styleProcessor.getNormalized(name, this._styles);\n  }\n  /**\n   * Returns a normalized style string. Styles are sorted by name.\n   *\n   *\t\tstyles.set( 'margin' , '1px' );\n   *\t\tstyles.set( 'background', '#f00' );\n   *\n   *\t\tstyles.toString(); // -> 'background:#f00;margin:1px;'\n   *\n   * **Note**: This method supports normalized styles if defined.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tstyles.set( 'margin' , '1px' );\n   *\t\tstyles.set( 'background', '#f00' );\n   *\t\tstyles.remove( 'margin-top' );\n   *\t\tstyles.remove( 'margin-right' );\n   *\n   *\t\tstyles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'\n   *\n   * @returns {String}\n   */\n  toString() {\n    if (this.isEmpty) {\n      return '';\n    }\n    return this._getStylesEntries().map(arr => arr.join(':')).sort().join(';') + ';';\n  }\n  /**\n   * Returns property as a value string or undefined if property is not set.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\t\tstyles.set( 'margin-bottom', '3em' );\n   *\n   *\t\tstyles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'\n   *\n   * Note, however, that all sub-values must be set for the longhand property name to return a value:\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\t\tstyles.remove( 'margin-bottom' );\n   *\n   *\t\tstyles.getAsString( 'margin' ); // -> undefined\n   *\n   * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.\n   * Instead, you should use:\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\t\tstyles.remove( 'margin-bottom' );\n   *\n   *\t\tfor ( const styleName of styles.getStyleNames() ) {\n   *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n   *\t\t}\n   *\t\t// 'margin-top', '1px'\n   *\t\t// 'margin-right', '1px'\n   *\t\t// 'margin-left', '1px'\n   *\n   * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all\n   * the currently set style values. So, if all the 4 margin values would be set\n   * the for-of loop above would yield only `'margin'`, `'1px'`:\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\n   *\t\tfor ( const styleName of styles.getStyleNames() ) {\n   *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n   *\t\t}\n   *\t\t// 'margin', '1px'\n   *\n   * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.\n   *\n   * @param {String} propertyName\n   * @returns {String|undefined}\n   */\n  getAsString(propertyName) {\n    if (this.isEmpty) {\n      return;\n    }\n    if (this._styles[propertyName] && !isObject(this._styles[propertyName])) {\n      // Try return styles set directly - values that are not parsed.\n      return this._styles[propertyName];\n    }\n    const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);\n    const propertyDescriptor = styles.find(_ref2 => {\n      let [property] = _ref2;\n      return property === propertyName;\n    });\n    // Only return a value if it is set;\n    if (Array.isArray(propertyDescriptor)) {\n      return propertyDescriptor[1];\n    }\n  }\n  /**\n   * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.\n   *\n   * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:\n   *\n   * \t\tstylesMap.setTo( 'margin: 1em' )\n   *\n   * will be expanded to:\n   *\n   * \t\t[ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]\n   *\n   * @param {Boolean} [expand=false] Expand shorthand style properties and all return equivalent style representations.\n   * @returns {Array.<String>}\n   */\n  getStyleNames() {\n    let expand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.isEmpty) {\n      return [];\n    }\n    if (expand) {\n      return this._styleProcessor.getStyleNames(this._styles);\n    }\n    const entries = this._getStylesEntries();\n    return entries.map(_ref3 => {\n      let [key] = _ref3;\n      return key;\n    });\n  }\n  /**\n   * Removes all styles.\n   */\n  clear() {\n    this._styles = {};\n  }\n  /**\n   * Returns normalized styles entries for further processing.\n   *\n   * @private\n   * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n   */\n  _getStylesEntries() {\n    const parsed = [];\n    const keys = Object.keys(this._styles);\n    for (const key of keys) {\n      parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));\n    }\n    return parsed;\n  }\n  /**\n   * Removes empty objects upon removing an entry from internal object.\n   *\n   * @param {String} path\n   * @private\n   */\n  _cleanEmptyObjectsOnPath(path) {\n    const pathParts = path.split('.');\n    const isChildPath = pathParts.length > 1;\n    if (!isChildPath) {\n      return;\n    }\n    const parentPath = pathParts.splice(0, pathParts.length - 1).join('.');\n    const parentObject = get(this._styles, parentPath);\n    if (!parentObject) {\n      return;\n    }\n    const isParentEmpty = !Array.from(Object.keys(parentObject)).length;\n    if (isParentEmpty) {\n      this.remove(parentPath);\n    }\n  }\n}\n/**\n * Style processor is responsible for writing and reading a normalized styles object.\n */\nexport class StylesProcessor {\n  /**\n   * Creates StylesProcessor instance.\n   *\n   * @private\n   */\n  constructor() {\n    this._normalizers = new Map();\n    this._extractors = new Map();\n    this._reducers = new Map();\n    this._consumables = new Map();\n  }\n  /**\n   * Parse style string value to a normalized object and appends it to styles object.\n   *\n   *\t\tconst styles = {};\n   *\n   *\t\tstylesProcessor.toNormalizedForm( 'margin', '1px', styles );\n   *\n   *\t\t// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }\n   *\n   * **Note**: To define normalizer callbacks use {@link #setNormalizer}.\n   *\n   * @param {String} name Name of style property.\n   * @param {String} propertyValue Value of style property.\n   * @param {Object} styles Object holding normalized styles.\n   */\n  toNormalizedForm(name, propertyValue, styles) {\n    if (isObject(propertyValue)) {\n      appendStyleValue(styles, toPath(name), propertyValue);\n      return;\n    }\n    if (this._normalizers.has(name)) {\n      const normalizer = this._normalizers.get(name);\n      const {\n        path,\n        value\n      } = normalizer(propertyValue);\n      appendStyleValue(styles, path, value);\n    } else {\n      appendStyleValue(styles, name, propertyValue);\n    }\n  }\n  /**\n   * Returns a normalized version of a style property.\n   *\t\tconst styles = {\n   *\t\t\tmargin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },\n   *\t\t\tbackground: { color: '#f00' }\n   *\t\t};\n   *\n   *\t\tstylesProcessor.getNormalized( 'background' );\n   *\t\t// will return: { color: '#f00' }\n   *\n   *\t\tstylesProcessor.getNormalized( 'margin-top' );\n   *\t\t// will return: '1px'\n   *\n   * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.\n   *\n   * @param {String} name Name of style property.\n   * @param {Object} styles Object holding normalized styles.\n   * @returns {*}\n   */\n  getNormalized(name, styles) {\n    if (!name) {\n      return merge({}, styles);\n    }\n    // Might be empty string.\n    if (styles[name] !== undefined) {\n      return styles[name];\n    }\n    if (this._extractors.has(name)) {\n      const extractor = this._extractors.get(name);\n      if (typeof extractor === 'string') {\n        return get(styles, extractor);\n      }\n      const value = extractor(name, styles);\n      if (value) {\n        return value;\n      }\n    }\n    return get(styles, toPath(name));\n  }\n  /**\n   * Returns a reduced form of style property form normalized object.\n   *\n   * For default margin reducer, the below code:\n   *\n   *\t\tstylesProcessor.getReducedForm( 'margin', {\n   *\t\t\tmargin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }\n   *\t\t} );\n   *\n   * will return:\n   *\n   *\t\t[\n   *\t\t\t[ 'margin', '1px 1px 2px' ]\n   *\t\t]\n   *\n   * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:\n   *\n   *\t\t[\n   *\t\t\t[ 'margin-top', '1px' ],\n   *\t\t\t[ 'margin-right', '1px' ],\n   *\t\t\t[ 'margin-bottom', '2px' ]\n   *\t\t\t// the 'left' value is missing - cannot use 'margin' shorthand.\n   *\t\t]\n   *\n   * **Note**: To define reducer callbacks use {@link #setReducer}.\n   *\n   * @param {String} name Name of style property.\n   * @param {Object} styles Object holding normalized styles.\n   * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n   */\n  getReducedForm(name, styles) {\n    const normalizedValue = this.getNormalized(name, styles);\n    // Might be empty string.\n    if (normalizedValue === undefined) {\n      return [];\n    }\n    if (this._reducers.has(name)) {\n      const reducer = this._reducers.get(name);\n      return reducer(normalizedValue);\n    }\n    return [[name, normalizedValue]];\n  }\n  /**\n   * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.\n   *\n   * @param {Object} styles Object holding normalized styles.\n   * @returns {Array.<String>}\n   */\n  getStyleNames(styles) {\n    // Find all extractable styles that have a value.\n    const expandedStyleNames = Array.from(this._consumables.keys()).filter(name => {\n      const style = this.getNormalized(name, styles);\n      if (style && typeof style == 'object') {\n        return Object.keys(style).length;\n      }\n      return style;\n    });\n    // For simple styles (for example `color`) we don't have a map of those styles\n    // but they are 1 to 1 with normalized object keys.\n    const styleNamesKeysSet = new Set([...expandedStyleNames, ...Object.keys(styles)]);\n    return Array.from(styleNamesKeysSet.values());\n  }\n  /**\n   * Returns related style names.\n   *\n   *\t\tstylesProcessor.getRelatedStyles( 'margin' );\n   *\t\t// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];\n   *\n   *\t\tstylesProcessor.getRelatedStyles( 'margin-top' );\n   *\t\t// will return: [ 'margin' ];\n   *\n   * **Note**: To define new style relations load an existing style processor or use\n   * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.\n   *\n   * @param {String} name\n   * @returns {Array.<String>}\n   */\n  getRelatedStyles(name) {\n    return this._consumables.get(name) || [];\n  }\n  /**\n   * Adds a normalizer method for a style property.\n   *\n   * A normalizer returns describing how the value should be normalized.\n   *\n   * For instance 'margin' style is a shorthand for four margin values:\n   *\n   * - 'margin-top'\n   * - 'margin-right'\n   * - 'margin-bottom'\n   * - 'margin-left'\n   *\n   * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for\n   * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.\n   *\n   * A normalizer should parse various margin notations as a single object:\n   *\n   *\t\tconst styles = {\n   *\t\t\tmargin: {\n   *\t\t\t\ttop: '1px',\n   *\t\t\t\tright: '2em',\n   *\t\t\t\tbottom: '1px',\n   *\t\t\t\tleft: '2em'\n   *\t\t\t}\n   *\t\t};\n   *\n   * Thus a normalizer for 'margin' style should return an object defining style path and value to store:\n   *\n   *\t\tconst returnValue = {\n   *\t\t\tpath: 'margin',\n   *\t\t\tvalue: {\n   *\t\t\t\ttop: '1px',\n   *\t\t\t\tright: '2em',\n   *\t\t\t\tbottom: '1px',\n   *\t\t\t\tleft: '2em'\n   *\t\t\t}\n   *\t\t};\n   *\n   * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below\n   * is an example for 'margin-top' style property normalizer:\n   *\n   *\t\tstylesProcessor.setNormalizer( 'margin-top', valueString => {\n   *\t\t\treturn {\n   *\t\t\t\tpath: 'margin.top',\n   *\t\t\t\tvalue: valueString\n   *\t\t\t}\n   *\t\t} );\n   *\n   * @param {String} name\n   * @param {Function} callback\n   */\n  setNormalizer(name, callback) {\n    this._normalizers.set(name, callback);\n  }\n  /**\n   * Adds a extractor callback for a style property.\n   *\n   * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:\n   *\n   *\t\tconst styles = {\n   *\t\t\tmargin: {\n   *\t\t\t\ttop: 'value'\n   *\t\t\t}\n   *\t\t}\n   *\n   * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance\n   * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`\n   * shorthands. The default border styles processors stores styles as:\n   *\n   *\t\tconst styles = {\n   *\t\t\tborder: {\n   *\t\t\t\tstyle: {\n   *\t\t\t\t\ttop: 'solid'\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t}\n   *\n   * as it is better to modify border style independently from other values. On the other part the output of the border might be\n   * desired as `border-top`, `border-left`, etc notation.\n   *\n   * In the above example a reducer should return a side border value that combines style, color and width:\n   *\n   *\t\tstyleProcessor.setExtractor( 'border-top', styles => {\n   *\t\t\treturn {\n   *\t\t\t\tcolor: styles.border.color.top,\n   *\t\t\t\tstyle: styles.border.style.top,\n   *\t\t\t\twidth: styles.border.width.top\n   *\t\t\t}\n   *\t\t} );\n   *\n   * @param {String} name\n   * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.\n   */\n  setExtractor(name, callbackOrPath) {\n    this._extractors.set(name, callbackOrPath);\n  }\n  /**\n   * Adds a reducer callback for a style property.\n   *\n   * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as\n   * by default the direct value from style path is taken.\n   *\n   * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples\n   * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:\n   *\n   *\t\tconst marginShortHandTuple = [\n   *\t\t\t[ 'margin', '1px 1px 2px' ]\n   *\t\t];\n   *\n   * or a longhand tuples for defined values:\n   *\n   *\t\t// Considering margin.bottom and margin.left are undefined.\n   *\t\tconst marginLonghandsTuples = [\n   *\t\t\t[ 'margin-top', '1px' ],\n   *\t\t\t[ 'margin-right', '1px' ]\n   *\t\t];\n   *\n   * A reducer obtains a normalized style value:\n   *\n   *\t\t// Simplified reducer that always outputs 4 values which are always present:\n   *\t\tstylesProcessor.setReducer( 'margin', margin => {\n   *\t\t\treturn [\n   *\t\t\t\t[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]\n   *\t\t\t]\n   *\t\t} );\n   *\n   * @param {String} name\n   * @param {Function} callback\n   */\n  setReducer(name, callback) {\n    this._reducers.set(name, callback);\n  }\n  /**\n   * Defines a style shorthand relation to other style notations.\n   *\n   *\t\tstylesProcessor.setStyleRelation( 'margin', [\n   *\t\t\t'margin-top',\n   *\t\t\t'margin-right',\n   *\t\t\t'margin-bottom',\n   *\t\t\t'margin-left'\n   *\t\t] );\n   *\n   * This enables expanding of style names for shorthands. For instance, if defined,\n   * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created\n   * for long-hand margin style notation alongside the `'margin'` item.\n   *\n   * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just\n   * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and\n   * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.\n   * However, once `margin-left` is consumed, `margin` will not be consumable anymore.\n   *\n   * @param {String} shorthandName\n   * @param {Array.<String>} styleNames\n   */\n  setStyleRelation(shorthandName, styleNames) {\n    this._mapStyleNames(shorthandName, styleNames);\n    for (const alsoName of styleNames) {\n      this._mapStyleNames(alsoName, [shorthandName]);\n    }\n  }\n  /**\n   * Set two-way binding of style names.\n   *\n   * @param {String} name\n   * @param {Array.<String>} styleNames\n   * @private\n   */\n  _mapStyleNames(name, styleNames) {\n    if (!this._consumables.has(name)) {\n      this._consumables.set(name, []);\n    }\n    this._consumables.get(name).push(...styleNames);\n  }\n}\n// Parses inline styles and puts property - value pairs into styles map.\n//\n// @param {String} stylesString Styles to parse.\n// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.\nfunction parseInlineStyles(stylesString) {\n  // `null` if no quote was found in input string or last found quote was a closing quote. See below.\n  let quoteType = null;\n  let propertyNameStart = 0;\n  let propertyValueStart = 0;\n  let propertyName = null;\n  const stylesMap = new Map();\n  // Do not set anything if input string is empty.\n  if (stylesString === '') {\n    return stylesMap;\n  }\n  // Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n  if (stylesString.charAt(stylesString.length - 1) != ';') {\n    stylesString = stylesString + ';';\n  }\n  // Seek the whole string for \"special characters\".\n  for (let i = 0; i < stylesString.length; i++) {\n    const char = stylesString.charAt(i);\n    if (quoteType === null) {\n      // No quote found yet or last found quote was a closing quote.\n      switch (char) {\n        case ':':\n          // Most of time colon means that property name just ended.\n          // Sometimes however `:` is found inside property value (for example in background image url).\n          if (!propertyName) {\n            // Treat this as end of property only if property name is not already saved.\n            // Save property name.\n            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);\n            // Save this point as the start of property value.\n            propertyValueStart = i + 1;\n          }\n          break;\n        case '\"':\n        case '\\'':\n          // Opening quote found (this is an opening quote, because `quoteType` is `null`).\n          quoteType = char;\n          break;\n        case ';':\n          {\n            // Property value just ended.\n            // Use previously stored property value start to obtain property value.\n            const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);\n            if (propertyName) {\n              // Save parsed part.\n              stylesMap.set(propertyName.trim(), propertyValue.trim());\n            }\n            propertyName = null;\n            // Save this point as property name start. Property name starts immediately after previous property value ends.\n            propertyNameStart = i + 1;\n            break;\n          }\n      }\n    } else if (char === quoteType) {\n      // If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n      quoteType = null;\n    }\n  }\n  return stylesMap;\n}\n// Return lodash compatible path from style name.\nfunction toPath(name) {\n  return name.replace('-', '.');\n}\n// Appends style definition to the styles object.\n//\n// @param {String} nameOrPath\n// @param {String|Object} valueOrObject\n// @private\nfunction appendStyleValue(stylesObject, nameOrPath, valueOrObject) {\n  let valueToSet = valueOrObject;\n  if (isObject(valueOrObject)) {\n    valueToSet = merge({}, get(stylesObject, nameOrPath), valueOrObject);\n  }\n  set(stylesObject, nameOrPath, valueToSet);\n}","map":{"version":3,"names":["get","isObject","merge","set","unset","StylesMap","constructor","styleProcessor","_styles","_styleProcessor","isEmpty","entries","Object","from","Array","length","size","getStyleNames","setTo","inlineStyle","clear","parsedStyles","parseInlineStyles","key","value","toNormalizedForm","has","name","styles","getReducedForm","propertyDescriptor","find","property","isArray","nameOrObject","valueOrObject","remove","path","toPath","_cleanEmptyObjectsOnPath","getNormalized","toString","_getStylesEntries","map","arr","join","sort","getAsString","propertyName","expand","parsed","keys","push","pathParts","split","isChildPath","parentPath","splice","parentObject","isParentEmpty","StylesProcessor","_normalizers","Map","_extractors","_reducers","_consumables","propertyValue","appendStyleValue","normalizer","undefined","extractor","normalizedValue","reducer","expandedStyleNames","filter","style","styleNamesKeysSet","Set","values","getRelatedStyles","setNormalizer","callback","setExtractor","callbackOrPath","setReducer","setStyleRelation","shorthandName","styleNames","_mapStyleNames","alsoName","stylesString","quoteType","propertyNameStart","propertyValueStart","stylesMap","charAt","i","char","substr","trim","replace","stylesObject","nameOrPath","valueToSet"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/stylesmap\n */\nimport { get, isObject, merge, set, unset } from 'lodash-es';\n/**\n * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).\n *\n * The styles map is capable of normalizing style names so e.g. the following operations are possible:\n */\nexport default class StylesMap {\n    /**\n     * Creates Styles instance.\n     *\n     * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor\n     */\n    constructor(styleProcessor) {\n        /**\n         * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and\n         * value access model using lodash's get, set, unset, etc methods.\n         *\n         * When no style processor rules are defined it acts as simple key-value storage.\n         *\n         * @private\n         * @type {Object}\n         */\n        this._styles = {};\n        /**\n         * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.\n         *\n         * @private\n         * @member {module:engine/view/stylesmap~StylesProcessor}\n         */\n        this._styleProcessor = styleProcessor;\n    }\n    /**\n     * Returns true if style map has no styles set.\n     *\n     * @type {Boolean}\n     */\n    get isEmpty() {\n        const entries = Object.entries(this._styles);\n        const from = Array.from(entries);\n        return !from.length;\n    }\n    /**\n     * Number of styles defined.\n     *\n     * @type {Number}\n     */\n    get size() {\n        if (this.isEmpty) {\n            return 0;\n        }\n        return this.getStyleNames().length;\n    }\n    /**\n     * Set styles map to a new value.\n     *\n     *\t\tstyles.setTo( 'border:1px solid blue;margin-top:1px;' );\n     *\n     * @param {String} inlineStyle\n     */\n    setTo(inlineStyle) {\n        this.clear();\n        const parsedStyles = Array.from(parseInlineStyles(inlineStyle).entries());\n        for (const [key, value] of parsedStyles) {\n            this._styleProcessor.toNormalizedForm(key, value, this._styles);\n        }\n    }\n    /**\n     * Checks if a given style is set.\n     *\n     *\t\tstyles.setTo( 'margin-left:1px;' );\n     *\n     *\t\tstyles.has( 'margin-left' );    // -> true\n     *\t\tstyles.has( 'padding' );        // -> false\n     *\n     * **Note**: This check supports normalized style names.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tstyles.setTo( 'margin:2px;' );\n     *\n     *\t\tstyles.has( 'margin' );         // -> true\n     *\t\tstyles.has( 'margin-top' );     // -> true\n     *\t\tstyles.has( 'margin-left' );    // -> true\n     *\n     *\t\tstyles.remove( 'margin-top' );\n     *\n     *\t\tstyles.has( 'margin' );         // -> false\n     *\t\tstyles.has( 'margin-top' );     // -> false\n     *\t\tstyles.has( 'margin-left' );    // -> true\n     *\n     * @param {String} name Style name.\n     * @returns {Boolean}\n     */\n    has(name) {\n        if (this.isEmpty) {\n            return false;\n        }\n        const styles = this._styleProcessor.getReducedForm(name, this._styles);\n        const propertyDescriptor = styles.find(([property]) => property === name);\n        // Only return a value if it is set;\n        return Array.isArray(propertyDescriptor);\n    }\n    set(nameOrObject, valueOrObject) {\n        if (isObject(nameOrObject)) {\n            for (const [key, value] of Object.entries(nameOrObject)) {\n                this._styleProcessor.toNormalizedForm(key, value, this._styles);\n            }\n        }\n        else {\n            this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);\n        }\n    }\n    /**\n     * Removes given style.\n     *\n     *\t\tstyles.setTo( 'background:#f00;margin-right:2px;' );\n     *\n     *\t\tstyles.remove( 'background' );\n     *\n     *\t\tstyles.toString();   // -> 'margin-right:2px;'\n     *\n     * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n     * enabled style processor rules} to normalize passed values.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tstyles.setTo( 'margin:1px' );\n     *\n     *\t\tstyles.remove( 'margin-top' );\n     *\t\tstyles.remove( 'margin-right' );\n     *\n     *\t\tstyles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'\n     *\n     * @param {String} name Style name.\n     */\n    remove(name) {\n        const path = toPath(name);\n        unset(this._styles, path);\n        delete this._styles[name];\n        this._cleanEmptyObjectsOnPath(path);\n    }\n    /**\n     * Returns a normalized style object or a single value.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px 2px 3em;' );\n     *\n     *\t\tstyles.getNormalized( 'margin' );\n     *\t\t// will log:\n     *\t\t// {\n     *\t\t//     top: '1px',\n     *\t\t//     right: '2px',\n     *\t\t//     bottom: '3em',\n     *\t\t//     left: '2px'     // normalized value from margin shorthand\n     *\t\t// }\n     *\n     *\t\tstyles.getNormalized( 'margin-left' ); // -> '2px'\n     *\n     * **Note**: This method will only return normalized styles if a style processor was defined.\n     *\n     * @param {String} name Style name.\n     * @returns {Object|String|undefined}\n     */\n    getNormalized(name) {\n        return this._styleProcessor.getNormalized(name, this._styles);\n    }\n    /**\n     * Returns a normalized style string. Styles are sorted by name.\n     *\n     *\t\tstyles.set( 'margin' , '1px' );\n     *\t\tstyles.set( 'background', '#f00' );\n     *\n     *\t\tstyles.toString(); // -> 'background:#f00;margin:1px;'\n     *\n     * **Note**: This method supports normalized styles if defined.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tstyles.set( 'margin' , '1px' );\n     *\t\tstyles.set( 'background', '#f00' );\n     *\t\tstyles.remove( 'margin-top' );\n     *\t\tstyles.remove( 'margin-right' );\n     *\n     *\t\tstyles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'\n     *\n     * @returns {String}\n     */\n    toString() {\n        if (this.isEmpty) {\n            return '';\n        }\n        return this._getStylesEntries()\n            .map(arr => arr.join(':'))\n            .sort()\n            .join(';') + ';';\n    }\n    /**\n     * Returns property as a value string or undefined if property is not set.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\t\tstyles.set( 'margin-bottom', '3em' );\n     *\n     *\t\tstyles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'\n     *\n     * Note, however, that all sub-values must be set for the longhand property name to return a value:\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\t\tstyles.remove( 'margin-bottom' );\n     *\n     *\t\tstyles.getAsString( 'margin' ); // -> undefined\n     *\n     * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.\n     * Instead, you should use:\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\t\tstyles.remove( 'margin-bottom' );\n     *\n     *\t\tfor ( const styleName of styles.getStyleNames() ) {\n     *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n     *\t\t}\n     *\t\t// 'margin-top', '1px'\n     *\t\t// 'margin-right', '1px'\n     *\t\t// 'margin-left', '1px'\n     *\n     * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all\n     * the currently set style values. So, if all the 4 margin values would be set\n     * the for-of loop above would yield only `'margin'`, `'1px'`:\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\n     *\t\tfor ( const styleName of styles.getStyleNames() ) {\n     *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n     *\t\t}\n     *\t\t// 'margin', '1px'\n     *\n     * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.\n     *\n     * @param {String} propertyName\n     * @returns {String|undefined}\n     */\n    getAsString(propertyName) {\n        if (this.isEmpty) {\n            return;\n        }\n        if (this._styles[propertyName] && !isObject(this._styles[propertyName])) {\n            // Try return styles set directly - values that are not parsed.\n            return this._styles[propertyName];\n        }\n        const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);\n        const propertyDescriptor = styles.find(([property]) => property === propertyName);\n        // Only return a value if it is set;\n        if (Array.isArray(propertyDescriptor)) {\n            return propertyDescriptor[1];\n        }\n    }\n    /**\n     * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.\n     *\n     * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:\n     *\n     * \t\tstylesMap.setTo( 'margin: 1em' )\n     *\n     * will be expanded to:\n     *\n     * \t\t[ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]\n     *\n     * @param {Boolean} [expand=false] Expand shorthand style properties and all return equivalent style representations.\n     * @returns {Array.<String>}\n     */\n    getStyleNames(expand = false) {\n        if (this.isEmpty) {\n            return [];\n        }\n        if (expand) {\n            return this._styleProcessor.getStyleNames(this._styles);\n        }\n        const entries = this._getStylesEntries();\n        return entries.map(([key]) => key);\n    }\n    /**\n     * Removes all styles.\n     */\n    clear() {\n        this._styles = {};\n    }\n    /**\n     * Returns normalized styles entries for further processing.\n     *\n     * @private\n     * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n     */\n    _getStylesEntries() {\n        const parsed = [];\n        const keys = Object.keys(this._styles);\n        for (const key of keys) {\n            parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));\n        }\n        return parsed;\n    }\n    /**\n     * Removes empty objects upon removing an entry from internal object.\n     *\n     * @param {String} path\n     * @private\n     */\n    _cleanEmptyObjectsOnPath(path) {\n        const pathParts = path.split('.');\n        const isChildPath = pathParts.length > 1;\n        if (!isChildPath) {\n            return;\n        }\n        const parentPath = pathParts.splice(0, pathParts.length - 1).join('.');\n        const parentObject = get(this._styles, parentPath);\n        if (!parentObject) {\n            return;\n        }\n        const isParentEmpty = !Array.from(Object.keys(parentObject)).length;\n        if (isParentEmpty) {\n            this.remove(parentPath);\n        }\n    }\n}\n/**\n * Style processor is responsible for writing and reading a normalized styles object.\n */\nexport class StylesProcessor {\n    /**\n     * Creates StylesProcessor instance.\n     *\n     * @private\n     */\n    constructor() {\n        this._normalizers = new Map();\n        this._extractors = new Map();\n        this._reducers = new Map();\n        this._consumables = new Map();\n    }\n    /**\n     * Parse style string value to a normalized object and appends it to styles object.\n     *\n     *\t\tconst styles = {};\n     *\n     *\t\tstylesProcessor.toNormalizedForm( 'margin', '1px', styles );\n     *\n     *\t\t// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }\n     *\n     * **Note**: To define normalizer callbacks use {@link #setNormalizer}.\n     *\n     * @param {String} name Name of style property.\n     * @param {String} propertyValue Value of style property.\n     * @param {Object} styles Object holding normalized styles.\n     */\n    toNormalizedForm(name, propertyValue, styles) {\n        if (isObject(propertyValue)) {\n            appendStyleValue(styles, toPath(name), propertyValue);\n            return;\n        }\n        if (this._normalizers.has(name)) {\n            const normalizer = this._normalizers.get(name);\n            const { path, value } = normalizer(propertyValue);\n            appendStyleValue(styles, path, value);\n        }\n        else {\n            appendStyleValue(styles, name, propertyValue);\n        }\n    }\n    /**\n     * Returns a normalized version of a style property.\n     *\t\tconst styles = {\n     *\t\t\tmargin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },\n     *\t\t\tbackground: { color: '#f00' }\n     *\t\t};\n     *\n     *\t\tstylesProcessor.getNormalized( 'background' );\n     *\t\t// will return: { color: '#f00' }\n     *\n     *\t\tstylesProcessor.getNormalized( 'margin-top' );\n     *\t\t// will return: '1px'\n     *\n     * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.\n     *\n     * @param {String} name Name of style property.\n     * @param {Object} styles Object holding normalized styles.\n     * @returns {*}\n     */\n    getNormalized(name, styles) {\n        if (!name) {\n            return merge({}, styles);\n        }\n        // Might be empty string.\n        if (styles[name] !== undefined) {\n            return styles[name];\n        }\n        if (this._extractors.has(name)) {\n            const extractor = this._extractors.get(name);\n            if (typeof extractor === 'string') {\n                return get(styles, extractor);\n            }\n            const value = extractor(name, styles);\n            if (value) {\n                return value;\n            }\n        }\n        return get(styles, toPath(name));\n    }\n    /**\n     * Returns a reduced form of style property form normalized object.\n     *\n     * For default margin reducer, the below code:\n     *\n     *\t\tstylesProcessor.getReducedForm( 'margin', {\n     *\t\t\tmargin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }\n     *\t\t} );\n     *\n     * will return:\n     *\n     *\t\t[\n     *\t\t\t[ 'margin', '1px 1px 2px' ]\n     *\t\t]\n     *\n     * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:\n     *\n     *\t\t[\n     *\t\t\t[ 'margin-top', '1px' ],\n     *\t\t\t[ 'margin-right', '1px' ],\n     *\t\t\t[ 'margin-bottom', '2px' ]\n     *\t\t\t// the 'left' value is missing - cannot use 'margin' shorthand.\n     *\t\t]\n     *\n     * **Note**: To define reducer callbacks use {@link #setReducer}.\n     *\n     * @param {String} name Name of style property.\n     * @param {Object} styles Object holding normalized styles.\n     * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n     */\n    getReducedForm(name, styles) {\n        const normalizedValue = this.getNormalized(name, styles);\n        // Might be empty string.\n        if (normalizedValue === undefined) {\n            return [];\n        }\n        if (this._reducers.has(name)) {\n            const reducer = this._reducers.get(name);\n            return reducer(normalizedValue);\n        }\n        return [[name, normalizedValue]];\n    }\n    /**\n     * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.\n     *\n     * @param {Object} styles Object holding normalized styles.\n     * @returns {Array.<String>}\n     */\n    getStyleNames(styles) {\n        // Find all extractable styles that have a value.\n        const expandedStyleNames = Array.from(this._consumables.keys()).filter(name => {\n            const style = this.getNormalized(name, styles);\n            if (style && typeof style == 'object') {\n                return Object.keys(style).length;\n            }\n            return style;\n        });\n        // For simple styles (for example `color`) we don't have a map of those styles\n        // but they are 1 to 1 with normalized object keys.\n        const styleNamesKeysSet = new Set([\n            ...expandedStyleNames,\n            ...Object.keys(styles)\n        ]);\n        return Array.from(styleNamesKeysSet.values());\n    }\n    /**\n     * Returns related style names.\n     *\n     *\t\tstylesProcessor.getRelatedStyles( 'margin' );\n     *\t\t// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];\n     *\n     *\t\tstylesProcessor.getRelatedStyles( 'margin-top' );\n     *\t\t// will return: [ 'margin' ];\n     *\n     * **Note**: To define new style relations load an existing style processor or use\n     * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.\n     *\n     * @param {String} name\n     * @returns {Array.<String>}\n     */\n    getRelatedStyles(name) {\n        return this._consumables.get(name) || [];\n    }\n    /**\n     * Adds a normalizer method for a style property.\n     *\n     * A normalizer returns describing how the value should be normalized.\n     *\n     * For instance 'margin' style is a shorthand for four margin values:\n     *\n     * - 'margin-top'\n     * - 'margin-right'\n     * - 'margin-bottom'\n     * - 'margin-left'\n     *\n     * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for\n     * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.\n     *\n     * A normalizer should parse various margin notations as a single object:\n     *\n     *\t\tconst styles = {\n     *\t\t\tmargin: {\n     *\t\t\t\ttop: '1px',\n     *\t\t\t\tright: '2em',\n     *\t\t\t\tbottom: '1px',\n     *\t\t\t\tleft: '2em'\n     *\t\t\t}\n     *\t\t};\n     *\n     * Thus a normalizer for 'margin' style should return an object defining style path and value to store:\n     *\n     *\t\tconst returnValue = {\n     *\t\t\tpath: 'margin',\n     *\t\t\tvalue: {\n     *\t\t\t\ttop: '1px',\n     *\t\t\t\tright: '2em',\n     *\t\t\t\tbottom: '1px',\n     *\t\t\t\tleft: '2em'\n     *\t\t\t}\n     *\t\t};\n     *\n     * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below\n     * is an example for 'margin-top' style property normalizer:\n     *\n     *\t\tstylesProcessor.setNormalizer( 'margin-top', valueString => {\n     *\t\t\treturn {\n     *\t\t\t\tpath: 'margin.top',\n     *\t\t\t\tvalue: valueString\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @param {String} name\n     * @param {Function} callback\n     */\n    setNormalizer(name, callback) {\n        this._normalizers.set(name, callback);\n    }\n    /**\n     * Adds a extractor callback for a style property.\n     *\n     * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:\n     *\n     *\t\tconst styles = {\n     *\t\t\tmargin: {\n     *\t\t\t\ttop: 'value'\n     *\t\t\t}\n     *\t\t}\n     *\n     * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance\n     * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`\n     * shorthands. The default border styles processors stores styles as:\n     *\n     *\t\tconst styles = {\n     *\t\t\tborder: {\n     *\t\t\t\tstyle: {\n     *\t\t\t\t\ttop: 'solid'\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t}\n     *\n     * as it is better to modify border style independently from other values. On the other part the output of the border might be\n     * desired as `border-top`, `border-left`, etc notation.\n     *\n     * In the above example a reducer should return a side border value that combines style, color and width:\n     *\n     *\t\tstyleProcessor.setExtractor( 'border-top', styles => {\n     *\t\t\treturn {\n     *\t\t\t\tcolor: styles.border.color.top,\n     *\t\t\t\tstyle: styles.border.style.top,\n     *\t\t\t\twidth: styles.border.width.top\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @param {String} name\n     * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.\n     */\n    setExtractor(name, callbackOrPath) {\n        this._extractors.set(name, callbackOrPath);\n    }\n    /**\n     * Adds a reducer callback for a style property.\n     *\n     * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as\n     * by default the direct value from style path is taken.\n     *\n     * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples\n     * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:\n     *\n     *\t\tconst marginShortHandTuple = [\n     *\t\t\t[ 'margin', '1px 1px 2px' ]\n     *\t\t];\n     *\n     * or a longhand tuples for defined values:\n     *\n     *\t\t// Considering margin.bottom and margin.left are undefined.\n     *\t\tconst marginLonghandsTuples = [\n     *\t\t\t[ 'margin-top', '1px' ],\n     *\t\t\t[ 'margin-right', '1px' ]\n     *\t\t];\n     *\n     * A reducer obtains a normalized style value:\n     *\n     *\t\t// Simplified reducer that always outputs 4 values which are always present:\n     *\t\tstylesProcessor.setReducer( 'margin', margin => {\n     *\t\t\treturn [\n     *\t\t\t\t[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]\n     *\t\t\t]\n     *\t\t} );\n     *\n     * @param {String} name\n     * @param {Function} callback\n     */\n    setReducer(name, callback) {\n        this._reducers.set(name, callback);\n    }\n    /**\n     * Defines a style shorthand relation to other style notations.\n     *\n     *\t\tstylesProcessor.setStyleRelation( 'margin', [\n     *\t\t\t'margin-top',\n     *\t\t\t'margin-right',\n     *\t\t\t'margin-bottom',\n     *\t\t\t'margin-left'\n     *\t\t] );\n     *\n     * This enables expanding of style names for shorthands. For instance, if defined,\n     * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created\n     * for long-hand margin style notation alongside the `'margin'` item.\n     *\n     * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just\n     * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and\n     * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.\n     * However, once `margin-left` is consumed, `margin` will not be consumable anymore.\n     *\n     * @param {String} shorthandName\n     * @param {Array.<String>} styleNames\n     */\n    setStyleRelation(shorthandName, styleNames) {\n        this._mapStyleNames(shorthandName, styleNames);\n        for (const alsoName of styleNames) {\n            this._mapStyleNames(alsoName, [shorthandName]);\n        }\n    }\n    /**\n     * Set two-way binding of style names.\n     *\n     * @param {String} name\n     * @param {Array.<String>} styleNames\n     * @private\n     */\n    _mapStyleNames(name, styleNames) {\n        if (!this._consumables.has(name)) {\n            this._consumables.set(name, []);\n        }\n        this._consumables.get(name).push(...styleNames);\n    }\n}\n// Parses inline styles and puts property - value pairs into styles map.\n//\n// @param {String} stylesString Styles to parse.\n// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.\nfunction parseInlineStyles(stylesString) {\n    // `null` if no quote was found in input string or last found quote was a closing quote. See below.\n    let quoteType = null;\n    let propertyNameStart = 0;\n    let propertyValueStart = 0;\n    let propertyName = null;\n    const stylesMap = new Map();\n    // Do not set anything if input string is empty.\n    if (stylesString === '') {\n        return stylesMap;\n    }\n    // Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n    if (stylesString.charAt(stylesString.length - 1) != ';') {\n        stylesString = stylesString + ';';\n    }\n    // Seek the whole string for \"special characters\".\n    for (let i = 0; i < stylesString.length; i++) {\n        const char = stylesString.charAt(i);\n        if (quoteType === null) {\n            // No quote found yet or last found quote was a closing quote.\n            switch (char) {\n                case ':':\n                    // Most of time colon means that property name just ended.\n                    // Sometimes however `:` is found inside property value (for example in background image url).\n                    if (!propertyName) {\n                        // Treat this as end of property only if property name is not already saved.\n                        // Save property name.\n                        propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);\n                        // Save this point as the start of property value.\n                        propertyValueStart = i + 1;\n                    }\n                    break;\n                case '\"':\n                case '\\'':\n                    // Opening quote found (this is an opening quote, because `quoteType` is `null`).\n                    quoteType = char;\n                    break;\n                case ';': {\n                    // Property value just ended.\n                    // Use previously stored property value start to obtain property value.\n                    const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);\n                    if (propertyName) {\n                        // Save parsed part.\n                        stylesMap.set(propertyName.trim(), propertyValue.trim());\n                    }\n                    propertyName = null;\n                    // Save this point as property name start. Property name starts immediately after previous property value ends.\n                    propertyNameStart = i + 1;\n                    break;\n                }\n            }\n        }\n        else if (char === quoteType) {\n            // If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n            quoteType = null;\n        }\n    }\n    return stylesMap;\n}\n// Return lodash compatible path from style name.\nfunction toPath(name) {\n    return name.replace('-', '.');\n}\n// Appends style definition to the styles object.\n//\n// @param {String} nameOrPath\n// @param {String|Object} valueOrObject\n// @private\nfunction appendStyleValue(stylesObject, nameOrPath, valueOrObject) {\n    let valueToSet = valueOrObject;\n    if (isObject(valueOrObject)) {\n        valueToSet = merge({}, get(stylesObject, nameOrPath), valueOrObject);\n    }\n    set(stylesObject, nameOrPath, valueToSet);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,GAAG,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,GAAG,EAAEC,KAAK,QAAQ,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,SAAS,CAAC;EAC3B;AACJ;AACA;AACA;AACA;EACIC,WAAW,CAACC,cAAc,EAAE;IACxB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAGF,cAAc;EACzC;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIG,OAAO,GAAG;IACV,MAAMC,OAAO,GAAGC,MAAM,CAACD,OAAO,CAAC,IAAI,CAACH,OAAO,CAAC;IAC5C,MAAMK,IAAI,GAAGC,KAAK,CAACD,IAAI,CAACF,OAAO,CAAC;IAChC,OAAO,CAACE,IAAI,CAACE,MAAM;EACvB;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIC,IAAI,GAAG;IACP,IAAI,IAAI,CAACN,OAAO,EAAE;MACd,OAAO,CAAC;IACZ;IACA,OAAO,IAAI,CAACO,aAAa,EAAE,CAACF,MAAM;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIG,KAAK,CAACC,WAAW,EAAE;IACf,IAAI,CAACC,KAAK,EAAE;IACZ,MAAMC,YAAY,GAAGP,KAAK,CAACD,IAAI,CAACS,iBAAiB,CAACH,WAAW,CAAC,CAACR,OAAO,EAAE,CAAC;IACzE,KAAK,MAAM,CAACY,GAAG,EAAEC,KAAK,CAAC,IAAIH,YAAY,EAAE;MACrC,IAAI,CAACZ,eAAe,CAACgB,gBAAgB,CAACF,GAAG,EAAEC,KAAK,EAAE,IAAI,CAAChB,OAAO,CAAC;IACnE;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkB,GAAG,CAACC,IAAI,EAAE;IACN,IAAI,IAAI,CAACjB,OAAO,EAAE;MACd,OAAO,KAAK;IAChB;IACA,MAAMkB,MAAM,GAAG,IAAI,CAACnB,eAAe,CAACoB,cAAc,CAACF,IAAI,EAAE,IAAI,CAACnB,OAAO,CAAC;IACtE,MAAMsB,kBAAkB,GAAGF,MAAM,CAACG,IAAI,CAAC;MAAA,IAAC,CAACC,QAAQ,CAAC;MAAA,OAAKA,QAAQ,KAAKL,IAAI;IAAA,EAAC;IACzE;IACA,OAAOb,KAAK,CAACmB,OAAO,CAACH,kBAAkB,CAAC;EAC5C;EACA3B,GAAG,CAAC+B,YAAY,EAAEC,aAAa,EAAE;IAC7B,IAAIlC,QAAQ,CAACiC,YAAY,CAAC,EAAE;MACxB,KAAK,MAAM,CAACX,GAAG,EAAEC,KAAK,CAAC,IAAIZ,MAAM,CAACD,OAAO,CAACuB,YAAY,CAAC,EAAE;QACrD,IAAI,CAACzB,eAAe,CAACgB,gBAAgB,CAACF,GAAG,EAAEC,KAAK,EAAE,IAAI,CAAChB,OAAO,CAAC;MACnE;IACJ,CAAC,MACI;MACD,IAAI,CAACC,eAAe,CAACgB,gBAAgB,CAACS,YAAY,EAAEC,aAAa,EAAE,IAAI,CAAC3B,OAAO,CAAC;IACpF;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI4B,MAAM,CAACT,IAAI,EAAE;IACT,MAAMU,IAAI,GAAGC,MAAM,CAACX,IAAI,CAAC;IACzBvB,KAAK,CAAC,IAAI,CAACI,OAAO,EAAE6B,IAAI,CAAC;IACzB,OAAO,IAAI,CAAC7B,OAAO,CAACmB,IAAI,CAAC;IACzB,IAAI,CAACY,wBAAwB,CAACF,IAAI,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,aAAa,CAACb,IAAI,EAAE;IAChB,OAAO,IAAI,CAAClB,eAAe,CAAC+B,aAAa,CAACb,IAAI,EAAE,IAAI,CAACnB,OAAO,CAAC;EACjE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIiC,QAAQ,GAAG;IACP,IAAI,IAAI,CAAC/B,OAAO,EAAE;MACd,OAAO,EAAE;IACb;IACA,OAAO,IAAI,CAACgC,iBAAiB,EAAE,CAC1BC,GAAG,CAACC,GAAG,IAAIA,GAAG,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC,CACzBC,IAAI,EAAE,CACND,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,WAAW,CAACC,YAAY,EAAE;IACtB,IAAI,IAAI,CAACtC,OAAO,EAAE;MACd;IACJ;IACA,IAAI,IAAI,CAACF,OAAO,CAACwC,YAAY,CAAC,IAAI,CAAC/C,QAAQ,CAAC,IAAI,CAACO,OAAO,CAACwC,YAAY,CAAC,CAAC,EAAE;MACrE;MACA,OAAO,IAAI,CAACxC,OAAO,CAACwC,YAAY,CAAC;IACrC;IACA,MAAMpB,MAAM,GAAG,IAAI,CAACnB,eAAe,CAACoB,cAAc,CAACmB,YAAY,EAAE,IAAI,CAACxC,OAAO,CAAC;IAC9E,MAAMsB,kBAAkB,GAAGF,MAAM,CAACG,IAAI,CAAC;MAAA,IAAC,CAACC,QAAQ,CAAC;MAAA,OAAKA,QAAQ,KAAKgB,YAAY;IAAA,EAAC;IACjF;IACA,IAAIlC,KAAK,CAACmB,OAAO,CAACH,kBAAkB,CAAC,EAAE;MACnC,OAAOA,kBAAkB,CAAC,CAAC,CAAC;IAChC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIb,aAAa,GAAiB;IAAA,IAAhBgC,MAAM,uEAAG,KAAK;IACxB,IAAI,IAAI,CAACvC,OAAO,EAAE;MACd,OAAO,EAAE;IACb;IACA,IAAIuC,MAAM,EAAE;MACR,OAAO,IAAI,CAACxC,eAAe,CAACQ,aAAa,CAAC,IAAI,CAACT,OAAO,CAAC;IAC3D;IACA,MAAMG,OAAO,GAAG,IAAI,CAAC+B,iBAAiB,EAAE;IACxC,OAAO/B,OAAO,CAACgC,GAAG,CAAC;MAAA,IAAC,CAACpB,GAAG,CAAC;MAAA,OAAKA,GAAG;IAAA,EAAC;EACtC;EACA;AACJ;AACA;EACIH,KAAK,GAAG;IACJ,IAAI,CAACZ,OAAO,GAAG,CAAC,CAAC;EACrB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIkC,iBAAiB,GAAG;IAChB,MAAMQ,MAAM,GAAG,EAAE;IACjB,MAAMC,IAAI,GAAGvC,MAAM,CAACuC,IAAI,CAAC,IAAI,CAAC3C,OAAO,CAAC;IACtC,KAAK,MAAMe,GAAG,IAAI4B,IAAI,EAAE;MACpBD,MAAM,CAACE,IAAI,CAAC,GAAG,IAAI,CAAC3C,eAAe,CAACoB,cAAc,CAACN,GAAG,EAAE,IAAI,CAACf,OAAO,CAAC,CAAC;IAC1E;IACA,OAAO0C,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIX,wBAAwB,CAACF,IAAI,EAAE;IAC3B,MAAMgB,SAAS,GAAGhB,IAAI,CAACiB,KAAK,CAAC,GAAG,CAAC;IACjC,MAAMC,WAAW,GAAGF,SAAS,CAACtC,MAAM,GAAG,CAAC;IACxC,IAAI,CAACwC,WAAW,EAAE;MACd;IACJ;IACA,MAAMC,UAAU,GAAGH,SAAS,CAACI,MAAM,CAAC,CAAC,EAAEJ,SAAS,CAACtC,MAAM,GAAG,CAAC,CAAC,CAAC8B,IAAI,CAAC,GAAG,CAAC;IACtE,MAAMa,YAAY,GAAG1D,GAAG,CAAC,IAAI,CAACQ,OAAO,EAAEgD,UAAU,CAAC;IAClD,IAAI,CAACE,YAAY,EAAE;MACf;IACJ;IACA,MAAMC,aAAa,GAAG,CAAC7C,KAAK,CAACD,IAAI,CAACD,MAAM,CAACuC,IAAI,CAACO,YAAY,CAAC,CAAC,CAAC3C,MAAM;IACnE,IAAI4C,aAAa,EAAE;MACf,IAAI,CAACvB,MAAM,CAACoB,UAAU,CAAC;IAC3B;EACJ;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAMI,eAAe,CAAC;EACzB;AACJ;AACA;AACA;AACA;EACItD,WAAW,GAAG;IACV,IAAI,CAACuD,YAAY,GAAG,IAAIC,GAAG,EAAE;IAC7B,IAAI,CAACC,WAAW,GAAG,IAAID,GAAG,EAAE;IAC5B,IAAI,CAACE,SAAS,GAAG,IAAIF,GAAG,EAAE;IAC1B,IAAI,CAACG,YAAY,GAAG,IAAIH,GAAG,EAAE;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIrC,gBAAgB,CAACE,IAAI,EAAEuC,aAAa,EAAEtC,MAAM,EAAE;IAC1C,IAAI3B,QAAQ,CAACiE,aAAa,CAAC,EAAE;MACzBC,gBAAgB,CAACvC,MAAM,EAAEU,MAAM,CAACX,IAAI,CAAC,EAAEuC,aAAa,CAAC;MACrD;IACJ;IACA,IAAI,IAAI,CAACL,YAAY,CAACnC,GAAG,CAACC,IAAI,CAAC,EAAE;MAC7B,MAAMyC,UAAU,GAAG,IAAI,CAACP,YAAY,CAAC7D,GAAG,CAAC2B,IAAI,CAAC;MAC9C,MAAM;QAAEU,IAAI;QAAEb;MAAM,CAAC,GAAG4C,UAAU,CAACF,aAAa,CAAC;MACjDC,gBAAgB,CAACvC,MAAM,EAAES,IAAI,EAAEb,KAAK,CAAC;IACzC,CAAC,MACI;MACD2C,gBAAgB,CAACvC,MAAM,EAAED,IAAI,EAAEuC,aAAa,CAAC;IACjD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI1B,aAAa,CAACb,IAAI,EAAEC,MAAM,EAAE;IACxB,IAAI,CAACD,IAAI,EAAE;MACP,OAAOzB,KAAK,CAAC,CAAC,CAAC,EAAE0B,MAAM,CAAC;IAC5B;IACA;IACA,IAAIA,MAAM,CAACD,IAAI,CAAC,KAAK0C,SAAS,EAAE;MAC5B,OAAOzC,MAAM,CAACD,IAAI,CAAC;IACvB;IACA,IAAI,IAAI,CAACoC,WAAW,CAACrC,GAAG,CAACC,IAAI,CAAC,EAAE;MAC5B,MAAM2C,SAAS,GAAG,IAAI,CAACP,WAAW,CAAC/D,GAAG,CAAC2B,IAAI,CAAC;MAC5C,IAAI,OAAO2C,SAAS,KAAK,QAAQ,EAAE;QAC/B,OAAOtE,GAAG,CAAC4B,MAAM,EAAE0C,SAAS,CAAC;MACjC;MACA,MAAM9C,KAAK,GAAG8C,SAAS,CAAC3C,IAAI,EAAEC,MAAM,CAAC;MACrC,IAAIJ,KAAK,EAAE;QACP,OAAOA,KAAK;MAChB;IACJ;IACA,OAAOxB,GAAG,CAAC4B,MAAM,EAAEU,MAAM,CAACX,IAAI,CAAC,CAAC;EACpC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,cAAc,CAACF,IAAI,EAAEC,MAAM,EAAE;IACzB,MAAM2C,eAAe,GAAG,IAAI,CAAC/B,aAAa,CAACb,IAAI,EAAEC,MAAM,CAAC;IACxD;IACA,IAAI2C,eAAe,KAAKF,SAAS,EAAE;MAC/B,OAAO,EAAE;IACb;IACA,IAAI,IAAI,CAACL,SAAS,CAACtC,GAAG,CAACC,IAAI,CAAC,EAAE;MAC1B,MAAM6C,OAAO,GAAG,IAAI,CAACR,SAAS,CAAChE,GAAG,CAAC2B,IAAI,CAAC;MACxC,OAAO6C,OAAO,CAACD,eAAe,CAAC;IACnC;IACA,OAAO,CAAC,CAAC5C,IAAI,EAAE4C,eAAe,CAAC,CAAC;EACpC;EACA;AACJ;AACA;AACA;AACA;AACA;EACItD,aAAa,CAACW,MAAM,EAAE;IAClB;IACA,MAAM6C,kBAAkB,GAAG3D,KAAK,CAACD,IAAI,CAAC,IAAI,CAACoD,YAAY,CAACd,IAAI,EAAE,CAAC,CAACuB,MAAM,CAAC/C,IAAI,IAAI;MAC3E,MAAMgD,KAAK,GAAG,IAAI,CAACnC,aAAa,CAACb,IAAI,EAAEC,MAAM,CAAC;MAC9C,IAAI+C,KAAK,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;QACnC,OAAO/D,MAAM,CAACuC,IAAI,CAACwB,KAAK,CAAC,CAAC5D,MAAM;MACpC;MACA,OAAO4D,KAAK;IAChB,CAAC,CAAC;IACF;IACA;IACA,MAAMC,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAC9B,GAAGJ,kBAAkB,EACrB,GAAG7D,MAAM,CAACuC,IAAI,CAACvB,MAAM,CAAC,CACzB,CAAC;IACF,OAAOd,KAAK,CAACD,IAAI,CAAC+D,iBAAiB,CAACE,MAAM,EAAE,CAAC;EACjD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgB,CAACpD,IAAI,EAAE;IACnB,OAAO,IAAI,CAACsC,YAAY,CAACjE,GAAG,CAAC2B,IAAI,CAAC,IAAI,EAAE;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIqD,aAAa,CAACrD,IAAI,EAAEsD,QAAQ,EAAE;IAC1B,IAAI,CAACpB,YAAY,CAAC1D,GAAG,CAACwB,IAAI,EAAEsD,QAAQ,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACvD,IAAI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"},"metadata":{},"sourceType":"module"}