{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/insertoperation\n */\nimport Operation from './operation';\nimport Position from '../position';\nimport NodeList from '../nodelist';\nimport MoveOperation from './moveoperation';\nimport { _insert, _normalizeNodes } from './utils';\nimport Text from '../text';\nimport Element from '../element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to insert one or more nodes at given position in the model.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class InsertOperation extends Operation {\n  /**\n   * Creates an insert operation.\n   *\n   * @param {module:engine/model/position~Position} position Position of insertion.\n   * @param {module:engine/model/node~NodeSet} nodes The list of nodes to be inserted.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  constructor(position, nodes, baseVersion) {\n    super(baseVersion);\n    /**\n     * Position of insertion.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position} module:engine/model/operation/insertoperation~InsertOperation#position\n     */\n    this.position = position.clone();\n    this.position.stickiness = 'toNone';\n    /**\n     * List of nodes to insert.\n     *\n     * @readonly\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/operation/insertoperation~InsertOperation#nodeList\n     */\n    this.nodes = new NodeList(_normalizeNodes(nodes));\n    /**\n     * Flag deciding how the operation should be transformed. If set to `true`, nodes might get additional attributes\n     * during operational transformation. This happens when the operation insertion position is inside of a range\n     * where attributes have changed.\n     *\n     * @member {Boolean} module:engine/model/operation/insertoperation~InsertOperation#shouldReceiveAttributes\n     */\n    this.shouldReceiveAttributes = false;\n  }\n  /**\n   * @inheritDoc\n   */\n  get type() {\n    return 'insert';\n  }\n  /**\n   * Total offset size of inserted nodes.\n   *\n   * @returns {Number}\n   */\n  get howMany() {\n    return this.nodes.maxOffset;\n  }\n  /**\n   * Creates and returns an operation that has the same parameters as this operation.\n   *\n   * @returns {module:engine/model/operation/insertoperation~InsertOperation} Clone of this operation.\n   */\n  clone() {\n    const nodes = new NodeList([...this.nodes].map(node => node._clone(true)));\n    const insert = new InsertOperation(this.position, nodes, this.baseVersion);\n    insert.shouldReceiveAttributes = this.shouldReceiveAttributes;\n    return insert;\n  }\n  /**\n   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n   *\n   * @returns {module:engine/model/operation/moveoperation~MoveOperation}\n   */\n  getReversed() {\n    const graveyard = this.position.root.document.graveyard;\n    const gyPosition = new Position(graveyard, [0]);\n    return new MoveOperation(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);\n  }\n  /**\n   * @inheritDoc\n   * @internal\n   */\n  _validate() {\n    const targetElement = this.position.parent;\n    if (!targetElement || targetElement.maxOffset < this.position.offset) {\n      /**\n       * Insertion position is invalid.\n       *\n       * @error insert-operation-position-invalid\n       */\n      throw new CKEditorError('insert-operation-position-invalid', this);\n    }\n  }\n  /**\n   * @inheritDoc\n   * @internal\n   */\n  _execute() {\n    // What happens here is that we want original nodes be passed to writer because we want original nodes\n    // to be inserted to the model. But in InsertOperation, we want to keep those nodes as they were added\n    // to the operation, not modified. For example, text nodes can get merged or cropped while Elements can\n    // get children. It is important that InsertOperation has the copy of original nodes in intact state.\n    const originalNodes = this.nodes;\n    this.nodes = new NodeList([...originalNodes].map(node => node._clone(true)));\n    _insert(this.position, originalNodes);\n  }\n  /**\n   * @inheritDoc\n   */\n  toJSON() {\n    const json = super.toJSON();\n    json.position = this.position.toJSON();\n    json.nodes = this.nodes.toJSON();\n    return json;\n  }\n  /**\n   * @inheritDoc\n   */\n  static get className() {\n    return 'InsertOperation';\n  }\n  /**\n   * Creates `InsertOperation` object from deserilized object, i.e. from parsed JSON string.\n   *\n   * @param {Object} json Deserialized JSON object.\n   * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n   * @returns {module:engine/model/operation/insertoperation~InsertOperation}\n   */\n  static fromJSON(json, document) {\n    const children = [];\n    for (const child of json.nodes) {\n      if (child.name) {\n        // If child has name property, it is an Element.\n        children.push(Element.fromJSON(child));\n      } else {\n        // Otherwise, it is a Text node.\n        children.push(Text.fromJSON(child));\n      }\n    }\n    const insert = new InsertOperation(Position.fromJSON(json.position, document), children, json.baseVersion);\n    insert.shouldReceiveAttributes = json.shouldReceiveAttributes;\n    return insert;\n  }\n}","map":{"version":3,"names":["Operation","Position","NodeList","MoveOperation","_insert","_normalizeNodes","Text","Element","CKEditorError","InsertOperation","constructor","position","nodes","baseVersion","clone","stickiness","shouldReceiveAttributes","type","howMany","maxOffset","map","node","_clone","insert","getReversed","graveyard","root","document","gyPosition","_validate","targetElement","parent","offset","_execute","originalNodes","toJSON","json","className","fromJSON","children","child","name","push"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/insertoperation.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/insertoperation\n */\nimport Operation from './operation';\nimport Position from '../position';\nimport NodeList from '../nodelist';\nimport MoveOperation from './moveoperation';\nimport { _insert, _normalizeNodes } from './utils';\nimport Text from '../text';\nimport Element from '../element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to insert one or more nodes at given position in the model.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class InsertOperation extends Operation {\n    /**\n     * Creates an insert operation.\n     *\n     * @param {module:engine/model/position~Position} position Position of insertion.\n     * @param {module:engine/model/node~NodeSet} nodes The list of nodes to be inserted.\n     * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n     * can be applied or `null` if the operation operates on detached (non-document) tree.\n     */\n    constructor(position, nodes, baseVersion) {\n        super(baseVersion);\n        /**\n         * Position of insertion.\n         *\n         * @readonly\n         * @member {module:engine/model/position~Position} module:engine/model/operation/insertoperation~InsertOperation#position\n         */\n        this.position = position.clone();\n        this.position.stickiness = 'toNone';\n        /**\n         * List of nodes to insert.\n         *\n         * @readonly\n         * @member {module:engine/model/nodelist~NodeList} module:engine/model/operation/insertoperation~InsertOperation#nodeList\n         */\n        this.nodes = new NodeList(_normalizeNodes(nodes));\n        /**\n         * Flag deciding how the operation should be transformed. If set to `true`, nodes might get additional attributes\n         * during operational transformation. This happens when the operation insertion position is inside of a range\n         * where attributes have changed.\n         *\n         * @member {Boolean} module:engine/model/operation/insertoperation~InsertOperation#shouldReceiveAttributes\n         */\n        this.shouldReceiveAttributes = false;\n    }\n    /**\n     * @inheritDoc\n     */\n    get type() {\n        return 'insert';\n    }\n    /**\n     * Total offset size of inserted nodes.\n     *\n     * @returns {Number}\n     */\n    get howMany() {\n        return this.nodes.maxOffset;\n    }\n    /**\n     * Creates and returns an operation that has the same parameters as this operation.\n     *\n     * @returns {module:engine/model/operation/insertoperation~InsertOperation} Clone of this operation.\n     */\n    clone() {\n        const nodes = new NodeList([...this.nodes].map(node => node._clone(true)));\n        const insert = new InsertOperation(this.position, nodes, this.baseVersion);\n        insert.shouldReceiveAttributes = this.shouldReceiveAttributes;\n        return insert;\n    }\n    /**\n     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n     *\n     * @returns {module:engine/model/operation/moveoperation~MoveOperation}\n     */\n    getReversed() {\n        const graveyard = this.position.root.document.graveyard;\n        const gyPosition = new Position(graveyard, [0]);\n        return new MoveOperation(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);\n    }\n    /**\n     * @inheritDoc\n     * @internal\n     */\n    _validate() {\n        const targetElement = this.position.parent;\n        if (!targetElement || targetElement.maxOffset < this.position.offset) {\n            /**\n             * Insertion position is invalid.\n             *\n             * @error insert-operation-position-invalid\n             */\n            throw new CKEditorError('insert-operation-position-invalid', this);\n        }\n    }\n    /**\n     * @inheritDoc\n     * @internal\n     */\n    _execute() {\n        // What happens here is that we want original nodes be passed to writer because we want original nodes\n        // to be inserted to the model. But in InsertOperation, we want to keep those nodes as they were added\n        // to the operation, not modified. For example, text nodes can get merged or cropped while Elements can\n        // get children. It is important that InsertOperation has the copy of original nodes in intact state.\n        const originalNodes = this.nodes;\n        this.nodes = new NodeList([...originalNodes].map(node => node._clone(true)));\n        _insert(this.position, originalNodes);\n    }\n    /**\n     * @inheritDoc\n     */\n    toJSON() {\n        const json = super.toJSON();\n        json.position = this.position.toJSON();\n        json.nodes = this.nodes.toJSON();\n        return json;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get className() {\n        return 'InsertOperation';\n    }\n    /**\n     * Creates `InsertOperation` object from deserilized object, i.e. from parsed JSON string.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n     * @returns {module:engine/model/operation/insertoperation~InsertOperation}\n     */\n    static fromJSON(json, document) {\n        const children = [];\n        for (const child of json.nodes) {\n            if (child.name) {\n                // If child has name property, it is an Element.\n                children.push(Element.fromJSON(child));\n            }\n            else {\n                // Otherwise, it is a Text node.\n                children.push(Text.fromJSON(child));\n            }\n        }\n        const insert = new InsertOperation(Position.fromJSON(json.position, document), children, json.baseVersion);\n        insert.shouldReceiveAttributes = json.shouldReceiveAttributes;\n        return insert;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}