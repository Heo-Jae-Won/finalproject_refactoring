{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/writer\n */\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MergeOperation from './operation/mergeoperation';\nimport MoveOperation from './operation/moveoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\nimport SplitOperation from './operation/splitoperation';\nimport DocumentFragment from './documentfragment';\nimport DocumentSelection from './documentselection';\nimport Element from './element';\nimport Position from './position';\nimport Range from './range';\nimport RootElement from './rootelement';\nimport Text from './text';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError, { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\nexport default class Writer {\n  /**\n   * Creates a writer instance.\n   *\n   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n   *\n   * @protected\n   * @param {module:engine/model/model~Model} model\n   * @param {module:engine/model/batch~Batch} batch\n   */\n  constructor(model, batch) {\n    /**\n     * Instance of the model on which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The batch to which this writer will add changes.\n     *\n     * @readonly\n     * @type {module:engine/model/batch~Batch}\n     */\n    this.batch = batch;\n  }\n  /**\n   * Creates a new {@link module:engine/model/text~Text text node}.\n   *\n   *\t\twriter.createText( 'foo' );\n   *\t\twriter.createText( 'foo', { bold: true } );\n   *\n   * @param {String} data Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @returns {module:engine/model/text~Text} Created text node.\n   */\n  createText(data, attributes) {\n    return new Text(data, attributes);\n  }\n  /**\n   * Creates a new {@link module:engine/model/element~Element element}.\n   *\n   *\t\twriter.createElement( 'paragraph' );\n   *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @returns {module:engine/model/element~Element} Created element.\n   */\n  createElement(name, attributes) {\n    return new Element(name, attributes);\n  }\n  /**\n   * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n   *\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n   */\n  createDocumentFragment() {\n    return new DocumentFragment();\n  }\n  /**\n   * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.\n   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n   *\n   * @param {module:engine/model/element~Element} element The element to clone.\n   * @param {Boolean} [deep=true] If set to `true` clones element and all its children recursively. When set to `false`,\n   * element will be cloned without any child.\n   */\n  cloneElement(element) {\n    let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return element._clone(deep);\n  }\n  /**\n   * Inserts item on given position.\n   *\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\twriter.insert( paragraph, position );\n   *\n   * Instead of using position you can use parent and offset:\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\twriter.insert( text, paragraph, 5 );\n   *\n   * You can also use `end` instead of the offset to insert at the end:\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\twriter.insert( text, paragraph, 'end' );\n   *\n   * Or insert before or after another element:\n   *\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n   *\n   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * Note that if the item already has parent it will be removed from the previous parent.\n   *\n   * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n   * `model-writer-insert-forbidden-move` is thrown.\n   *\n   * If you want to move {@link module:engine/model/range~Range range} instead of an\n   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n   *\n   * **Note:** For a paste-like content insertion mechanism see\n   * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n   * fragment to insert.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * second parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  insert(item, itemOrPosition) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._assertWriterUsedCorrectly();\n    if (item instanceof Text && item.data == '') {\n      return;\n    }\n    const position = Position._createAt(itemOrPosition, offset);\n    // If item has a parent already.\n    if (item.parent) {\n      // We need to check if item is going to be inserted within the same document.\n      if (isSameTree(item.root, position.root)) {\n        // If it's we just need to move it.\n        this.move(Range._createOn(item), position);\n        return;\n      }\n      // If it isn't the same root.\n      else {\n        if (item.root.document) {\n          /**\n           * Cannot move a node from a document to a different tree.\n           * It is forbidden to move a node that was already in a document outside of it.\n           *\n           * @error model-writer-insert-forbidden-move\n           */\n          throw new CKEditorError('model-writer-insert-forbidden-move', this);\n        } else {\n          // Move between two different document fragments or from document fragment to a document is possible.\n          // In that case, remove the item from it's original parent.\n          this.remove(item);\n        }\n      }\n    }\n    const version = position.root.document ? position.root.document.version : null;\n    const insert = new InsertOperation(position, item, version);\n    if (item instanceof Text) {\n      insert.shouldReceiveAttributes = true;\n    }\n    this.batch.addOperation(insert);\n    this.model.applyOperation(insert);\n    // When element is a DocumentFragment we need to move its markers to Document#markers.\n    if (item instanceof DocumentFragment) {\n      for (const [markerName, markerRange] of item.markers) {\n        // We need to migrate marker range from DocumentFragment to Document.\n        const rangeRootPosition = Position._createAt(markerRange.root, 0);\n        const range = new Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));\n        const options = {\n          range,\n          usingOperation: true,\n          affectsData: true\n        };\n        if (this.model.markers.has(markerName)) {\n          this.updateMarker(markerName, options);\n        } else {\n          this.addMarker(markerName, options);\n        }\n      }\n    }\n  }\n  /**\n   * Creates and inserts text on given position. You can optionally set text attributes:\n   *\n   *\t\twriter.insertText( 'foo', position );\n   *\t\twriter.insertText( 'foo', { bold: true }, position );\n   *\n   * Instead of using position you can use parent and offset or define that text should be inserted at the end\n   * or before or after other node:\n   *\n   *\t\t// Inserts 'foo' in paragraph, at offset 5:\n   *\t\twriter.insertText( 'foo', paragraph, 5 );\n   *\t\t// Inserts 'foo' at the end of a paragraph:\n   *\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t// Inserts 'foo' after an image:\n   *\t\twriter.insertText( 'foo', image, 'after' );\n   *\n   * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * @param {String} dattexta Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * third parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  insertText(text, attributes,\n  // Too complicated when not using `any`.\n  itemOrPosition,\n  // Too complicated when not using `any`.\n  offset // Too complicated when not using `any`.\n  ) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n      this.insert(this.createText(text), attributes, itemOrPosition);\n    } else {\n      this.insert(this.createText(text, attributes), itemOrPosition, offset);\n    }\n  }\n  /**\n   * Creates and inserts element on given position. You can optionally set attributes:\n   *\n   *\t\twriter.insertElement( 'paragraph', position );\n   *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n   *\n   * Instead of using position you can use parent and offset or define that text should be inserted at the end\n   * or before or after other node:\n   *\n   *\t\t// Inserts paragraph in the root at offset 5:\n   *\t\twriter.insertElement( 'paragraph', root, 5 );\n   *\t\t// Inserts paragraph at the end of a blockquote:\n   *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n   *\t\t// Inserts after an image:\n   *\t\twriter.insertElement( 'paragraph', image, 'after' );\n   *\n   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * third parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  insertElement(name, attributes,\n  // Too complicated when not using `any`.\n  itemOrPositionOrOffset,\n  // Too complicated when not using `any`.\n  offset // Too complicated when not using `any`.\n  ) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n      this.insert(this.createElement(name), attributes, itemOrPositionOrOffset);\n    } else {\n      this.insert(this.createElement(name, attributes), itemOrPositionOrOffset, offset);\n    }\n  }\n  /**\n   * Inserts item at the end of the given parent.\n   *\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\twriter.append( paragraph, root );\n   *\n   * Note that if the item already has parent it will be removed from the previous parent.\n   *\n   * If you want to move {@link module:engine/model/range~Range range} instead of an\n   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n   * item Item or document fragment to insert.\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n   */\n  append(item, parent) {\n    this.insert(item, parent, 'end');\n  }\n  /**\n   * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n   *\n   *\t\twriter.appendText( 'foo', paragraph );\n   *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n   *\n   * @param {String} text Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n   */\n  appendText(text, attributes, parent) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n      this.insert(this.createText(text), attributes, 'end');\n    } else {\n      this.insert(this.createText(text, attributes), parent, 'end');\n    }\n  }\n  /**\n   * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n   *\n   *\t\twriter.appendElement( 'paragraph', root );\n   *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n   */\n  appendElement(name, attributes, parent) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n      this.insert(this.createElement(name), attributes, 'end');\n    } else {\n      this.insert(this.createElement(name, attributes), parent, 'end');\n    }\n  }\n  /**\n   * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n   * or on a {@link module:engine/model/range~Range range}.\n   *\n   * @param {String} key Attribute key.\n   * @param {*} value Attribute new value.\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range on which the attribute will be set.\n   */\n  setAttribute(key, value, itemOrRange) {\n    this._assertWriterUsedCorrectly();\n    if (itemOrRange instanceof Range) {\n      const ranges = itemOrRange.getMinimalFlatRanges();\n      for (const range of ranges) {\n        setAttributeOnRange(this, key, value, range);\n      }\n    } else {\n      setAttributeOnItem(this, key, value, itemOrRange);\n    }\n  }\n  /**\n   * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n   * or on a {@link module:engine/model/range~Range range}.\n   *\n   *\t\twriter.setAttributes( {\n   *\t\t\tbold: true,\n   *\t\t\titalic: true\n   *\t\t}, range );\n   *\n   * @param {Object} attributes Attributes keys and values.\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range on which the attributes will be set.\n   */\n  setAttributes(attributes, itemOrRange) {\n    for (const [key, val] of toMap(attributes)) {\n      this.setAttribute(key, val, itemOrRange);\n    }\n  }\n  /**\n   * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n   * or from a {@link module:engine/model/range~Range range}.\n   *\n   * @param {String} key Attribute key.\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range from which the attribute will be removed.\n   */\n  removeAttribute(key, itemOrRange) {\n    this._assertWriterUsedCorrectly();\n    if (itemOrRange instanceof Range) {\n      const ranges = itemOrRange.getMinimalFlatRanges();\n      for (const range of ranges) {\n        setAttributeOnRange(this, key, null, range);\n      }\n    } else {\n      setAttributeOnItem(this, key, null, itemOrRange);\n    }\n  }\n  /**\n   * Removes all attributes from all elements in the range or from the given item.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range from which all attributes will be removed.\n   */\n  clearAttributes(itemOrRange) {\n    this._assertWriterUsedCorrectly();\n    const removeAttributesFromItem = item => {\n      for (const attribute of item.getAttributeKeys()) {\n        this.removeAttribute(attribute, item);\n      }\n    };\n    if (!(itemOrRange instanceof Range)) {\n      removeAttributesFromItem(itemOrRange);\n    } else {\n      for (const item of itemOrRange.getItems()) {\n        removeAttributesFromItem(item);\n      }\n    }\n  }\n  /**\n   * Moves all items in the source range to the target position.\n   *\n   *\t\twriter.move( sourceRange, targetPosition );\n   *\n   * Instead of the target position you can use parent and offset or define that range should be moved to the end\n   * or before or after chosen item:\n   *\n   *\t\t// Moves all items in the range to the paragraph at offset 5:\n   *\t\twriter.move( sourceRange, paragraph, 5 );\n   *\t\t// Moves all items in the range to the end of a blockquote:\n   *\t\twriter.move( sourceRange, blockquote, 'end' );\n   *\t\t// Moves all items in the range to a position after an image:\n   *\t\twriter.move( sourceRange, image, 'after' );\n   *\n   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * Note that items can be moved only within the same tree. It means that you can move items within the same root\n   * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n   * but you can not move items from document fragment to the document or from one detached element to another. Use\n   * {@link module:engine/model/writer~Writer#insert} in such cases.\n   *\n   * @param {module:engine/model/range~Range} range Source range.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * second parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  move(range, itemOrPosition, offset) {\n    this._assertWriterUsedCorrectly();\n    if (!(range instanceof Range)) {\n      /**\n       * Invalid range to move.\n       *\n       * @error writer-move-invalid-range\n       */\n      throw new CKEditorError('writer-move-invalid-range', this);\n    }\n    if (!range.isFlat) {\n      /**\n       * Range to move is not flat.\n       *\n       * @error writer-move-range-not-flat\n       */\n      throw new CKEditorError('writer-move-range-not-flat', this);\n    }\n    const position = Position._createAt(itemOrPosition, offset);\n    // Do not move anything if the move target is same as moved range start.\n    if (position.isEqual(range.start)) {\n      return;\n    }\n    // If part of the marker is removed, create additional marker operation for undo purposes.\n    this._addOperationForAffectedMarkers('move', range);\n    if (!isSameTree(range.root, position.root)) {\n      /**\n       * Range is going to be moved within not the same document. Please use\n       * {@link module:engine/model/writer~Writer#insert insert} instead.\n       *\n       * @error writer-move-different-document\n       */\n      throw new CKEditorError('writer-move-different-document', this);\n    }\n    const version = range.root.document ? range.root.document.version : null;\n    const operation = new MoveOperation(range.start, range.end.offset - range.start.offset, position, version);\n    this.batch.addOperation(operation);\n    this.model.applyOperation(operation);\n  }\n  /**\n   * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n   */\n  remove(itemOrRange) {\n    this._assertWriterUsedCorrectly();\n    const rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn(itemOrRange);\n    const ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n    for (const flat of ranges) {\n      // If part of the marker is removed, create additional marker operation for undo purposes.\n      this._addOperationForAffectedMarkers('move', flat);\n      applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);\n    }\n  }\n  /**\n   * Merges two siblings at the given position.\n   *\n   * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n   * `writer-merge-no-element-after` error will be thrown.\n   *\n   * @param {module:engine/model/position~Position} position Position between merged elements.\n   */\n  merge(position) {\n    this._assertWriterUsedCorrectly();\n    const nodeBefore = position.nodeBefore;\n    const nodeAfter = position.nodeAfter;\n    // If part of the marker is removed, create additional marker operation for undo purposes.\n    this._addOperationForAffectedMarkers('merge', position);\n    if (!(nodeBefore instanceof Element)) {\n      /**\n       * Node before merge position must be an element.\n       *\n       * @error writer-merge-no-element-before\n       */\n      throw new CKEditorError('writer-merge-no-element-before', this);\n    }\n    if (!(nodeAfter instanceof Element)) {\n      /**\n       * Node after merge position must be an element.\n       *\n       * @error writer-merge-no-element-after\n       */\n      throw new CKEditorError('writer-merge-no-element-after', this);\n    }\n    if (!position.root.document) {\n      this._mergeDetached(position);\n    } else {\n      this._merge(position);\n    }\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   * @returns {module:engine/model/position~Position}\n   */\n  createPositionFromPath(root, path, stickiness) {\n    return this.model.createPositionFromPath(root, path, stickiness);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @returns {module:engine/model/position~Position}\n   */\n  createPositionAt(itemOrPosition, offset) {\n    return this.model.createPositionAt(itemOrPosition, offset);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n  createPositionAfter(item) {\n    return this.model.createPositionAfter(item);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n  createPositionBefore(item) {\n    return this.model.createPositionBefore(item);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n   *\n   * @param {module:engine/model/position~Position} start Start position.\n   * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n   * @returns {module:engine/model/range~Range}\n   */\n  createRange(start, end) {\n    return this.model.createRange(start, end);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n   *\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n  createRangeIn(element) {\n    return this.model.createRangeIn(element);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n   *\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n  createRangeOn(element) {\n    return this.model.createRangeOn(element);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @returns {module:engine/model/selection~Selection}\n   */\n  createSelection() {\n    return this.model.createSelection(...arguments);\n  }\n  /**\n   * Performs merge action in a detached tree.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position Position between merged elements.\n   */\n  _mergeDetached(position) {\n    const nodeBefore = position.nodeBefore;\n    const nodeAfter = position.nodeAfter;\n    this.move(Range._createIn(nodeAfter), Position._createAt(nodeBefore, 'end'));\n    this.remove(nodeAfter);\n  }\n  /**\n   * Performs merge action in a non-detached tree.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position Position between merged elements.\n   */\n  _merge(position) {\n    const targetPosition = Position._createAt(position.nodeBefore, 'end');\n    const sourcePosition = Position._createAt(position.nodeAfter, 0);\n    const graveyard = position.root.document.graveyard;\n    const graveyardPosition = new Position(graveyard, [0]);\n    const version = position.root.document.version;\n    const merge = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version);\n    this.batch.addOperation(merge);\n    this.model.applyOperation(merge);\n  }\n  /**\n   * Renames the given element.\n   *\n   * @param {module:engine/model/element~Element} element The element to rename.\n   * @param {String} newName New element name.\n   */\n  rename(element, newName) {\n    this._assertWriterUsedCorrectly();\n    if (!(element instanceof Element)) {\n      /**\n       * Trying to rename an object which is not an instance of Element.\n       *\n       * @error writer-rename-not-element-instance\n       */\n      throw new CKEditorError('writer-rename-not-element-instance', this);\n    }\n    const version = element.root.document ? element.root.document.version : null;\n    const renameOperation = new RenameOperation(Position._createBefore(element), element.name, newName, version);\n    this.batch.addOperation(renameOperation);\n    this.model.applyOperation(renameOperation);\n  }\n  /**\n   * Splits elements starting from the given position and going to the top of the model tree as long as given\n   * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n   *\n   * The element needs to have a parent. It cannot be a root element nor a document fragment.\n   * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n   *\n   * @param {module:engine/model/position~Position} position Position of split.\n   * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n   * @returns {Object} result Split result.\n   * @returns {module:engine/model/position~Position} result.position Position between split elements.\n   * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n   * at the beginning of the first copy element.\n   */\n  split(position, limitElement) {\n    this._assertWriterUsedCorrectly();\n    let splitElement = position.parent;\n    if (!splitElement.parent) {\n      /**\n       * Element with no parent can not be split.\n       *\n       * @error writer-split-element-no-parent\n       */\n      throw new CKEditorError('writer-split-element-no-parent', this);\n    }\n    // When limit element is not defined lets set splitElement parent as limit.\n    if (!limitElement) {\n      limitElement = splitElement.parent;\n    }\n    if (!position.parent.getAncestors({\n      includeSelf: true\n    }).includes(limitElement)) {\n      /**\n       * Limit element is not a position ancestor.\n       *\n       * @error writer-split-invalid-limit-element\n       */\n      throw new CKEditorError('writer-split-invalid-limit-element', this);\n    }\n    // We need to cache elements that will be created as a result of the first split because\n    // we need to create a range from the end of the first split element to the beginning of the\n    // first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n    let firstSplitElement;\n    let firstCopyElement;\n    do {\n      const version = splitElement.root.document ? splitElement.root.document.version : null;\n      const howMany = splitElement.maxOffset - position.offset;\n      const insertionPosition = SplitOperation.getInsertionPosition(position);\n      const split = new SplitOperation(position, howMany, insertionPosition, null, version);\n      this.batch.addOperation(split);\n      this.model.applyOperation(split);\n      // Cache result of the first split.\n      if (!firstSplitElement && !firstCopyElement) {\n        firstSplitElement = splitElement;\n        firstCopyElement = position.parent.nextSibling;\n      }\n      position = this.createPositionAfter(position.parent);\n      splitElement = position.parent;\n    } while (splitElement !== limitElement);\n    return {\n      position,\n      range: new Range(Position._createAt(firstSplitElement, 'end'), Position._createAt(firstCopyElement, 0))\n    };\n  }\n  /**\n   * Wraps the given range with the given element or with a new element (if a string was passed).\n   *\n   * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n   * If not, an error will be thrown.\n   *\n   * @param {module:engine/model/range~Range} range Range to wrap.\n   * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n   */\n  wrap(range, elementOrString) {\n    this._assertWriterUsedCorrectly();\n    if (!range.isFlat) {\n      /**\n       * Range to wrap is not flat.\n       *\n       * @error writer-wrap-range-not-flat\n       */\n      throw new CKEditorError('writer-wrap-range-not-flat', this);\n    }\n    const element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);\n    if (element.childCount > 0) {\n      /**\n       * Element to wrap with is not empty.\n       *\n       * @error writer-wrap-element-not-empty\n       */\n      throw new CKEditorError('writer-wrap-element-not-empty', this);\n    }\n    if (element.parent !== null) {\n      /**\n       * Element to wrap with is already attached to a tree model.\n       *\n       * @error writer-wrap-element-attached\n       */\n      throw new CKEditorError('writer-wrap-element-attached', this);\n    }\n    this.insert(element, range.start);\n    // Shift the range-to-wrap because we just inserted an element before that range.\n    const shiftedRange = new Range(range.start.getShiftedBy(1), range.end.getShiftedBy(1));\n    this.move(shiftedRange, Position._createAt(element, 0));\n  }\n  /**\n   * Unwraps children of the given element – all its children are moved before it and then the element is removed.\n   * Throws error if you try to unwrap an element which does not have a parent.\n   *\n   * @param {module:engine/model/element~Element} element Element to unwrap.\n   */\n  unwrap(element) {\n    this._assertWriterUsedCorrectly();\n    if (element.parent === null) {\n      /**\n       * Trying to unwrap an element which has no parent.\n       *\n       * @error writer-unwrap-element-no-parent\n       */\n      throw new CKEditorError('writer-unwrap-element-no-parent', this);\n    }\n    this.move(Range._createIn(element), this.createPositionAfter(element));\n    this.remove(element);\n  }\n  /**\n   * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n   * changes in the document and updates its range automatically, when model tree changes.\n   *\n   * As the first parameter you can set marker name.\n   *\n   * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n   * markers managed by operations and not-managed by operations.\n   *\n   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n   * `true` when the marker change changes the data returned by the\n   * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n   *\n   * Create marker directly base on marker's name:\n   *\n   *\t\taddMarker( markerName, { range, usingOperation: false } );\n   *\n   * Create marker using operation:\n   *\n   *\t\taddMarker( markerName, { range, usingOperation: true } );\n   *\n   * Create marker that affects the editor data:\n   *\n   *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n   *\n   * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n   *\n   * @see module:engine/model/markercollection~Marker\n   * @param {String} name Name of a marker to create - must be unique.\n   * @param {Object} options\n   * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n   * @param {module:engine/model/range~Range} options.range Marker range.\n   * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n   * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n   */\n  addMarker(name, options) {\n    this._assertWriterUsedCorrectly();\n    if (!options || typeof options.usingOperation != 'boolean') {\n      /**\n       * The `options.usingOperation` parameter is required when adding a new marker.\n       *\n       * @error writer-addmarker-no-usingoperation\n       */\n      throw new CKEditorError('writer-addmarker-no-usingoperation', this);\n    }\n    const usingOperation = options.usingOperation;\n    const range = options.range;\n    const affectsData = options.affectsData === undefined ? false : options.affectsData;\n    if (this.model.markers.has(name)) {\n      /**\n       * Marker with provided name already exists.\n       *\n       * @error writer-addmarker-marker-exists\n       */\n      throw new CKEditorError('writer-addmarker-marker-exists', this);\n    }\n    if (!range) {\n      /**\n       * Range parameter is required when adding a new marker.\n       *\n       * @error writer-addmarker-no-range\n       */\n      throw new CKEditorError('writer-addmarker-no-range', this);\n    }\n    if (!usingOperation) {\n      return this.model.markers._set(name, range, usingOperation, affectsData);\n    }\n    applyMarkerOperation(this, name, null, range, affectsData);\n    return this.model.markers.get(name);\n  }\n  /**\n   * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n   * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n   * marker's range directly using this method.\n   *\n   * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n   * name is created and returned.\n   *\n   * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model\n   * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.\n   *\n   * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n   * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n   *\n   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n   * `true` when the marker change changes the data returned by\n   * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n   *\n   * Update marker directly base on marker's name:\n   *\n   *\t\tupdateMarker( markerName, { range } );\n   *\n   * Update marker using operation:\n   *\n   *\t\tupdateMarker( marker, { range, usingOperation: true } );\n   *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n   *\n   * Change marker's option (start using operations to manage it):\n   *\n   *\t\tupdateMarker( marker, { usingOperation: true } );\n   *\n   * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n   *\n   *\t\tupdateMarker( markerName, { affectsData: false } );\n   *\n   * @see module:engine/model/markercollection~Marker\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n   * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n   * downcast conversion for this marker with the same data.\n   * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n   * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n   * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n   */\n  updateMarker(markerOrName, options) {\n    this._assertWriterUsedCorrectly();\n    const markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n    const currentMarker = this.model.markers.get(markerName);\n    if (!currentMarker) {\n      /**\n       * Marker with provided name does not exist and will not be updated.\n       *\n       * @error writer-updatemarker-marker-not-exists\n       */\n      throw new CKEditorError('writer-updatemarker-marker-not-exists', this);\n    }\n    if (!options) {\n      /**\n       * The usage of `writer.updateMarker()` only to reconvert (refresh) a\n       * {@link module:engine/model/markercollection~Marker model marker} was deprecated and may not work in the future.\n       * Please update your code to use\n       * {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker `editor.editing.reconvertMarker()`}\n       * instead.\n       *\n       * @error writer-updatemarker-reconvert-using-editingcontroller\n       * @param {String} markerName The name of the updated marker.\n       */\n      logWarning('writer-updatemarker-reconvert-using-editingcontroller', {\n        markerName\n      });\n      this.model.markers._refresh(currentMarker);\n      return;\n    }\n    const hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n    const affectsDataDefined = typeof options.affectsData == 'boolean';\n    // Use previously defined marker's affectsData if the property is not provided.\n    const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n    if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {\n      /**\n       * One of the options is required - provide range, usingOperations or affectsData.\n       *\n       * @error writer-updatemarker-wrong-options\n       */\n      throw new CKEditorError('writer-updatemarker-wrong-options', this);\n    }\n    const currentRange = currentMarker.getRange();\n    const updatedRange = options.range ? options.range : currentRange;\n    if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {\n      // The marker type is changed so it's necessary to create proper operations.\n      if (options.usingOperation) {\n        // If marker changes to a managed one treat this as synchronizing existing marker.\n        // Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n        applyMarkerOperation(this, markerName, null, updatedRange, affectsData);\n      } else {\n        // If marker changes to a marker that do not use operations then we need to create additional operation\n        // that removes that marker first.\n        applyMarkerOperation(this, markerName, currentRange, null, affectsData);\n        // Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n        this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n      }\n      return;\n    }\n    // Marker's type doesn't change so update it accordingly.\n    if (currentMarker.managedUsingOperations) {\n      applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);\n    } else {\n      this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n    }\n  }\n  /**\n   * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n   * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n   * it will be destroyed using operation.\n   *\n   * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n   */\n  removeMarker(markerOrName) {\n    this._assertWriterUsedCorrectly();\n    const name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n    if (!this.model.markers.has(name)) {\n      /**\n       * Trying to remove marker which does not exist.\n       *\n       * @error writer-removemarker-no-marker\n       */\n      throw new CKEditorError('writer-removemarker-no-marker', this);\n    }\n    const marker = this.model.markers.get(name);\n    if (!marker.managedUsingOperations) {\n      this.model.markers._remove(name);\n      return;\n    }\n    const oldRange = marker.getRange();\n    applyMarkerOperation(this, name, oldRange, null, marker.affectsData);\n  }\n  /**\n   * Sets the document's selection (ranges and direction) to the specified location based on the given\n   * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\twriter.setSelection( ranges );\n   *\n   *\t\t// Sets selection to other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\twriter.setSelection( otherSelection );\n   *\n   *\t\t// Sets selection to the given document selection.\n   *\t\tconst documentSelection = model.document.selection;\n   *\t\twriter.setSelection( documentSelection );\n   *\n   *\t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPosition( root, path );\n   *\t\twriter.setSelection( position );\n   *\n   *\t\t// Sets collapsed selection at the position of the given node and an offset.\n   *\t\twriter.setSelection( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   *\t\twriter.setSelection( paragraph, 'in' );\n   *\n   * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\twriter.setSelection( paragraph, 'on' );\n   *\n   *\t\t// Removes all selection's ranges.\n   *\t\twriter.setSelection( null );\n   *\n   * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\twriter.setSelection( range, { backward: true } );\n   *\n   * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n  setSelection() {\n    this._assertWriterUsedCorrectly();\n    this.model.document.selection._setTo(...arguments);\n  }\n  /**\n   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n   *\n   * The location can be specified in the same form as\n   * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n  setSelectionFocus(itemOrPosition, offset) {\n    this._assertWriterUsedCorrectly();\n    this.model.document.selection._setFocus(itemOrPosition, offset);\n  }\n  /**\n   * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n   *\n   * Using key and value pair:\n   *\n   * \twriter.setSelectionAttribute( 'italic', true );\n   *\n   * Using key-value object:\n   *\n   * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n   *\n   * Using iterable object:\n   *\n   * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n   *\n   * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n   * or object / iterable of key => value attribute pairs.\n   * @param {*} [value] Attribute value.\n   */\n  setSelectionAttribute(keyOrObjectOrIterable, value) {\n    this._assertWriterUsedCorrectly();\n    if (typeof keyOrObjectOrIterable === 'string') {\n      this._setSelectionAttribute(keyOrObjectOrIterable, value);\n    } else {\n      for (const [key, value] of toMap(keyOrObjectOrIterable)) {\n        this._setSelectionAttribute(key, value);\n      }\n    }\n  }\n  /**\n   * Removes attribute(s) with given key(s) from the selection.\n   *\n   * Remove one attribute:\n   *\n   *\t\twriter.removeSelectionAttribute( 'italic' );\n   *\n   * Remove multiple attributes:\n   *\n   *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n   *\n   * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n   */\n  removeSelectionAttribute(keyOrIterableOfKeys) {\n    this._assertWriterUsedCorrectly();\n    if (typeof keyOrIterableOfKeys === 'string') {\n      this._removeSelectionAttribute(keyOrIterableOfKeys);\n    } else {\n      for (const key of keyOrIterableOfKeys) {\n        this._removeSelectionAttribute(key);\n      }\n    }\n  }\n  /**\n   * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n   * of the selection from left to right.\n   *\n   * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n   * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n   * This method allows to temporarily override this behavior by forcing the gravity to the right.\n   *\n   * For the following model fragment:\n   *\n   *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n   *\n   * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n   * * Overridden gravity: selection will have `bold` attribute.\n   *\n   * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n   * of the process.\n   *\n   * @returns {String} The unique id which allows restoring the gravity.\n   */\n  overrideSelectionGravity() {\n    return this.model.document.selection._overrideGravity();\n  }\n  /**\n   * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n   *\n   * Restoring the gravity is only possible using the unique identifier returned by\n   * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n   * the same number of times it was overridden.\n   *\n   * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n   */\n  restoreSelectionGravity(uid) {\n    this.model.document.selection._restoreGravity(uid);\n  }\n  /**\n   * @private\n   * @param {String} key Key of the attribute to remove.\n   * @param {*} value Attribute value.\n   */\n  _setSelectionAttribute(key, value) {\n    const selection = this.model.document.selection;\n    // Store attribute in parent element if the selection is collapsed in an empty node.\n    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n      const storeKey = DocumentSelection._getStoreAttributeKey(key);\n      this.setAttribute(storeKey, value, selection.anchor.parent);\n    }\n    selection._setAttribute(key, value);\n  }\n  /**\n   * @private\n   * @param {String} key Key of the attribute to remove.\n   */\n  _removeSelectionAttribute(key) {\n    const selection = this.model.document.selection;\n    // Remove stored attribute from parent element if the selection is collapsed in an empty node.\n    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n      const storeKey = DocumentSelection._getStoreAttributeKey(key);\n      this.removeAttribute(storeKey, selection.anchor.parent);\n    }\n    selection._removeAttribute(key);\n  }\n  /**\n   * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n   *\n   * @private\n   */\n  _assertWriterUsedCorrectly() {\n    /**\n     * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or\n     * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n     *\n     * The writer can only be used inside these blocks which ensures that the model\n     * can only be changed during such \"sessions\".\n     *\n     * @error writer-incorrect-use\n     */\n    if (this.model._currentWriter !== this) {\n      throw new CKEditorError('writer-incorrect-use', this);\n    }\n  }\n  /**\n   * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n   * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n   * can be later correctly processed during undo.\n   *\n   * @private\n   * @param {'move'|'merge'} type Writer action type.\n   * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n   * where the writer action happens.\n   */\n  _addOperationForAffectedMarkers(type, positionOrRange) {\n    for (const marker of this.model.markers) {\n      if (!marker.managedUsingOperations) {\n        continue;\n      }\n      const markerRange = marker.getRange();\n      let isAffected = false;\n      if (type === 'move') {\n        const range = positionOrRange;\n        isAffected = range.containsPosition(markerRange.start) || range.start.isEqual(markerRange.start) || range.containsPosition(markerRange.end) || range.end.isEqual(markerRange.end);\n      } else {\n        // if type === 'merge'.\n        const position = positionOrRange;\n        const elementBefore = position.nodeBefore;\n        const elementAfter = position.nodeAfter;\n        //               Start:  <p>Foo[</p><p>Bar]</p>\n        //         After merge:  <p>Foo[Bar]</p>\n        // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n        //\n        const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;\n        //               Start:  <p>[Foo</p><p>]Bar</p>\n        //         After merge:  <p>[Foo]Bar</p>\n        // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n        //\n        const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;\n        //               Start:  <p>[Foo</p>]<p>Bar</p>\n        //         After merge:  <p>[Foo]Bar</p>\n        // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n        //\n        const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;\n        //               Start:  <p>Foo</p>[<p>Bar]</p>\n        //         After merge:  <p>Foo[Bar]</p>\n        // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n        //\n        const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n        isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n      }\n      if (isAffected) {\n        this.updateMarker(marker.name, {\n          range: markerRange\n        });\n      }\n    }\n  }\n}\n// Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\nfunction setAttributeOnRange(writer, key, value, range) {\n  const model = writer.model;\n  const doc = model.document;\n  // Position of the last split, the beginning of the new range.\n  let lastSplitPosition = range.start;\n  // Currently position in the scanning range. Because we need value after the position, it is not a current\n  // position of the iterator but the previous one (we need to iterate one more time to get the value after).\n  let position;\n  // Value before the currently position.\n  let valueBefore;\n  // Value after the currently position.\n  let valueAfter;\n  for (const val of range.getWalker({\n    shallow: true\n  })) {\n    valueAfter = val.item.getAttribute(key);\n    // At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n    // because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n    if (position && valueBefore != valueAfter) {\n      // if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n      if (valueBefore != value) {\n        addOperation();\n      }\n      lastSplitPosition = position;\n    }\n    position = val.nextPosition;\n    valueBefore = valueAfter;\n  }\n  // Because position in the loop is not the iterator position (see let position comment), the last position in\n  // the while loop will be last but one position in the range. We need to check the last position manually.\n  if (position instanceof Position && position != lastSplitPosition && valueBefore != value) {\n    addOperation();\n  }\n  function addOperation() {\n    const range = new Range(lastSplitPosition, position);\n    const version = range.root.document ? doc.version : null;\n    const operation = new AttributeOperation(range, key, valueBefore, value, version);\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n}\n// Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\nfunction setAttributeOnItem(writer, key, value, item) {\n  const model = writer.model;\n  const doc = model.document;\n  const previousValue = item.getAttribute(key);\n  let range, operation;\n  if (previousValue != value) {\n    const isRootChanged = item.root === item;\n    if (isRootChanged) {\n      // If we change attributes of root element, we have to use `RootAttributeOperation`.\n      const version = item.document ? doc.version : null;\n      operation = new RootAttributeOperation(item, key, previousValue, value, version);\n    } else {\n      range = new Range(Position._createBefore(item), writer.createPositionAfter(item));\n      const version = range.root.document ? doc.version : null;\n      operation = new AttributeOperation(range, key, previousValue, value, version);\n    }\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n}\n// Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\nfunction applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {\n  const model = writer.model;\n  const doc = model.document;\n  const operation = new MarkerOperation(name, oldRange, newRange, model.markers, !!affectsData, doc.version);\n  writer.batch.addOperation(operation);\n  model.applyOperation(operation);\n}\n// Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\nfunction applyRemoveOperation(position, howMany, batch, model) {\n  let operation;\n  if (position.root.document) {\n    const doc = model.document;\n    const graveyardPosition = new Position(doc.graveyard, [0]);\n    operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);\n  } else {\n    operation = new DetachOperation(position, howMany);\n  }\n  batch.addOperation(operation);\n  model.applyOperation(operation);\n}\n// Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\nfunction isSameTree(rootA, rootB) {\n  // If it is the same root this is the same tree.\n  if (rootA === rootB) {\n    return true;\n  }\n  // If both roots are documents root it is operation within the document what we still treat as the same tree.\n  if (rootA instanceof RootElement && rootB instanceof RootElement) {\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["AttributeOperation","DetachOperation","InsertOperation","MarkerOperation","MergeOperation","MoveOperation","RenameOperation","RootAttributeOperation","SplitOperation","DocumentFragment","DocumentSelection","Element","Position","Range","RootElement","Text","toMap","CKEditorError","logWarning","Writer","constructor","model","batch","createText","data","attributes","createElement","name","createDocumentFragment","cloneElement","element","deep","_clone","insert","item","itemOrPosition","offset","_assertWriterUsedCorrectly","position","_createAt","parent","isSameTree","root","move","_createOn","document","remove","version","shouldReceiveAttributes","addOperation","applyOperation","markerName","markerRange","markers","rangeRootPosition","range","start","_getCombined","end","options","usingOperation","affectsData","has","updateMarker","addMarker","insertText","text","insertElement","itemOrPositionOrOffset","append","appendText","appendElement","setAttribute","key","value","itemOrRange","ranges","getMinimalFlatRanges","setAttributeOnRange","setAttributeOnItem","setAttributes","val","removeAttribute","clearAttributes","removeAttributesFromItem","attribute","getAttributeKeys","getItems","isFlat","isEqual","_addOperationForAffectedMarkers","operation","rangeToRemove","reverse","flat","applyRemoveOperation","merge","nodeBefore","nodeAfter","_mergeDetached","_merge","createPositionFromPath","path","stickiness","createPositionAt","createPositionAfter","createPositionBefore","createRange","createRangeIn","createRangeOn","createSelection","_createIn","targetPosition","sourcePosition","graveyard","graveyardPosition","maxOffset","rename","newName","renameOperation","_createBefore","split","limitElement","splitElement","getAncestors","includeSelf","includes","firstSplitElement","firstCopyElement","howMany","insertionPosition","getInsertionPosition","nextSibling","wrap","elementOrString","childCount","shiftedRange","getShiftedBy","unwrap","undefined","_set","applyMarkerOperation","get","markerOrName","currentMarker","_refresh","hasUsingOperationDefined","affectsDataDefined","currentRange","getRange","updatedRange","managedUsingOperations","removeMarker","marker","_remove","oldRange","setSelection","selection","_setTo","setSelectionFocus","_setFocus","setSelectionAttribute","keyOrObjectOrIterable","_setSelectionAttribute","removeSelectionAttribute","keyOrIterableOfKeys","_removeSelectionAttribute","overrideSelectionGravity","_overrideGravity","restoreSelectionGravity","uid","_restoreGravity","isCollapsed","anchor","isEmpty","storeKey","_getStoreAttributeKey","_setAttribute","_removeAttribute","_currentWriter","type","positionOrRange","isAffected","containsPosition","elementBefore","elementAfter","affectedInLeftElement","isAtEnd","affectedInRightElement","affectedAfterLeftElement","affectedBeforeRightElement","writer","doc","lastSplitPosition","valueBefore","valueAfter","getWalker","shallow","getAttribute","nextPosition","previousValue","isRootChanged","newRange","rootA","rootB"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/writer\n */\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MergeOperation from './operation/mergeoperation';\nimport MoveOperation from './operation/moveoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\nimport SplitOperation from './operation/splitoperation';\nimport DocumentFragment from './documentfragment';\nimport DocumentSelection from './documentselection';\nimport Element from './element';\nimport Position from './position';\nimport Range from './range';\nimport RootElement from './rootelement';\nimport Text from './text';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError, { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\nexport default class Writer {\n    /**\n     * Creates a writer instance.\n     *\n     * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n     * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n     *\n     * @protected\n     * @param {module:engine/model/model~Model} model\n     * @param {module:engine/model/batch~Batch} batch\n     */\n    constructor(model, batch) {\n        /**\n         * Instance of the model on which this writer operates.\n         *\n         * @readonly\n         * @type {module:engine/model/model~Model}\n         */\n        this.model = model;\n        /**\n         * The batch to which this writer will add changes.\n         *\n         * @readonly\n         * @type {module:engine/model/batch~Batch}\n         */\n        this.batch = batch;\n    }\n    /**\n     * Creates a new {@link module:engine/model/text~Text text node}.\n     *\n     *\t\twriter.createText( 'foo' );\n     *\t\twriter.createText( 'foo', { bold: true } );\n     *\n     * @param {String} data Text data.\n     * @param {Object} [attributes] Text attributes.\n     * @returns {module:engine/model/text~Text} Created text node.\n     */\n    createText(data, attributes) {\n        return new Text(data, attributes);\n    }\n    /**\n     * Creates a new {@link module:engine/model/element~Element element}.\n     *\n     *\t\twriter.createElement( 'paragraph' );\n     *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @returns {module:engine/model/element~Element} Created element.\n     */\n    createElement(name, attributes) {\n        return new Element(name, attributes);\n    }\n    /**\n     * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n     *\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n     */\n    createDocumentFragment() {\n        return new DocumentFragment();\n    }\n    /**\n     * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.\n     * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n     *\n     * @param {module:engine/model/element~Element} element The element to clone.\n     * @param {Boolean} [deep=true] If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any child.\n     */\n    cloneElement(element, deep = true) {\n        return element._clone(deep);\n    }\n    /**\n     * Inserts item on given position.\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.insert( paragraph, position );\n     *\n     * Instead of using position you can use parent and offset:\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\twriter.insert( text, paragraph, 5 );\n     *\n     * You can also use `end` instead of the offset to insert at the end:\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\twriter.insert( text, paragraph, 'end' );\n     *\n     * Or insert before or after another element:\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * Note that if the item already has parent it will be removed from the previous parent.\n     *\n     * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n     * `model-writer-insert-forbidden-move` is thrown.\n     *\n     * If you want to move {@link module:engine/model/range~Range range} instead of an\n     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n     *\n     * **Note:** For a paste-like content insertion mechanism see\n     * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n     * fragment to insert.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * second parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    insert(item, itemOrPosition, offset = 0) {\n        this._assertWriterUsedCorrectly();\n        if (item instanceof Text && item.data == '') {\n            return;\n        }\n        const position = Position._createAt(itemOrPosition, offset);\n        // If item has a parent already.\n        if (item.parent) {\n            // We need to check if item is going to be inserted within the same document.\n            if (isSameTree(item.root, position.root)) {\n                // If it's we just need to move it.\n                this.move(Range._createOn(item), position);\n                return;\n            }\n            // If it isn't the same root.\n            else {\n                if (item.root.document) {\n                    /**\n                     * Cannot move a node from a document to a different tree.\n                     * It is forbidden to move a node that was already in a document outside of it.\n                     *\n                     * @error model-writer-insert-forbidden-move\n                     */\n                    throw new CKEditorError('model-writer-insert-forbidden-move', this);\n                }\n                else {\n                    // Move between two different document fragments or from document fragment to a document is possible.\n                    // In that case, remove the item from it's original parent.\n                    this.remove(item);\n                }\n            }\n        }\n        const version = position.root.document ? position.root.document.version : null;\n        const insert = new InsertOperation(position, item, version);\n        if (item instanceof Text) {\n            insert.shouldReceiveAttributes = true;\n        }\n        this.batch.addOperation(insert);\n        this.model.applyOperation(insert);\n        // When element is a DocumentFragment we need to move its markers to Document#markers.\n        if (item instanceof DocumentFragment) {\n            for (const [markerName, markerRange] of item.markers) {\n                // We need to migrate marker range from DocumentFragment to Document.\n                const rangeRootPosition = Position._createAt(markerRange.root, 0);\n                const range = new Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));\n                const options = { range, usingOperation: true, affectsData: true };\n                if (this.model.markers.has(markerName)) {\n                    this.updateMarker(markerName, options);\n                }\n                else {\n                    this.addMarker(markerName, options);\n                }\n            }\n        }\n    }\n    /**\n     * Creates and inserts text on given position. You can optionally set text attributes:\n     *\n     *\t\twriter.insertText( 'foo', position );\n     *\t\twriter.insertText( 'foo', { bold: true }, position );\n     *\n     * Instead of using position you can use parent and offset or define that text should be inserted at the end\n     * or before or after other node:\n     *\n     *\t\t// Inserts 'foo' in paragraph, at offset 5:\n     *\t\twriter.insertText( 'foo', paragraph, 5 );\n     *\t\t// Inserts 'foo' at the end of a paragraph:\n     *\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t// Inserts 'foo' after an image:\n     *\t\twriter.insertText( 'foo', image, 'after' );\n     *\n     * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * @param {String} dattexta Text data.\n     * @param {Object} [attributes] Text attributes.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * third parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    insertText(text, attributes, // Too complicated when not using `any`.\n    itemOrPosition, // Too complicated when not using `any`.\n    offset // Too complicated when not using `any`.\n    ) {\n        if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n            this.insert(this.createText(text), attributes, itemOrPosition);\n        }\n        else {\n            this.insert(this.createText(text, attributes), itemOrPosition, offset);\n        }\n    }\n    /**\n     * Creates and inserts element on given position. You can optionally set attributes:\n     *\n     *\t\twriter.insertElement( 'paragraph', position );\n     *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n     *\n     * Instead of using position you can use parent and offset or define that text should be inserted at the end\n     * or before or after other node:\n     *\n     *\t\t// Inserts paragraph in the root at offset 5:\n     *\t\twriter.insertElement( 'paragraph', root, 5 );\n     *\t\t// Inserts paragraph at the end of a blockquote:\n     *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n     *\t\t// Inserts after an image:\n     *\t\twriter.insertElement( 'paragraph', image, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * third parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    insertElement(name, attributes, // Too complicated when not using `any`.\n    itemOrPositionOrOffset, // Too complicated when not using `any`.\n    offset // Too complicated when not using `any`.\n    ) {\n        if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n            this.insert(this.createElement(name), attributes, itemOrPositionOrOffset);\n        }\n        else {\n            this.insert(this.createElement(name, attributes), itemOrPositionOrOffset, offset);\n        }\n    }\n    /**\n     * Inserts item at the end of the given parent.\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.append( paragraph, root );\n     *\n     * Note that if the item already has parent it will be removed from the previous parent.\n     *\n     * If you want to move {@link module:engine/model/range~Range range} instead of an\n     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n     * item Item or document fragment to insert.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n    append(item, parent) {\n        this.insert(item, parent, 'end');\n    }\n    /**\n     * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n     *\n     *\t\twriter.appendText( 'foo', paragraph );\n     *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n     *\n     * @param {String} text Text data.\n     * @param {Object} [attributes] Text attributes.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n    appendText(text, attributes, parent) {\n        if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n            this.insert(this.createText(text), attributes, 'end');\n        }\n        else {\n            this.insert(this.createText(text, attributes), parent, 'end');\n        }\n    }\n    /**\n     * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n     *\n     *\t\twriter.appendElement( 'paragraph', root );\n     *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n    appendElement(name, attributes, parent) {\n        if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n            this.insert(this.createElement(name), attributes, 'end');\n        }\n        else {\n            this.insert(this.createElement(name, attributes), parent, 'end');\n        }\n    }\n    /**\n     * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n     * or on a {@link module:engine/model/range~Range range}.\n     *\n     * @param {String} key Attribute key.\n     * @param {*} value Attribute new value.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range on which the attribute will be set.\n     */\n    setAttribute(key, value, itemOrRange) {\n        this._assertWriterUsedCorrectly();\n        if (itemOrRange instanceof Range) {\n            const ranges = itemOrRange.getMinimalFlatRanges();\n            for (const range of ranges) {\n                setAttributeOnRange(this, key, value, range);\n            }\n        }\n        else {\n            setAttributeOnItem(this, key, value, itemOrRange);\n        }\n    }\n    /**\n     * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n     * or on a {@link module:engine/model/range~Range range}.\n     *\n     *\t\twriter.setAttributes( {\n     *\t\t\tbold: true,\n     *\t\t\titalic: true\n     *\t\t}, range );\n     *\n     * @param {Object} attributes Attributes keys and values.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range on which the attributes will be set.\n     */\n    setAttributes(attributes, itemOrRange) {\n        for (const [key, val] of toMap(attributes)) {\n            this.setAttribute(key, val, itemOrRange);\n        }\n    }\n    /**\n     * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n     * or from a {@link module:engine/model/range~Range range}.\n     *\n     * @param {String} key Attribute key.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range from which the attribute will be removed.\n     */\n    removeAttribute(key, itemOrRange) {\n        this._assertWriterUsedCorrectly();\n        if (itemOrRange instanceof Range) {\n            const ranges = itemOrRange.getMinimalFlatRanges();\n            for (const range of ranges) {\n                setAttributeOnRange(this, key, null, range);\n            }\n        }\n        else {\n            setAttributeOnItem(this, key, null, itemOrRange);\n        }\n    }\n    /**\n     * Removes all attributes from all elements in the range or from the given item.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range from which all attributes will be removed.\n     */\n    clearAttributes(itemOrRange) {\n        this._assertWriterUsedCorrectly();\n        const removeAttributesFromItem = (item) => {\n            for (const attribute of item.getAttributeKeys()) {\n                this.removeAttribute(attribute, item);\n            }\n        };\n        if (!(itemOrRange instanceof Range)) {\n            removeAttributesFromItem(itemOrRange);\n        }\n        else {\n            for (const item of itemOrRange.getItems()) {\n                removeAttributesFromItem(item);\n            }\n        }\n    }\n    /**\n     * Moves all items in the source range to the target position.\n     *\n     *\t\twriter.move( sourceRange, targetPosition );\n     *\n     * Instead of the target position you can use parent and offset or define that range should be moved to the end\n     * or before or after chosen item:\n     *\n     *\t\t// Moves all items in the range to the paragraph at offset 5:\n     *\t\twriter.move( sourceRange, paragraph, 5 );\n     *\t\t// Moves all items in the range to the end of a blockquote:\n     *\t\twriter.move( sourceRange, blockquote, 'end' );\n     *\t\t// Moves all items in the range to a position after an image:\n     *\t\twriter.move( sourceRange, image, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * Note that items can be moved only within the same tree. It means that you can move items within the same root\n     * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n     * but you can not move items from document fragment to the document or from one detached element to another. Use\n     * {@link module:engine/model/writer~Writer#insert} in such cases.\n     *\n     * @param {module:engine/model/range~Range} range Source range.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * second parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    move(range, itemOrPosition, offset) {\n        this._assertWriterUsedCorrectly();\n        if (!(range instanceof Range)) {\n            /**\n             * Invalid range to move.\n             *\n             * @error writer-move-invalid-range\n             */\n            throw new CKEditorError('writer-move-invalid-range', this);\n        }\n        if (!range.isFlat) {\n            /**\n             * Range to move is not flat.\n             *\n             * @error writer-move-range-not-flat\n             */\n            throw new CKEditorError('writer-move-range-not-flat', this);\n        }\n        const position = Position._createAt(itemOrPosition, offset);\n        // Do not move anything if the move target is same as moved range start.\n        if (position.isEqual(range.start)) {\n            return;\n        }\n        // If part of the marker is removed, create additional marker operation for undo purposes.\n        this._addOperationForAffectedMarkers('move', range);\n        if (!isSameTree(range.root, position.root)) {\n            /**\n             * Range is going to be moved within not the same document. Please use\n             * {@link module:engine/model/writer~Writer#insert insert} instead.\n             *\n             * @error writer-move-different-document\n             */\n            throw new CKEditorError('writer-move-different-document', this);\n        }\n        const version = range.root.document ? range.root.document.version : null;\n        const operation = new MoveOperation(range.start, range.end.offset - range.start.offset, position, version);\n        this.batch.addOperation(operation);\n        this.model.applyOperation(operation);\n    }\n    /**\n     * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n     */\n    remove(itemOrRange) {\n        this._assertWriterUsedCorrectly();\n        const rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn(itemOrRange);\n        const ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n        for (const flat of ranges) {\n            // If part of the marker is removed, create additional marker operation for undo purposes.\n            this._addOperationForAffectedMarkers('move', flat);\n            applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);\n        }\n    }\n    /**\n     * Merges two siblings at the given position.\n     *\n     * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n     * `writer-merge-no-element-after` error will be thrown.\n     *\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n    merge(position) {\n        this._assertWriterUsedCorrectly();\n        const nodeBefore = position.nodeBefore;\n        const nodeAfter = position.nodeAfter;\n        // If part of the marker is removed, create additional marker operation for undo purposes.\n        this._addOperationForAffectedMarkers('merge', position);\n        if (!(nodeBefore instanceof Element)) {\n            /**\n             * Node before merge position must be an element.\n             *\n             * @error writer-merge-no-element-before\n             */\n            throw new CKEditorError('writer-merge-no-element-before', this);\n        }\n        if (!(nodeAfter instanceof Element)) {\n            /**\n             * Node after merge position must be an element.\n             *\n             * @error writer-merge-no-element-after\n             */\n            throw new CKEditorError('writer-merge-no-element-after', this);\n        }\n        if (!position.root.document) {\n            this._mergeDetached(position);\n        }\n        else {\n            this._merge(position);\n        }\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * See {@link module:engine/model/position~PositionStickiness}.\n     * @returns {module:engine/model/position~Position}\n     */\n    createPositionFromPath(root, path, stickiness) {\n        return this.model.createPositionFromPath(root, path, stickiness);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     * @returns {module:engine/model/position~Position}\n     */\n    createPositionAt(itemOrPosition, offset) {\n        return this.model.createPositionAt(itemOrPosition, offset);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n    createPositionAfter(item) {\n        return this.model.createPositionAfter(item);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n    createPositionBefore(item) {\n        return this.model.createPositionBefore(item);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n     *\n     * @param {module:engine/model/position~Position} start Start position.\n     * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n     * @returns {module:engine/model/range~Range}\n     */\n    createRange(start, end) {\n        return this.model.createRange(start, end);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n    createRangeIn(element) {\n        return this.model.createRangeIn(element);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n    createRangeOn(element) {\n        return this.model.createRangeOn(element);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @returns {module:engine/model/selection~Selection}\n     */\n    createSelection(...args) {\n        return this.model.createSelection(...args);\n    }\n    /**\n     * Performs merge action in a detached tree.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n    _mergeDetached(position) {\n        const nodeBefore = position.nodeBefore;\n        const nodeAfter = position.nodeAfter;\n        this.move(Range._createIn(nodeAfter), Position._createAt(nodeBefore, 'end'));\n        this.remove(nodeAfter);\n    }\n    /**\n     * Performs merge action in a non-detached tree.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n    _merge(position) {\n        const targetPosition = Position._createAt(position.nodeBefore, 'end');\n        const sourcePosition = Position._createAt(position.nodeAfter, 0);\n        const graveyard = position.root.document.graveyard;\n        const graveyardPosition = new Position(graveyard, [0]);\n        const version = position.root.document.version;\n        const merge = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version);\n        this.batch.addOperation(merge);\n        this.model.applyOperation(merge);\n    }\n    /**\n     * Renames the given element.\n     *\n     * @param {module:engine/model/element~Element} element The element to rename.\n     * @param {String} newName New element name.\n     */\n    rename(element, newName) {\n        this._assertWriterUsedCorrectly();\n        if (!(element instanceof Element)) {\n            /**\n             * Trying to rename an object which is not an instance of Element.\n             *\n             * @error writer-rename-not-element-instance\n             */\n            throw new CKEditorError('writer-rename-not-element-instance', this);\n        }\n        const version = element.root.document ? element.root.document.version : null;\n        const renameOperation = new RenameOperation(Position._createBefore(element), element.name, newName, version);\n        this.batch.addOperation(renameOperation);\n        this.model.applyOperation(renameOperation);\n    }\n    /**\n     * Splits elements starting from the given position and going to the top of the model tree as long as given\n     * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n     *\n     * The element needs to have a parent. It cannot be a root element nor a document fragment.\n     * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n     *\n     * @param {module:engine/model/position~Position} position Position of split.\n     * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n     * @returns {Object} result Split result.\n     * @returns {module:engine/model/position~Position} result.position Position between split elements.\n     * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n     * at the beginning of the first copy element.\n     */\n    split(position, limitElement) {\n        this._assertWriterUsedCorrectly();\n        let splitElement = position.parent;\n        if (!splitElement.parent) {\n            /**\n             * Element with no parent can not be split.\n             *\n             * @error writer-split-element-no-parent\n             */\n            throw new CKEditorError('writer-split-element-no-parent', this);\n        }\n        // When limit element is not defined lets set splitElement parent as limit.\n        if (!limitElement) {\n            limitElement = splitElement.parent;\n        }\n        if (!position.parent.getAncestors({ includeSelf: true }).includes(limitElement)) {\n            /**\n             * Limit element is not a position ancestor.\n             *\n             * @error writer-split-invalid-limit-element\n             */\n            throw new CKEditorError('writer-split-invalid-limit-element', this);\n        }\n        // We need to cache elements that will be created as a result of the first split because\n        // we need to create a range from the end of the first split element to the beginning of the\n        // first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n        let firstSplitElement;\n        let firstCopyElement;\n        do {\n            const version = splitElement.root.document ? splitElement.root.document.version : null;\n            const howMany = splitElement.maxOffset - position.offset;\n            const insertionPosition = SplitOperation.getInsertionPosition(position);\n            const split = new SplitOperation(position, howMany, insertionPosition, null, version);\n            this.batch.addOperation(split);\n            this.model.applyOperation(split);\n            // Cache result of the first split.\n            if (!firstSplitElement && !firstCopyElement) {\n                firstSplitElement = splitElement;\n                firstCopyElement = position.parent.nextSibling;\n            }\n            position = this.createPositionAfter(position.parent);\n            splitElement = position.parent;\n        } while (splitElement !== limitElement);\n        return {\n            position,\n            range: new Range(Position._createAt(firstSplitElement, 'end'), Position._createAt(firstCopyElement, 0))\n        };\n    }\n    /**\n     * Wraps the given range with the given element or with a new element (if a string was passed).\n     *\n     * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n     * If not, an error will be thrown.\n     *\n     * @param {module:engine/model/range~Range} range Range to wrap.\n     * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n     */\n    wrap(range, elementOrString) {\n        this._assertWriterUsedCorrectly();\n        if (!range.isFlat) {\n            /**\n             * Range to wrap is not flat.\n             *\n             * @error writer-wrap-range-not-flat\n             */\n            throw new CKEditorError('writer-wrap-range-not-flat', this);\n        }\n        const element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);\n        if (element.childCount > 0) {\n            /**\n             * Element to wrap with is not empty.\n             *\n             * @error writer-wrap-element-not-empty\n             */\n            throw new CKEditorError('writer-wrap-element-not-empty', this);\n        }\n        if (element.parent !== null) {\n            /**\n             * Element to wrap with is already attached to a tree model.\n             *\n             * @error writer-wrap-element-attached\n             */\n            throw new CKEditorError('writer-wrap-element-attached', this);\n        }\n        this.insert(element, range.start);\n        // Shift the range-to-wrap because we just inserted an element before that range.\n        const shiftedRange = new Range(range.start.getShiftedBy(1), range.end.getShiftedBy(1));\n        this.move(shiftedRange, Position._createAt(element, 0));\n    }\n    /**\n     * Unwraps children of the given element – all its children are moved before it and then the element is removed.\n     * Throws error if you try to unwrap an element which does not have a parent.\n     *\n     * @param {module:engine/model/element~Element} element Element to unwrap.\n     */\n    unwrap(element) {\n        this._assertWriterUsedCorrectly();\n        if (element.parent === null) {\n            /**\n             * Trying to unwrap an element which has no parent.\n             *\n             * @error writer-unwrap-element-no-parent\n             */\n            throw new CKEditorError('writer-unwrap-element-no-parent', this);\n        }\n        this.move(Range._createIn(element), this.createPositionAfter(element));\n        this.remove(element);\n    }\n    /**\n     * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n     * changes in the document and updates its range automatically, when model tree changes.\n     *\n     * As the first parameter you can set marker name.\n     *\n     * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n     * markers managed by operations and not-managed by operations.\n     *\n     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n     * `true` when the marker change changes the data returned by the\n     * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n     *\n     * Create marker directly base on marker's name:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: false } );\n     *\n     * Create marker using operation:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: true } );\n     *\n     * Create marker that affects the editor data:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n     *\n     * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n     *\n     * @see module:engine/model/markercollection~Marker\n     * @param {String} name Name of a marker to create - must be unique.\n     * @param {Object} options\n     * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n     * @param {module:engine/model/range~Range} options.range Marker range.\n     * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n     * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n     */\n    addMarker(name, options) {\n        this._assertWriterUsedCorrectly();\n        if (!options || typeof options.usingOperation != 'boolean') {\n            /**\n             * The `options.usingOperation` parameter is required when adding a new marker.\n             *\n             * @error writer-addmarker-no-usingoperation\n             */\n            throw new CKEditorError('writer-addmarker-no-usingoperation', this);\n        }\n        const usingOperation = options.usingOperation;\n        const range = options.range;\n        const affectsData = options.affectsData === undefined ? false : options.affectsData;\n        if (this.model.markers.has(name)) {\n            /**\n             * Marker with provided name already exists.\n             *\n             * @error writer-addmarker-marker-exists\n             */\n            throw new CKEditorError('writer-addmarker-marker-exists', this);\n        }\n        if (!range) {\n            /**\n             * Range parameter is required when adding a new marker.\n             *\n             * @error writer-addmarker-no-range\n             */\n            throw new CKEditorError('writer-addmarker-no-range', this);\n        }\n        if (!usingOperation) {\n            return this.model.markers._set(name, range, usingOperation, affectsData);\n        }\n        applyMarkerOperation(this, name, null, range, affectsData);\n        return this.model.markers.get(name);\n    }\n    /**\n     * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n     * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n     * marker's range directly using this method.\n     *\n     * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n     * name is created and returned.\n     *\n     * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model\n     * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.\n     *\n     * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n     * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n     *\n     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n     * `true` when the marker change changes the data returned by\n     * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n     *\n     * Update marker directly base on marker's name:\n     *\n     *\t\tupdateMarker( markerName, { range } );\n     *\n     * Update marker using operation:\n     *\n     *\t\tupdateMarker( marker, { range, usingOperation: true } );\n     *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n     *\n     * Change marker's option (start using operations to manage it):\n     *\n     *\t\tupdateMarker( marker, { usingOperation: true } );\n     *\n     * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n     *\n     *\t\tupdateMarker( markerName, { affectsData: false } );\n     *\n     * @see module:engine/model/markercollection~Marker\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n     * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n     * downcast conversion for this marker with the same data.\n     * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n     * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n     * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n     */\n    updateMarker(markerOrName, options) {\n        this._assertWriterUsedCorrectly();\n        const markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n        const currentMarker = this.model.markers.get(markerName);\n        if (!currentMarker) {\n            /**\n             * Marker with provided name does not exist and will not be updated.\n             *\n             * @error writer-updatemarker-marker-not-exists\n             */\n            throw new CKEditorError('writer-updatemarker-marker-not-exists', this);\n        }\n        if (!options) {\n            /**\n             * The usage of `writer.updateMarker()` only to reconvert (refresh) a\n             * {@link module:engine/model/markercollection~Marker model marker} was deprecated and may not work in the future.\n             * Please update your code to use\n             * {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker `editor.editing.reconvertMarker()`}\n             * instead.\n             *\n             * @error writer-updatemarker-reconvert-using-editingcontroller\n             * @param {String} markerName The name of the updated marker.\n             */\n            logWarning('writer-updatemarker-reconvert-using-editingcontroller', { markerName });\n            this.model.markers._refresh(currentMarker);\n            return;\n        }\n        const hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n        const affectsDataDefined = typeof options.affectsData == 'boolean';\n        // Use previously defined marker's affectsData if the property is not provided.\n        const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n        if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {\n            /**\n             * One of the options is required - provide range, usingOperations or affectsData.\n             *\n             * @error writer-updatemarker-wrong-options\n             */\n            throw new CKEditorError('writer-updatemarker-wrong-options', this);\n        }\n        const currentRange = currentMarker.getRange();\n        const updatedRange = options.range ? options.range : currentRange;\n        if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {\n            // The marker type is changed so it's necessary to create proper operations.\n            if (options.usingOperation) {\n                // If marker changes to a managed one treat this as synchronizing existing marker.\n                // Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n                applyMarkerOperation(this, markerName, null, updatedRange, affectsData);\n            }\n            else {\n                // If marker changes to a marker that do not use operations then we need to create additional operation\n                // that removes that marker first.\n                applyMarkerOperation(this, markerName, currentRange, null, affectsData);\n                // Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n                this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n            }\n            return;\n        }\n        // Marker's type doesn't change so update it accordingly.\n        if (currentMarker.managedUsingOperations) {\n            applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);\n        }\n        else {\n            this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n        }\n    }\n    /**\n     * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n     * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n     * it will be destroyed using operation.\n     *\n     * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n     */\n    removeMarker(markerOrName) {\n        this._assertWriterUsedCorrectly();\n        const name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n        if (!this.model.markers.has(name)) {\n            /**\n             * Trying to remove marker which does not exist.\n             *\n             * @error writer-removemarker-no-marker\n             */\n            throw new CKEditorError('writer-removemarker-no-marker', this);\n        }\n        const marker = this.model.markers.get(name);\n        if (!marker.managedUsingOperations) {\n            this.model.markers._remove(name);\n            return;\n        }\n        const oldRange = marker.getRange();\n        applyMarkerOperation(this, name, oldRange, null, marker.affectsData);\n    }\n    /**\n     * Sets the document's selection (ranges and direction) to the specified location based on the given\n     * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\twriter.setSelection( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\twriter.setSelection( ranges );\n     *\n     *\t\t// Sets selection to other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\twriter.setSelection( otherSelection );\n     *\n     *\t\t// Sets selection to the given document selection.\n     *\t\tconst documentSelection = model.document.selection;\n     *\t\twriter.setSelection( documentSelection );\n     *\n     *\t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPosition( root, path );\n     *\t\twriter.setSelection( position );\n     *\n     *\t\t// Sets collapsed selection at the position of the given node and an offset.\n     *\t\twriter.setSelection( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     *\t\twriter.setSelection( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\twriter.setSelection( paragraph, 'on' );\n     *\n     *\t\t// Removes all selection's ranges.\n     *\t\twriter.setSelection( null );\n     *\n     * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n     *\n     *\t\t// Sets selection as backward.\n     *\t\twriter.setSelection( range, { backward: true } );\n     *\n     * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n    setSelection(...args) {\n        this._assertWriterUsedCorrectly();\n        this.model.document.selection._setTo(...args);\n    }\n    /**\n     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n     *\n     * The location can be specified in the same form as\n     * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n    setSelectionFocus(itemOrPosition, offset) {\n        this._assertWriterUsedCorrectly();\n        this.model.document.selection._setFocus(itemOrPosition, offset);\n    }\n    /**\n     * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n     *\n     * Using key and value pair:\n     *\n     * \twriter.setSelectionAttribute( 'italic', true );\n     *\n     * Using key-value object:\n     *\n     * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n     *\n     * Using iterable object:\n     *\n     * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n     *\n     * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n     * or object / iterable of key => value attribute pairs.\n     * @param {*} [value] Attribute value.\n     */\n    setSelectionAttribute(keyOrObjectOrIterable, value) {\n        this._assertWriterUsedCorrectly();\n        if (typeof keyOrObjectOrIterable === 'string') {\n            this._setSelectionAttribute(keyOrObjectOrIterable, value);\n        }\n        else {\n            for (const [key, value] of toMap(keyOrObjectOrIterable)) {\n                this._setSelectionAttribute(key, value);\n            }\n        }\n    }\n    /**\n     * Removes attribute(s) with given key(s) from the selection.\n     *\n     * Remove one attribute:\n     *\n     *\t\twriter.removeSelectionAttribute( 'italic' );\n     *\n     * Remove multiple attributes:\n     *\n     *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n     *\n     * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n     */\n    removeSelectionAttribute(keyOrIterableOfKeys) {\n        this._assertWriterUsedCorrectly();\n        if (typeof keyOrIterableOfKeys === 'string') {\n            this._removeSelectionAttribute(keyOrIterableOfKeys);\n        }\n        else {\n            for (const key of keyOrIterableOfKeys) {\n                this._removeSelectionAttribute(key);\n            }\n        }\n    }\n    /**\n     * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n     * of the selection from left to right.\n     *\n     * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n     * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n     * This method allows to temporarily override this behavior by forcing the gravity to the right.\n     *\n     * For the following model fragment:\n     *\n     *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n     *\n     * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n     * * Overridden gravity: selection will have `bold` attribute.\n     *\n     * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n     * of the process.\n     *\n     * @returns {String} The unique id which allows restoring the gravity.\n     */\n    overrideSelectionGravity() {\n        return this.model.document.selection._overrideGravity();\n    }\n    /**\n     * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n     *\n     * Restoring the gravity is only possible using the unique identifier returned by\n     * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n     * the same number of times it was overridden.\n     *\n     * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n     */\n    restoreSelectionGravity(uid) {\n        this.model.document.selection._restoreGravity(uid);\n    }\n    /**\n     * @private\n     * @param {String} key Key of the attribute to remove.\n     * @param {*} value Attribute value.\n     */\n    _setSelectionAttribute(key, value) {\n        const selection = this.model.document.selection;\n        // Store attribute in parent element if the selection is collapsed in an empty node.\n        if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n            const storeKey = DocumentSelection._getStoreAttributeKey(key);\n            this.setAttribute(storeKey, value, selection.anchor.parent);\n        }\n        selection._setAttribute(key, value);\n    }\n    /**\n     * @private\n     * @param {String} key Key of the attribute to remove.\n     */\n    _removeSelectionAttribute(key) {\n        const selection = this.model.document.selection;\n        // Remove stored attribute from parent element if the selection is collapsed in an empty node.\n        if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n            const storeKey = DocumentSelection._getStoreAttributeKey(key);\n            this.removeAttribute(storeKey, selection.anchor.parent);\n        }\n        selection._removeAttribute(key);\n    }\n    /**\n     * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n     *\n     * @private\n     */\n    _assertWriterUsedCorrectly() {\n        /**\n         * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or\n         * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n         *\n         * The writer can only be used inside these blocks which ensures that the model\n         * can only be changed during such \"sessions\".\n         *\n         * @error writer-incorrect-use\n         */\n        if (this.model._currentWriter !== this) {\n            throw new CKEditorError('writer-incorrect-use', this);\n        }\n    }\n    /**\n     * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n     * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n     * can be later correctly processed during undo.\n     *\n     * @private\n     * @param {'move'|'merge'} type Writer action type.\n     * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n     * where the writer action happens.\n     */\n    _addOperationForAffectedMarkers(type, positionOrRange) {\n        for (const marker of this.model.markers) {\n            if (!marker.managedUsingOperations) {\n                continue;\n            }\n            const markerRange = marker.getRange();\n            let isAffected = false;\n            if (type === 'move') {\n                const range = positionOrRange;\n                isAffected =\n                    range.containsPosition(markerRange.start) ||\n                        range.start.isEqual(markerRange.start) ||\n                        range.containsPosition(markerRange.end) ||\n                        range.end.isEqual(markerRange.end);\n            }\n            else {\n                // if type === 'merge'.\n                const position = positionOrRange;\n                const elementBefore = position.nodeBefore;\n                const elementAfter = position.nodeAfter;\n                //               Start:  <p>Foo[</p><p>Bar]</p>\n                //         After merge:  <p>Foo[Bar]</p>\n                // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n                //\n                const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;\n                //               Start:  <p>[Foo</p><p>]Bar</p>\n                //         After merge:  <p>[Foo]Bar</p>\n                // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n                //\n                const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;\n                //               Start:  <p>[Foo</p>]<p>Bar</p>\n                //         After merge:  <p>[Foo]Bar</p>\n                // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n                //\n                const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;\n                //               Start:  <p>Foo</p>[<p>Bar]</p>\n                //         After merge:  <p>Foo[Bar]</p>\n                // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n                //\n                const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n                isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n            }\n            if (isAffected) {\n                this.updateMarker(marker.name, { range: markerRange });\n            }\n        }\n    }\n}\n// Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\nfunction setAttributeOnRange(writer, key, value, range) {\n    const model = writer.model;\n    const doc = model.document;\n    // Position of the last split, the beginning of the new range.\n    let lastSplitPosition = range.start;\n    // Currently position in the scanning range. Because we need value after the position, it is not a current\n    // position of the iterator but the previous one (we need to iterate one more time to get the value after).\n    let position;\n    // Value before the currently position.\n    let valueBefore;\n    // Value after the currently position.\n    let valueAfter;\n    for (const val of range.getWalker({ shallow: true })) {\n        valueAfter = val.item.getAttribute(key);\n        // At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n        // because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n        if (position && valueBefore != valueAfter) {\n            // if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n            if (valueBefore != value) {\n                addOperation();\n            }\n            lastSplitPosition = position;\n        }\n        position = val.nextPosition;\n        valueBefore = valueAfter;\n    }\n    // Because position in the loop is not the iterator position (see let position comment), the last position in\n    // the while loop will be last but one position in the range. We need to check the last position manually.\n    if (position instanceof Position && position != lastSplitPosition && valueBefore != value) {\n        addOperation();\n    }\n    function addOperation() {\n        const range = new Range(lastSplitPosition, position);\n        const version = range.root.document ? doc.version : null;\n        const operation = new AttributeOperation(range, key, valueBefore, value, version);\n        writer.batch.addOperation(operation);\n        model.applyOperation(operation);\n    }\n}\n// Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\nfunction setAttributeOnItem(writer, key, value, item) {\n    const model = writer.model;\n    const doc = model.document;\n    const previousValue = item.getAttribute(key);\n    let range, operation;\n    if (previousValue != value) {\n        const isRootChanged = item.root === item;\n        if (isRootChanged) {\n            // If we change attributes of root element, we have to use `RootAttributeOperation`.\n            const version = item.document ? doc.version : null;\n            operation = new RootAttributeOperation(item, key, previousValue, value, version);\n        }\n        else {\n            range = new Range(Position._createBefore(item), writer.createPositionAfter(item));\n            const version = range.root.document ? doc.version : null;\n            operation = new AttributeOperation(range, key, previousValue, value, version);\n        }\n        writer.batch.addOperation(operation);\n        model.applyOperation(operation);\n    }\n}\n// Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\nfunction applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {\n    const model = writer.model;\n    const doc = model.document;\n    const operation = new MarkerOperation(name, oldRange, newRange, model.markers, !!affectsData, doc.version);\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n}\n// Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\nfunction applyRemoveOperation(position, howMany, batch, model) {\n    let operation;\n    if (position.root.document) {\n        const doc = model.document;\n        const graveyardPosition = new Position(doc.graveyard, [0]);\n        operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);\n    }\n    else {\n        operation = new DetachOperation(position, howMany);\n    }\n    batch.addOperation(operation);\n    model.applyOperation(operation);\n}\n// Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\nfunction isSameTree(rootA, rootB) {\n    // If it is the same root this is the same tree.\n    if (rootA === rootB) {\n        return true;\n    }\n    // If both roots are documents root it is operation within the document what we still treat as the same tree.\n    if (rootA instanceof RootElement && rootB instanceof RootElement) {\n        return true;\n    }\n    return false;\n}\n"],"mappings":"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,QAAQ,EAAE;IAClCR,oBAAoB,CAAC,IAAI,EAAElH,IAAI,EAAEgI,QAAQ,EAAE,IAAI,EAAEF,MAAM,CAAC5F,WAAW,CAAC;EACxE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+F,YAAY,GAAU;IAClB,IAAI,CAACvH,0BAA0B,EAAE;IACjC,IAAI,CAAChB,KAAK,CAACwB,QAAQ,CAACgH,SAAS,CAACC,MAAM,CAAC,YAAO,CAAC;EACjD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,iBAAiB,CAAC5H,cAAc,EAAEC,MAAM,EAAE;IACtC,IAAI,CAACC,0BAA0B,EAAE;IACjC,IAAI,CAAChB,KAAK,CAACwB,QAAQ,CAACgH,SAAS,CAACG,SAAS,CAAC7H,cAAc,EAAEC,MAAM,CAAC;EACnE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI6H,qBAAqB,CAACC,qBAAqB,EAAExF,KAAK,EAAE;IAChD,IAAI,CAACrC,0BAA0B,EAAE;IACjC,IAAI,OAAO6H,qBAAqB,KAAK,QAAQ,EAAE;MAC3C,IAAI,CAACC,sBAAsB,CAACD,qBAAqB,EAAExF,KAAK,CAAC;IAC7D,CAAC,MACI;MACD,KAAK,MAAM,CAACD,GAAG,EAAEC,KAAK,CAAC,IAAI1D,KAAK,CAACkJ,qBAAqB,CAAC,EAAE;QACrD,IAAI,CAACC,sBAAsB,CAAC1F,GAAG,EAAEC,KAAK,CAAC;MAC3C;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0F,wBAAwB,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"},"metadata":{},"sourceType":"module"}