{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/collection\n */\nimport { Emitter } from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport isIterable from './isiterable';\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Collection extends Emitter {\n  /**\n   * Creates a new Collection instance.\n   *\n   * You can provide an iterable of initial items the collection will be created with:\n   *\n   *\t\tconst collection = new Collection( [ { id: 'John' }, { id: 'Mike' } ] );\n   *\n   *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n   *\t\tconsole.log( collection.get( 1 ) ); // -> { id: 'Mike' }\n   *\t\tconsole.log( collection.get( 'Mike' ) ); // -> { id: 'Mike' }\n   *\n   * Or you can first create a collection and then add new items using the {@link #add} method:\n   *\n   *\t\tconst collection = new Collection();\n   *\n   *\t\tcollection.add( { id: 'John' } );\n   *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n   *\n   * Whatever option you choose, you can always pass a configuration object as the last argument\n   * of the constructor:\n   *\n   *\t\tconst emptyCollection = new Collection( { idProperty: 'name' } );\n   *\t\temptyCollection.add( { name: 'John' } );\n   *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n   *\n   *\t\tconst nonEmptyCollection = new Collection( [ { name: 'John' } ], { idProperty: 'name' } );\n   *\t\tnonEmptyCollection.add( { name: 'George' } );\n   *\t\tconsole.log( collection.get( 'George' ) ); // -> { name: 'George' }\n   *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n   *\n   * @param {Iterable.<Object>|Object} [initialItemsOrOptions] The initial items of the collection or\n   * the options object.\n   * @param {Object} [options={}] The options object, when the first argument is an array of initial items.\n   * @param {String} [options.idProperty='id'] The name of the property which is used to identify an item.\n   * Items that do not have such a property will be assigned one when added to the collection.\n   */\n  constructor() {\n    let initialItemsOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    const hasInitialItems = isIterable(initialItemsOrOptions);\n    if (!hasInitialItems) {\n      options = initialItemsOrOptions;\n    }\n    this._items = [];\n    this._itemMap = new Map();\n    this._idProperty = options.idProperty || 'id';\n    this._bindToExternalToInternalMap = new WeakMap();\n    this._bindToInternalToExternalMap = new WeakMap();\n    this._skippedIndexesFromExternal = [];\n    // Set the initial content of the collection (if provided in the constructor).\n    if (hasInitialItems) {\n      for (const item of initialItemsOrOptions) {\n        this._items.push(item);\n        this._itemMap.set(this._getItemIdBeforeAdding(item), item);\n      }\n    }\n  }\n  /**\n   * The number of items available in the collection.\n   *\n   * @member {Number} #length\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Returns the first item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The first item or `null` if collection is empty.\n   */\n  get first() {\n    return this._items[0] || null;\n  }\n  /**\n   * Returns the last item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The last item or `null` if collection is empty.\n   */\n  get last() {\n    return this._items[this.length - 1] || null;\n  }\n  /**\n   * Adds an item into the collection.\n   *\n   * If the item does not have an id, then it will be automatically generated and set on the item.\n   *\n   * @chainable\n   * @param {Object} item\n   * @param {Number} [index] The position of the item in the collection. The item\n   * is pushed to the collection when `index` not specified.\n   * @fires add\n   * @fires change\n   */\n  add(item, index) {\n    return this.addMany([item], index);\n  }\n  /**\n   * Adds multiple items into the collection.\n   *\n   * Any item not containing an id will get an automatically generated one.\n   *\n   * @chainable\n   * @param {Iterable.<Object>} items\n   * @param {Number} [index] The position of the insertion. Items will be appended if no `index` is specified.\n   * @fires add\n   * @fires change\n   */\n  addMany(items, index) {\n    if (index === undefined) {\n      index = this._items.length;\n    } else if (index > this._items.length || index < 0) {\n      /**\n       * The `index` passed to {@link module:utils/collection~Collection#addMany `Collection#addMany()`}\n       * is invalid. It must be a number between 0 and the collection's length.\n       *\n       * @error collection-add-item-invalid-index\n       */\n      throw new CKEditorError('collection-add-item-invalid-index', this);\n    }\n    let offset = 0;\n    for (const item of items) {\n      const itemId = this._getItemIdBeforeAdding(item);\n      const currentItemIndex = index + offset;\n      this._items.splice(currentItemIndex, 0, item);\n      this._itemMap.set(itemId, item);\n      this.fire('add', item, currentItemIndex);\n      offset++;\n    }\n    this.fire('change', {\n      added: items,\n      removed: [],\n      index\n    });\n    return this;\n  }\n  /**\n   * Gets an item by its ID or index.\n   *\n   * @param {String|Number} idOrIndex The item ID or index in the collection.\n   * @returns {Object|null} The requested item or `null` if such item does not exist.\n   */\n  get(idOrIndex) {\n    let item;\n    if (typeof idOrIndex == 'string') {\n      item = this._itemMap.get(idOrIndex);\n    } else if (typeof idOrIndex == 'number') {\n      item = this._items[idOrIndex];\n    } else {\n      /**\n       * An index or ID must be given.\n       *\n       * @error collection-get-invalid-arg\n       */\n      throw new CKEditorError('collection-get-invalid-arg', this);\n    }\n    return item || null;\n  }\n  /**\n   * Returns a Boolean indicating whether the collection contains an item.\n   *\n   * @param {Object|String} itemOrId The item or its ID in the collection.\n   * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n   */\n  has(itemOrId) {\n    if (typeof itemOrId == 'string') {\n      return this._itemMap.has(itemOrId);\n    } else {\n      // Object\n      const idProperty = this._idProperty;\n      const id = itemOrId[idProperty];\n      return id && this._itemMap.has(id);\n    }\n  }\n  /**\n   * Gets an index of an item in the collection.\n   * When an item is not defined in the collection, the index will equal -1.\n   *\n   * @param {Object|String} itemOrId The item or its ID in the collection.\n   * @returns {Number} The index of a given item.\n   */\n  getIndex(itemOrId) {\n    let item;\n    if (typeof itemOrId == 'string') {\n      item = this._itemMap.get(itemOrId);\n    } else {\n      item = itemOrId;\n    }\n    return item ? this._items.indexOf(item) : -1;\n  }\n  /**\n   * Removes an item from the collection.\n   *\n   * @param {Object|Number|String} subject The item to remove, its ID or index in the collection.\n   * @returns {Object} The removed item.\n   * @fires remove\n   * @fires change\n   */\n  remove(subject) {\n    const [item, index] = this._remove(subject);\n    this.fire('change', {\n      added: [],\n      removed: [item],\n      index\n    });\n    return item;\n  }\n  /**\n   * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} [ctx] Context in which the `callback` will be called.\n   * @returns {Array} The result of mapping.\n   */\n  map(callback, ctx) {\n    return this._items.map(callback, ctx);\n  }\n  /**\n   * Finds the first item in the collection for which the `callback` returns a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} [ctx] Context in which the `callback` will be called.\n   * @returns {Object|undefined} The item for which `callback` returned a true value.\n   */\n  find(callback, ctx) {\n    return this._items.find(callback, ctx);\n  }\n  /**\n   * Returns an array with items for which the `callback` returned a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} [ctx] Context in which the `callback` will be called.\n   * @returns {Array} The array with matching items.\n   */\n  filter(callback, ctx) {\n    return this._items.filter(callback, ctx);\n  }\n  /**\n   * Removes all items from the collection and destroys the binding created using\n   * {@link #bindTo}.\n   *\n   * @fires remove\n   * @fires change\n   */\n  clear() {\n    if (this._bindToCollection) {\n      this.stopListening(this._bindToCollection);\n      this._bindToCollection = null;\n    }\n    const removedItems = Array.from(this._items);\n    while (this.length) {\n      this._remove(0);\n    }\n    this.fire('change', {\n      added: [],\n      removed: removedItems,\n      index: 0\n    });\n  }\n  /**\n   * Binds and synchronizes the collection with another one.\n   *\n   * The binding can be a simple factory:\n   *\n   *\t\tclass FactoryClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).as( FactoryClass );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n   *\n   *\t\tsource.remove( 0 );\n   *\t\tconsole.log( target.length ); // 1\n   *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n   *\n   * or the factory driven by a custom callback:\n   *\n   *\t\tclass FooClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tclass BarClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( ( item ) => {\n   *\t\t\tif ( item.label == 'foo' ) {\n   *\t\t\t\treturn new FooClass( item );\n   *\t\t\t} else {\n   *\t\t\t\treturn new BarClass( item );\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n   *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n   *\n   * or the factory out of property name:\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( 'label' );\n   *\n   *\t\tsource.add( { label: { value: 'foo' } } );\n   *\t\tsource.add( { label: { value: 'bar' } } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n   *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n   *\n   * It's possible to skip specified items by returning falsy value:\n   *\n   *\t\tconst source = new Collection();\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( item => {\n   *\t\t\tif ( item.hidden ) {\n   *\t\t\t\treturn null;\n   *\t\t\t}\n   *\n   *\t\t\treturn item;\n   *\t\t} );\n   *\n   *\t\tsource.add( { hidden: true } );\n   *\t\tsource.add( { hidden: false } );\n   *\n   *\t\tconsole.log( source.length ); // 2\n   *\t\tconsole.log( target.length ); // 1\n   *\n   * **Note**: {@link #clear} can be used to break the binding.\n   *\n   * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n   * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n   */\n  bindTo(externalCollection) {\n    if (this._bindToCollection) {\n      /**\n       * The collection cannot be bound more than once.\n       *\n       * @error collection-bind-to-rebind\n       */\n      throw new CKEditorError('collection-bind-to-rebind', this);\n    }\n    this._bindToCollection = externalCollection;\n    return {\n      as: Class => {\n        this._setUpBindToBinding(item => new Class(item));\n      },\n      using: callbackOrProperty => {\n        if (typeof callbackOrProperty == 'function') {\n          this._setUpBindToBinding(callbackOrProperty);\n        } else {\n          this._setUpBindToBinding(item => item[callbackOrProperty]);\n        }\n      }\n    };\n  }\n  /**\n   * Finalizes and activates a binding initiated by {#bindTo}.\n   *\n   * @private\n   * @param {Function} factory A function which produces collection items.\n   */\n  _setUpBindToBinding(factory) {\n    const externalCollection = this._bindToCollection;\n    // Adds the item to the collection once a change has been done to the external collection.\n    //\n    // @private\n    const addItem = (evt, externalItem, index) => {\n      const isExternalBoundToThis = externalCollection._bindToCollection == this;\n      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);\n      // If an external collection is bound to this collection, which makes it a 2–way binding,\n      // and the particular external collection item is already bound, don't add it here.\n      // The external item has been created **out of this collection's item** and (re)adding it will\n      // cause a loop.\n      if (isExternalBoundToThis && externalItemBound) {\n        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);\n        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);\n      } else {\n        const item = factory(externalItem);\n        // When there is no item we need to remember skipped index first and then we can skip this item.\n        if (!item) {\n          this._skippedIndexesFromExternal.push(index);\n          return;\n        }\n        // Lets try to put item at the same index as index in external collection\n        // but when there are a skipped items in one or both collections we need to recalculate this index.\n        let finalIndex = index;\n        // When we try to insert item after some skipped items from external collection we need\n        // to include this skipped items and decrease index.\n        //\n        // For the following example:\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n        // internal -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n        //\n        // We can't just add 'D' to internal at the same index as index in external because\n        // this will produce empty indexes what is invalid:\n        // internal -> [ 'A', empty, empty, 'D' ]\n        //\n        // So we need to include skipped items and decrease index\n        // internal -> [ 'A', 'D' ]\n        for (const skipped of this._skippedIndexesFromExternal) {\n          if (index > skipped) {\n            finalIndex--;\n          }\n        }\n        // We need to take into consideration that external collection could skip some items from\n        // internal collection.\n        //\n        // For the following example:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n        // external -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'D' ]\n        //\n        // We need to include skipped items and place new item after them:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n        for (const skipped of externalCollection._skippedIndexesFromExternal) {\n          if (finalIndex >= skipped) {\n            finalIndex++;\n          }\n        }\n        this._bindToExternalToInternalMap.set(externalItem, item);\n        this._bindToInternalToExternalMap.set(item, externalItem);\n        this.add(item, finalIndex);\n        // After adding new element to internal collection we need update indexes\n        // of skipped items in external collection.\n        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {\n          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {\n            externalCollection._skippedIndexesFromExternal[i]++;\n          }\n        }\n      }\n    };\n    // Load the initial content of the collection.\n    for (const externalItem of externalCollection) {\n      addItem(null, externalItem, externalCollection.getIndex(externalItem));\n    }\n    // Synchronize the with collection as new items are added.\n    this.listenTo(externalCollection, 'add', addItem);\n    // Synchronize the with collection as new items are removed.\n    this.listenTo(externalCollection, 'remove', (evt, externalItem, index) => {\n      const item = this._bindToExternalToInternalMap.get(externalItem);\n      if (item) {\n        this.remove(item);\n      }\n      // After removing element from external collection we need update/remove indexes\n      // of skipped items in internal collection.\n      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {\n        if (index < skipped) {\n          result.push(skipped - 1);\n        }\n        if (index > skipped) {\n          result.push(skipped);\n        }\n        return result;\n      }, []);\n    });\n  }\n  /**\n   * Returns an unique id property for a given `item`.\n   *\n   * The method will generate new id and assign it to the `item` if it doesn't have any.\n   *\n   * @private\n   * @param {Object} item Item to be added.\n   * @returns {String}\n   */\n  _getItemIdBeforeAdding(item) {\n    const idProperty = this._idProperty;\n    let itemId;\n    if (idProperty in item) {\n      itemId = item[idProperty];\n      if (typeof itemId != 'string') {\n        /**\n         * This item's ID should be a string.\n         *\n         * @error collection-add-invalid-id\n         */\n        throw new CKEditorError('collection-add-invalid-id', this);\n      }\n      if (this.get(itemId)) {\n        /**\n         * This item already exists in the collection.\n         *\n         * @error collection-add-item-already-exists\n         */\n        throw new CKEditorError('collection-add-item-already-exists', this);\n      }\n    } else {\n      item[idProperty] = itemId = uid();\n    }\n    return itemId;\n  }\n  /**\n   * Core {@link #remove} method implementation shared in other functions.\n   *\n   * In contrast this method **does not** fire the {@link #event:change} event.\n   *\n   * @private\n   * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n   * @returns {Array} Returns an array with the removed item and its index.\n   * @fires remove\n   */\n  _remove(subject) {\n    let index, id, item;\n    let itemDoesNotExist = false;\n    const idProperty = this._idProperty;\n    if (typeof subject == 'string') {\n      id = subject;\n      item = this._itemMap.get(id);\n      itemDoesNotExist = !item;\n      if (item) {\n        index = this._items.indexOf(item);\n      }\n    } else if (typeof subject == 'number') {\n      index = subject;\n      item = this._items[index];\n      itemDoesNotExist = !item;\n      if (item) {\n        id = item[idProperty];\n      }\n    } else {\n      item = subject;\n      id = item[idProperty];\n      index = this._items.indexOf(item);\n      itemDoesNotExist = index == -1 || !this._itemMap.get(id);\n    }\n    if (itemDoesNotExist) {\n      /**\n       * Item not found.\n       *\n       * @error collection-remove-404\n       */\n      throw new CKEditorError('collection-remove-404', this);\n    }\n    this._items.splice(index, 1);\n    this._itemMap.delete(id);\n    const externalItem = this._bindToInternalToExternalMap.get(item);\n    this._bindToInternalToExternalMap.delete(item);\n    this._bindToExternalToInternalMap.delete(externalItem);\n    this.fire('remove', item, index);\n    return [item, index];\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterator.<*>}\n   */\n  [Symbol.iterator]() {\n    return this._items[Symbol.iterator]();\n  }\n}","map":{"version":3,"names":["Emitter","CKEditorError","uid","isIterable","Collection","constructor","initialItemsOrOptions","options","hasInitialItems","_items","_itemMap","Map","_idProperty","idProperty","_bindToExternalToInternalMap","WeakMap","_bindToInternalToExternalMap","_skippedIndexesFromExternal","item","push","set","_getItemIdBeforeAdding","length","first","last","add","index","addMany","items","undefined","offset","itemId","currentItemIndex","splice","fire","added","removed","get","idOrIndex","has","itemOrId","id","getIndex","indexOf","remove","subject","_remove","map","callback","ctx","find","filter","clear","_bindToCollection","stopListening","removedItems","Array","from","bindTo","externalCollection","as","Class","_setUpBindToBinding","using","callbackOrProperty","factory","addItem","evt","externalItem","isExternalBoundToThis","externalItemBound","finalIndex","skipped","i","listenTo","reduce","result","itemDoesNotExist","delete","Symbol","iterator"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/collection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/collection\n */\nimport { Emitter } from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport isIterable from './isiterable';\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Collection extends Emitter {\n    /**\n     * Creates a new Collection instance.\n     *\n     * You can provide an iterable of initial items the collection will be created with:\n     *\n     *\t\tconst collection = new Collection( [ { id: 'John' }, { id: 'Mike' } ] );\n     *\n     *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n     *\t\tconsole.log( collection.get( 1 ) ); // -> { id: 'Mike' }\n     *\t\tconsole.log( collection.get( 'Mike' ) ); // -> { id: 'Mike' }\n     *\n     * Or you can first create a collection and then add new items using the {@link #add} method:\n     *\n     *\t\tconst collection = new Collection();\n     *\n     *\t\tcollection.add( { id: 'John' } );\n     *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n     *\n     * Whatever option you choose, you can always pass a configuration object as the last argument\n     * of the constructor:\n     *\n     *\t\tconst emptyCollection = new Collection( { idProperty: 'name' } );\n     *\t\temptyCollection.add( { name: 'John' } );\n     *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n     *\n     *\t\tconst nonEmptyCollection = new Collection( [ { name: 'John' } ], { idProperty: 'name' } );\n     *\t\tnonEmptyCollection.add( { name: 'George' } );\n     *\t\tconsole.log( collection.get( 'George' ) ); // -> { name: 'George' }\n     *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n     *\n     * @param {Iterable.<Object>|Object} [initialItemsOrOptions] The initial items of the collection or\n     * the options object.\n     * @param {Object} [options={}] The options object, when the first argument is an array of initial items.\n     * @param {String} [options.idProperty='id'] The name of the property which is used to identify an item.\n     * Items that do not have such a property will be assigned one when added to the collection.\n     */\n    constructor(initialItemsOrOptions = {}, options = {}) {\n        super();\n        const hasInitialItems = isIterable(initialItemsOrOptions);\n        if (!hasInitialItems) {\n            options = initialItemsOrOptions;\n        }\n        this._items = [];\n        this._itemMap = new Map();\n        this._idProperty = options.idProperty || 'id';\n        this._bindToExternalToInternalMap = new WeakMap();\n        this._bindToInternalToExternalMap = new WeakMap();\n        this._skippedIndexesFromExternal = [];\n        // Set the initial content of the collection (if provided in the constructor).\n        if (hasInitialItems) {\n            for (const item of initialItemsOrOptions) {\n                this._items.push(item);\n                this._itemMap.set(this._getItemIdBeforeAdding(item), item);\n            }\n        }\n    }\n    /**\n     * The number of items available in the collection.\n     *\n     * @member {Number} #length\n     */\n    get length() {\n        return this._items.length;\n    }\n    /**\n     * Returns the first item from the collection or null when collection is empty.\n     *\n     * @returns {Object|null} The first item or `null` if collection is empty.\n     */\n    get first() {\n        return this._items[0] || null;\n    }\n    /**\n     * Returns the last item from the collection or null when collection is empty.\n     *\n     * @returns {Object|null} The last item or `null` if collection is empty.\n     */\n    get last() {\n        return this._items[this.length - 1] || null;\n    }\n    /**\n     * Adds an item into the collection.\n     *\n     * If the item does not have an id, then it will be automatically generated and set on the item.\n     *\n     * @chainable\n     * @param {Object} item\n     * @param {Number} [index] The position of the item in the collection. The item\n     * is pushed to the collection when `index` not specified.\n     * @fires add\n     * @fires change\n     */\n    add(item, index) {\n        return this.addMany([item], index);\n    }\n    /**\n     * Adds multiple items into the collection.\n     *\n     * Any item not containing an id will get an automatically generated one.\n     *\n     * @chainable\n     * @param {Iterable.<Object>} items\n     * @param {Number} [index] The position of the insertion. Items will be appended if no `index` is specified.\n     * @fires add\n     * @fires change\n     */\n    addMany(items, index) {\n        if (index === undefined) {\n            index = this._items.length;\n        }\n        else if (index > this._items.length || index < 0) {\n            /**\n             * The `index` passed to {@link module:utils/collection~Collection#addMany `Collection#addMany()`}\n             * is invalid. It must be a number between 0 and the collection's length.\n             *\n             * @error collection-add-item-invalid-index\n             */\n            throw new CKEditorError('collection-add-item-invalid-index', this);\n        }\n        let offset = 0;\n        for (const item of items) {\n            const itemId = this._getItemIdBeforeAdding(item);\n            const currentItemIndex = index + offset;\n            this._items.splice(currentItemIndex, 0, item);\n            this._itemMap.set(itemId, item);\n            this.fire('add', item, currentItemIndex);\n            offset++;\n        }\n        this.fire('change', {\n            added: items,\n            removed: [],\n            index\n        });\n        return this;\n    }\n    /**\n     * Gets an item by its ID or index.\n     *\n     * @param {String|Number} idOrIndex The item ID or index in the collection.\n     * @returns {Object|null} The requested item or `null` if such item does not exist.\n     */\n    get(idOrIndex) {\n        let item;\n        if (typeof idOrIndex == 'string') {\n            item = this._itemMap.get(idOrIndex);\n        }\n        else if (typeof idOrIndex == 'number') {\n            item = this._items[idOrIndex];\n        }\n        else {\n            /**\n             * An index or ID must be given.\n             *\n             * @error collection-get-invalid-arg\n             */\n            throw new CKEditorError('collection-get-invalid-arg', this);\n        }\n        return item || null;\n    }\n    /**\n     * Returns a Boolean indicating whether the collection contains an item.\n     *\n     * @param {Object|String} itemOrId The item or its ID in the collection.\n     * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n     */\n    has(itemOrId) {\n        if (typeof itemOrId == 'string') {\n            return this._itemMap.has(itemOrId);\n        }\n        else { // Object\n            const idProperty = this._idProperty;\n            const id = itemOrId[idProperty];\n            return id && this._itemMap.has(id);\n        }\n    }\n    /**\n     * Gets an index of an item in the collection.\n     * When an item is not defined in the collection, the index will equal -1.\n     *\n     * @param {Object|String} itemOrId The item or its ID in the collection.\n     * @returns {Number} The index of a given item.\n     */\n    getIndex(itemOrId) {\n        let item;\n        if (typeof itemOrId == 'string') {\n            item = this._itemMap.get(itemOrId);\n        }\n        else {\n            item = itemOrId;\n        }\n        return item ? this._items.indexOf(item) : -1;\n    }\n    /**\n     * Removes an item from the collection.\n     *\n     * @param {Object|Number|String} subject The item to remove, its ID or index in the collection.\n     * @returns {Object} The removed item.\n     * @fires remove\n     * @fires change\n     */\n    remove(subject) {\n        const [item, index] = this._remove(subject);\n        this.fire('change', {\n            added: [],\n            removed: [item],\n            index\n        });\n        return item;\n    }\n    /**\n     * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n     *\n     * @param {Function} callback\n     * @param {Object} callback.item\n     * @param {Number} callback.index\n     * @param {Object} [ctx] Context in which the `callback` will be called.\n     * @returns {Array} The result of mapping.\n     */\n    map(callback, ctx) {\n        return this._items.map(callback, ctx);\n    }\n    /**\n     * Finds the first item in the collection for which the `callback` returns a true value.\n     *\n     * @param {Function} callback\n     * @param {Object} callback.item\n     * @param {Number} callback.index\n     * @param {Object} [ctx] Context in which the `callback` will be called.\n     * @returns {Object|undefined} The item for which `callback` returned a true value.\n     */\n    find(callback, ctx) {\n        return this._items.find(callback, ctx);\n    }\n    /**\n     * Returns an array with items for which the `callback` returned a true value.\n     *\n     * @param {Function} callback\n     * @param {Object} callback.item\n     * @param {Number} callback.index\n     * @param {Object} [ctx] Context in which the `callback` will be called.\n     * @returns {Array} The array with matching items.\n     */\n    filter(callback, ctx) {\n        return this._items.filter(callback, ctx);\n    }\n    /**\n     * Removes all items from the collection and destroys the binding created using\n     * {@link #bindTo}.\n     *\n     * @fires remove\n     * @fires change\n     */\n    clear() {\n        if (this._bindToCollection) {\n            this.stopListening(this._bindToCollection);\n            this._bindToCollection = null;\n        }\n        const removedItems = Array.from(this._items);\n        while (this.length) {\n            this._remove(0);\n        }\n        this.fire('change', {\n            added: [],\n            removed: removedItems,\n            index: 0\n        });\n    }\n    /**\n     * Binds and synchronizes the collection with another one.\n     *\n     * The binding can be a simple factory:\n     *\n     *\t\tclass FactoryClass {\n     *\t\t\tconstructor( data ) {\n     *\t\t\t\tthis.label = data.label;\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst source = new Collection( { idProperty: 'label' } );\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).as( FactoryClass );\n     *\n     *\t\tsource.add( { label: 'foo' } );\n     *\t\tsource.add( { label: 'bar' } );\n     *\n     *\t\tconsole.log( target.length ); // 2\n     *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n     *\n     *\t\tsource.remove( 0 );\n     *\t\tconsole.log( target.length ); // 1\n     *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n     *\n     * or the factory driven by a custom callback:\n     *\n     *\t\tclass FooClass {\n     *\t\t\tconstructor( data ) {\n     *\t\t\t\tthis.label = data.label;\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tclass BarClass {\n     *\t\t\tconstructor( data ) {\n     *\t\t\t\tthis.label = data.label;\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst source = new Collection( { idProperty: 'label' } );\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).using( ( item ) => {\n     *\t\t\tif ( item.label == 'foo' ) {\n     *\t\t\t\treturn new FooClass( item );\n     *\t\t\t} else {\n     *\t\t\t\treturn new BarClass( item );\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\tsource.add( { label: 'foo' } );\n     *\t\tsource.add( { label: 'bar' } );\n     *\n     *\t\tconsole.log( target.length ); // 2\n     *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n     *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n     *\n     * or the factory out of property name:\n     *\n     *\t\tconst source = new Collection( { idProperty: 'label' } );\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).using( 'label' );\n     *\n     *\t\tsource.add( { label: { value: 'foo' } } );\n     *\t\tsource.add( { label: { value: 'bar' } } );\n     *\n     *\t\tconsole.log( target.length ); // 2\n     *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n     *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n     *\n     * It's possible to skip specified items by returning falsy value:\n     *\n     *\t\tconst source = new Collection();\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).using( item => {\n     *\t\t\tif ( item.hidden ) {\n     *\t\t\t\treturn null;\n     *\t\t\t}\n     *\n     *\t\t\treturn item;\n     *\t\t} );\n     *\n     *\t\tsource.add( { hidden: true } );\n     *\t\tsource.add( { hidden: false } );\n     *\n     *\t\tconsole.log( source.length ); // 2\n     *\t\tconsole.log( target.length ); // 1\n     *\n     * **Note**: {@link #clear} can be used to break the binding.\n     *\n     * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n     * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n     */\n    bindTo(externalCollection) {\n        if (this._bindToCollection) {\n            /**\n             * The collection cannot be bound more than once.\n             *\n             * @error collection-bind-to-rebind\n             */\n            throw new CKEditorError('collection-bind-to-rebind', this);\n        }\n        this._bindToCollection = externalCollection;\n        return {\n            as: Class => {\n                this._setUpBindToBinding(item => new Class(item));\n            },\n            using: callbackOrProperty => {\n                if (typeof callbackOrProperty == 'function') {\n                    this._setUpBindToBinding(callbackOrProperty);\n                }\n                else {\n                    this._setUpBindToBinding(item => item[callbackOrProperty]);\n                }\n            }\n        };\n    }\n    /**\n     * Finalizes and activates a binding initiated by {#bindTo}.\n     *\n     * @private\n     * @param {Function} factory A function which produces collection items.\n     */\n    _setUpBindToBinding(factory) {\n        const externalCollection = this._bindToCollection;\n        // Adds the item to the collection once a change has been done to the external collection.\n        //\n        // @private\n        const addItem = (evt, externalItem, index) => {\n            const isExternalBoundToThis = externalCollection._bindToCollection == this;\n            const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);\n            // If an external collection is bound to this collection, which makes it a 2–way binding,\n            // and the particular external collection item is already bound, don't add it here.\n            // The external item has been created **out of this collection's item** and (re)adding it will\n            // cause a loop.\n            if (isExternalBoundToThis && externalItemBound) {\n                this._bindToExternalToInternalMap.set(externalItem, externalItemBound);\n                this._bindToInternalToExternalMap.set(externalItemBound, externalItem);\n            }\n            else {\n                const item = factory(externalItem);\n                // When there is no item we need to remember skipped index first and then we can skip this item.\n                if (!item) {\n                    this._skippedIndexesFromExternal.push(index);\n                    return;\n                }\n                // Lets try to put item at the same index as index in external collection\n                // but when there are a skipped items in one or both collections we need to recalculate this index.\n                let finalIndex = index;\n                // When we try to insert item after some skipped items from external collection we need\n                // to include this skipped items and decrease index.\n                //\n                // For the following example:\n                // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n                // internal -> [ A ]\n                //\n                // Another item is been added at the end of external collection:\n                // external.add( 'D' )\n                // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n                //\n                // We can't just add 'D' to internal at the same index as index in external because\n                // this will produce empty indexes what is invalid:\n                // internal -> [ 'A', empty, empty, 'D' ]\n                //\n                // So we need to include skipped items and decrease index\n                // internal -> [ 'A', 'D' ]\n                for (const skipped of this._skippedIndexesFromExternal) {\n                    if (index > skipped) {\n                        finalIndex--;\n                    }\n                }\n                // We need to take into consideration that external collection could skip some items from\n                // internal collection.\n                //\n                // For the following example:\n                // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n                // external -> [ A ]\n                //\n                // Another item is been added at the end of external collection:\n                // external.add( 'D' )\n                // external -> [ 'A', 'D' ]\n                //\n                // We need to include skipped items and place new item after them:\n                // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n                for (const skipped of externalCollection._skippedIndexesFromExternal) {\n                    if (finalIndex >= skipped) {\n                        finalIndex++;\n                    }\n                }\n                this._bindToExternalToInternalMap.set(externalItem, item);\n                this._bindToInternalToExternalMap.set(item, externalItem);\n                this.add(item, finalIndex);\n                // After adding new element to internal collection we need update indexes\n                // of skipped items in external collection.\n                for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {\n                    if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {\n                        externalCollection._skippedIndexesFromExternal[i]++;\n                    }\n                }\n            }\n        };\n        // Load the initial content of the collection.\n        for (const externalItem of externalCollection) {\n            addItem(null, externalItem, externalCollection.getIndex(externalItem));\n        }\n        // Synchronize the with collection as new items are added.\n        this.listenTo(externalCollection, 'add', addItem);\n        // Synchronize the with collection as new items are removed.\n        this.listenTo(externalCollection, 'remove', (evt, externalItem, index) => {\n            const item = this._bindToExternalToInternalMap.get(externalItem);\n            if (item) {\n                this.remove(item);\n            }\n            // After removing element from external collection we need update/remove indexes\n            // of skipped items in internal collection.\n            this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {\n                if (index < skipped) {\n                    result.push(skipped - 1);\n                }\n                if (index > skipped) {\n                    result.push(skipped);\n                }\n                return result;\n            }, []);\n        });\n    }\n    /**\n     * Returns an unique id property for a given `item`.\n     *\n     * The method will generate new id and assign it to the `item` if it doesn't have any.\n     *\n     * @private\n     * @param {Object} item Item to be added.\n     * @returns {String}\n     */\n    _getItemIdBeforeAdding(item) {\n        const idProperty = this._idProperty;\n        let itemId;\n        if ((idProperty in item)) {\n            itemId = item[idProperty];\n            if (typeof itemId != 'string') {\n                /**\n                 * This item's ID should be a string.\n                 *\n                 * @error collection-add-invalid-id\n                 */\n                throw new CKEditorError('collection-add-invalid-id', this);\n            }\n            if (this.get(itemId)) {\n                /**\n                 * This item already exists in the collection.\n                 *\n                 * @error collection-add-item-already-exists\n                 */\n                throw new CKEditorError('collection-add-item-already-exists', this);\n            }\n        }\n        else {\n            item[idProperty] = itemId = uid();\n        }\n        return itemId;\n    }\n    /**\n     * Core {@link #remove} method implementation shared in other functions.\n     *\n     * In contrast this method **does not** fire the {@link #event:change} event.\n     *\n     * @private\n     * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n     * @returns {Array} Returns an array with the removed item and its index.\n     * @fires remove\n     */\n    _remove(subject) {\n        let index, id, item;\n        let itemDoesNotExist = false;\n        const idProperty = this._idProperty;\n        if (typeof subject == 'string') {\n            id = subject;\n            item = this._itemMap.get(id);\n            itemDoesNotExist = !item;\n            if (item) {\n                index = this._items.indexOf(item);\n            }\n        }\n        else if (typeof subject == 'number') {\n            index = subject;\n            item = this._items[index];\n            itemDoesNotExist = !item;\n            if (item) {\n                id = item[idProperty];\n            }\n        }\n        else {\n            item = subject;\n            id = item[idProperty];\n            index = this._items.indexOf(item);\n            itemDoesNotExist = (index == -1 || !this._itemMap.get(id));\n        }\n        if (itemDoesNotExist) {\n            /**\n             * Item not found.\n             *\n             * @error collection-remove-404\n             */\n            throw new CKEditorError('collection-remove-404', this);\n        }\n        this._items.splice(index, 1);\n        this._itemMap.delete(id);\n        const externalItem = this._bindToInternalToExternalMap.get(item);\n        this._bindToInternalToExternalMap.delete(item);\n        this._bindToExternalToInternalMap.delete(externalItem);\n        this.fire('remove', item, index);\n        return [item, index];\n    }\n    /**\n     * Iterable interface.\n     *\n     * @returns {Iterator.<*>}\n     */\n    [Symbol.iterator]() {\n        return this._items[Symbol.iterator]();\n    }\n}\n"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIgC,MAAM,CAACC,kBAAkB,EAAE;IACvB,IAAI,IAAI,CAACN,iBAAiB,EAAE;MACxB;AACZ;AACA;AACA;AACA;MACY,MAAM,IAAIpD,aAAa,CAAC,2BAA2B,EAAE,IAAI,CAAC;IAC9D;IACA,IAAI,CAACoD,iBAAiB,GAAGM,kBAAkB;IAC3C,OAAO;MACHC,EAAE,EAAEC,KAAK,IAAI;QACT,IAAI,CAACC,mBAAmB,CAAC5C,IAAI,IAAI,IAAI2C,KAAK,CAAC3C,IAAI,CAAC,CAAC;MACrD,CAAC;MACD6C,KAAK,EAAEC,kBAAkB,IAAI;QACzB,IAAI,OAAOA,kBAAkB,IAAI,UAAU,EAAE;UACzC,IAAI,CAACF,mBAAmB,CAACE,kBAAkB,CAAC;QAChD,CAAC,MACI;UACD,IAAI,CAACF,mBAAmB,CAAC5C,IAAI,IAAIA,IAAI,CAAC8C,kBAAkB,CAAC,CAAC;QAC9D;MACJ;IACJ,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;EACIF,mBAAmB,CAACG,OAAO,EAAE;IACzB,MAAMN,kBAAkB,GAAG,IAAI,CAACN,iBAAiB;IACjD;IACA;IACA;IACA,MAAMa,OAAO,GAAG,CAACC,GAAG,EAAEC,YAAY,EAAE1C,KAAK,KAAK;MAC1C,MAAM2C,qBAAqB,GAAGV,kBAAkB,CAACN,iBAAiB,IAAI,IAAI;MAC1E,MAAMiB,iBAAiB,GAAGX,kBAAkB,CAAC3C,4BAA4B,CAACqB,GAAG,CAAC+B,YAAY,CAAC;MAC3F;MACA;MACA;MACA;MACA,IAAI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"},"metadata":{},"sourceType":"module"}