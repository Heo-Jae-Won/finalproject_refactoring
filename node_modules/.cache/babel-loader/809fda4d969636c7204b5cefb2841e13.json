{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/splitoperation\n */\nimport Operation from './operation';\nimport MergeOperation from './mergeoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _insert, _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to split {@link module:engine/model/element~Element an element} at given\n * {@link module:engine/model/operation/splitoperation~SplitOperation#splitPosition split position} into two elements,\n * both containing a part of the element's original content.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class SplitOperation extends Operation {\n  /**\n   * Creates a split operation.\n   *\n   * @param {module:engine/model/position~Position} splitPosition Position at which an element should be split.\n   * @param {Number} howMany Total offset size of elements that are in the split element after `position`.\n   * @param {module:engine/model/position~Position} insertionPosition Position at which the clone of split element\n   * (or element from graveyard) will be inserted.\n   * @param {module:engine/model/position~Position|null} graveyardPosition Position in the graveyard root before the element which\n   * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {\n    super(baseVersion);\n    /**\n     * Position at which an element should be split.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#splitPosition\n     */\n    this.splitPosition = splitPosition.clone();\n    // Keep position sticking to the next node. This way any new content added at the place where the element is split\n    // will be left in the original element.\n    this.splitPosition.stickiness = 'toNext';\n    /**\n     * Total offset size of elements that are in the split element after `position`.\n     *\n     * @member {Number} module:engine/model/operation/splitoperation~SplitOperation#howMany\n     */\n    this.howMany = howMany;\n    /**\n     * Position at which the clone of split element (or element from graveyard) will be inserted.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#insertionPosition\n     */\n    this.insertionPosition = insertionPosition;\n    /**\n     * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.\n     * If it is not set, a copy of the the `position` parent will be used.\n     *\n     * The default behavior is to clone the split element. Element from graveyard is used during undo.\n     *\n     * @member {module:engine/model/position~Position|null} #graveyardPosition\n     */\n    this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;\n    if (this.graveyardPosition) {\n      this.graveyardPosition.stickiness = 'toNext';\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  get type() {\n    return 'split';\n  }\n  /**\n   * Position inside the new clone of a split element.\n   *\n   * This is a position where nodes that are after the split position will be moved to.\n   *\n   * @readonly\n   * @type {module:engine/model/position~Position}\n   */\n  get moveTargetPosition() {\n    const path = this.insertionPosition.path.slice();\n    path.push(0);\n    return new Position(this.insertionPosition.root, path);\n  }\n  /**\n   * Artificial range that contains all the nodes from the split element that will be moved to the new element.\n   * The range starts at {@link ~#splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n   *\n   * @readonly\n   * @type {module:engine/model/range~Range}\n   */\n  get movedRange() {\n    const end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);\n    return new Range(this.splitPosition, end);\n  }\n  /**\n   * Creates and returns an operation that has the same parameters as this operation.\n   *\n   * @returns {module:engine/model/operation/splitoperation~SplitOperation} Clone of this operation.\n   */\n  clone() {\n    return new SplitOperation(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);\n  }\n  /**\n   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n   *\n   * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n   */\n  getReversed() {\n    const graveyard = this.splitPosition.root.document.graveyard;\n    const graveyardPosition = new Position(graveyard, [0]);\n    return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);\n  }\n  /**\n   * @inheritDoc\n   * @internal\n   */\n  _validate() {\n    const element = this.splitPosition.parent;\n    const offset = this.splitPosition.offset;\n    // Validate whether split operation has correct parameters.\n    if (!element || element.maxOffset < offset) {\n      /**\n       * Split position is invalid.\n       *\n       * @error split-operation-position-invalid\n       */\n      throw new CKEditorError('split-operation-position-invalid', this);\n    } else if (!element.parent) {\n      /**\n       * Cannot split root element.\n       *\n       * @error split-operation-split-in-root\n       */\n      throw new CKEditorError('split-operation-split-in-root', this);\n    } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {\n      /**\n       * Split operation specifies wrong number of nodes to move.\n       *\n       * @error split-operation-how-many-invalid\n       */\n      throw new CKEditorError('split-operation-how-many-invalid', this);\n    } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {\n      /**\n       * Graveyard position invalid.\n       *\n       * @error split-operation-graveyard-position-invalid\n       */\n      throw new CKEditorError('split-operation-graveyard-position-invalid', this);\n    }\n  }\n  /**\n   * @inheritDoc\n   * @internal\n   */\n  _execute() {\n    const splitElement = this.splitPosition.parent;\n    if (this.graveyardPosition) {\n      _move(Range._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);\n    } else {\n      const newElement = splitElement._clone();\n      _insert(this.insertionPosition, newElement);\n    }\n    const sourceRange = new Range(Position._createAt(splitElement, this.splitPosition.offset), Position._createAt(splitElement, splitElement.maxOffset));\n    _move(sourceRange, this.moveTargetPosition);\n  }\n  /**\n   * @inheritDoc\n   */\n  toJSON() {\n    const json = super.toJSON();\n    json.splitPosition = this.splitPosition.toJSON();\n    json.insertionPosition = this.insertionPosition.toJSON();\n    if (this.graveyardPosition) {\n      json.graveyardPosition = this.graveyardPosition.toJSON();\n    }\n    return json;\n  }\n  /**\n   * @inheritDoc\n   */\n  static get className() {\n    return 'SplitOperation';\n  }\n  /**\n   * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion\n   * position is after the split element.\n   *\n   * @param {module:engine/model/position~Position} splitPosition\n   * @returns {module:engine/model/position~Position}\n   */\n  static getInsertionPosition(splitPosition) {\n    const path = splitPosition.path.slice(0, -1);\n    path[path.length - 1]++;\n    return new Position(splitPosition.root, path, 'toPrevious');\n  }\n  /**\n   * Creates `SplitOperation` object from deserilized object, i.e. from parsed JSON string.\n   *\n   * @param {Object} json Deserialized JSON object.\n   * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n   * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n   */\n  static fromJSON(json, document) {\n    const splitPosition = Position.fromJSON(json.splitPosition, document);\n    const insertionPosition = Position.fromJSON(json.insertionPosition, document);\n    const graveyardPosition = json.graveyardPosition ? Position.fromJSON(json.graveyardPosition, document) : null;\n    return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);\n  }\n}","map":{"version":3,"names":["Operation","MergeOperation","Position","Range","_insert","_move","CKEditorError","SplitOperation","constructor","splitPosition","howMany","insertionPosition","graveyardPosition","baseVersion","clone","stickiness","type","moveTargetPosition","path","slice","push","root","movedRange","end","getShiftedBy","Number","POSITIVE_INFINITY","getReversed","graveyard","document","_validate","element","parent","offset","maxOffset","nodeAfter","_execute","splitElement","_createFromPositionAndShift","newElement","_clone","sourceRange","_createAt","toJSON","json","className","getInsertionPosition","length","fromJSON"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/splitoperation.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/splitoperation\n */\nimport Operation from './operation';\nimport MergeOperation from './mergeoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _insert, _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to split {@link module:engine/model/element~Element an element} at given\n * {@link module:engine/model/operation/splitoperation~SplitOperation#splitPosition split position} into two elements,\n * both containing a part of the element's original content.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class SplitOperation extends Operation {\n    /**\n     * Creates a split operation.\n     *\n     * @param {module:engine/model/position~Position} splitPosition Position at which an element should be split.\n     * @param {Number} howMany Total offset size of elements that are in the split element after `position`.\n     * @param {module:engine/model/position~Position} insertionPosition Position at which the clone of split element\n     * (or element from graveyard) will be inserted.\n     * @param {module:engine/model/position~Position|null} graveyardPosition Position in the graveyard root before the element which\n     * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.\n     * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n     * can be applied or `null` if the operation operates on detached (non-document) tree.\n     */\n    constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {\n        super(baseVersion);\n        /**\n         * Position at which an element should be split.\n         *\n         * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#splitPosition\n         */\n        this.splitPosition = splitPosition.clone();\n        // Keep position sticking to the next node. This way any new content added at the place where the element is split\n        // will be left in the original element.\n        this.splitPosition.stickiness = 'toNext';\n        /**\n         * Total offset size of elements that are in the split element after `position`.\n         *\n         * @member {Number} module:engine/model/operation/splitoperation~SplitOperation#howMany\n         */\n        this.howMany = howMany;\n        /**\n         * Position at which the clone of split element (or element from graveyard) will be inserted.\n         *\n         * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#insertionPosition\n         */\n        this.insertionPosition = insertionPosition;\n        /**\n         * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.\n         * If it is not set, a copy of the the `position` parent will be used.\n         *\n         * The default behavior is to clone the split element. Element from graveyard is used during undo.\n         *\n         * @member {module:engine/model/position~Position|null} #graveyardPosition\n         */\n        this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;\n        if (this.graveyardPosition) {\n            this.graveyardPosition.stickiness = 'toNext';\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    get type() {\n        return 'split';\n    }\n    /**\n     * Position inside the new clone of a split element.\n     *\n     * This is a position where nodes that are after the split position will be moved to.\n     *\n     * @readonly\n     * @type {module:engine/model/position~Position}\n     */\n    get moveTargetPosition() {\n        const path = this.insertionPosition.path.slice();\n        path.push(0);\n        return new Position(this.insertionPosition.root, path);\n    }\n    /**\n     * Artificial range that contains all the nodes from the split element that will be moved to the new element.\n     * The range starts at {@link ~#splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n     *\n     * @readonly\n     * @type {module:engine/model/range~Range}\n     */\n    get movedRange() {\n        const end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);\n        return new Range(this.splitPosition, end);\n    }\n    /**\n     * Creates and returns an operation that has the same parameters as this operation.\n     *\n     * @returns {module:engine/model/operation/splitoperation~SplitOperation} Clone of this operation.\n     */\n    clone() {\n        return new SplitOperation(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);\n    }\n    /**\n     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n     *\n     * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n     */\n    getReversed() {\n        const graveyard = this.splitPosition.root.document.graveyard;\n        const graveyardPosition = new Position(graveyard, [0]);\n        return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);\n    }\n    /**\n     * @inheritDoc\n     * @internal\n     */\n    _validate() {\n        const element = this.splitPosition.parent;\n        const offset = this.splitPosition.offset;\n        // Validate whether split operation has correct parameters.\n        if (!element || element.maxOffset < offset) {\n            /**\n             * Split position is invalid.\n             *\n             * @error split-operation-position-invalid\n             */\n            throw new CKEditorError('split-operation-position-invalid', this);\n        }\n        else if (!element.parent) {\n            /**\n             * Cannot split root element.\n             *\n             * @error split-operation-split-in-root\n             */\n            throw new CKEditorError('split-operation-split-in-root', this);\n        }\n        else if (this.howMany != element.maxOffset - this.splitPosition.offset) {\n            /**\n             * Split operation specifies wrong number of nodes to move.\n             *\n             * @error split-operation-how-many-invalid\n             */\n            throw new CKEditorError('split-operation-how-many-invalid', this);\n        }\n        else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {\n            /**\n             * Graveyard position invalid.\n             *\n             * @error split-operation-graveyard-position-invalid\n             */\n            throw new CKEditorError('split-operation-graveyard-position-invalid', this);\n        }\n    }\n    /**\n     * @inheritDoc\n     * @internal\n     */\n    _execute() {\n        const splitElement = this.splitPosition.parent;\n        if (this.graveyardPosition) {\n            _move(Range._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);\n        }\n        else {\n            const newElement = splitElement._clone();\n            _insert(this.insertionPosition, newElement);\n        }\n        const sourceRange = new Range(Position._createAt(splitElement, this.splitPosition.offset), Position._createAt(splitElement, splitElement.maxOffset));\n        _move(sourceRange, this.moveTargetPosition);\n    }\n    /**\n     * @inheritDoc\n     */\n    toJSON() {\n        const json = super.toJSON();\n        json.splitPosition = this.splitPosition.toJSON();\n        json.insertionPosition = this.insertionPosition.toJSON();\n        if (this.graveyardPosition) {\n            json.graveyardPosition = this.graveyardPosition.toJSON();\n        }\n        return json;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get className() {\n        return 'SplitOperation';\n    }\n    /**\n     * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion\n     * position is after the split element.\n     *\n     * @param {module:engine/model/position~Position} splitPosition\n     * @returns {module:engine/model/position~Position}\n     */\n    static getInsertionPosition(splitPosition) {\n        const path = splitPosition.path.slice(0, -1);\n        path[path.length - 1]++;\n        return new Position(splitPosition.root, path, 'toPrevious');\n    }\n    /**\n     * Creates `SplitOperation` object from deserilized object, i.e. from parsed JSON string.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n     * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n     */\n    static fromJSON(json, document) {\n        const splitPosition = Position.fromJSON(json.splitPosition, document);\n        const insertionPosition = Position.fromJSON(json.insertionPosition, document);\n        const graveyardPosition = json.graveyardPosition ? Position.fromJSON(json.graveyardPosition, document) : null;\n        return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}