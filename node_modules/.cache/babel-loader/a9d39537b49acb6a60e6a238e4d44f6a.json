{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/schema\n */\nimport Element from './element';\nimport Position from './position';\nimport Range from './range';\nimport Text from './text';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\n/**\n * The model's schema. It defines the allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by the features and based on them, the editing framework and features\n * make decisions on how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * The {@glink framework/guides/architecture/editing-engine#schema schema section} of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture} guide.\n * * The {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema extends Observable {\n  /**\n   * Creates a schema instance.\n   */\n  constructor() {\n    super();\n    this._sourceDefinitions = {};\n    /**\n     * A dictionary containing attribute properties.\n     *\n     * @private\n     * @member {Object.<String,AttributeProperties>}\n     */\n    this._attributeProperties = {};\n    this.decorate('checkChild');\n    this.decorate('checkAttribute');\n    this.on('checkAttribute', (evt, args) => {\n      args[0] = new SchemaContext(args[0]);\n    }, {\n      priority: 'highest'\n    });\n    this.on('checkChild', (evt, args) => {\n      args[0] = new SchemaContext(args[0]);\n      args[1] = this.getDefinition(args[1]);\n    }, {\n      priority: 'highest'\n    });\n  }\n  /**\n   * Registers a schema item. Can only be called once for every item name.\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tinheritAllFrom: '$block'\n   *\t\t} );\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n  register(itemName, definition) {\n    if (this._sourceDefinitions[itemName]) {\n      /**\n       * A single item cannot be registered twice in the schema.\n       *\n       * This situation may happen when:\n       *\n       * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n       * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n       * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n       * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n       * and usually means one or more of the following issues:\n       *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n       *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n       *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n       *\n       * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n       *\n       * @param itemName The name of the model element that is being registered twice.\n       * @error schema-cannot-register-item-twice\n       */\n      throw new CKEditorError('schema-cannot-register-item-twice', this, {\n        itemName\n      });\n    }\n    this._sourceDefinitions[itemName] = [Object.assign({}, definition)];\n    this._clearCache();\n  }\n  /**\n   * Extends a {@link #register registered} item's definition.\n   *\n   * Extending properties such as `allowIn` will add more items to the existing properties,\n   * while redefining properties such as `isBlock` will override the previously defined ones.\n   *\n   *\t\tschema.register( 'foo', {\n   *\t\t\tallowIn: '$root',\n   *\t\t\tisBlock: true;\n   *\t\t} );\n   *\t\tschema.extend( 'foo', {\n   *\t\t\tallowIn: 'blockQuote',\n   *\t\t\tisBlock: false\n   *\t\t} );\n   *\n   *\t\tschema.getDefinition( 'foo' );\n   *\t\t//\t{\n   *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n   *\t\t// \t\tisBlock: false\n   *\t\t//\t}\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n  extend(itemName, definition) {\n    if (!this._sourceDefinitions[itemName]) {\n      /**\n       * Cannot extend an item which was not registered yet.\n       *\n       * This error happens when a plugin tries to extend the schema definition of an item which was not\n       * {@link #register registered} yet.\n       *\n       * @param itemName The name of the model element which is being extended.\n       * @error schema-cannot-extend-missing-item\n       */\n      throw new CKEditorError('schema-cannot-extend-missing-item', this, {\n        itemName\n      });\n    }\n    this._sourceDefinitions[itemName].push(Object.assign({}, definition));\n    this._clearCache();\n  }\n  /**\n   * Returns data of all registered items.\n   *\n   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n   * checking a list of all block elements, etc).\n   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n   * in other cases.\n   *\n   * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n   */\n  getDefinitions() {\n    if (!this._compiledDefinitions) {\n      this._compile();\n    }\n    return this._compiledDefinitions;\n  }\n  /**\n   * Returns a definition of the given item or `undefined` if an item is not registered.\n   *\n   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n   * checking a list of all block elements, etc).\n   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n   * in other cases.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n   */\n  getDefinition(item) {\n    let itemName;\n    if (typeof item == 'string') {\n      itemName = item;\n    } else if ('is' in item && (item.is('$text') || item.is('$textProxy'))) {\n      itemName = '$text';\n    }\n    // Element or module:engine/model/schema~SchemaContextItem.\n    else {\n      itemName = item.name;\n    }\n    return this.getDefinitions()[itemName];\n  }\n  /**\n   * Returns `true` if the given item is registered in the schema.\n   *\n   *\t\tschema.isRegistered( 'paragraph' ); // -> true\n   *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n   *\t\tschema.isRegistered( 'foo' ); // -> false\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n  isRegistered(item) {\n    return !!this.getDefinition(item);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n   *\n   *\t\tschema.isBlock( 'paragraph' ); // -> true\n   *\t\tschema.isBlock( '$root' ); // -> false\n   *\n   *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n   *\t\tschema.isBlock( paragraphElement ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n  isBlock(item) {\n    const def = this.getDefinition(item);\n    return !!(def && def.isBlock);\n  }\n  /**\n   * Returns `true` if the given item should be treated as a limit element.\n   *\n   * It considers an item to be a limit element if its\n   * {@link module:engine/model/schema~SchemaItemDefinition}'s\n   * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n   * was set to `true`.\n   *\n   *\t\tschema.isLimit( 'paragraph' ); // -> false\n   *\t\tschema.isLimit( '$root' ); // -> true\n   *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n   *\t\tschema.isLimit( 'imageBlock' ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n  isLimit(item) {\n    const def = this.getDefinition(item);\n    if (!def) {\n      return false;\n    }\n    return !!(def.isLimit || def.isObject);\n  }\n  /**\n   * Returns `true` if the given item should be treated as an object element.\n   *\n   * It considers an item to be an object element if its\n   * {@link module:engine/model/schema~SchemaItemDefinition}'s\n   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n   * was set to `true`.\n   *\n   *\t\tschema.isObject( 'paragraph' ); // -> false\n   *\t\tschema.isObject( 'imageBlock' ); // -> true\n   *\n   *\t\tconst imageElement = writer.createElement( 'imageBlock' );\n   *\t\tschema.isObject( imageElement ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n  isObject(item) {\n    const def = this.getDefinition(item);\n    if (!def) {\n      return false;\n    }\n    // Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n    // to understand why these three constitute an object.\n    return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n   *\n   *\t\tschema.isInline( 'paragraph' ); // -> false\n   *\t\tschema.isInline( 'softBreak' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isInline( text ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n  isInline(item) {\n    const def = this.getDefinition(item);\n    return !!(def && def.isInline);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n   *\n   *\t\tschema.isSelectable( 'paragraph' ); // -> false\n   *\t\tschema.isSelectable( 'heading1' ); // -> false\n   *\t\tschema.isSelectable( 'imageBlock' ); // -> true\n   *\t\tschema.isSelectable( 'tableCell' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isSelectable( text ); // -> false\n   *\n   * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n  isSelectable(item) {\n    const def = this.getDefinition(item);\n    if (!def) {\n      return false;\n    }\n    return !!(def.isSelectable || def.isObject);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n   *\n   *\t\tschema.isContent( 'paragraph' ); // -> false\n   *\t\tschema.isContent( 'heading1' ); // -> false\n   *\t\tschema.isContent( 'imageBlock' ); // -> true\n   *\t\tschema.isContent( 'horizontalLine' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isContent( text ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n  isContent(item) {\n    const def = this.getDefinition(item);\n    if (!def) {\n      return false;\n    }\n    return !!(def.isContent || def.isObject);\n  }\n  /**\n   * Checks whether the given node (`child`) can be a child of the given context.\n   *\n   *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tallowIn: '$root'\n   *\t\t} );\n   *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n   *\n   * Note: When verifying whether the given node can be a child of the given context, the\n   * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n   * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n   * It happens if one of the context's elements does not allow its child.\n   *\n   * @fires checkChild\n   * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n   * @param {module:engine/model/node~Node|String} def The child to check.\n   * @returns {Boolean}\n   */\n  checkChild(context, def) {\n    // Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n    if (!def) {\n      return false;\n    }\n    return this._checkContextMatch(def, context);\n  }\n  /**\n   * Checks whether the given attribute can be applied in the given context (on the last\n   * item of the context).\n   *\n   *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n   *\n   *\t\tschema.extend( '$text', {\n   *\t\t\tallowAttributes: 'bold'\n   *\t\t} );\n   *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n   *\n   * @fires checkAttribute\n   * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n   * @param {String} attributeName\n   * @returns {Boolean}\n   */\n  checkAttribute(context, attributeName) {\n    const def = this.getDefinition(context.last);\n    if (!def) {\n      return false;\n    }\n    return def.allowAttributes.includes(attributeName);\n  }\n  /**\n   * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n   *\n   * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n   *\n   * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n   * will be valid.\n   *\n   * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n   * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n   *\n   * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n   * element to which the `elementToMerge` will be merged.\n   * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n   * @returns {Boolean}\n   */\n  checkMerge(positionOrBaseElement, elementToMerge) {\n    if (positionOrBaseElement instanceof Position) {\n      const nodeBefore = positionOrBaseElement.nodeBefore;\n      const nodeAfter = positionOrBaseElement.nodeAfter;\n      if (!(nodeBefore instanceof Element)) {\n        /**\n         * The node before the merge position must be an element.\n         *\n         * @error schema-check-merge-no-element-before\n         */\n        throw new CKEditorError('schema-check-merge-no-element-before', this);\n      }\n      if (!(nodeAfter instanceof Element)) {\n        /**\n         * The node after the merge position must be an element.\n         *\n         * @error schema-check-merge-no-element-after\n         */\n        throw new CKEditorError('schema-check-merge-no-element-after', this);\n      }\n      return this.checkMerge(nodeBefore, nodeAfter);\n    }\n    for (const child of elementToMerge.getChildren()) {\n      if (!this.checkChild(positionOrBaseElement, child)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Allows registering a callback to the {@link #checkChild} method calls.\n   *\n   * Callbacks allow you to implement rules which are not otherwise possible to achieve\n   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n   * For example, by using this method you can disallow elements in specific contexts.\n   *\n   * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n   * you can use that event instead.\n   *\n   * Example:\n   *\n   *\t\t// Disallow heading1 directly inside a blockQuote.\n   *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n   *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n   *\t\t\t\treturn false;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Which translates to:\n   *\n   *\t\tschema.on( 'checkChild', ( evt, args ) => {\n   *\t\t\tconst context = args[ 0 ];\n   *\t\t\tconst childDefinition = args[ 1 ];\n   *\n   *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n   *\t\t\t\t// Prevent next listeners from being called.\n   *\t\t\t\tevt.stop();\n   *\t\t\t\t// Set the checkChild()'s return value.\n   *\t\t\t\tevt.return = false;\n   *\t\t\t}\n   *\t\t}, { priority: 'high' } );\n   *\n   * @param {Function} callback The callback to be called. It is called with two parameters:\n   * {@link module:engine/model/schema~SchemaContext} (context) instance and\n   * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n   * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n   * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n   */\n  addChildCheck(callback) {\n    this.on('checkChild', (evt, _ref) => {\n      let [ctx, childDef] = _ref;\n      // checkChild() was called with a non-registered child.\n      // In 99% cases such check should return false, so not to overcomplicate all callbacks\n      // don't even execute them.\n      if (!childDef) {\n        return;\n      }\n      const retValue = callback(ctx, childDef);\n      if (typeof retValue == 'boolean') {\n        evt.stop();\n        evt.return = retValue;\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Allows registering a callback to the {@link #checkAttribute} method calls.\n   *\n   * Callbacks allow you to implement rules which are not otherwise possible to achieve\n   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n   * For example, by using this method you can disallow attribute if node to which it is applied\n   * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n   *\n   * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n   * you can use that event instead.\n   *\n   * Example:\n   *\n   *\t\t// Disallow bold on $text inside heading1.\n   *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n   *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n   *\t\t\t\treturn false;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Which translates to:\n   *\n   *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n   *\t\t\tconst context = args[ 0 ];\n   *\t\t\tconst attributeName = args[ 1 ];\n   *\n   *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n   *\t\t\t\t// Prevent next listeners from being called.\n   *\t\t\t\tevt.stop();\n   *\t\t\t\t// Set the checkAttribute()'s return value.\n   *\t\t\t\tevt.return = false;\n   *\t\t\t}\n   *\t\t}, { priority: 'high' } );\n   *\n   * @param {Function} callback The callback to be called. It is called with two parameters:\n   * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n   * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n   * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n   */\n  addAttributeCheck(callback) {\n    this.on('checkAttribute', (evt, _ref2) => {\n      let [ctx, attributeName] = _ref2;\n      const retValue = callback(ctx, attributeName);\n      if (typeof retValue == 'boolean') {\n        evt.stop();\n        evt.return = retValue;\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * This method allows assigning additional metadata to the model attributes. For example,\n   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n   * used to mark formatting attributes (like `bold` or `italic`).\n   *\n   *\t\t// Mark bold as a formatting attribute.\n   *\t\tschema.setAttributeProperties( 'bold', {\n   *\t\t\tisFormatting: true\n   *\t\t} );\n   *\n   *\t\t// Override code not to be considered a formatting markup.\n   *\t\tschema.setAttributeProperties( 'code', {\n   *\t\t\tisFormatting: false\n   *\t\t} );\n   *\n   * Properties are not limited to members defined in the\n   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\tcustomProperty: 'value'\n   *\t\t} );\n   *\n   * Subsequent calls with the same attribute will extend its custom properties:\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\tone: 1\n   *\t\t} );\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\ttwo: 2\n   *\t\t} );\n   *\n   *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n   *\t\t// Logs: { one: 1, two: 2 }\n   *\n   * @param {String} attributeName A name of the attribute to receive the properties.\n   * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n   */\n  setAttributeProperties(attributeName, properties) {\n    this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);\n  }\n  /**\n   * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n   *\n   * @param {String} attributeName A name of the attribute.\n   * @returns {module:engine/model/schema~AttributeProperties}\n   */\n  getAttributeProperties(attributeName) {\n    return this._attributeProperties[attributeName] || {};\n  }\n  /**\n   * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n   * selection/range/position or the root otherwise.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n   * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n   * The selection/range/position to check.\n   * @returns {module:engine/model/element~Element} The lowest limit element containing\n   * the entire `selectionOrRangeOrPosition`.\n   */\n  getLimitElement(selectionOrRangeOrPosition) {\n    let element;\n    if (selectionOrRangeOrPosition instanceof Position) {\n      element = selectionOrRangeOrPosition.parent;\n    } else {\n      const ranges = selectionOrRangeOrPosition instanceof Range ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges());\n      // Find the common ancestor for all selection's ranges.\n      element = ranges.reduce((element, range) => {\n        const rangeCommonAncestor = range.getCommonAncestor();\n        if (!element) {\n          return rangeCommonAncestor;\n        }\n        return element.getCommonAncestor(rangeCommonAncestor, {\n          includeSelf: true\n        });\n      }, null);\n    }\n    while (!this.isLimit(element)) {\n      if (element.parent) {\n        element = element.parent;\n      } else {\n        break;\n      }\n    }\n    return element;\n  }\n  /**\n   * Checks whether the attribute is allowed in selection:\n   *\n   * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n   * * if the selection is collapsed, then checks if on the selection position there's a text with the\n   * specified attribute allowed.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * Selection which will be checked.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Boolean}\n   */\n  checkAttributeInSelection(selection, attribute) {\n    if (selection.isCollapsed) {\n      const firstPosition = selection.getFirstPosition();\n      const context = [...firstPosition.getAncestors(), new Text('', selection.getAttributes())];\n      // Check whether schema allows for a text with the attribute in the selection.\n      return this.checkAttribute(context, attribute);\n    } else {\n      const ranges = selection.getRanges();\n      // For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n      for (const range of ranges) {\n        for (const value of range) {\n          if (this.checkAttribute(value.item, attribute)) {\n            // If we found a node that is allowed to have the attribute, return true.\n            return true;\n          }\n        }\n      }\n    }\n    // If we haven't found such node, return false.\n    return false;\n  }\n  /**\n   * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n   *\n   * @param {Iterable.<module:engine/model/range~Range>} ranges Ranges to be validated.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n   */\n  *getValidRanges(ranges, attribute) {\n    ranges = convertToMinimalFlatRanges(ranges);\n    for (const range of ranges) {\n      yield* this._getValidRangesForRange(range, attribute);\n    }\n  }\n  /**\n   * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n   * nearest to that `position` and is a correct range for selection.\n   *\n   * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n   * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n   * the {@link module:engine/model/schema~Schema schema}.\n   *\n   * Direction of searching for the nearest correct selection range can be specified as:\n   *\n   * * `both` - searching will be performed in both ways,\n   * * `forward` - searching will be performed only forward,\n   * * `backward` - searching will be performed only backward.\n   *\n   * When valid selection range cannot be found, `null` is returned.\n   *\n   * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n   * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n   * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n   */\n  getNearestSelectionRange(position) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'both';\n    // Return collapsed range if provided position is valid.\n    if (this.checkChild(position, '$text')) {\n      return new Range(position);\n    }\n    let backwardWalker, forwardWalker;\n    // Never leave a limit element.\n    const limitElement = position.getAncestors().reverse().find(item => this.isLimit(item)) || position.root;\n    if (direction == 'both' || direction == 'backward') {\n      backwardWalker = new TreeWalker({\n        boundaries: Range._createIn(limitElement),\n        startPosition: position,\n        direction: 'backward'\n      });\n    }\n    if (direction == 'both' || direction == 'forward') {\n      forwardWalker = new TreeWalker({\n        boundaries: Range._createIn(limitElement),\n        startPosition: position\n      });\n    }\n    for (const data of combineWalkers(backwardWalker, forwardWalker)) {\n      const type = data.walker == backwardWalker ? 'elementEnd' : 'elementStart';\n      const value = data.value;\n      if (value.type == type && this.isObject(value.item)) {\n        return Range._createOn(value.item);\n      }\n      if (this.checkChild(value.nextPosition, '$text')) {\n        return new Range(value.nextPosition);\n      }\n    }\n    return null;\n  }\n  /**\n   * Tries to find position ancestors that allow to insert a given node.\n   * It starts searching from the given position and goes node by node to the top of the model tree\n   * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n   * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n   *\n   * @param {module:engine/model/position~Position} position The position that the search will start from.\n   * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n   * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n   */\n  findAllowedParent(position, node) {\n    let parent = position.parent;\n    while (parent) {\n      if (this.checkChild(parent, node)) {\n        return parent;\n      }\n      // Do not split limit elements.\n      if (this.isLimit(parent)) {\n        return null;\n      }\n      parent = parent.parent;\n    }\n    return null;\n  }\n  /**\n   * Sets attributes allowed by the schema on a given node.\n   *\n   * @param {module:engine/model/node~Node} node A node to set attributes on.\n   * @param {Object} attributes Attributes keys and values.\n   * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n   */\n  setAllowedAttributes(node, attributes, writer) {\n    const model = writer.model;\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      if (model.schema.checkAttribute(node, attributeName)) {\n        writer.setAttribute(attributeName, attributeValue, node);\n      }\n    }\n  }\n  /**\n   * Removes attributes disallowed by the schema.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n   * @param {module:engine/model/writer~Writer} writer\n   */\n  removeDisallowedAttributes(nodes, writer) {\n    for (const node of nodes) {\n      // When node is a `Text` it has no children, so just filter it out.\n      if (node.is('$text')) {\n        removeDisallowedAttributeFromNode(this, node, writer);\n      }\n      // In a case of `Element` iterates through positions between nodes inside this element\n      // and filter out node before the current position, or position parent when position\n      // is at start of an element. Using positions prevent from omitting merged nodes\n      // see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n      else {\n        const rangeInNode = Range._createIn(node);\n        const positionsInRange = rangeInNode.getPositions();\n        for (const position of positionsInRange) {\n          const item = position.nodeBefore || position.parent;\n          removeDisallowedAttributeFromNode(this, item, writer);\n        }\n      }\n    }\n  }\n  /**\n   * Gets attributes of a node that have a given property.\n   *\n   * @param {module:engine/model/node~Node} node Node to get attributes from.\n   * @param {String} propertyName Name of the property that attribute must have to return it.\n   * @param {Boolean|Symbol|String|Number|Object|null|undefined} propertyValue Desired value of the property that we want to check.\n   * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will\n   * return attributes which given property's value is equal to this parameter.\n   * @returns {Object} Object with attributes' names as key and attributes' values as value.\n   */\n  getAttributesWithProperty(node, propertyName, propertyValue) {\n    const attributes = {};\n    for (const [attributeName, attributeValue] of node.getAttributes()) {\n      const attributeProperties = this.getAttributeProperties(attributeName);\n      if (attributeProperties[propertyName] === undefined) {\n        continue;\n      }\n      if (propertyValue === undefined || propertyValue === attributeProperties[propertyName]) {\n        attributes[attributeName] = attributeValue;\n      }\n    }\n    return attributes;\n  }\n  /**\n   * Creates an instance of the schema context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   * @returns {module:engine/model/schema~SchemaContext}\n   */\n  createContext(context) {\n    return new SchemaContext(context);\n  }\n  /**\n   * @private\n   */\n  _clearCache() {\n    this._compiledDefinitions = null;\n  }\n  /**\n   * @private\n   */\n  _compile() {\n    const compiledDefinitions = {};\n    const sourceRules = this._sourceDefinitions;\n    const itemNames = Object.keys(sourceRules);\n    for (const itemName of itemNames) {\n      compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);\n    }\n    for (const itemName of itemNames) {\n      compileAllowChildren(compiledDefinitions, itemName);\n    }\n    for (const itemName of itemNames) {\n      compileAllowContentOf(compiledDefinitions, itemName);\n    }\n    for (const itemName of itemNames) {\n      compileAllowWhere(compiledDefinitions, itemName);\n    }\n    for (const itemName of itemNames) {\n      compileAllowAttributesOf(compiledDefinitions, itemName);\n      compileInheritPropertiesFrom(compiledDefinitions, itemName);\n    }\n    for (const itemName of itemNames) {\n      cleanUpAllowIn(compiledDefinitions, itemName);\n      setupAllowChildren(compiledDefinitions, itemName);\n      cleanUpAllowAttributes(compiledDefinitions, itemName);\n    }\n    this._compiledDefinitions = compiledDefinitions;\n  }\n  /**\n   * @private\n   * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n   * @param {module:engine/model/schema~SchemaContext} context\n   * @param {Number} contextItemIndex\n   */\n  _checkContextMatch(def, context) {\n    let contextItemIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;\n    const contextItem = context.getItem(contextItemIndex);\n    if (def.allowIn.includes(contextItem.name)) {\n      if (contextItemIndex == 0) {\n        return true;\n      } else {\n        const parentRule = this.getDefinition(contextItem);\n        return this._checkContextMatch(parentRule, context, contextItemIndex - 1);\n      }\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n   * inside the given range on which the attribute can be applied.\n   *\n   * This is a helper function for {@link ~Schema#getValidRanges}.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The range to process.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n   */\n  *_getValidRangesForRange(range, attribute) {\n    let start = range.start;\n    let end = range.start;\n    for (const item of range.getItems({\n      shallow: true\n    })) {\n      if (item.is('element')) {\n        yield* this._getValidRangesForRange(Range._createIn(item), attribute);\n      }\n      if (!this.checkAttribute(item, attribute)) {\n        if (!start.isEqual(end)) {\n          yield new Range(start, end);\n        }\n        start = Position._createAfter(item);\n      }\n      end = Position._createAfter(item);\n    }\n    if (!start.isEqual(end)) {\n      yield new Range(start, end);\n    }\n  }\n}\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n  /**\n   * Creates an instance of the context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   */\n  constructor(context) {\n    if (context instanceof SchemaContext) {\n      return context;\n    }\n    let items;\n    if (typeof context == 'string') {\n      items = [context];\n    } else if (!Array.isArray(context)) {\n      // `context` is item or position.\n      // Position#getAncestors() doesn't accept any parameters but it works just fine here.\n      items = context.getAncestors({\n        includeSelf: true\n      });\n    } else {\n      items = context;\n    }\n    this._items = items.map(mapContextItem);\n  }\n  /**\n   * The number of items.\n   *\n   * @type {Number}\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * The last item (the lowest node).\n   *\n   * @type {module:engine/model/schema~SchemaContextItem}\n   */\n  get last() {\n    return this._items[this._items.length - 1];\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all context items.\n   *\n   * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n   */\n  [Symbol.iterator]() {\n    return this._items[Symbol.iterator]();\n  }\n  /**\n   * Returns a new schema context instance with an additional item.\n   *\n   * Item can be added as:\n   *\n   * \t\tconst context = new SchemaContext( [ '$root' ] );\n   *\n   * \t\t// An element.\n   * \t\tconst fooElement = writer.createElement( 'fooElement' );\n   * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n   *\n   * \t\t// A text node.\n   * \t\tconst text = writer.createText( 'foobar' );\n   * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n   *\n   * \t\t// A string (element name).\n   * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n   *\n   * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n   * (without ancestors).\n   *\n   * @param {String|module:engine/model/node~Node} item An item that will be added\n   * to the current context.\n   * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n   */\n  push(item) {\n    const ctx = new SchemaContext([item]);\n    ctx._items = [...this._items, ...ctx._items];\n    return ctx;\n  }\n  /**\n   * Gets an item on the given index.\n   *\n   * @returns {module:engine/model/schema~SchemaContextItem}\n   */\n  getItem(index) {\n    return this._items[index];\n  }\n  /**\n   * Returns the names of items.\n   *\n   * @returns {Iterable.<String>}\n   */\n  *getNames() {\n    yield* this._items.map(item => item.name);\n  }\n  /**\n   * Checks whether the context ends with the given nodes.\n   *\n   *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n   *\n   *\t\tctx.endsWith( '$text' ); // -> true\n   *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n   *\t\tctx.endsWith( '$root' ); // -> false\n   *\t\tctx.endsWith( 'paragraph' ); // -> false\n   *\n   * @param {String} query\n   * @returns {Boolean}\n   */\n  endsWith(query) {\n    return Array.from(this.getNames()).join(' ').endsWith(query);\n  }\n  /**\n   * Checks whether the context starts with the given nodes.\n   *\n   *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n   *\n   *\t\tctx.endsWith( '$root' ); // -> true\n   *\t\tctx.endsWith( '$root paragraph' ); // -> true\n   *\t\tctx.endsWith( '$text' ); // -> false\n   *\t\tctx.endsWith( 'paragraph' ); // -> false\n   *\n   * @param {String} query\n   * @returns {Boolean}\n   */\n  startsWith(query) {\n    return Array.from(this.getNames()).join(' ').startsWith(query);\n  }\n}\nfunction compileBaseItemRule(sourceItemRules, itemName) {\n  const itemRule = {\n    name: itemName,\n    allowIn: [],\n    allowContentOf: [],\n    allowWhere: [],\n    allowAttributes: [],\n    allowAttributesOf: [],\n    allowChildren: [],\n    inheritTypesFrom: []\n  };\n  copyTypes(sourceItemRules, itemRule);\n  copyProperty(sourceItemRules, itemRule, 'allowIn');\n  copyProperty(sourceItemRules, itemRule, 'allowContentOf');\n  copyProperty(sourceItemRules, itemRule, 'allowWhere');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributes');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributesOf');\n  copyProperty(sourceItemRules, itemRule, 'allowChildren');\n  copyProperty(sourceItemRules, itemRule, 'inheritTypesFrom');\n  makeInheritAllWork(sourceItemRules, itemRule);\n  return itemRule;\n}\nfunction compileAllowChildren(compiledDefinitions, itemName) {\n  const item = compiledDefinitions[itemName];\n  for (const allowChildrenItem of item.allowChildren) {\n    const allowedChildren = compiledDefinitions[allowChildrenItem];\n    // The allowChildren property may point to an unregistered element.\n    if (!allowedChildren) {\n      continue;\n    }\n    allowedChildren.allowIn.push(itemName);\n  }\n  // The allowIn property already includes correct items, reset the allowChildren property\n  // to avoid duplicates later when setting up compilation results.\n  item.allowChildren.length = 0;\n}\nfunction compileAllowContentOf(compiledDefinitions, itemName) {\n  for (const allowContentOfItemName of compiledDefinitions[itemName].allowContentOf) {\n    // The allowContentOf property may point to an unregistered element.\n    if (compiledDefinitions[allowContentOfItemName]) {\n      const allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);\n      allowedChildren.forEach(allowedItem => {\n        allowedItem.allowIn.push(itemName);\n      });\n    }\n  }\n  delete compiledDefinitions[itemName].allowContentOf;\n}\nfunction compileAllowWhere(compiledDefinitions, itemName) {\n  for (const allowWhereItemName of compiledDefinitions[itemName].allowWhere) {\n    const inheritFrom = compiledDefinitions[allowWhereItemName];\n    // The allowWhere property may point to an unregistered element.\n    if (inheritFrom) {\n      const allowedIn = inheritFrom.allowIn;\n      compiledDefinitions[itemName].allowIn.push(...allowedIn);\n    }\n  }\n  delete compiledDefinitions[itemName].allowWhere;\n}\nfunction compileAllowAttributesOf(compiledDefinitions, itemName) {\n  for (const allowAttributeOfItem of compiledDefinitions[itemName].allowAttributesOf) {\n    const inheritFrom = compiledDefinitions[allowAttributeOfItem];\n    if (inheritFrom) {\n      const inheritAttributes = inheritFrom.allowAttributes;\n      compiledDefinitions[itemName].allowAttributes.push(...inheritAttributes);\n    }\n  }\n  delete compiledDefinitions[itemName].allowAttributesOf;\n}\nfunction compileInheritPropertiesFrom(compiledDefinitions, itemName) {\n  const item = compiledDefinitions[itemName];\n  for (const inheritPropertiesOfItem of item.inheritTypesFrom) {\n    const inheritFrom = compiledDefinitions[inheritPropertiesOfItem];\n    if (inheritFrom) {\n      const typeNames = Object.keys(inheritFrom).filter(name => name.startsWith('is'));\n      for (const name of typeNames) {\n        if (!(name in item)) {\n          item[name] = inheritFrom[name];\n        }\n      }\n    }\n  }\n  delete item.inheritTypesFrom;\n}\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  const existingItems = itemRule.allowIn.filter(itemToCheck => compiledDefinitions[itemToCheck]);\n  itemRule.allowIn = Array.from(new Set(existingItems));\n}\n// Setup allowChildren items based on allowIn.\nfunction setupAllowChildren(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  for (const allowedParentItemName of itemRule.allowIn) {\n    const allowedParentItem = compiledDefinitions[allowedParentItemName];\n    allowedParentItem.allowChildren.push(itemName);\n  }\n}\nfunction cleanUpAllowAttributes(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));\n}\nfunction copyTypes(sourceItemRules, itemRule) {\n  for (const sourceItemRule of sourceItemRules) {\n    const typeNames = Object.keys(sourceItemRule).filter(name => name.startsWith('is'));\n    for (const name of typeNames) {\n      itemRule[name] = !!sourceItemRule[name];\n    }\n  }\n}\nfunction copyProperty(sourceItemRules, itemRule, propertyName) {\n  for (const sourceItemRule of sourceItemRules) {\n    const value = sourceItemRule[propertyName];\n    if (typeof value == 'string') {\n      itemRule[propertyName].push(value);\n    } else if (Array.isArray(value)) {\n      itemRule[propertyName].push(...value);\n    }\n  }\n}\nfunction makeInheritAllWork(sourceItemRules, itemRule) {\n  for (const sourceItemRule of sourceItemRules) {\n    const inheritFrom = sourceItemRule.inheritAllFrom;\n    if (inheritFrom) {\n      itemRule.allowContentOf.push(inheritFrom);\n      itemRule.allowWhere.push(inheritFrom);\n      itemRule.allowAttributesOf.push(inheritFrom);\n      itemRule.inheritTypesFrom.push(inheritFrom);\n    }\n  }\n}\nfunction getAllowedChildren(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  return getValues(compiledDefinitions).filter(def => def.allowIn.includes(itemRule.name));\n}\nfunction getValues(obj) {\n  return Object.keys(obj).map(key => obj[key]);\n}\nfunction mapContextItem(ctxItem) {\n  if (typeof ctxItem == 'string' || ctxItem.is('documentFragment')) {\n    return {\n      name: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n      *getAttributeKeys() {},\n      getAttribute() {}\n    };\n  } else {\n    return {\n      // '$text' means text nodes and text proxies.\n      name: ctxItem.is('element') ? ctxItem.name : '$text',\n      *getAttributeKeys() {\n        yield* ctxItem.getAttributeKeys();\n      },\n      getAttribute(key) {\n        return ctxItem.getAttribute(key);\n      }\n    };\n  }\n}\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers(backward, forward) {\n  let done = false;\n  while (!done) {\n    done = true;\n    if (backward) {\n      const step = backward.next();\n      if (!step.done) {\n        done = false;\n        yield {\n          walker: backward,\n          value: step.value\n        };\n      }\n    }\n    if (forward) {\n      const step = forward.next();\n      if (!step.done) {\n        done = false;\n        yield {\n          walker: forward,\n          value: step.value\n        };\n      }\n    }\n  }\n}\n// Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\nfunction* convertToMinimalFlatRanges(ranges) {\n  for (const range of ranges) {\n    yield* range.getMinimalFlatRanges();\n  }\n}\nfunction removeDisallowedAttributeFromNode(schema, node, writer) {\n  for (const attribute of node.getAttributeKeys()) {\n    if (!schema.checkAttribute(node, attribute)) {\n      writer.removeAttribute(attribute, node);\n    }\n  }\n}","map":{"version":3,"names":["Element","Position","Range","Text","TreeWalker","CKEditorError","Observable","Schema","constructor","_sourceDefinitions","_attributeProperties","decorate","on","evt","args","SchemaContext","priority","getDefinition","register","itemName","definition","Object","assign","_clearCache","extend","push","getDefinitions","_compiledDefinitions","_compile","item","is","name","isRegistered","isBlock","def","isLimit","isObject","isSelectable","isContent","isInline","checkChild","context","_checkContextMatch","checkAttribute","attributeName","last","allowAttributes","includes","checkMerge","positionOrBaseElement","elementToMerge","nodeBefore","nodeAfter","child","getChildren","addChildCheck","callback","ctx","childDef","retValue","stop","return","addAttributeCheck","setAttributeProperties","properties","getAttributeProperties","getLimitElement","selectionOrRangeOrPosition","element","parent","ranges","Array","from","getRanges","reduce","range","rangeCommonAncestor","getCommonAncestor","includeSelf","checkAttributeInSelection","selection","attribute","isCollapsed","firstPosition","getFirstPosition","getAncestors","getAttributes","value","getValidRanges","convertToMinimalFlatRanges","_getValidRangesForRange","getNearestSelectionRange","position","direction","backwardWalker","forwardWalker","limitElement","reverse","find","root","boundaries","_createIn","startPosition","data","combineWalkers","type","walker","_createOn","nextPosition","findAllowedParent","node","setAllowedAttributes","attributes","writer","model","attributeValue","entries","schema","setAttribute","removeDisallowedAttributes","nodes","removeDisallowedAttributeFromNode","rangeInNode","positionsInRange","getPositions","getAttributesWithProperty","propertyName","propertyValue","attributeProperties","undefined","createContext","compiledDefinitions","sourceRules","itemNames","keys","compileBaseItemRule","compileAllowChildren","compileAllowContentOf","compileAllowWhere","compileAllowAttributesOf","compileInheritPropertiesFrom","cleanUpAllowIn","setupAllowChildren","cleanUpAllowAttributes","contextItemIndex","length","contextItem","getItem","allowIn","parentRule","start","end","getItems","shallow","isEqual","_createAfter","items","isArray","_items","map","mapContextItem","Symbol","iterator","index","getNames","endsWith","query","join","startsWith","sourceItemRules","itemRule","allowContentOf","allowWhere","allowAttributesOf","allowChildren","inheritTypesFrom","copyTypes","copyProperty","makeInheritAllWork","allowChildrenItem","allowedChildren","allowContentOfItemName","getAllowedChildren","forEach","allowedItem","allowWhereItemName","inheritFrom","allowedIn","allowAttributeOfItem","inheritAttributes","inheritPropertiesOfItem","typeNames","filter","existingItems","itemToCheck","Set","allowedParentItemName","allowedParentItem","sourceItemRule","inheritAllFrom","getValues","obj","key","ctxItem","getAttributeKeys","getAttribute","backward","forward","done","step","next","getMinimalFlatRanges","removeAttribute"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/schema\n */\nimport Element from './element';\nimport Position from './position';\nimport Range from './range';\nimport Text from './text';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\n/**\n * The model's schema. It defines the allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by the features and based on them, the editing framework and features\n * make decisions on how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * The {@glink framework/guides/architecture/editing-engine#schema schema section} of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture} guide.\n * * The {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema extends Observable {\n    /**\n     * Creates a schema instance.\n     */\n    constructor() {\n        super();\n        this._sourceDefinitions = {};\n        /**\n         * A dictionary containing attribute properties.\n         *\n         * @private\n         * @member {Object.<String,AttributeProperties>}\n         */\n        this._attributeProperties = {};\n        this.decorate('checkChild');\n        this.decorate('checkAttribute');\n        this.on('checkAttribute', (evt, args) => {\n            args[0] = new SchemaContext(args[0]);\n        }, { priority: 'highest' });\n        this.on('checkChild', (evt, args) => {\n            args[0] = new SchemaContext(args[0]);\n            args[1] = this.getDefinition(args[1]);\n        }, { priority: 'highest' });\n    }\n    /**\n     * Registers a schema item. Can only be called once for every item name.\n     *\n     *\t\tschema.register( 'paragraph', {\n     *\t\t\tinheritAllFrom: '$block'\n     *\t\t} );\n     *\n     * @param {String} itemName\n     * @param {module:engine/model/schema~SchemaItemDefinition} definition\n     */\n    register(itemName, definition) {\n        if (this._sourceDefinitions[itemName]) {\n            /**\n             * A single item cannot be registered twice in the schema.\n             *\n             * This situation may happen when:\n             *\n             * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n             * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n             * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n             * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n             * and usually means one or more of the following issues:\n             *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n             *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n             *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n             *\n             * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n             *\n             * @param itemName The name of the model element that is being registered twice.\n             * @error schema-cannot-register-item-twice\n             */\n            throw new CKEditorError('schema-cannot-register-item-twice', this, {\n                itemName\n            });\n        }\n        this._sourceDefinitions[itemName] = [\n            Object.assign({}, definition)\n        ];\n        this._clearCache();\n    }\n    /**\n     * Extends a {@link #register registered} item's definition.\n     *\n     * Extending properties such as `allowIn` will add more items to the existing properties,\n     * while redefining properties such as `isBlock` will override the previously defined ones.\n     *\n     *\t\tschema.register( 'foo', {\n     *\t\t\tallowIn: '$root',\n     *\t\t\tisBlock: true;\n     *\t\t} );\n     *\t\tschema.extend( 'foo', {\n     *\t\t\tallowIn: 'blockQuote',\n     *\t\t\tisBlock: false\n     *\t\t} );\n     *\n     *\t\tschema.getDefinition( 'foo' );\n     *\t\t//\t{\n     *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n     *\t\t// \t\tisBlock: false\n     *\t\t//\t}\n     *\n     * @param {String} itemName\n     * @param {module:engine/model/schema~SchemaItemDefinition} definition\n     */\n    extend(itemName, definition) {\n        if (!this._sourceDefinitions[itemName]) {\n            /**\n             * Cannot extend an item which was not registered yet.\n             *\n             * This error happens when a plugin tries to extend the schema definition of an item which was not\n             * {@link #register registered} yet.\n             *\n             * @param itemName The name of the model element which is being extended.\n             * @error schema-cannot-extend-missing-item\n             */\n            throw new CKEditorError('schema-cannot-extend-missing-item', this, {\n                itemName\n            });\n        }\n        this._sourceDefinitions[itemName].push(Object.assign({}, definition));\n        this._clearCache();\n    }\n    /**\n     * Returns data of all registered items.\n     *\n     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n     * checking a list of all block elements, etc).\n     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n     * in other cases.\n     *\n     * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n     */\n    getDefinitions() {\n        if (!this._compiledDefinitions) {\n            this._compile();\n        }\n        return this._compiledDefinitions;\n    }\n    /**\n     * Returns a definition of the given item or `undefined` if an item is not registered.\n     *\n     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n     * checking a list of all block elements, etc).\n     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n     * in other cases.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n     */\n    getDefinition(item) {\n        let itemName;\n        if (typeof item == 'string') {\n            itemName = item;\n        }\n        else if ('is' in item && (item.is('$text') || item.is('$textProxy'))) {\n            itemName = '$text';\n        }\n        // Element or module:engine/model/schema~SchemaContextItem.\n        else {\n            itemName = item.name;\n        }\n        return this.getDefinitions()[itemName];\n    }\n    /**\n     * Returns `true` if the given item is registered in the schema.\n     *\n     *\t\tschema.isRegistered( 'paragraph' ); // -> true\n     *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n     *\t\tschema.isRegistered( 'foo' ); // -> false\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n    isRegistered(item) {\n        return !!this.getDefinition(item);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n     *\n     *\t\tschema.isBlock( 'paragraph' ); // -> true\n     *\t\tschema.isBlock( '$root' ); // -> false\n     *\n     *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n     *\t\tschema.isBlock( paragraphElement ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n    isBlock(item) {\n        const def = this.getDefinition(item);\n        return !!(def && def.isBlock);\n    }\n    /**\n     * Returns `true` if the given item should be treated as a limit element.\n     *\n     * It considers an item to be a limit element if its\n     * {@link module:engine/model/schema~SchemaItemDefinition}'s\n     * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n     * was set to `true`.\n     *\n     *\t\tschema.isLimit( 'paragraph' ); // -> false\n     *\t\tschema.isLimit( '$root' ); // -> true\n     *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n     *\t\tschema.isLimit( 'imageBlock' ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n    isLimit(item) {\n        const def = this.getDefinition(item);\n        if (!def) {\n            return false;\n        }\n        return !!(def.isLimit || def.isObject);\n    }\n    /**\n     * Returns `true` if the given item should be treated as an object element.\n     *\n     * It considers an item to be an object element if its\n     * {@link module:engine/model/schema~SchemaItemDefinition}'s\n     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n     * was set to `true`.\n     *\n     *\t\tschema.isObject( 'paragraph' ); // -> false\n     *\t\tschema.isObject( 'imageBlock' ); // -> true\n     *\n     *\t\tconst imageElement = writer.createElement( 'imageBlock' );\n     *\t\tschema.isObject( imageElement ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n    isObject(item) {\n        const def = this.getDefinition(item);\n        if (!def) {\n            return false;\n        }\n        // Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n        // to understand why these three constitute an object.\n        return !!(def.isObject || (def.isLimit && def.isSelectable && def.isContent));\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n     *\n     *\t\tschema.isInline( 'paragraph' ); // -> false\n     *\t\tschema.isInline( 'softBreak' ); // -> true\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\tschema.isInline( text ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n    isInline(item) {\n        const def = this.getDefinition(item);\n        return !!(def && def.isInline);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n     *\n     *\t\tschema.isSelectable( 'paragraph' ); // -> false\n     *\t\tschema.isSelectable( 'heading1' ); // -> false\n     *\t\tschema.isSelectable( 'imageBlock' ); // -> true\n     *\t\tschema.isSelectable( 'tableCell' ); // -> true\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\tschema.isSelectable( text ); // -> false\n     *\n     * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n    isSelectable(item) {\n        const def = this.getDefinition(item);\n        if (!def) {\n            return false;\n        }\n        return !!(def.isSelectable || def.isObject);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n     *\n     *\t\tschema.isContent( 'paragraph' ); // -> false\n     *\t\tschema.isContent( 'heading1' ); // -> false\n     *\t\tschema.isContent( 'imageBlock' ); // -> true\n     *\t\tschema.isContent( 'horizontalLine' ); // -> true\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\tschema.isContent( text ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n    isContent(item) {\n        const def = this.getDefinition(item);\n        if (!def) {\n            return false;\n        }\n        return !!(def.isContent || def.isObject);\n    }\n    /**\n     * Checks whether the given node (`child`) can be a child of the given context.\n     *\n     *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n     *\n     *\t\tschema.register( 'paragraph', {\n     *\t\t\tallowIn: '$root'\n     *\t\t} );\n     *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n     *\n     * Note: When verifying whether the given node can be a child of the given context, the\n     * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n     * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n     * It happens if one of the context's elements does not allow its child.\n     *\n     * @fires checkChild\n     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n     * @param {module:engine/model/node~Node|String} def The child to check.\n     * @returns {Boolean}\n     */\n    checkChild(context, def) {\n        // Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n        if (!def) {\n            return false;\n        }\n        return this._checkContextMatch(def, context);\n    }\n    /**\n     * Checks whether the given attribute can be applied in the given context (on the last\n     * item of the context).\n     *\n     *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n     *\n     *\t\tschema.extend( '$text', {\n     *\t\t\tallowAttributes: 'bold'\n     *\t\t} );\n     *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n     *\n     * @fires checkAttribute\n     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n     * @param {String} attributeName\n     * @returns {Boolean}\n     */\n    checkAttribute(context, attributeName) {\n        const def = this.getDefinition(context.last);\n        if (!def) {\n            return false;\n        }\n        return def.allowAttributes.includes(attributeName);\n    }\n    /**\n     * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n     *\n     * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n     *\n     * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n     * will be valid.\n     *\n     * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n     * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n     *\n     * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n     * element to which the `elementToMerge` will be merged.\n     * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n     * @returns {Boolean}\n     */\n    checkMerge(positionOrBaseElement, elementToMerge) {\n        if (positionOrBaseElement instanceof Position) {\n            const nodeBefore = positionOrBaseElement.nodeBefore;\n            const nodeAfter = positionOrBaseElement.nodeAfter;\n            if (!(nodeBefore instanceof Element)) {\n                /**\n                 * The node before the merge position must be an element.\n                 *\n                 * @error schema-check-merge-no-element-before\n                 */\n                throw new CKEditorError('schema-check-merge-no-element-before', this);\n            }\n            if (!(nodeAfter instanceof Element)) {\n                /**\n                 * The node after the merge position must be an element.\n                 *\n                 * @error schema-check-merge-no-element-after\n                 */\n                throw new CKEditorError('schema-check-merge-no-element-after', this);\n            }\n            return this.checkMerge(nodeBefore, nodeAfter);\n        }\n        for (const child of elementToMerge.getChildren()) {\n            if (!this.checkChild(positionOrBaseElement, child)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Allows registering a callback to the {@link #checkChild} method calls.\n     *\n     * Callbacks allow you to implement rules which are not otherwise possible to achieve\n     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n     * For example, by using this method you can disallow elements in specific contexts.\n     *\n     * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n     * you can use that event instead.\n     *\n     * Example:\n     *\n     *\t\t// Disallow heading1 directly inside a blockQuote.\n     *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n     *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n     *\t\t\t\treturn false;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Which translates to:\n     *\n     *\t\tschema.on( 'checkChild', ( evt, args ) => {\n     *\t\t\tconst context = args[ 0 ];\n     *\t\t\tconst childDefinition = args[ 1 ];\n     *\n     *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n     *\t\t\t\t// Prevent next listeners from being called.\n     *\t\t\t\tevt.stop();\n     *\t\t\t\t// Set the checkChild()'s return value.\n     *\t\t\t\tevt.return = false;\n     *\t\t\t}\n     *\t\t}, { priority: 'high' } );\n     *\n     * @param {Function} callback The callback to be called. It is called with two parameters:\n     * {@link module:engine/model/schema~SchemaContext} (context) instance and\n     * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n     * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n     * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n     */\n    addChildCheck(callback) {\n        this.on('checkChild', (evt, [ctx, childDef]) => {\n            // checkChild() was called with a non-registered child.\n            // In 99% cases such check should return false, so not to overcomplicate all callbacks\n            // don't even execute them.\n            if (!childDef) {\n                return;\n            }\n            const retValue = callback(ctx, childDef);\n            if (typeof retValue == 'boolean') {\n                evt.stop();\n                evt.return = retValue;\n            }\n        }, { priority: 'high' });\n    }\n    /**\n     * Allows registering a callback to the {@link #checkAttribute} method calls.\n     *\n     * Callbacks allow you to implement rules which are not otherwise possible to achieve\n     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n     * For example, by using this method you can disallow attribute if node to which it is applied\n     * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n     *\n     * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n     * you can use that event instead.\n     *\n     * Example:\n     *\n     *\t\t// Disallow bold on $text inside heading1.\n     *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n     *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n     *\t\t\t\treturn false;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Which translates to:\n     *\n     *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n     *\t\t\tconst context = args[ 0 ];\n     *\t\t\tconst attributeName = args[ 1 ];\n     *\n     *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n     *\t\t\t\t// Prevent next listeners from being called.\n     *\t\t\t\tevt.stop();\n     *\t\t\t\t// Set the checkAttribute()'s return value.\n     *\t\t\t\tevt.return = false;\n     *\t\t\t}\n     *\t\t}, { priority: 'high' } );\n     *\n     * @param {Function} callback The callback to be called. It is called with two parameters:\n     * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n     * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n     * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n     */\n    addAttributeCheck(callback) {\n        this.on('checkAttribute', (evt, [ctx, attributeName]) => {\n            const retValue = callback(ctx, attributeName);\n            if (typeof retValue == 'boolean') {\n                evt.stop();\n                evt.return = retValue;\n            }\n        }, { priority: 'high' });\n    }\n    /**\n     * This method allows assigning additional metadata to the model attributes. For example,\n     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n     * used to mark formatting attributes (like `bold` or `italic`).\n     *\n     *\t\t// Mark bold as a formatting attribute.\n     *\t\tschema.setAttributeProperties( 'bold', {\n     *\t\t\tisFormatting: true\n     *\t\t} );\n     *\n     *\t\t// Override code not to be considered a formatting markup.\n     *\t\tschema.setAttributeProperties( 'code', {\n     *\t\t\tisFormatting: false\n     *\t\t} );\n     *\n     * Properties are not limited to members defined in the\n     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\tcustomProperty: 'value'\n     *\t\t} );\n     *\n     * Subsequent calls with the same attribute will extend its custom properties:\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\tone: 1\n     *\t\t} );\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\ttwo: 2\n     *\t\t} );\n     *\n     *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n     *\t\t// Logs: { one: 1, two: 2 }\n     *\n     * @param {String} attributeName A name of the attribute to receive the properties.\n     * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n     */\n    setAttributeProperties(attributeName, properties) {\n        this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);\n    }\n    /**\n     * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n     *\n     * @param {String} attributeName A name of the attribute.\n     * @returns {module:engine/model/schema~AttributeProperties}\n     */\n    getAttributeProperties(attributeName) {\n        return this._attributeProperties[attributeName] || {};\n    }\n    /**\n     * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n     * selection/range/position or the root otherwise.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n     * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n     * The selection/range/position to check.\n     * @returns {module:engine/model/element~Element} The lowest limit element containing\n     * the entire `selectionOrRangeOrPosition`.\n     */\n    getLimitElement(selectionOrRangeOrPosition) {\n        let element;\n        if (selectionOrRangeOrPosition instanceof Position) {\n            element = selectionOrRangeOrPosition.parent;\n        }\n        else {\n            const ranges = selectionOrRangeOrPosition instanceof Range ?\n                [selectionOrRangeOrPosition] :\n                Array.from(selectionOrRangeOrPosition.getRanges());\n            // Find the common ancestor for all selection's ranges.\n            element = ranges\n                .reduce((element, range) => {\n                const rangeCommonAncestor = range.getCommonAncestor();\n                if (!element) {\n                    return rangeCommonAncestor;\n                }\n                return element.getCommonAncestor(rangeCommonAncestor, { includeSelf: true });\n            }, null);\n        }\n        while (!this.isLimit(element)) {\n            if (element.parent) {\n                element = element.parent;\n            }\n            else {\n                break;\n            }\n        }\n        return element;\n    }\n    /**\n     * Checks whether the attribute is allowed in selection:\n     *\n     * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n     * * if the selection is collapsed, then checks if on the selection position there's a text with the\n     * specified attribute allowed.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * Selection which will be checked.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Boolean}\n     */\n    checkAttributeInSelection(selection, attribute) {\n        if (selection.isCollapsed) {\n            const firstPosition = selection.getFirstPosition();\n            const context = [\n                ...firstPosition.getAncestors(),\n                new Text('', selection.getAttributes())\n            ];\n            // Check whether schema allows for a text with the attribute in the selection.\n            return this.checkAttribute(context, attribute);\n        }\n        else {\n            const ranges = selection.getRanges();\n            // For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n            for (const range of ranges) {\n                for (const value of range) {\n                    if (this.checkAttribute(value.item, attribute)) {\n                        // If we found a node that is allowed to have the attribute, return true.\n                        return true;\n                    }\n                }\n            }\n        }\n        // If we haven't found such node, return false.\n        return false;\n    }\n    /**\n     * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n     *\n     * @param {Iterable.<module:engine/model/range~Range>} ranges Ranges to be validated.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n     */\n    *getValidRanges(ranges, attribute) {\n        ranges = convertToMinimalFlatRanges(ranges);\n        for (const range of ranges) {\n            yield* this._getValidRangesForRange(range, attribute);\n        }\n    }\n    /**\n     * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n     * nearest to that `position` and is a correct range for selection.\n     *\n     * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n     * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n     * the {@link module:engine/model/schema~Schema schema}.\n     *\n     * Direction of searching for the nearest correct selection range can be specified as:\n     *\n     * * `both` - searching will be performed in both ways,\n     * * `forward` - searching will be performed only forward,\n     * * `backward` - searching will be performed only backward.\n     *\n     * When valid selection range cannot be found, `null` is returned.\n     *\n     * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n     * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n     * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n     */\n    getNearestSelectionRange(position, direction = 'both') {\n        // Return collapsed range if provided position is valid.\n        if (this.checkChild(position, '$text')) {\n            return new Range(position);\n        }\n        let backwardWalker, forwardWalker;\n        // Never leave a limit element.\n        const limitElement = position.getAncestors().reverse().find(item => this.isLimit(item)) ||\n            position.root;\n        if (direction == 'both' || direction == 'backward') {\n            backwardWalker = new TreeWalker({\n                boundaries: Range._createIn(limitElement),\n                startPosition: position,\n                direction: 'backward'\n            });\n        }\n        if (direction == 'both' || direction == 'forward') {\n            forwardWalker = new TreeWalker({\n                boundaries: Range._createIn(limitElement),\n                startPosition: position\n            });\n        }\n        for (const data of combineWalkers(backwardWalker, forwardWalker)) {\n            const type = (data.walker == backwardWalker ? 'elementEnd' : 'elementStart');\n            const value = data.value;\n            if (value.type == type && this.isObject(value.item)) {\n                return Range._createOn(value.item);\n            }\n            if (this.checkChild(value.nextPosition, '$text')) {\n                return new Range(value.nextPosition);\n            }\n        }\n        return null;\n    }\n    /**\n     * Tries to find position ancestors that allow to insert a given node.\n     * It starts searching from the given position and goes node by node to the top of the model tree\n     * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n     * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n     *\n     * @param {module:engine/model/position~Position} position The position that the search will start from.\n     * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n     * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n     */\n    findAllowedParent(position, node) {\n        let parent = position.parent;\n        while (parent) {\n            if (this.checkChild(parent, node)) {\n                return parent;\n            }\n            // Do not split limit elements.\n            if (this.isLimit(parent)) {\n                return null;\n            }\n            parent = parent.parent;\n        }\n        return null;\n    }\n    /**\n     * Sets attributes allowed by the schema on a given node.\n     *\n     * @param {module:engine/model/node~Node} node A node to set attributes on.\n     * @param {Object} attributes Attributes keys and values.\n     * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n     */\n    setAllowedAttributes(node, attributes, writer) {\n        const model = writer.model;\n        for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n            if (model.schema.checkAttribute(node, attributeName)) {\n                writer.setAttribute(attributeName, attributeValue, node);\n            }\n        }\n    }\n    /**\n     * Removes attributes disallowed by the schema.\n     *\n     * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n     * @param {module:engine/model/writer~Writer} writer\n     */\n    removeDisallowedAttributes(nodes, writer) {\n        for (const node of nodes) {\n            // When node is a `Text` it has no children, so just filter it out.\n            if (node.is('$text')) {\n                removeDisallowedAttributeFromNode(this, node, writer);\n            }\n            // In a case of `Element` iterates through positions between nodes inside this element\n            // and filter out node before the current position, or position parent when position\n            // is at start of an element. Using positions prevent from omitting merged nodes\n            // see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n            else {\n                const rangeInNode = Range._createIn(node);\n                const positionsInRange = rangeInNode.getPositions();\n                for (const position of positionsInRange) {\n                    const item = position.nodeBefore || position.parent;\n                    removeDisallowedAttributeFromNode(this, item, writer);\n                }\n            }\n        }\n    }\n    /**\n     * Gets attributes of a node that have a given property.\n     *\n     * @param {module:engine/model/node~Node} node Node to get attributes from.\n     * @param {String} propertyName Name of the property that attribute must have to return it.\n     * @param {Boolean|Symbol|String|Number|Object|null|undefined} propertyValue Desired value of the property that we want to check.\n     * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will\n     * return attributes which given property's value is equal to this parameter.\n     * @returns {Object} Object with attributes' names as key and attributes' values as value.\n     */\n    getAttributesWithProperty(node, propertyName, propertyValue) {\n        const attributes = {};\n        for (const [attributeName, attributeValue] of node.getAttributes()) {\n            const attributeProperties = this.getAttributeProperties(attributeName);\n            if (attributeProperties[propertyName] === undefined) {\n                continue;\n            }\n            if (propertyValue === undefined || propertyValue === attributeProperties[propertyName]) {\n                attributes[attributeName] = attributeValue;\n            }\n        }\n        return attributes;\n    }\n    /**\n     * Creates an instance of the schema context.\n     *\n     * @param {module:engine/model/schema~SchemaContextDefinition} context\n     * @returns {module:engine/model/schema~SchemaContext}\n     */\n    createContext(context) {\n        return new SchemaContext(context);\n    }\n    /**\n     * @private\n     */\n    _clearCache() {\n        this._compiledDefinitions = null;\n    }\n    /**\n     * @private\n     */\n    _compile() {\n        const compiledDefinitions = {};\n        const sourceRules = this._sourceDefinitions;\n        const itemNames = Object.keys(sourceRules);\n        for (const itemName of itemNames) {\n            compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);\n        }\n        for (const itemName of itemNames) {\n            compileAllowChildren(compiledDefinitions, itemName);\n        }\n        for (const itemName of itemNames) {\n            compileAllowContentOf(compiledDefinitions, itemName);\n        }\n        for (const itemName of itemNames) {\n            compileAllowWhere(compiledDefinitions, itemName);\n        }\n        for (const itemName of itemNames) {\n            compileAllowAttributesOf(compiledDefinitions, itemName);\n            compileInheritPropertiesFrom(compiledDefinitions, itemName);\n        }\n        for (const itemName of itemNames) {\n            cleanUpAllowIn(compiledDefinitions, itemName);\n            setupAllowChildren(compiledDefinitions, itemName);\n            cleanUpAllowAttributes(compiledDefinitions, itemName);\n        }\n        this._compiledDefinitions = compiledDefinitions;\n    }\n    /**\n     * @private\n     * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n     * @param {module:engine/model/schema~SchemaContext} context\n     * @param {Number} contextItemIndex\n     */\n    _checkContextMatch(def, context, contextItemIndex = context.length - 1) {\n        const contextItem = context.getItem(contextItemIndex);\n        if (def.allowIn.includes(contextItem.name)) {\n            if (contextItemIndex == 0) {\n                return true;\n            }\n            else {\n                const parentRule = this.getDefinition(contextItem);\n                return this._checkContextMatch(parentRule, context, contextItemIndex - 1);\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n     * inside the given range on which the attribute can be applied.\n     *\n     * This is a helper function for {@link ~Schema#getValidRanges}.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range The range to process.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n     */\n    *_getValidRangesForRange(range, attribute) {\n        let start = range.start;\n        let end = range.start;\n        for (const item of range.getItems({ shallow: true })) {\n            if (item.is('element')) {\n                yield* this._getValidRangesForRange(Range._createIn(item), attribute);\n            }\n            if (!this.checkAttribute(item, attribute)) {\n                if (!start.isEqual(end)) {\n                    yield new Range(start, end);\n                }\n                start = Position._createAfter(item);\n            }\n            end = Position._createAfter(item);\n        }\n        if (!start.isEqual(end)) {\n            yield new Range(start, end);\n        }\n    }\n}\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n    /**\n     * Creates an instance of the context.\n     *\n     * @param {module:engine/model/schema~SchemaContextDefinition} context\n     */\n    constructor(context) {\n        if (context instanceof SchemaContext) {\n            return context;\n        }\n        let items;\n        if (typeof context == 'string') {\n            items = [context];\n        }\n        else if (!Array.isArray(context)) {\n            // `context` is item or position.\n            // Position#getAncestors() doesn't accept any parameters but it works just fine here.\n            items = context.getAncestors({ includeSelf: true });\n        }\n        else {\n            items = context;\n        }\n        this._items = items.map(mapContextItem);\n    }\n    /**\n     * The number of items.\n     *\n     * @type {Number}\n     */\n    get length() {\n        return this._items.length;\n    }\n    /**\n     * The last item (the lowest node).\n     *\n     * @type {module:engine/model/schema~SchemaContextItem}\n     */\n    get last() {\n        return this._items[this._items.length - 1];\n    }\n    /**\n     * Iterable interface.\n     *\n     * Iterates over all context items.\n     *\n     * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n     */\n    [Symbol.iterator]() {\n        return this._items[Symbol.iterator]();\n    }\n    /**\n     * Returns a new schema context instance with an additional item.\n     *\n     * Item can be added as:\n     *\n     * \t\tconst context = new SchemaContext( [ '$root' ] );\n     *\n     * \t\t// An element.\n     * \t\tconst fooElement = writer.createElement( 'fooElement' );\n     * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n     *\n     * \t\t// A text node.\n     * \t\tconst text = writer.createText( 'foobar' );\n     * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n     *\n     * \t\t// A string (element name).\n     * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n     *\n     * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n     * (without ancestors).\n     *\n     * @param {String|module:engine/model/node~Node} item An item that will be added\n     * to the current context.\n     * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n     */\n    push(item) {\n        const ctx = new SchemaContext([item]);\n        ctx._items = [...this._items, ...ctx._items];\n        return ctx;\n    }\n    /**\n     * Gets an item on the given index.\n     *\n     * @returns {module:engine/model/schema~SchemaContextItem}\n     */\n    getItem(index) {\n        return this._items[index];\n    }\n    /**\n     * Returns the names of items.\n     *\n     * @returns {Iterable.<String>}\n     */\n    *getNames() {\n        yield* this._items.map(item => item.name);\n    }\n    /**\n     * Checks whether the context ends with the given nodes.\n     *\n     *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n     *\n     *\t\tctx.endsWith( '$text' ); // -> true\n     *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n     *\t\tctx.endsWith( '$root' ); // -> false\n     *\t\tctx.endsWith( 'paragraph' ); // -> false\n     *\n     * @param {String} query\n     * @returns {Boolean}\n     */\n    endsWith(query) {\n        return Array.from(this.getNames()).join(' ').endsWith(query);\n    }\n    /**\n     * Checks whether the context starts with the given nodes.\n     *\n     *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n     *\n     *\t\tctx.endsWith( '$root' ); // -> true\n     *\t\tctx.endsWith( '$root paragraph' ); // -> true\n     *\t\tctx.endsWith( '$text' ); // -> false\n     *\t\tctx.endsWith( 'paragraph' ); // -> false\n     *\n     * @param {String} query\n     * @returns {Boolean}\n     */\n    startsWith(query) {\n        return Array.from(this.getNames()).join(' ').startsWith(query);\n    }\n}\nfunction compileBaseItemRule(sourceItemRules, itemName) {\n    const itemRule = {\n        name: itemName,\n        allowIn: [],\n        allowContentOf: [],\n        allowWhere: [],\n        allowAttributes: [],\n        allowAttributesOf: [],\n        allowChildren: [],\n        inheritTypesFrom: []\n    };\n    copyTypes(sourceItemRules, itemRule);\n    copyProperty(sourceItemRules, itemRule, 'allowIn');\n    copyProperty(sourceItemRules, itemRule, 'allowContentOf');\n    copyProperty(sourceItemRules, itemRule, 'allowWhere');\n    copyProperty(sourceItemRules, itemRule, 'allowAttributes');\n    copyProperty(sourceItemRules, itemRule, 'allowAttributesOf');\n    copyProperty(sourceItemRules, itemRule, 'allowChildren');\n    copyProperty(sourceItemRules, itemRule, 'inheritTypesFrom');\n    makeInheritAllWork(sourceItemRules, itemRule);\n    return itemRule;\n}\nfunction compileAllowChildren(compiledDefinitions, itemName) {\n    const item = compiledDefinitions[itemName];\n    for (const allowChildrenItem of item.allowChildren) {\n        const allowedChildren = compiledDefinitions[allowChildrenItem];\n        // The allowChildren property may point to an unregistered element.\n        if (!allowedChildren) {\n            continue;\n        }\n        allowedChildren.allowIn.push(itemName);\n    }\n    // The allowIn property already includes correct items, reset the allowChildren property\n    // to avoid duplicates later when setting up compilation results.\n    item.allowChildren.length = 0;\n}\nfunction compileAllowContentOf(compiledDefinitions, itemName) {\n    for (const allowContentOfItemName of compiledDefinitions[itemName].allowContentOf) {\n        // The allowContentOf property may point to an unregistered element.\n        if (compiledDefinitions[allowContentOfItemName]) {\n            const allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);\n            allowedChildren.forEach(allowedItem => {\n                allowedItem.allowIn.push(itemName);\n            });\n        }\n    }\n    delete compiledDefinitions[itemName].allowContentOf;\n}\nfunction compileAllowWhere(compiledDefinitions, itemName) {\n    for (const allowWhereItemName of compiledDefinitions[itemName].allowWhere) {\n        const inheritFrom = compiledDefinitions[allowWhereItemName];\n        // The allowWhere property may point to an unregistered element.\n        if (inheritFrom) {\n            const allowedIn = inheritFrom.allowIn;\n            compiledDefinitions[itemName].allowIn.push(...allowedIn);\n        }\n    }\n    delete compiledDefinitions[itemName].allowWhere;\n}\nfunction compileAllowAttributesOf(compiledDefinitions, itemName) {\n    for (const allowAttributeOfItem of compiledDefinitions[itemName].allowAttributesOf) {\n        const inheritFrom = compiledDefinitions[allowAttributeOfItem];\n        if (inheritFrom) {\n            const inheritAttributes = inheritFrom.allowAttributes;\n            compiledDefinitions[itemName].allowAttributes.push(...inheritAttributes);\n        }\n    }\n    delete compiledDefinitions[itemName].allowAttributesOf;\n}\nfunction compileInheritPropertiesFrom(compiledDefinitions, itemName) {\n    const item = compiledDefinitions[itemName];\n    for (const inheritPropertiesOfItem of item.inheritTypesFrom) {\n        const inheritFrom = compiledDefinitions[inheritPropertiesOfItem];\n        if (inheritFrom) {\n            const typeNames = Object.keys(inheritFrom).filter(name => name.startsWith('is'));\n            for (const name of typeNames) {\n                if (!(name in item)) {\n                    item[name] = inheritFrom[name];\n                }\n            }\n        }\n    }\n    delete item.inheritTypesFrom;\n}\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn(compiledDefinitions, itemName) {\n    const itemRule = compiledDefinitions[itemName];\n    const existingItems = itemRule.allowIn.filter(itemToCheck => compiledDefinitions[itemToCheck]);\n    itemRule.allowIn = Array.from(new Set(existingItems));\n}\n// Setup allowChildren items based on allowIn.\nfunction setupAllowChildren(compiledDefinitions, itemName) {\n    const itemRule = compiledDefinitions[itemName];\n    for (const allowedParentItemName of itemRule.allowIn) {\n        const allowedParentItem = compiledDefinitions[allowedParentItemName];\n        allowedParentItem.allowChildren.push(itemName);\n    }\n}\nfunction cleanUpAllowAttributes(compiledDefinitions, itemName) {\n    const itemRule = compiledDefinitions[itemName];\n    itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));\n}\nfunction copyTypes(sourceItemRules, itemRule) {\n    for (const sourceItemRule of sourceItemRules) {\n        const typeNames = Object.keys(sourceItemRule).filter(name => name.startsWith('is'));\n        for (const name of typeNames) {\n            itemRule[name] = !!sourceItemRule[name];\n        }\n    }\n}\nfunction copyProperty(sourceItemRules, itemRule, propertyName) {\n    for (const sourceItemRule of sourceItemRules) {\n        const value = sourceItemRule[propertyName];\n        if (typeof value == 'string') {\n            itemRule[propertyName].push(value);\n        }\n        else if (Array.isArray(value)) {\n            itemRule[propertyName].push(...value);\n        }\n    }\n}\nfunction makeInheritAllWork(sourceItemRules, itemRule) {\n    for (const sourceItemRule of sourceItemRules) {\n        const inheritFrom = sourceItemRule.inheritAllFrom;\n        if (inheritFrom) {\n            itemRule.allowContentOf.push(inheritFrom);\n            itemRule.allowWhere.push(inheritFrom);\n            itemRule.allowAttributesOf.push(inheritFrom);\n            itemRule.inheritTypesFrom.push(inheritFrom);\n        }\n    }\n}\nfunction getAllowedChildren(compiledDefinitions, itemName) {\n    const itemRule = compiledDefinitions[itemName];\n    return getValues(compiledDefinitions).filter(def => def.allowIn.includes(itemRule.name));\n}\nfunction getValues(obj) {\n    return Object.keys(obj).map(key => obj[key]);\n}\nfunction mapContextItem(ctxItem) {\n    if (typeof ctxItem == 'string' || ctxItem.is('documentFragment')) {\n        return {\n            name: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n            *getAttributeKeys() { },\n            getAttribute() { }\n        };\n    }\n    else {\n        return {\n            // '$text' means text nodes and text proxies.\n            name: ctxItem.is('element') ? ctxItem.name : '$text',\n            *getAttributeKeys() {\n                yield* ctxItem.getAttributeKeys();\n            },\n            getAttribute(key) {\n                return ctxItem.getAttribute(key);\n            }\n        };\n    }\n}\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers(backward, forward) {\n    let done = false;\n    while (!done) {\n        done = true;\n        if (backward) {\n            const step = backward.next();\n            if (!step.done) {\n                done = false;\n                yield {\n                    walker: backward,\n                    value: step.value\n                };\n            }\n        }\n        if (forward) {\n            const step = forward.next();\n            if (!step.done) {\n                done = false;\n                yield {\n                    walker: forward,\n                    value: step.value\n                };\n            }\n        }\n    }\n}\n// Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\nfunction* convertToMinimalFlatRanges(ranges) {\n    for (const range of ranges) {\n        yield* range.getMinimalFlatRanges();\n    }\n}\nfunction removeDisallowedAttributeFromNode(schema, node, writer) {\n    for (const attribute of node.getAttributeKeys()) {\n        if (!schema.checkAttribute(node, attribute)) {\n            writer.removeAttribute(attribute, node);\n        }\n    }\n}\n"],"mappings":"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lEX,QAAQ,GAAG,OAAO;IACtB;IACA;IAAA,KACK;MACDA,QAAQ,GAAGU,IAAI,CAACE,IAAI;IACxB;IACA,OAAO,IAAI,CAACL,cAAc,EAAE,CAACP,QAAQ,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIa,YAAY,CAACH,IAAI,EAAE;IACf,OAAO,CAAC,CAAC,IAAI,CAACZ,aAAa,CAACY,IAAI,CAAC;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,OAAO,CAACJ,IAAI,EAAE;IACV,MAAMK,GAAG,GAAG,IAAI,CAACjB,aAAa,CAACY,IAAI,CAAC;IACpC,OAAO,CAAC,EAAEK,GAAG,IAAIA,GAAG,CAACD,OAAO,CAAC;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,OAAO,CAACN,IAAI,EAAE;IACV,MAAMK,GAAG,GAAG,IAAI,CAACjB,aAAa,CAACY,IAAI,CAAC;IACpC,IAAI,CAACK,GAAG,EAAE;MACN,OAAO,KAAK;IAChB;IACA,OAAO,CAAC,EAAEA,GAAG,CAACC,OAAO,IAAID,GAAG,CAACE,QAAQ,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIA,QAAQ,CAACP,IAAI,EAAE;IACX,MAAMK,GAAG,GAAG,IAAI,CAACjB,aAAa,CAACY,IAAI,CAAC;IACpC,IAAI,CAACK,GAAG,EAAE;MACN,OAAO,KAAK;IAChB;IACA;IACA;IACA,OAAO,CAAC,EAAEA,GAAG,CAACE,QAAQ,IAAKF,GAAG,CAACC,OAAO,IAAID,GAAG,CAACG,YAAY,IAAIH,GAAG,CAACI,SAAU,CAAC;EACjF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQ,CAACV,IAAI,EAAE;IACX,MAAMK,GAAG,GAAG,IAAI,CAACjB,aAAa,CAACY,IAAI,CAAC;IACpC,OAAO,CAAC,EAAEK,GAAG,IAAIA,GAAG,CAACK,QAAQ,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,YAAY,CAACR,IAAI,EAAE;IACf,MAAMK,GAAG,GAAG,IAAI,CAACjB,aAAa,CAACY,IAAI,CAAC;IACpC,IAAI,CAACK,GAAG,EAAE;MACN,OAAO,KAAK;IAChB;IACA,OAAO,CAAC,EAAEA,GAAG,CAACG,YAAY,IAAIH,GAAG,CAACE,QAAQ,CAAC;EAC/C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,SAAS,CAACT,IAAI,EAAE;IACZ,MAAMK,GAAG,GAAG,IAAI,CAACjB,aAAa,CAACY,IAAI,CAAC;IACpC,IAAI,CAACK,GAAG,EAAE;MACN,OAAO,KAAK;IAChB;IACA,OAAO,CAAC,EAAEA,GAAG,CAACI,SAAS,IAAIJ,GAAG,CAACE,QAAQ,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,UAAU,CAACC,OAAO,EAAEP,GAAG,EAAE;IACrB;IACA,IAAI,CAACA,GAAG,EAAE;MACN,OAAO,KAAK;IAChB;IACA,OAAO,IAAI,CAACQ,kBAAkB,CAACR,GAAG,EAAEO,OAAO,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,cAAc,CAACF,OAAO,EAAEG,aAAa,EAAE;IACnC,MAAMV,GAAG,GAAG,IAAI,CAACjB,aAAa,CAACwB,OAAO,CAACI,IAAI,CAAC;IAC5C,IAAI,CAACX,GAAG,EA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"},"metadata":{},"sourceType":"module"}