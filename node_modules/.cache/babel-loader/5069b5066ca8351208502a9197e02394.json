{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/model/markercollection\n */\nimport TypeCheckable from './typecheckable';\nimport LiveRange from './liverange';\nimport EmitterMixin, { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.\n * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.\n *\n * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:\n * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since\n * the writer is the only proper way to change the data model it is not possible to change markers directly using this\n * collection. All markers created by the writer will be automatically added to this collection.\n *\n * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.\n *\n * @see module:engine/model/markercollection~Marker\n */\nexport default class MarkerCollection extends Emitter {\n  /**\n   * Creates a markers collection.\n   */\n  constructor() {\n    super();\n    /**\n     * Stores {@link ~Marker markers} added to the collection.\n     *\n     * @private\n     * @member {Map} #_markers\n     */\n    this._markers = new Map();\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link ~Marker markers} added to the collection.\n   *\n   * @returns {Iterator}\n   */\n  [Symbol.iterator]() {\n    return this._markers.values();\n  }\n  /**\n   * Checks if given {@link ~Marker marker} or marker name is in the collection.\n   *\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker or marker instance to check.\n   * @returns {Boolean} `true` if marker is in the collection, `false` otherwise.\n   */\n  has(markerOrName) {\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n    return this._markers.has(markerName);\n  }\n  /**\n   * Returns {@link ~Marker marker} with given `markerName`.\n   *\n   * @param {String} markerName Name of marker to get.\n   * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was\n   * not added to the collection.\n   */\n  get(markerName) {\n    return this._markers.get(markerName) || null;\n  }\n  /**\n   * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given\n   * {@link module:engine/model/range~Range range}.\n   *\n   * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in\n   * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired\n   * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}\n   * flag has changed.\n   *\n   * @internal\n   * @protected\n   * @fires module:engine/model/markercollection~MarkerCollection#event:update\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.\n   * @param {module:engine/model/range~Range} range Marker range.\n   * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.\n   * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline\n   * (is persisted in the editor's data).\n   * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.\n   */\n  _set(markerOrName, range) {\n    let managedUsingOperations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let affectsData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n    if (markerName.includes(',')) {\n      /**\n       * Marker name cannot contain the \",\" character.\n       *\n       * @error markercollection-incorrect-marker-name\n       */\n      throw new CKEditorError('markercollection-incorrect-marker-name', this);\n    }\n    const oldMarker = this._markers.get(markerName);\n    if (oldMarker) {\n      const oldMarkerData = oldMarker.getData();\n      const oldRange = oldMarker.getRange();\n      let hasChanged = false;\n      if (!oldRange.isEqual(range)) {\n        oldMarker._attachLiveRange(LiveRange.fromRange(range));\n        hasChanged = true;\n      }\n      if (managedUsingOperations != oldMarker.managedUsingOperations) {\n        oldMarker._managedUsingOperations = managedUsingOperations;\n        hasChanged = true;\n      }\n      if (typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData) {\n        oldMarker._affectsData = affectsData;\n        hasChanged = true;\n      }\n      if (hasChanged) {\n        this.fire(`update:${markerName}`, oldMarker, oldRange, range, oldMarkerData);\n      }\n      return oldMarker;\n    }\n    const liveRange = LiveRange.fromRange(range);\n    const marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);\n    this._markers.set(markerName, marker);\n    this.fire(`update:${markerName}`, marker, null, range, {\n      ...marker.getData(),\n      range: null\n    });\n    return marker;\n  }\n  /**\n   * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.\n   *\n   * @internal\n   * @protected\n   * @fires module:engine/model/markercollection~MarkerCollection#event:update\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Marker or name of a marker to remove.\n   * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.\n   */\n  _remove(markerOrName) {\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n    const oldMarker = this._markers.get(markerName);\n    if (oldMarker) {\n      this._markers.delete(markerName);\n      this.fire(`update:${markerName}`, oldMarker, oldMarker.getRange(), null, oldMarker.getData());\n      this._destroyMarker(oldMarker);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}\n   * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast\n   * conversion} for the marker.\n   *\n   * @internal\n   * @protected\n   * @fires module:engine/model/markercollection~MarkerCollection#event:update\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Marker or name of a marker to refresh.\n   */\n  _refresh(markerOrName) {\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n    const marker = this._markers.get(markerName);\n    if (!marker) {\n      /**\n       * Marker with provided name does not exists.\n       *\n       * @error markercollection-refresh-marker-not-exists\n       */\n      throw new CKEditorError('markercollection-refresh-marker-not-exists', this);\n    }\n    const range = marker.getRange();\n    this.fire(`update:${markerName}`, marker, range, range, marker.getData());\n  }\n  /**\n   * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.\n   *\n   * @param {module:engine/model/position~Position} position\n   * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n   */\n  *getMarkersAtPosition(position) {\n    for (const marker of this) {\n      if (marker.getRange().containsPosition(position)) {\n        yield marker;\n      }\n    }\n  }\n  /**\n   * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.\n   *\n   * @param {module:engine/model/range~Range} range\n   * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n   */\n  *getMarkersIntersectingRange(range) {\n    for (const marker of this) {\n      if (marker.getRange().getIntersection(range) !== null) {\n        yield marker;\n      }\n    }\n  }\n  /**\n   * Destroys marker collection and all markers inside it.\n   */\n  destroy() {\n    for (const marker of this._markers.values()) {\n      this._destroyMarker(marker);\n    }\n    this._markers = null;\n    this.stopListening();\n  }\n  /**\n   * Iterates over all markers that starts with given `prefix`.\n   *\n   *\t\tconst markerFooA = markersCollection.set( 'foo:a', rangeFooA );\n   *\t\tconst markerFooB = markersCollection.set( 'foo:b', rangeFooB );\n   *\t\tconst markerBarA = markersCollection.set( 'bar:a', rangeBarA );\n   *\t\tconst markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );\n   *\t\tArray.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]\n   *\t\tArray.from( markersCollection.getMarkersGroup( 'a' ) ); // []\n   *\n   * @param prefix\n   * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n   */\n  *getMarkersGroup(prefix) {\n    for (const marker of this._markers.values()) {\n      if (marker.name.startsWith(prefix + ':')) {\n        yield marker;\n      }\n    }\n  }\n  /**\n   * Destroys the marker.\n   *\n   * @private\n   * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.\n   */\n  _destroyMarker(marker) {\n    marker.stopListening();\n    marker._detachLiveRange();\n  }\n}\n/**\n * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked\n * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of\n * model document tree, markers are not stored directly in document tree but in\n * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving\n * additional meaning to the part of a model document between marker start and marker end.\n *\n * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is\n * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).\n * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that\n * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being\n * \"special\" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document\n * model, it starts being \"special\" and the marker is enlarged.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * Markers are built from a name and a range.\n *\n * Range of the marker is updated automatically when document changes, using\n * {@link module:engine/model/liverange~LiveRange live range} mechanism.\n *\n * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by\n * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating\n * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.\n * For instance: `model.markers.on( 'update:user', callback );` will be called whenever any `user:*` markers changes.\n *\n * There are two types of markers.\n *\n * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}\n * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used\n * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.\n *\n * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}\n * but changes in these markers is managed the same way all other changes in the model structure - using operations.\n * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.\n * This type of markers is useful for solutions like spell checking or comments.\n *\n * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}\n * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.\n *\n *\t\tmodel.change( ( writer ) => {\n * \t\t\tconst marker = writer.addMarker( name, { range, usingOperation: true } );\n *\n * \t\t\t// ...\n *\n * \t\t\twriter.removeMarker( marker );\n *\t\t} );\n *\n * See {@link module:engine/model/writer~Writer} to find more examples.\n *\n * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little\n * markers as possible and remove them as soon as they are not needed anymore.\n *\n * Markers can be downcasted and upcasted.\n *\n * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.\n * Use {@link module:engine/conversion/downcasthelpers downcast converters} or attach a custom converter to mentioned events.\n * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.\n * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcasthelpers upcast converters} or\n * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.\n *\n * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.\n */\nclass Marker extends EmitterMixin(TypeCheckable) {\n  /**\n   * Creates a marker instance.\n   *\n   * @param {String} name Marker name.\n   * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.\n   * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.\n   * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline\n   * (is persisted in the editor's data).\n   */\n  constructor(name, liveRange, managedUsingOperations, affectsData) {\n    super();\n    /**\n     * Marker's name.\n     *\n     * @readonly\n     * @type {String}\n     */\n    this.name = name;\n    /**\n     * Range marked by the marker.\n     *\n     * @protected\n     * @member {module:engine/model/liverange~LiveRange}\n     */\n    this._liveRange = this._attachLiveRange(liveRange);\n    /**\n     * Flag indicates if the marker is managed using operations or not.\n     *\n     * @private\n     * @member {Boolean}\n     */\n    this._managedUsingOperations = managedUsingOperations;\n    /**\n     * Specifies whether the marker affects the data produced by the data pipeline\n     * (is persisted in the editor's data).\n     *\n     * @private\n     * @member {Boolean}\n     */\n    this._affectsData = affectsData;\n  }\n  /**\n   * A value indicating if the marker is managed using operations.\n   * See {@link ~Marker marker class description} to learn more about marker types.\n   * See {@link module:engine/model/writer~Writer#addMarker}.\n   *\n   * @returns {Boolean}\n   */\n  get managedUsingOperations() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n    return this._managedUsingOperations;\n  }\n  /**\n   * A value indicating if the marker changes the data.\n   *\n   * @returns {Boolean}\n   */\n  get affectsData() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n    return this._affectsData;\n  }\n  /**\n   * Returns the marker data (properties defining the marker).\n   *\n   * @returns {module:engine/model/markercollection~MarkerData}\n   */\n  getData() {\n    return {\n      range: this.getRange(),\n      affectsData: this.affectsData,\n      managedUsingOperations: this.managedUsingOperations\n    };\n  }\n  /**\n   * Returns current marker start position.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n  getStart() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n    return this._liveRange.start.clone();\n  }\n  /**\n   * Returns current marker end position.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n  getEnd() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n    return this._liveRange.end.clone();\n  }\n  /**\n   * Returns a range that represents the current state of the marker.\n   *\n   * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a\n   * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only\n   * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}\n   * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every\n   * time there is a need to read marker properties. This will guarantee that the marker has not been removed and\n   * that it's data is up-to-date.\n   *\n   * @returns {module:engine/model/range~Range}\n   */\n  getRange() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n    return this._liveRange.toRange();\n  }\n  /**\n   * Binds new live range to the marker and detach the old one if is attached.\n   *\n   * @internal\n   * @protected\n   * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach\n   * @returns {module:engine/model/liverange~LiveRange} Attached live range.\n   */\n  _attachLiveRange(liveRange) {\n    if (this._liveRange) {\n      this._detachLiveRange();\n    }\n    // Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).\n    liveRange.delegate('change:range').to(this);\n    liveRange.delegate('change:content').to(this);\n    this._liveRange = liveRange;\n    return liveRange;\n  }\n  /**\n   * Unbinds and destroys currently attached live range.\n   *\n   * @internal\n   * @protected\n   */\n  _detachLiveRange() {\n    this._liveRange.stopDelegating('change:range', this);\n    this._liveRange.stopDelegating('change:content', this);\n    this._liveRange.detach();\n    this._liveRange = null;\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tmarker.is( 'marker' ); // -> true\n *\t\tmarker.is( 'model:marker' ); // -> true\n *\n *\t\tmarker.is( 'view:element' ); // -> false\n *\t\tmarker.is( 'documentSelection' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nMarker.prototype.is = function (type) {\n  return type === 'marker' || type === 'model:marker';\n};\n/**\n * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.\n *\n * @error marker-destroyed\n */","map":{"version":3,"names":["TypeCheckable","LiveRange","EmitterMixin","Emitter","CKEditorError","MarkerCollection","constructor","_markers","Map","Symbol","iterator","values","has","markerOrName","markerName","Marker","name","get","_set","range","managedUsingOperations","affectsData","includes","oldMarker","oldMarkerData","getData","oldRange","getRange","hasChanged","isEqual","_attachLiveRange","fromRange","_managedUsingOperations","_affectsData","fire","liveRange","marker","set","_remove","delete","_destroyMarker","_refresh","getMarkersAtPosition","position","containsPosition","getMarkersIntersectingRange","getIntersection","destroy","stopListening","getMarkersGroup","prefix","startsWith","_detachLiveRange","_liveRange","getStart","start","clone","getEnd","end","toRange","delegate","to","stopDelegating","detach","prototype","is","type"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/markercollection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/model/markercollection\n */\nimport TypeCheckable from './typecheckable';\nimport LiveRange from './liverange';\nimport EmitterMixin, { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.\n * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.\n *\n * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:\n * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since\n * the writer is the only proper way to change the data model it is not possible to change markers directly using this\n * collection. All markers created by the writer will be automatically added to this collection.\n *\n * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.\n *\n * @see module:engine/model/markercollection~Marker\n */\nexport default class MarkerCollection extends Emitter {\n    /**\n     * Creates a markers collection.\n     */\n    constructor() {\n        super();\n        /**\n         * Stores {@link ~Marker markers} added to the collection.\n         *\n         * @private\n         * @member {Map} #_markers\n         */\n        this._markers = new Map();\n    }\n    /**\n     * Iterable interface.\n     *\n     * Iterates over all {@link ~Marker markers} added to the collection.\n     *\n     * @returns {Iterator}\n     */\n    [Symbol.iterator]() {\n        return this._markers.values();\n    }\n    /**\n     * Checks if given {@link ~Marker marker} or marker name is in the collection.\n     *\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker or marker instance to check.\n     * @returns {Boolean} `true` if marker is in the collection, `false` otherwise.\n     */\n    has(markerOrName) {\n        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n        return this._markers.has(markerName);\n    }\n    /**\n     * Returns {@link ~Marker marker} with given `markerName`.\n     *\n     * @param {String} markerName Name of marker to get.\n     * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was\n     * not added to the collection.\n     */\n    get(markerName) {\n        return this._markers.get(markerName) || null;\n    }\n    /**\n     * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given\n     * {@link module:engine/model/range~Range range}.\n     *\n     * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in\n     * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired\n     * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}\n     * flag has changed.\n     *\n     * @internal\n     * @protected\n     * @fires module:engine/model/markercollection~MarkerCollection#event:update\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.\n     * @param {module:engine/model/range~Range} range Marker range.\n     * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.\n     * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline\n     * (is persisted in the editor's data).\n     * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.\n     */\n    _set(markerOrName, range, managedUsingOperations = false, affectsData = false) {\n        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n        if (markerName.includes(',')) {\n            /**\n             * Marker name cannot contain the \",\" character.\n             *\n             * @error markercollection-incorrect-marker-name\n             */\n            throw new CKEditorError('markercollection-incorrect-marker-name', this);\n        }\n        const oldMarker = this._markers.get(markerName);\n        if (oldMarker) {\n            const oldMarkerData = oldMarker.getData();\n            const oldRange = oldMarker.getRange();\n            let hasChanged = false;\n            if (!oldRange.isEqual(range)) {\n                oldMarker._attachLiveRange(LiveRange.fromRange(range));\n                hasChanged = true;\n            }\n            if (managedUsingOperations != oldMarker.managedUsingOperations) {\n                oldMarker._managedUsingOperations = managedUsingOperations;\n                hasChanged = true;\n            }\n            if (typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData) {\n                oldMarker._affectsData = affectsData;\n                hasChanged = true;\n            }\n            if (hasChanged) {\n                this.fire(`update:${markerName}`, oldMarker, oldRange, range, oldMarkerData);\n            }\n            return oldMarker;\n        }\n        const liveRange = LiveRange.fromRange(range);\n        const marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);\n        this._markers.set(markerName, marker);\n        this.fire(`update:${markerName}`, marker, null, range, { ...marker.getData(), range: null });\n        return marker;\n    }\n    /**\n     * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.\n     *\n     * @internal\n     * @protected\n     * @fires module:engine/model/markercollection~MarkerCollection#event:update\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Marker or name of a marker to remove.\n     * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.\n     */\n    _remove(markerOrName) {\n        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n        const oldMarker = this._markers.get(markerName);\n        if (oldMarker) {\n            this._markers.delete(markerName);\n            this.fire(`update:${markerName}`, oldMarker, oldMarker.getRange(), null, oldMarker.getData());\n            this._destroyMarker(oldMarker);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}\n     * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast\n     * conversion} for the marker.\n     *\n     * @internal\n     * @protected\n     * @fires module:engine/model/markercollection~MarkerCollection#event:update\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Marker or name of a marker to refresh.\n     */\n    _refresh(markerOrName) {\n        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n        const marker = this._markers.get(markerName);\n        if (!marker) {\n            /**\n             * Marker with provided name does not exists.\n             *\n             * @error markercollection-refresh-marker-not-exists\n             */\n            throw new CKEditorError('markercollection-refresh-marker-not-exists', this);\n        }\n        const range = marker.getRange();\n        this.fire(`update:${markerName}`, marker, range, range, marker.getData());\n    }\n    /**\n     * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.\n     *\n     * @param {module:engine/model/position~Position} position\n     * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n     */\n    *getMarkersAtPosition(position) {\n        for (const marker of this) {\n            if (marker.getRange().containsPosition(position)) {\n                yield marker;\n            }\n        }\n    }\n    /**\n     * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.\n     *\n     * @param {module:engine/model/range~Range} range\n     * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n     */\n    *getMarkersIntersectingRange(range) {\n        for (const marker of this) {\n            if (marker.getRange().getIntersection(range) !== null) {\n                yield marker;\n            }\n        }\n    }\n    /**\n     * Destroys marker collection and all markers inside it.\n     */\n    destroy() {\n        for (const marker of this._markers.values()) {\n            this._destroyMarker(marker);\n        }\n        this._markers = null;\n        this.stopListening();\n    }\n    /**\n     * Iterates over all markers that starts with given `prefix`.\n     *\n     *\t\tconst markerFooA = markersCollection.set( 'foo:a', rangeFooA );\n     *\t\tconst markerFooB = markersCollection.set( 'foo:b', rangeFooB );\n     *\t\tconst markerBarA = markersCollection.set( 'bar:a', rangeBarA );\n     *\t\tconst markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );\n     *\t\tArray.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]\n     *\t\tArray.from( markersCollection.getMarkersGroup( 'a' ) ); // []\n     *\n     * @param prefix\n     * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n     */\n    *getMarkersGroup(prefix) {\n        for (const marker of this._markers.values()) {\n            if (marker.name.startsWith(prefix + ':')) {\n                yield marker;\n            }\n        }\n    }\n    /**\n     * Destroys the marker.\n     *\n     * @private\n     * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.\n     */\n    _destroyMarker(marker) {\n        marker.stopListening();\n        marker._detachLiveRange();\n    }\n}\n/**\n * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked\n * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of\n * model document tree, markers are not stored directly in document tree but in\n * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving\n * additional meaning to the part of a model document between marker start and marker end.\n *\n * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is\n * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).\n * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that\n * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being\n * \"special\" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document\n * model, it starts being \"special\" and the marker is enlarged.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * Markers are built from a name and a range.\n *\n * Range of the marker is updated automatically when document changes, using\n * {@link module:engine/model/liverange~LiveRange live range} mechanism.\n *\n * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by\n * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating\n * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.\n * For instance: `model.markers.on( 'update:user', callback );` will be called whenever any `user:*` markers changes.\n *\n * There are two types of markers.\n *\n * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}\n * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used\n * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.\n *\n * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}\n * but changes in these markers is managed the same way all other changes in the model structure - using operations.\n * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.\n * This type of markers is useful for solutions like spell checking or comments.\n *\n * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}\n * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.\n *\n *\t\tmodel.change( ( writer ) => {\n * \t\t\tconst marker = writer.addMarker( name, { range, usingOperation: true } );\n *\n * \t\t\t// ...\n *\n * \t\t\twriter.removeMarker( marker );\n *\t\t} );\n *\n * See {@link module:engine/model/writer~Writer} to find more examples.\n *\n * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little\n * markers as possible and remove them as soon as they are not needed anymore.\n *\n * Markers can be downcasted and upcasted.\n *\n * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.\n * Use {@link module:engine/conversion/downcasthelpers downcast converters} or attach a custom converter to mentioned events.\n * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.\n * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcasthelpers upcast converters} or\n * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.\n *\n * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.\n */\nclass Marker extends EmitterMixin(TypeCheckable) {\n    /**\n     * Creates a marker instance.\n     *\n     * @param {String} name Marker name.\n     * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.\n     * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.\n     * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline\n     * (is persisted in the editor's data).\n     */\n    constructor(name, liveRange, managedUsingOperations, affectsData) {\n        super();\n        /**\n         * Marker's name.\n         *\n         * @readonly\n         * @type {String}\n         */\n        this.name = name;\n        /**\n         * Range marked by the marker.\n         *\n         * @protected\n         * @member {module:engine/model/liverange~LiveRange}\n         */\n        this._liveRange = this._attachLiveRange(liveRange);\n        /**\n         * Flag indicates if the marker is managed using operations or not.\n         *\n         * @private\n         * @member {Boolean}\n         */\n        this._managedUsingOperations = managedUsingOperations;\n        /**\n         * Specifies whether the marker affects the data produced by the data pipeline\n         * (is persisted in the editor's data).\n         *\n         * @private\n         * @member {Boolean}\n         */\n        this._affectsData = affectsData;\n    }\n    /**\n     * A value indicating if the marker is managed using operations.\n     * See {@link ~Marker marker class description} to learn more about marker types.\n     * See {@link module:engine/model/writer~Writer#addMarker}.\n     *\n     * @returns {Boolean}\n     */\n    get managedUsingOperations() {\n        if (!this._liveRange) {\n            throw new CKEditorError('marker-destroyed', this);\n        }\n        return this._managedUsingOperations;\n    }\n    /**\n     * A value indicating if the marker changes the data.\n     *\n     * @returns {Boolean}\n     */\n    get affectsData() {\n        if (!this._liveRange) {\n            throw new CKEditorError('marker-destroyed', this);\n        }\n        return this._affectsData;\n    }\n    /**\n     * Returns the marker data (properties defining the marker).\n     *\n     * @returns {module:engine/model/markercollection~MarkerData}\n     */\n    getData() {\n        return {\n            range: this.getRange(),\n            affectsData: this.affectsData,\n            managedUsingOperations: this.managedUsingOperations\n        };\n    }\n    /**\n     * Returns current marker start position.\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n    getStart() {\n        if (!this._liveRange) {\n            throw new CKEditorError('marker-destroyed', this);\n        }\n        return this._liveRange.start.clone();\n    }\n    /**\n     * Returns current marker end position.\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n    getEnd() {\n        if (!this._liveRange) {\n            throw new CKEditorError('marker-destroyed', this);\n        }\n        return this._liveRange.end.clone();\n    }\n    /**\n     * Returns a range that represents the current state of the marker.\n     *\n     * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a\n     * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only\n     * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}\n     * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every\n     * time there is a need to read marker properties. This will guarantee that the marker has not been removed and\n     * that it's data is up-to-date.\n     *\n     * @returns {module:engine/model/range~Range}\n     */\n    getRange() {\n        if (!this._liveRange) {\n            throw new CKEditorError('marker-destroyed', this);\n        }\n        return this._liveRange.toRange();\n    }\n    /**\n     * Binds new live range to the marker and detach the old one if is attached.\n     *\n     * @internal\n     * @protected\n     * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach\n     * @returns {module:engine/model/liverange~LiveRange} Attached live range.\n     */\n    _attachLiveRange(liveRange) {\n        if (this._liveRange) {\n            this._detachLiveRange();\n        }\n        // Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).\n        liveRange.delegate('change:range').to(this);\n        liveRange.delegate('change:content').to(this);\n        this._liveRange = liveRange;\n        return liveRange;\n    }\n    /**\n     * Unbinds and destroys currently attached live range.\n     *\n     * @internal\n     * @protected\n     */\n    _detachLiveRange() {\n        this._liveRange.stopDelegating('change:range', this);\n        this._liveRange.stopDelegating('change:content', this);\n        this._liveRange.detach();\n        this._liveRange = null;\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tmarker.is( 'marker' ); // -> true\n *\t\tmarker.is( 'model:marker' ); // -> true\n *\n *\t\tmarker.is( 'view:element' ); // -> false\n *\t\tmarker.is( 'documentSelection' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nMarker.prototype.is = function (type) {\n    return type === 'marker' || type === 'model:marker';\n};\n/**\n * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.\n *\n * @error marker-destroyed\n */\n"],"mappings":"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AAMiB,MAAM,IAAI,IAAI,EAAE;MACvB,IAAIA,MAAM,CAACT,QAAQ,EAAE,CAACmB,eAAe,CAAC3B,KAAK,CAAC,KAAK,IAAI,EAAE;QACnD,MAAMiB,MAAM;MAChB;IACJ;EACJ;EACA;AACJ;AACA;EACIW,OAAO,GAAG;IACN,KAAK,MAAMX,MAAM,IAAI,IAAI,CAAC7B,QAAQ,CAACI,MAAM,EAAE,EAAE;MACzC,IAAI,CAAC6B,cAAc,CAACJ,MAAM,CAAC;IAC/B;IACA,IAAI,CAAC7B,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACyC,aAAa,EAAE;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAACC,eAAe,CAACC,MAAM,EAAE;IACrB,KAAK,MAAMd,MAAM,IAAI,IAAI,CAAC7B,QAAQ,CAACI,MAAM,EAAE,EAAE;MACzC,IAAIyB,MAAM,CAACpB,IAAI,CAACmC,UAAU,CAACD,MAAM,GAAG,GAAG,CAAC,EAAE;QACtC,MAAMd,MAAM;MAChB;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACII,cAAc,CAACJ,MAAM,EAAE;IACnBA,MAAM,CAACY,aAAa,EAAE;IACtBZ,MAAM,CAACgB,gBAAgB,EAAE;EAC7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMrC,MAAM,SAASb,YAAY,CAACF,aAAa,CAAC,CAAC;EAC7C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,WAAW,CAACU,IAAI,EAAEmB,SAA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"},"metadata":{},"sourceType":"module"}