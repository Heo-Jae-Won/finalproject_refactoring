{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/utils\n */\nimport Node from '../node';\nimport Range from '../range';\nimport Text from '../text';\nimport TextProxy from '../textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n/**\n * Inserts given nodes at given position.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} normalizedNodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\nexport function _insert(position, nodes) {\n  const normalizedNodes = _normalizeNodes(nodes);\n  // We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n  const offset = normalizedNodes.reduce((sum, node) => sum + node.offsetSize, 0);\n  const parent = position.parent;\n  // Insertion might be in a text node, we should split it if that's the case.\n  _splitNodeAtPosition(position);\n  const index = position.index;\n  // Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n  // using basic `Element` API.\n  parent._insertChild(index, normalizedNodes);\n  // Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n  _mergeNodesAtIndex(parent, index + normalizedNodes.length);\n  _mergeNodesAtIndex(parent, index);\n  return new Range(position, position.getShiftedBy(offset));\n}\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\nexport function _remove(range) {\n  if (!range.isFlat) {\n    /**\n     * Trying to remove a range which starts and ends in different element.\n     *\n     * @error operation-utils-remove-range-not-flat\n     */\n    throw new CKEditorError('operation-utils-remove-range-not-flat', this);\n  }\n  const parent = range.start.parent;\n  // Range may be inside text nodes, we have to split them if that's the case.\n  _splitNodeAtPosition(range.start);\n  _splitNodeAtPosition(range.end);\n  // Remove the text nodes using basic `Element` API.\n  const removed = parent._removeChildren(range.start.index, range.end.index - range.start.index);\n  // Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n  // touching at the position equal to the removed range beginning. We check merging possibility there.\n  _mergeNodesAtIndex(parent, range.start.index);\n  return removed;\n}\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\nexport function _move(sourceRange, targetPosition) {\n  if (!sourceRange.isFlat) {\n    /**\n     * Trying to move a range which starts and ends in different element.\n     *\n     * @error operation-utils-move-range-not-flat\n     */\n    throw new CKEditorError('operation-utils-move-range-not-flat', this);\n  }\n  const nodes = _remove(sourceRange);\n  // We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n  // that change might have an impact on `targetPosition`.\n  targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);\n  return _insert(targetPosition, nodes);\n}\n/**\n * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\nexport function _setAttribute(range, key, value) {\n  // Range might start or end in text nodes, so we have to split them.\n  _splitNodeAtPosition(range.start);\n  _splitNodeAtPosition(range.end);\n  // Iterate over all items in the range.\n  for (const item of range.getItems({\n    shallow: true\n  })) {\n    // Iterator will return `TextProxy` instances but we know that those text proxies will\n    // always represent full text nodes (this is guaranteed thanks to splitting we did before).\n    // So, we can operate on those text proxies' text nodes.\n    const node = item.is('$textProxy') ? item.textNode : item;\n    if (value !== null) {\n      node._setAttribute(key, value);\n    } else {\n      node._removeAttribute(key);\n    }\n    // After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n    _mergeNodesAtIndex(node.parent, node.index);\n  }\n  // Try to merge last changed node with it's previous sibling (not covered by the loop above).\n  _mergeNodesAtIndex(range.end.parent, range.end.index);\n}\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\nexport function _normalizeNodes(nodes) {\n  const normalized = [];\n  function convert(nodes) {\n    if (typeof nodes == 'string') {\n      normalized.push(new Text(nodes));\n    } else if (nodes instanceof TextProxy) {\n      normalized.push(new Text(nodes.data, nodes.getAttributes()));\n    } else if (nodes instanceof Node) {\n      normalized.push(nodes);\n    } else if (isIterable(nodes)) {\n      for (const node of nodes) {\n        convert(node);\n      }\n    }\n    // Skip unrecognized type.\n  }\n\n  convert(nodes);\n  // Merge text nodes.\n  for (let i = 1; i < normalized.length; i++) {\n    const node = normalized[i];\n    const prev = normalized[i - 1];\n    if (node instanceof Text && prev instanceof Text && _haveSameAttributes(node, prev)) {\n      // Doing this instead changing `prev.data` because `data` is readonly.\n      normalized.splice(i - 1, 2, new Text(prev.data + node.data, prev.getAttributes()));\n      i--;\n    }\n  }\n  return normalized;\n}\n// Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n// merges them into one node if they have same attributes.\n//\n// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n//\n// @private\n// @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n// @param {Number} index Index between nodes to merge.\nfunction _mergeNodesAtIndex(element, index) {\n  const nodeBefore = element.getChild(index - 1);\n  const nodeAfter = element.getChild(index);\n  // Check if both of those nodes are text objects with same attributes.\n  if (nodeBefore && nodeAfter && nodeBefore.is('$text') && nodeAfter.is('$text') && _haveSameAttributes(nodeBefore, nodeAfter)) {\n    // Append text of text node after index to the before one.\n    const mergedNode = new Text(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());\n    // Remove separate text nodes.\n    element._removeChildren(index - 1, 2);\n    // Insert merged text node.\n    element._insertChild(index - 1, mergedNode);\n  }\n}\n// Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n// containing a part of original text node.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position at which node should be split.\nfunction _splitNodeAtPosition(position) {\n  const textNode = position.textNode;\n  const element = position.parent;\n  if (textNode) {\n    const offsetDiff = position.offset - textNode.startOffset;\n    const index = textNode.index;\n    element._removeChildren(index, 1);\n    const firstPart = new Text(textNode.data.substr(0, offsetDiff), textNode.getAttributes());\n    const secondPart = new Text(textNode.data.substr(offsetDiff), textNode.getAttributes());\n    element._insertChild(index, [firstPart, secondPart]);\n  }\n}\n// Checks whether two given nodes have same attributes.\n//\n// @private\n// @param {module:engine/model/node~Node} nodeA Node to check.\n// @param {module:engine/model/node~Node} nodeB Node to check.\n// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\nfunction _haveSameAttributes(nodeA, nodeB) {\n  const iteratorA = nodeA.getAttributes();\n  const iteratorB = nodeB.getAttributes();\n  for (const attr of iteratorA) {\n    if (attr[1] !== nodeB.getAttribute(attr[0])) {\n      return false;\n    }\n    iteratorB.next();\n  }\n  return iteratorB.next().done;\n}","map":{"version":3,"names":["Node","Range","Text","TextProxy","CKEditorError","isIterable","_insert","position","nodes","normalizedNodes","_normalizeNodes","offset","reduce","sum","node","offsetSize","parent","_splitNodeAtPosition","index","_insertChild","_mergeNodesAtIndex","length","getShiftedBy","_remove","range","isFlat","start","end","removed","_removeChildren","_move","sourceRange","targetPosition","_getTransformedByDeletion","_setAttribute","key","value","item","getItems","shallow","is","textNode","_removeAttribute","normalized","convert","push","data","getAttributes","i","prev","_haveSameAttributes","splice","element","nodeBefore","getChild","nodeAfter","mergedNode","offsetDiff","startOffset","firstPart","substr","secondPart","nodeA","nodeB","iteratorA","iteratorB","attr","getAttribute","next","done"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/operation/utils\n */\nimport Node from '../node';\nimport Range from '../range';\nimport Text from '../text';\nimport TextProxy from '../textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n/**\n * Inserts given nodes at given position.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} normalizedNodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\nexport function _insert(position, nodes) {\n    const normalizedNodes = _normalizeNodes(nodes);\n    // We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n    const offset = normalizedNodes.reduce((sum, node) => sum + node.offsetSize, 0);\n    const parent = position.parent;\n    // Insertion might be in a text node, we should split it if that's the case.\n    _splitNodeAtPosition(position);\n    const index = position.index;\n    // Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n    // using basic `Element` API.\n    parent._insertChild(index, normalizedNodes);\n    // Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n    _mergeNodesAtIndex(parent, index + normalizedNodes.length);\n    _mergeNodesAtIndex(parent, index);\n    return new Range(position, position.getShiftedBy(offset));\n}\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\nexport function _remove(range) {\n    if (!range.isFlat) {\n        /**\n         * Trying to remove a range which starts and ends in different element.\n         *\n         * @error operation-utils-remove-range-not-flat\n         */\n        throw new CKEditorError('operation-utils-remove-range-not-flat', this);\n    }\n    const parent = range.start.parent;\n    // Range may be inside text nodes, we have to split them if that's the case.\n    _splitNodeAtPosition(range.start);\n    _splitNodeAtPosition(range.end);\n    // Remove the text nodes using basic `Element` API.\n    const removed = parent._removeChildren(range.start.index, range.end.index - range.start.index);\n    // Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n    // touching at the position equal to the removed range beginning. We check merging possibility there.\n    _mergeNodesAtIndex(parent, range.start.index);\n    return removed;\n}\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\nexport function _move(sourceRange, targetPosition) {\n    if (!sourceRange.isFlat) {\n        /**\n         * Trying to move a range which starts and ends in different element.\n         *\n         * @error operation-utils-move-range-not-flat\n         */\n        throw new CKEditorError('operation-utils-move-range-not-flat', this);\n    }\n    const nodes = _remove(sourceRange);\n    // We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n    // that change might have an impact on `targetPosition`.\n    targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);\n    return _insert(targetPosition, nodes);\n}\n/**\n * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.\n *\n * @internal\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\nexport function _setAttribute(range, key, value) {\n    // Range might start or end in text nodes, so we have to split them.\n    _splitNodeAtPosition(range.start);\n    _splitNodeAtPosition(range.end);\n    // Iterate over all items in the range.\n    for (const item of range.getItems({ shallow: true })) {\n        // Iterator will return `TextProxy` instances but we know that those text proxies will\n        // always represent full text nodes (this is guaranteed thanks to splitting we did before).\n        // So, we can operate on those text proxies' text nodes.\n        const node = item.is('$textProxy') ? item.textNode : item;\n        if (value !== null) {\n            node._setAttribute(key, value);\n        }\n        else {\n            node._removeAttribute(key);\n        }\n        // After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n        _mergeNodesAtIndex(node.parent, node.index);\n    }\n    // Try to merge last changed node with it's previous sibling (not covered by the loop above).\n    _mergeNodesAtIndex(range.end.parent, range.end.index);\n}\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\nexport function _normalizeNodes(nodes) {\n    const normalized = [];\n    function convert(nodes) {\n        if (typeof nodes == 'string') {\n            normalized.push(new Text(nodes));\n        }\n        else if (nodes instanceof TextProxy) {\n            normalized.push(new Text(nodes.data, nodes.getAttributes()));\n        }\n        else if (nodes instanceof Node) {\n            normalized.push(nodes);\n        }\n        else if (isIterable(nodes)) {\n            for (const node of nodes) {\n                convert(node);\n            }\n        }\n        // Skip unrecognized type.\n    }\n    convert(nodes);\n    // Merge text nodes.\n    for (let i = 1; i < normalized.length; i++) {\n        const node = normalized[i];\n        const prev = normalized[i - 1];\n        if (node instanceof Text && prev instanceof Text && _haveSameAttributes(node, prev)) {\n            // Doing this instead changing `prev.data` because `data` is readonly.\n            normalized.splice(i - 1, 2, new Text(prev.data + node.data, prev.getAttributes()));\n            i--;\n        }\n    }\n    return normalized;\n}\n// Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n// merges them into one node if they have same attributes.\n//\n// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n//\n// @private\n// @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n// @param {Number} index Index between nodes to merge.\nfunction _mergeNodesAtIndex(element, index) {\n    const nodeBefore = element.getChild(index - 1);\n    const nodeAfter = element.getChild(index);\n    // Check if both of those nodes are text objects with same attributes.\n    if (nodeBefore && nodeAfter && nodeBefore.is('$text') && nodeAfter.is('$text') && _haveSameAttributes(nodeBefore, nodeAfter)) {\n        // Append text of text node after index to the before one.\n        const mergedNode = new Text(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());\n        // Remove separate text nodes.\n        element._removeChildren(index - 1, 2);\n        // Insert merged text node.\n        element._insertChild(index - 1, mergedNode);\n    }\n}\n// Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n// containing a part of original text node.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position at which node should be split.\nfunction _splitNodeAtPosition(position) {\n    const textNode = position.textNode;\n    const element = position.parent;\n    if (textNode) {\n        const offsetDiff = position.offset - textNode.startOffset;\n        const index = textNode.index;\n        element._removeChildren(index, 1);\n        const firstPart = new Text(textNode.data.substr(0, offsetDiff), textNode.getAttributes());\n        const secondPart = new Text(textNode.data.substr(offsetDiff), textNode.getAttributes());\n        element._insertChild(index, [firstPart, secondPart]);\n    }\n}\n// Checks whether two given nodes have same attributes.\n//\n// @private\n// @param {module:engine/model/node~Node} nodeA Node to check.\n// @param {module:engine/model/node~Node} nodeB Node to check.\n// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\nfunction _haveSameAttributes(nodeA, nodeB) {\n    const iteratorA = nodeA.getAttributes();\n    const iteratorB = nodeB.getAttributes();\n    for (const attr of iteratorA) {\n        if (attr[1] !== nodeB.getAttribute(attr[0])) {\n            return false;\n        }\n        iteratorB.next();\n    }\n    return iteratorB.next().done;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}