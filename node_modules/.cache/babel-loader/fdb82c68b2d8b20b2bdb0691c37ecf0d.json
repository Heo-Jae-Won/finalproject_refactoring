{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/modifyselection\n */\nimport DocumentSelection from '../documentselection';\nimport Position from '../position';\nimport Range from '../range';\nimport TreeWalker from '../treewalker';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/src/unicode';\nconst wordBoundaryCharacters = ' ,.?!:;\"-()';\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n */\nexport default function modifySelection(model, selection) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const schema = model.schema;\n  const isForward = options.direction != 'backward';\n  const unit = options.unit ? options.unit : 'character';\n  const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;\n  const focus = selection.focus;\n  const walker = new TreeWalker({\n    boundaries: getSearchRange(focus, isForward),\n    singleCharacters: true,\n    direction: isForward ? 'forward' : 'backward'\n  });\n  const data = {\n    walker,\n    schema,\n    isForward,\n    unit,\n    treatEmojiAsSingleUnit\n  };\n  let next;\n  while (next = walker.next()) {\n    if (next.done) {\n      return;\n    }\n    const position = tryExtendingTo(data, next.value);\n    if (position) {\n      if (selection instanceof DocumentSelection) {\n        model.change(writer => {\n          writer.setSelectionFocus(position);\n        });\n      } else {\n        selection.setFocus(position);\n      }\n      return;\n    }\n  }\n}\n// Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema, treatEmojiAsSingleUnit }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\nfunction tryExtendingTo(data, value) {\n  const {\n    isForward,\n    walker,\n    unit,\n    schema,\n    treatEmojiAsSingleUnit\n  } = data;\n  const {\n    type,\n    item,\n    nextPosition\n  } = value;\n  // If found text, we can certainly put the focus in it. Let's just find a correct position\n  // based on the unit.\n  if (type == 'text') {\n    if (data.unit === 'word') {\n      return getCorrectWordBreakPosition(walker, isForward);\n    }\n    return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);\n  }\n  // Entering an element.\n  if (type == (isForward ? 'elementStart' : 'elementEnd')) {\n    // If it's a selectable, we can select it now.\n    if (schema.isSelectable(item)) {\n      return Position._createAt(item, isForward ? 'after' : 'before');\n    }\n    // If text allowed on this position, extend to this place.\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  }\n  // Leaving an element.\n  else {\n    // If leaving a limit element, stop.\n    if (schema.isLimit(item)) {\n      // NOTE: Fast-forward the walker until the end.\n      walker.skip(() => true);\n      return;\n    }\n    // If text allowed on this position, extend to this place.\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  }\n}\n// Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n// @param {Boolean} treatEmojiAsSingleUnit\nfunction getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {\n  const textNode = walker.position.textNode;\n  if (textNode) {\n    const data = textNode.data;\n    let offset = walker.position.offset - textNode.startOffset;\n    while (isInsideSurrogatePair(data, offset) || unit == 'character' && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {\n      walker.next();\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n  return walker.position;\n}\n// Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction getCorrectWordBreakPosition(walker, isForward) {\n  let textNode = walker.position.textNode;\n  if (textNode) {\n    let offset = walker.position.offset - textNode.startOffset;\n    while (!isAtWordBoundary(textNode.data, offset, isForward) && !isAtNodeBoundary(textNode, offset, isForward)) {\n      walker.next();\n      // Check of adjacent text nodes with different attributes (like BOLD).\n      // Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n      // should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n      const nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;\n      // Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n      if (nextNode && nextNode.is('$text')) {\n        // Check boundary char of an adjacent text node.\n        const boundaryChar = nextNode.data.charAt(isForward ? 0 : nextNode.data.length - 1);\n        // Go to the next node if the character at the boundary of that node belongs to the same word.\n        if (!wordBoundaryCharacters.includes(boundaryChar)) {\n          // If adjacent text node belongs to the same word go to it & reset values.\n          walker.next();\n          textNode = walker.position.textNode;\n        }\n      }\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n  return walker.position;\n}\nfunction getSearchRange(start, isForward) {\n  const root = start.root;\n  const searchEnd = Position._createAt(root, isForward ? 'end' : 0);\n  if (isForward) {\n    return new Range(start, searchEnd);\n  } else {\n    return new Range(searchEnd, start);\n  }\n}\n// Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtWordBoundary(data, offset, isForward) {\n  // The offset to check depends on direction.\n  const offsetToCheck = offset + (isForward ? 0 : -1);\n  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));\n}\n// Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtNodeBoundary(textNode, offset, isForward) {\n  return offset === (isForward ? textNode.endOffset : 0);\n}","map":{"version":3,"names":["DocumentSelection","Position","Range","TreeWalker","isInsideSurrogatePair","isInsideCombinedSymbol","isInsideEmojiSequence","wordBoundaryCharacters","modifySelection","model","selection","options","schema","isForward","direction","unit","treatEmojiAsSingleUnit","focus","walker","boundaries","getSearchRange","singleCharacters","data","next","done","position","tryExtendingTo","value","change","writer","setSelectionFocus","setFocus","type","item","nextPosition","getCorrectWordBreakPosition","getCorrectPosition","isSelectable","_createAt","checkChild","isLimit","skip","textNode","offset","startOffset","isAtWordBoundary","isAtNodeBoundary","nextNode","nodeAfter","nodeBefore","is","boundaryChar","charAt","length","includes","start","root","searchEnd","offsetToCheck","endOffset"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/modifyselection\n */\nimport DocumentSelection from '../documentselection';\nimport Position from '../position';\nimport Range from '../range';\nimport TreeWalker from '../treewalker';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/src/unicode';\nconst wordBoundaryCharacters = ' ,.?!:;\"-()';\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n */\nexport default function modifySelection(model, selection, options = {}) {\n    const schema = model.schema;\n    const isForward = options.direction != 'backward';\n    const unit = options.unit ? options.unit : 'character';\n    const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;\n    const focus = selection.focus;\n    const walker = new TreeWalker({\n        boundaries: getSearchRange(focus, isForward),\n        singleCharacters: true,\n        direction: isForward ? 'forward' : 'backward'\n    });\n    const data = { walker, schema, isForward, unit, treatEmojiAsSingleUnit };\n    let next;\n    while ((next = walker.next())) {\n        if (next.done) {\n            return;\n        }\n        const position = tryExtendingTo(data, next.value);\n        if (position) {\n            if (selection instanceof DocumentSelection) {\n                model.change(writer => {\n                    writer.setSelectionFocus(position);\n                });\n            }\n            else {\n                selection.setFocus(position);\n            }\n            return;\n        }\n    }\n}\n// Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema, treatEmojiAsSingleUnit }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\nfunction tryExtendingTo(data, value) {\n    const { isForward, walker, unit, schema, treatEmojiAsSingleUnit } = data;\n    const { type, item, nextPosition } = value;\n    // If found text, we can certainly put the focus in it. Let's just find a correct position\n    // based on the unit.\n    if (type == 'text') {\n        if (data.unit === 'word') {\n            return getCorrectWordBreakPosition(walker, isForward);\n        }\n        return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);\n    }\n    // Entering an element.\n    if (type == (isForward ? 'elementStart' : 'elementEnd')) {\n        // If it's a selectable, we can select it now.\n        if (schema.isSelectable(item)) {\n            return Position._createAt(item, isForward ? 'after' : 'before');\n        }\n        // If text allowed on this position, extend to this place.\n        if (schema.checkChild(nextPosition, '$text')) {\n            return nextPosition;\n        }\n    }\n    // Leaving an element.\n    else {\n        // If leaving a limit element, stop.\n        if (schema.isLimit(item)) {\n            // NOTE: Fast-forward the walker until the end.\n            walker.skip(() => true);\n            return;\n        }\n        // If text allowed on this position, extend to this place.\n        if (schema.checkChild(nextPosition, '$text')) {\n            return nextPosition;\n        }\n    }\n}\n// Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n// @param {Boolean} treatEmojiAsSingleUnit\nfunction getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {\n    const textNode = walker.position.textNode;\n    if (textNode) {\n        const data = textNode.data;\n        let offset = walker.position.offset - textNode.startOffset;\n        while (isInsideSurrogatePair(data, offset) ||\n            (unit == 'character' && isInsideCombinedSymbol(data, offset)) ||\n            (treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset))) {\n            walker.next();\n            offset = walker.position.offset - textNode.startOffset;\n        }\n    }\n    return walker.position;\n}\n// Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction getCorrectWordBreakPosition(walker, isForward) {\n    let textNode = walker.position.textNode;\n    if (textNode) {\n        let offset = walker.position.offset - textNode.startOffset;\n        while (!isAtWordBoundary(textNode.data, offset, isForward) && !isAtNodeBoundary(textNode, offset, isForward)) {\n            walker.next();\n            // Check of adjacent text nodes with different attributes (like BOLD).\n            // Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n            // should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n            const nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;\n            // Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n            if (nextNode && nextNode.is('$text')) {\n                // Check boundary char of an adjacent text node.\n                const boundaryChar = nextNode.data.charAt(isForward ? 0 : nextNode.data.length - 1);\n                // Go to the next node if the character at the boundary of that node belongs to the same word.\n                if (!wordBoundaryCharacters.includes(boundaryChar)) {\n                    // If adjacent text node belongs to the same word go to it & reset values.\n                    walker.next();\n                    textNode = walker.position.textNode;\n                }\n            }\n            offset = walker.position.offset - textNode.startOffset;\n        }\n    }\n    return walker.position;\n}\nfunction getSearchRange(start, isForward) {\n    const root = start.root;\n    const searchEnd = Position._createAt(root, isForward ? 'end' : 0);\n    if (isForward) {\n        return new Range(start, searchEnd);\n    }\n    else {\n        return new Range(searchEnd, start);\n    }\n}\n// Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtWordBoundary(data, offset, isForward) {\n    // The offset to check depends on direction.\n    const offsetToCheck = offset + (isForward ? 0 : -1);\n    return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));\n}\n// Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtNodeBoundary(textNode, offset, isForward) {\n    return offset === (isForward ? textNode.endOffset : 0);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}