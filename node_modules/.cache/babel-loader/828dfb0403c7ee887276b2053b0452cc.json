{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/findoptimalinsertionrange\n */\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n// Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n//\n// For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n// will be returned so that it is not split. If the selection is at the end of a paragraph,\n// the collapsed range after this paragraph will be returned.\n//\n// Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n// is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n// by the inserted widget block.\n//\n// **Note:** Use {@link module:widget/utils#findOptimalInsertionRange} instead of this function outside engine.\n// This function is only exposed to be used by {@link module:widget/utils#findOptimalInsertionRange findOptimalInsertionRange()}\n// in the `widget` package and inside the `engine` package.\n//\n// @private\n// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n// The selection based on which the insertion position should be calculated.\n// @param {module:engine/model/model~Model} model Model instance.\n// @param {'auto'|'before'|'after'} [place='auto'] The place where to look for optimal insertion range.\n// The default `auto` value will determine itself the best position for insertion.\n// The `before` value will try to find a position before selection.\n// The `after` value will try to find a position after selection.\n// @returns {module:engine/model/range~Range} The optimal range.\nexport function findOptimalInsertionRange(selection, model) {\n  let place = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'auto';\n  const selectedElement = selection.getSelectedElement();\n  if (selectedElement && model.schema.isObject(selectedElement) && !model.schema.isInline(selectedElement)) {\n    if (place == 'before' || place == 'after') {\n      return model.createRange(model.createPositionAt(selectedElement, place));\n    }\n    return model.createRangeOn(selectedElement);\n  }\n  const firstBlock = first(selection.getSelectedBlocks());\n  // There are no block elements within ancestors (in the current limit element).\n  if (!firstBlock) {\n    return model.createRange(selection.focus);\n  }\n  // If inserting into an empty block – return position in that block. It will get\n  // replaced with the image by insertContent(). #42.\n  if (firstBlock.isEmpty) {\n    return model.createRange(model.createPositionAt(firstBlock, 0));\n  }\n  const positionAfter = model.createPositionAfter(firstBlock);\n  // If selection is at the end of the block - return position after the block.\n  if (selection.focus.isTouching(positionAfter)) {\n    return model.createRange(positionAfter);\n  }\n  // Otherwise, return position before the block.\n  return model.createRange(model.createPositionBefore(firstBlock));\n}","map":{"version":3,"names":["first","findOptimalInsertionRange","selection","model","place","selectedElement","getSelectedElement","schema","isObject","isInline","createRange","createPositionAt","createRangeOn","firstBlock","getSelectedBlocks","focus","isEmpty","positionAfter","createPositionAfter","isTouching","createPositionBefore"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/findoptimalinsertionrange.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/findoptimalinsertionrange\n */\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n// Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n//\n// For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n// will be returned so that it is not split. If the selection is at the end of a paragraph,\n// the collapsed range after this paragraph will be returned.\n//\n// Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n// is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n// by the inserted widget block.\n//\n// **Note:** Use {@link module:widget/utils#findOptimalInsertionRange} instead of this function outside engine.\n// This function is only exposed to be used by {@link module:widget/utils#findOptimalInsertionRange findOptimalInsertionRange()}\n// in the `widget` package and inside the `engine` package.\n//\n// @private\n// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n// The selection based on which the insertion position should be calculated.\n// @param {module:engine/model/model~Model} model Model instance.\n// @param {'auto'|'before'|'after'} [place='auto'] The place where to look for optimal insertion range.\n// The default `auto` value will determine itself the best position for insertion.\n// The `before` value will try to find a position before selection.\n// The `after` value will try to find a position after selection.\n// @returns {module:engine/model/range~Range} The optimal range.\nexport function findOptimalInsertionRange(selection, model, place = 'auto') {\n    const selectedElement = selection.getSelectedElement();\n    if (selectedElement && model.schema.isObject(selectedElement) && !model.schema.isInline(selectedElement)) {\n        if (place == 'before' || place == 'after') {\n            return model.createRange(model.createPositionAt(selectedElement, place));\n        }\n        return model.createRangeOn(selectedElement);\n    }\n    const firstBlock = first(selection.getSelectedBlocks());\n    // There are no block elements within ancestors (in the current limit element).\n    if (!firstBlock) {\n        return model.createRange(selection.focus);\n    }\n    // If inserting into an empty block – return position in that block. It will get\n    // replaced with the image by insertContent(). #42.\n    if (firstBlock.isEmpty) {\n        return model.createRange(model.createPositionAt(firstBlock, 0));\n    }\n    const positionAfter = model.createPositionAfter(firstBlock);\n    // If selection is at the end of the block - return position after the block.\n    if (selection.focus.isTouching(positionAfter)) {\n        return model.createRange(positionAfter);\n    }\n    // Otherwise, return position before the block.\n    return model.createRange(model.createPositionBefore(firstBlock));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAK,MAAM,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,yBAAyB,CAACC,SAAS,EAAEC,KAAK,EAAkB;EAAA,IAAhBC,KAAK,uEAAG,MAAM;EACtE,MAAMC,eAAe,GAAGH,SAAS,CAACI,kBAAkB,EAAE;EACtD,IAAID,eAAe,IAAIF,KAAK,CAACI,MAAM,CAACC,QAAQ,CAACH,eAAe,CAAC,IAAI,CAACF,KAAK,CAACI,MAAM,CAACE,QAAQ,CAACJ,eAAe,CAAC,EAAE;IACtG,IAAID,KAAK,IAAI,QAAQ,IAAIA,KAAK,IAAI,OAAO,EAAE;MACvC,OAAOD,KAAK,CAACO,WAAW,CAACP,KAAK,CAACQ,gBAAgB,CAACN,eAAe,EAAED,KAAK,CAAC,CAAC;IAC5E;IACA,OAAOD,KAAK,CAACS,aAAa,CAACP,eAAe,CAAC;EAC/C;EACA,MAAMQ,UAAU,GAAGb,KAAK,CAACE,SAAS,CAACY,iBAAiB,EAAE,CAAC;EACvD;EACA,IAAI,CAACD,UAAU,EAAE;IACb,OAAOV,KAAK,CAACO,WAAW,CAACR,SAAS,CAACa,KAAK,CAAC;EAC7C;EACA;EACA;EACA,IAAIF,UAAU,CAACG,OAAO,EAAE;IACpB,OAAOb,KAAK,CAACO,WAAW,CAACP,KAAK,CAACQ,gBAAgB,CAACE,UAAU,EAAE,CAAC,CAAC,CAAC;EACnE;EACA,MAAMI,aAAa,GAAGd,KAAK,CAACe,mBAAmB,CAACL,UAAU,CAAC;EAC3D;EACA,IAAIX,SAAS,CAACa,KAAK,CAACI,UAAU,CAACF,aAAa,CAAC,EAAE;IAC3C,OAAOd,KAAK,CAACO,WAAW,CAACO,aAAa,CAAC;EAC3C;EACA;EACA,OAAOd,KAAK,CAACO,WAAW,CAACP,KAAK,CAACiB,oBAAoB,CAACP,UAAU,CAAC,CAAC;AACpE"},"metadata":{},"sourceType":"module"}