{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/rooteditableelement\n */\nimport EditableElement from './editableelement';\nconst rootNameSymbol = Symbol('rootName');\n/**\n * Class representing a single root in the data view. A root can be either {@link ~RootEditableElement#isReadOnly editable or read-only},\n * but in both cases it is called \"an editable\". Roots can contain other {@link module:engine/view/editableelement~EditableElement\n * editable elements} making them \"nested editables\".\n *\n * @extends module:engine/view/editableelement~EditableElement\n */\nexport default class RootEditableElement extends EditableElement {\n  /**\n   * Creates root editable element.\n   *\n   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n   * @param {String} name Node name.\n   */\n  constructor(document, name) {\n    super(document, name);\n    /**\n     * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no\n     * other name is set, `main` name is used.\n     *\n     * @readonly\n     * @member {String}\n     */\n    this.rootName = 'main';\n  }\n  get rootName() {\n    return this.getCustomProperty(rootNameSymbol);\n  }\n  set rootName(rootName) {\n    this._setCustomProperty(rootNameSymbol, rootName);\n  }\n  /**\n   * Overrides old element name and sets new one.\n   * This is needed because view roots are created before they are attached to the DOM.\n   * The name of the root element is temporary at this stage. It has to be changed when the\n   * view root element is attached to the DOM element.\n   *\n   * @protected\n   * @param {String} name The new name of element.\n   */\n  set _name(name) {\n    this.name = name;\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\trootEditableElement.is( 'rootElement' ); // -> true\n *\t\trootEditableElement.is( 'editableElement' ); // -> true\n *\t\trootEditableElement.is( 'element' ); // -> true\n *\t\trootEditableElement.is( 'node' ); // -> true\n *\t\trootEditableElement.is( 'view:editableElement' ); // -> true\n *\t\trootEditableElement.is( 'view:element' ); // -> true\n *\t\trootEditableElement.is( 'view:node' ); // -> true\n *\n *\t\trootEditableElement.is( 'model:element' ); // -> false\n *\t\trootEditableElement.is( 'documentFragment' ); // -> false\n *\n * Assuming that the object being checked is a root editable element, you can also check its\n * {@link module:engine/view/rooteditableelement~RootEditableElement#name name}:\n *\n *\t\trootEditableElement.is( 'element', 'div' ); // -> true if this is a div root editable element\n *\t\trootEditableElement.is( 'rootElement', 'div' ); // -> same as above\n *\t\ttext.is( 'element', 'div' ); -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nRootEditableElement.prototype.is = function (type, name) {\n  if (!name) {\n    return type === 'rootElement' || type === 'view:rootElement' ||\n    // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n    type === 'editableElement' || type === 'view:editableElement' || type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';\n  } else {\n    return name === this.name && (type === 'rootElement' || type === 'view:rootElement' ||\n    // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n    type === 'editableElement' || type === 'view:editableElement' || type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element');\n  }\n};","map":{"version":3,"names":["EditableElement","rootNameSymbol","Symbol","RootEditableElement","constructor","document","name","rootName","getCustomProperty","_setCustomProperty","_name","prototype","is","type"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/rooteditableelement.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/rooteditableelement\n */\nimport EditableElement from './editableelement';\nconst rootNameSymbol = Symbol('rootName');\n/**\n * Class representing a single root in the data view. A root can be either {@link ~RootEditableElement#isReadOnly editable or read-only},\n * but in both cases it is called \"an editable\". Roots can contain other {@link module:engine/view/editableelement~EditableElement\n * editable elements} making them \"nested editables\".\n *\n * @extends module:engine/view/editableelement~EditableElement\n */\nexport default class RootEditableElement extends EditableElement {\n    /**\n     * Creates root editable element.\n     *\n     * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n     * @param {String} name Node name.\n     */\n    constructor(document, name) {\n        super(document, name);\n        /**\n         * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no\n         * other name is set, `main` name is used.\n         *\n         * @readonly\n         * @member {String}\n         */\n        this.rootName = 'main';\n    }\n    get rootName() {\n        return this.getCustomProperty(rootNameSymbol);\n    }\n    set rootName(rootName) {\n        this._setCustomProperty(rootNameSymbol, rootName);\n    }\n    /**\n     * Overrides old element name and sets new one.\n     * This is needed because view roots are created before they are attached to the DOM.\n     * The name of the root element is temporary at this stage. It has to be changed when the\n     * view root element is attached to the DOM element.\n     *\n     * @protected\n     * @param {String} name The new name of element.\n     */\n    set _name(name) {\n        this.name = name;\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\trootEditableElement.is( 'rootElement' ); // -> true\n *\t\trootEditableElement.is( 'editableElement' ); // -> true\n *\t\trootEditableElement.is( 'element' ); // -> true\n *\t\trootEditableElement.is( 'node' ); // -> true\n *\t\trootEditableElement.is( 'view:editableElement' ); // -> true\n *\t\trootEditableElement.is( 'view:element' ); // -> true\n *\t\trootEditableElement.is( 'view:node' ); // -> true\n *\n *\t\trootEditableElement.is( 'model:element' ); // -> false\n *\t\trootEditableElement.is( 'documentFragment' ); // -> false\n *\n * Assuming that the object being checked is a root editable element, you can also check its\n * {@link module:engine/view/rooteditableelement~RootEditableElement#name name}:\n *\n *\t\trootEditableElement.is( 'element', 'div' ); // -> true if this is a div root editable element\n *\t\trootEditableElement.is( 'rootElement', 'div' ); // -> same as above\n *\t\ttext.is( 'element', 'div' ); -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nRootEditableElement.prototype.is = function (type, name) {\n    if (!name) {\n        return type === 'rootElement' || type === 'view:rootElement' ||\n            // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n            type === 'editableElement' || type === 'view:editableElement' ||\n            type === 'containerElement' || type === 'view:containerElement' ||\n            type === 'element' || type === 'view:element' ||\n            type === 'node' || type === 'view:node';\n    }\n    else {\n        return name === this.name && (type === 'rootElement' || type === 'view:rootElement' ||\n            // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n            type === 'editableElement' || type === 'view:editableElement' ||\n            type === 'containerElement' || type === 'view:containerElement' ||\n            type === 'element' || type === 'view:element');\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,eAAe,MAAM,mBAAmB;AAC/C,MAAMC,cAAc,GAAGC,MAAM,CAAC,UAAU,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,mBAAmB,SAASH,eAAe,CAAC;EAC7D;AACJ;AACA;AACA;AACA;AACA;EACII,WAAW,CAACC,QAAQ,EAAEC,IAAI,EAAE;IACxB,KAAK,CAACD,QAAQ,EAAEC,IAAI,CAAC;IACrB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,MAAM;EAC1B;EACA,IAAIA,QAAQ,GAAG;IACX,OAAO,IAAI,CAACC,iBAAiB,CAACP,cAAc,CAAC;EACjD;EACA,IAAIM,QAAQ,CAACA,QAAQ,EAAE;IACnB,IAAI,CAACE,kBAAkB,CAACR,cAAc,EAAEM,QAAQ,CAAC;EACrD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIG,KAAK,CAACJ,IAAI,EAAE;IACZ,IAAI,CAACA,IAAI,GAAGA,IAAI;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,mBAAmB,CAACQ,SAAS,CAACC,EAAE,GAAG,UAAUC,IAAI,EAAEP,IAAI,EAAE;EACrD,IAAI,CAACA,IAAI,EAAE;IACP,OAAOO,IAAI,KAAK,aAAa,IAAIA,IAAI,KAAK,kBAAkB;IACxD;IACAA,IAAI,KAAK,iBAAiB,IAAIA,IAAI,KAAK,sBAAsB,IAC7DA,IAAI,KAAK,kBAAkB,IAAIA,IAAI,KAAK,uBAAuB,IAC/DA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,cAAc,IAC7CA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,WAAW;EAC/C,CAAC,MACI;IACD,OAAOP,IAAI,KAAK,IAAI,CAACA,IAAI,KAAKO,IAAI,KAAK,aAAa,IAAIA,IAAI,KAAK,kBAAkB;IAC/E;IACAA,IAAI,KAAK,iBAAiB,IAAIA,IAAI,KAAK,sBAAsB,IAC7DA,IAAI,KAAK,kBAAkB,IAAIA,IAAI,KAAK,uBAAuB,IAC/DA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,cAAc,CAAC;EACtD;AACJ,CAAC"},"metadata":{},"sourceType":"module"}