{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/dom/scroll\n */\nimport isRange from './isrange';\nimport Rect from './rect';\nimport isText from './istext';\n/**\n * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.\n * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to\n * the user. If the `target` is already visible, nothing will happen.\n *\n * @param {Object} options\n * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.\n * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)\n * the `target` will be moved by when the viewport is scrolled. It enhances the user experience\n * by keeping the `target` some distance from the edge of the viewport and thus making it easier to\n * read or edit by the user.\n */\nexport function scrollViewportToShowTarget(_ref) {\n  let {\n    target,\n    viewportOffset = 0\n  } = _ref;\n  const targetWindow = getWindow(target);\n  let currentWindow = targetWindow;\n  let currentFrame = null;\n  // Iterate over all windows, starting from target's parent window up to window#top.\n  while (currentWindow) {\n    let firstAncestorToScroll;\n    // Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls\n    // settled down, the algorithm can eventually scroll the viewport of the current window.\n    //\n    // Note: If the current window is target's **original** window (e.g. the first one),\n    // start scrolling the closest parent of the target. If not, scroll the closest parent\n    // of an iframe that resides in the current window.\n    if (currentWindow == targetWindow) {\n      firstAncestorToScroll = getParentElement(target);\n    } else {\n      firstAncestorToScroll = getParentElement(currentFrame);\n    }\n    // Scroll the target's ancestors first. Once done, scrolling the viewport is easy.\n    scrollAncestorsToShowRect(firstAncestorToScroll, () => {\n      // Note: If the target does not belong to the current window **directly**,\n      // i.e. it resides in an iframe belonging to the window, obtain the target's rect\n      // in the coordinates of the current window. By default, a Rect returns geometry\n      // relative to the current window's viewport. To make it work in a parent window,\n      // it must be shifted.\n      return getRectRelativeToWindow(target, currentWindow);\n    });\n    // Obtain the rect of the target after it has been scrolled within its ancestors.\n    // It's time to scroll the viewport.\n    const targetRect = getRectRelativeToWindow(target, currentWindow);\n    scrollWindowToShowRect(currentWindow, targetRect, viewportOffset);\n    if (currentWindow.parent != currentWindow) {\n      // Keep the reference to the <iframe> element the \"previous current window\" was\n      // rendered within. It will be useful to re–calculate the rect of the target\n      // in the parent window's relative geometry. The target's rect must be shifted\n      // by it's iframe's position.\n      currentFrame = currentWindow.frameElement;\n      currentWindow = currentWindow.parent;\n      // If the current window has some parent but frameElement is inaccessible, then they have\n      // different domains/ports and, due to security reasons, accessing and scrolling\n      // the parent window won't be possible.\n      // See https://github.com/ckeditor/ckeditor5/issues/930.\n      if (!currentFrame) {\n        return;\n      }\n    } else {\n      currentWindow = null;\n    }\n  }\n}\n/**\n * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,\n * e.g. if they have `overflow: scroll` CSS style.\n *\n * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.\n */\nexport function scrollAncestorsToShowTarget(target) {\n  const targetParent = getParentElement(target);\n  scrollAncestorsToShowRect(targetParent, () => {\n    return new Rect(target);\n  });\n}\n// Makes a given rect visible within its parent window.\n//\n// Note: Avoid the situation where the caret is still in the viewport, but totally\n// at the edge of it. In such situation, if it moved beyond the viewport in the next\n// action e.g. after paste, the scrolling would move it to the viewportOffset level\n// and it all would look like the caret visually moved up/down:\n//\n// 1.\n//\t\t| foo[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// 2. *paste*\n// 3.\n//\t\t|\n//\t\t|\n//\t\t+-foo-----------------------------...\n//\t\t  bar[]                              <--- caret below viewport, scrolling...\n//\n// 4. *scrolling*\n// 5.\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]                              <--- caret precisely at the edge\n//\t\t+---------------------------------...\n//\n// To prevent this, this method checks the rects moved by the viewportOffset to cover\n// the upper/lower edge of the viewport. It makes sure if the action repeats, there's\n// no twitching – it's a purely visual improvement:\n//\n// 5. (after fix)\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// @private\n// @param {Window} window A window which is scrolled to reveal the rect.\n// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.\n// @param {Number} viewportOffset See scrollViewportToShowTarget.\nfunction scrollWindowToShowRect(window, rect, viewportOffset) {\n  const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset);\n  const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset);\n  const viewportRect = new Rect(window).excludeScrollbarsAndBorders();\n  const rects = [targetShiftedUpRect, targetShiftedDownRect];\n  if (!rects.every(rect => viewportRect.contains(rect))) {\n    let {\n      scrollX,\n      scrollY\n    } = window;\n    if (isAbove(targetShiftedUpRect, viewportRect)) {\n      scrollY -= viewportRect.top - rect.top + viewportOffset;\n    } else if (isBelow(targetShiftedDownRect, viewportRect)) {\n      scrollY += rect.bottom - viewportRect.bottom + viewportOffset;\n    }\n    // TODO: Web browsers scroll natively to place the target in the middle\n    // of the viewport. It's not a very popular case, though.\n    if (isLeftOf(rect, viewportRect)) {\n      scrollX -= viewportRect.left - rect.left + viewportOffset;\n    } else if (isRightOf(rect, viewportRect)) {\n      scrollX += rect.right - viewportRect.right + viewportOffset;\n    }\n    window.scrollTo(scrollX, scrollY);\n  }\n}\n// Recursively scrolls element ancestors to visually reveal a rect.\n//\n// @private\n// @param {HTMLElement} A parent The first ancestors to start scrolling.\n// @param {Function} getRect A function which returns the Rect, which is to be revealed.\nfunction scrollAncestorsToShowRect(parent, getRect) {\n  const parentWindow = getWindow(parent);\n  let parentRect, targetRect;\n  while (parent != parentWindow.document.body) {\n    targetRect = getRect();\n    parentRect = new Rect(parent).excludeScrollbarsAndBorders();\n    if (!parentRect.contains(targetRect)) {\n      if (isAbove(targetRect, parentRect)) {\n        parent.scrollTop -= parentRect.top - targetRect.top;\n      } else if (isBelow(targetRect, parentRect)) {\n        parent.scrollTop += targetRect.bottom - parentRect.bottom;\n      }\n      if (isLeftOf(targetRect, parentRect)) {\n        parent.scrollLeft -= parentRect.left - targetRect.left;\n      } else if (isRightOf(targetRect, parentRect)) {\n        parent.scrollLeft += targetRect.right - parentRect.right;\n      }\n    }\n    parent = parent.parentNode;\n  }\n}\n// Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isBelow(firstRect, secondRect) {\n  return firstRect.bottom > secondRect.bottom;\n}\n// Determines if a given `Rect` extends beyond the top edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isAbove(firstRect, secondRect) {\n  return firstRect.top < secondRect.top;\n}\n// Determines if a given `Rect` extends beyond the left edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isLeftOf(firstRect, secondRect) {\n  return firstRect.left < secondRect.left;\n}\n// Determines if a given `Rect` extends beyond the right edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isRightOf(firstRect, secondRect) {\n  return firstRect.right > secondRect.right;\n}\n// Returns the closest window of an element or range.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {Window}\nfunction getWindow(elementOrRange) {\n  if (isRange(elementOrRange)) {\n    return elementOrRange.startContainer.ownerDocument.defaultView;\n  } else {\n    return elementOrRange.ownerDocument.defaultView;\n  }\n}\n// Returns the closest parent of an element or DOM range.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {HTMLelement}\nfunction getParentElement(elementOrRange) {\n  if (isRange(elementOrRange)) {\n    let parent = elementOrRange.commonAncestorContainer;\n    // If a Range is attached to the Text, use the closest element ancestor.\n    if (isText(parent)) {\n      parent = parent.parentNode;\n    }\n    return parent;\n  } else {\n    return elementOrRange.parentNode;\n  }\n}\n// Returns the rect of an element or range residing in an iframe.\n// The result rect is relative to the geometry of the passed window instance.\n//\n// @private\n// @param {HTMLElement|Range} target Element or range which rect should be returned.\n// @param {Window} relativeWindow A window the rect should be relative to.\n// @returns {module:utils/dom/rect~Rect}\nfunction getRectRelativeToWindow(target, relativeWindow) {\n  const targetWindow = getWindow(target);\n  const rect = new Rect(target);\n  if (targetWindow === relativeWindow) {\n    return rect;\n  } else {\n    let currentWindow = targetWindow;\n    while (currentWindow != relativeWindow) {\n      const frame = currentWindow.frameElement;\n      const frameRect = new Rect(frame).excludeScrollbarsAndBorders();\n      rect.moveBy(frameRect.left, frameRect.top);\n      currentWindow = currentWindow.parent;\n    }\n  }\n  return rect;\n}","map":{"version":3,"names":["isRange","Rect","isText","scrollViewportToShowTarget","target","viewportOffset","targetWindow","getWindow","currentWindow","currentFrame","firstAncestorToScroll","getParentElement","scrollAncestorsToShowRect","getRectRelativeToWindow","targetRect","scrollWindowToShowRect","parent","frameElement","scrollAncestorsToShowTarget","targetParent","window","rect","targetShiftedDownRect","clone","moveBy","targetShiftedUpRect","viewportRect","excludeScrollbarsAndBorders","rects","every","contains","scrollX","scrollY","isAbove","top","isBelow","bottom","isLeftOf","left","isRightOf","right","scrollTo","getRect","parentWindow","parentRect","document","body","scrollTop","scrollLeft","parentNode","firstRect","secondRect","elementOrRange","startContainer","ownerDocument","defaultView","commonAncestorContainer","relativeWindow","frame","frameRect"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/dom/scroll\n */\nimport isRange from './isrange';\nimport Rect from './rect';\nimport isText from './istext';\n/**\n * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.\n * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to\n * the user. If the `target` is already visible, nothing will happen.\n *\n * @param {Object} options\n * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.\n * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)\n * the `target` will be moved by when the viewport is scrolled. It enhances the user experience\n * by keeping the `target` some distance from the edge of the viewport and thus making it easier to\n * read or edit by the user.\n */\nexport function scrollViewportToShowTarget({ target, viewportOffset = 0 }) {\n    const targetWindow = getWindow(target);\n    let currentWindow = targetWindow;\n    let currentFrame = null;\n    // Iterate over all windows, starting from target's parent window up to window#top.\n    while (currentWindow) {\n        let firstAncestorToScroll;\n        // Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls\n        // settled down, the algorithm can eventually scroll the viewport of the current window.\n        //\n        // Note: If the current window is target's **original** window (e.g. the first one),\n        // start scrolling the closest parent of the target. If not, scroll the closest parent\n        // of an iframe that resides in the current window.\n        if (currentWindow == targetWindow) {\n            firstAncestorToScroll = getParentElement(target);\n        }\n        else {\n            firstAncestorToScroll = getParentElement(currentFrame);\n        }\n        // Scroll the target's ancestors first. Once done, scrolling the viewport is easy.\n        scrollAncestorsToShowRect(firstAncestorToScroll, () => {\n            // Note: If the target does not belong to the current window **directly**,\n            // i.e. it resides in an iframe belonging to the window, obtain the target's rect\n            // in the coordinates of the current window. By default, a Rect returns geometry\n            // relative to the current window's viewport. To make it work in a parent window,\n            // it must be shifted.\n            return getRectRelativeToWindow(target, currentWindow);\n        });\n        // Obtain the rect of the target after it has been scrolled within its ancestors.\n        // It's time to scroll the viewport.\n        const targetRect = getRectRelativeToWindow(target, currentWindow);\n        scrollWindowToShowRect(currentWindow, targetRect, viewportOffset);\n        if (currentWindow.parent != currentWindow) {\n            // Keep the reference to the <iframe> element the \"previous current window\" was\n            // rendered within. It will be useful to re–calculate the rect of the target\n            // in the parent window's relative geometry. The target's rect must be shifted\n            // by it's iframe's position.\n            currentFrame = currentWindow.frameElement;\n            currentWindow = currentWindow.parent;\n            // If the current window has some parent but frameElement is inaccessible, then they have\n            // different domains/ports and, due to security reasons, accessing and scrolling\n            // the parent window won't be possible.\n            // See https://github.com/ckeditor/ckeditor5/issues/930.\n            if (!currentFrame) {\n                return;\n            }\n        }\n        else {\n            currentWindow = null;\n        }\n    }\n}\n/**\n * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,\n * e.g. if they have `overflow: scroll` CSS style.\n *\n * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.\n */\nexport function scrollAncestorsToShowTarget(target) {\n    const targetParent = getParentElement(target);\n    scrollAncestorsToShowRect(targetParent, () => {\n        return new Rect(target);\n    });\n}\n// Makes a given rect visible within its parent window.\n//\n// Note: Avoid the situation where the caret is still in the viewport, but totally\n// at the edge of it. In such situation, if it moved beyond the viewport in the next\n// action e.g. after paste, the scrolling would move it to the viewportOffset level\n// and it all would look like the caret visually moved up/down:\n//\n// 1.\n//\t\t| foo[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// 2. *paste*\n// 3.\n//\t\t|\n//\t\t|\n//\t\t+-foo-----------------------------...\n//\t\t  bar[]                              <--- caret below viewport, scrolling...\n//\n// 4. *scrolling*\n// 5.\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]                              <--- caret precisely at the edge\n//\t\t+---------------------------------...\n//\n// To prevent this, this method checks the rects moved by the viewportOffset to cover\n// the upper/lower edge of the viewport. It makes sure if the action repeats, there's\n// no twitching – it's a purely visual improvement:\n//\n// 5. (after fix)\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// @private\n// @param {Window} window A window which is scrolled to reveal the rect.\n// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.\n// @param {Number} viewportOffset See scrollViewportToShowTarget.\nfunction scrollWindowToShowRect(window, rect, viewportOffset) {\n    const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset);\n    const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset);\n    const viewportRect = new Rect(window).excludeScrollbarsAndBorders();\n    const rects = [targetShiftedUpRect, targetShiftedDownRect];\n    if (!rects.every(rect => viewportRect.contains(rect))) {\n        let { scrollX, scrollY } = window;\n        if (isAbove(targetShiftedUpRect, viewportRect)) {\n            scrollY -= viewportRect.top - rect.top + viewportOffset;\n        }\n        else if (isBelow(targetShiftedDownRect, viewportRect)) {\n            scrollY += rect.bottom - viewportRect.bottom + viewportOffset;\n        }\n        // TODO: Web browsers scroll natively to place the target in the middle\n        // of the viewport. It's not a very popular case, though.\n        if (isLeftOf(rect, viewportRect)) {\n            scrollX -= viewportRect.left - rect.left + viewportOffset;\n        }\n        else if (isRightOf(rect, viewportRect)) {\n            scrollX += rect.right - viewportRect.right + viewportOffset;\n        }\n        window.scrollTo(scrollX, scrollY);\n    }\n}\n// Recursively scrolls element ancestors to visually reveal a rect.\n//\n// @private\n// @param {HTMLElement} A parent The first ancestors to start scrolling.\n// @param {Function} getRect A function which returns the Rect, which is to be revealed.\nfunction scrollAncestorsToShowRect(parent, getRect) {\n    const parentWindow = getWindow(parent);\n    let parentRect, targetRect;\n    while (parent != parentWindow.document.body) {\n        targetRect = getRect();\n        parentRect = new Rect(parent).excludeScrollbarsAndBorders();\n        if (!parentRect.contains(targetRect)) {\n            if (isAbove(targetRect, parentRect)) {\n                parent.scrollTop -= parentRect.top - targetRect.top;\n            }\n            else if (isBelow(targetRect, parentRect)) {\n                parent.scrollTop += targetRect.bottom - parentRect.bottom;\n            }\n            if (isLeftOf(targetRect, parentRect)) {\n                parent.scrollLeft -= parentRect.left - targetRect.left;\n            }\n            else if (isRightOf(targetRect, parentRect)) {\n                parent.scrollLeft += targetRect.right - parentRect.right;\n            }\n        }\n        parent = parent.parentNode;\n    }\n}\n// Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isBelow(firstRect, secondRect) {\n    return firstRect.bottom > secondRect.bottom;\n}\n// Determines if a given `Rect` extends beyond the top edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isAbove(firstRect, secondRect) {\n    return firstRect.top < secondRect.top;\n}\n// Determines if a given `Rect` extends beyond the left edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isLeftOf(firstRect, secondRect) {\n    return firstRect.left < secondRect.left;\n}\n// Determines if a given `Rect` extends beyond the right edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n// @returns {Boolean}\nfunction isRightOf(firstRect, secondRect) {\n    return firstRect.right > secondRect.right;\n}\n// Returns the closest window of an element or range.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {Window}\nfunction getWindow(elementOrRange) {\n    if (isRange(elementOrRange)) {\n        return elementOrRange.startContainer.ownerDocument.defaultView;\n    }\n    else {\n        return elementOrRange.ownerDocument.defaultView;\n    }\n}\n// Returns the closest parent of an element or DOM range.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {HTMLelement}\nfunction getParentElement(elementOrRange) {\n    if (isRange(elementOrRange)) {\n        let parent = elementOrRange.commonAncestorContainer;\n        // If a Range is attached to the Text, use the closest element ancestor.\n        if (isText(parent)) {\n            parent = parent.parentNode;\n        }\n        return parent;\n    }\n    else {\n        return elementOrRange.parentNode;\n    }\n}\n// Returns the rect of an element or range residing in an iframe.\n// The result rect is relative to the geometry of the passed window instance.\n//\n// @private\n// @param {HTMLElement|Range} target Element or range which rect should be returned.\n// @param {Window} relativeWindow A window the rect should be relative to.\n// @returns {module:utils/dom/rect~Rect}\nfunction getRectRelativeToWindow(target, relativeWindow) {\n    const targetWindow = getWindow(target);\n    const rect = new Rect(target);\n    if (targetWindow === relativeWindow) {\n        return rect;\n    }\n    else {\n        let currentWindow = targetWindow;\n        while (currentWindow != relativeWindow) {\n            const frame = currentWindow.frameElement;\n            const frameRect = new Rect(frame).excludeScrollbarsAndBorders();\n            rect.moveBy(frameRect.left, frameRect.top);\n            currentWindow = currentWindow.parent;\n        }\n    }\n    return rect;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}