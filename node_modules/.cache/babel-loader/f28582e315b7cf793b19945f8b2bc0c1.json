{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/insertcontent\n */\nimport DocumentSelection from '../documentselection';\nimport Element from '../element';\nimport LivePosition from '../liveposition';\nimport Position from '../position';\nimport Range from '../range';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { LiveRange } from '../../index';\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste functionality to work.\n *\n * It takes care of removing the selected content, splitting elements (if needed), inserting elements and merging elements appropriately.\n *\n * Some examples:\n *\n * \t\t<p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n * \t\t<p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n * \t\t<p>x^y</p> + <img /> => <p>x</p>^<p>y</p> + <img /> => <p>x</p><img /><p>y</p>\n * \t\t<p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p> (no merging)\n * \t\t<p>x</p>[<img />]<p>z</p> + <p>y</p> => <p>x</p>^<p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p>\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\nexport default function insertContent(model, content, selectable, placeOrOffset) {\n  return model.change(writer => {\n    let selection;\n    if (!selectable) {\n      selection = model.document.selection;\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      selection = selectable;\n    } else {\n      selection = writer.createSelection(selectable, placeOrOffset);\n    }\n    if (!selection.isCollapsed) {\n      model.deleteContent(selection, {\n        doNotAutoparagraph: true\n      });\n    }\n    const insertion = new Insertion(model, writer, selection.anchor);\n    const fakeMarkerElements = [];\n    let nodesToInsert;\n    if (content.is('documentFragment')) {\n      // If document fragment has any markers, these markers should be inserted into the model as well.\n      if (content.markers.size) {\n        const markersPosition = [];\n        for (const [name, range] of content.markers) {\n          const {\n            start,\n            end\n          } = range;\n          const isCollapsed = start.isEqual(end);\n          markersPosition.push({\n            position: start,\n            name,\n            isCollapsed\n          }, {\n            position: end,\n            name,\n            isCollapsed\n          });\n        }\n        // Markers position is sorted backwards to ensure that the insertion of fake markers will not change\n        // the position of the next markers.\n        markersPosition.sort((_ref, _ref2) => {\n          let {\n            position: posA\n          } = _ref;\n          let {\n            position: posB\n          } = _ref2;\n          return posA.isBefore(posB) ? 1 : -1;\n        });\n        for (const {\n          position,\n          name,\n          isCollapsed\n        } of markersPosition) {\n          let fakeElement = null;\n          let collapsed = null;\n          const isAtBeginning = position.parent === content && position.isAtStart;\n          const isAtEnd = position.parent === content && position.isAtEnd;\n          // We have two ways of handling markers. In general, we want to add temporary <$marker> model elements to\n          // represent marker boundaries. These elements will be inserted into content together with the rest\n          // of the document fragment. After insertion is done, positions for these elements will be read\n          // and proper, actual markers will be created in the model and fake elements will be removed.\n          //\n          // However, if the <$marker> element is at the beginning or at the end of the document fragment,\n          // it may affect how the inserted content is merged with current model, impacting the insertion\n          // result. To avoid that, we don't add <$marker> elements at these positions. Instead, we will use\n          // `Insertion#getAffectedRange()` to figure out new positions for these marker boundaries.\n          if (!isAtBeginning && !isAtEnd) {\n            fakeElement = writer.createElement('$marker');\n            writer.insert(fakeElement, position);\n          } else if (isCollapsed) {\n            // Save whether the collapsed marker was at the beginning or at the end of document fragment\n            // to know where to create it after the insertion is done.\n            collapsed = isAtBeginning ? 'start' : 'end';\n          }\n          fakeMarkerElements.push({\n            name,\n            element: fakeElement,\n            collapsed\n          });\n        }\n      }\n      nodesToInsert = content.getChildren();\n    } else {\n      nodesToInsert = [content];\n    }\n    insertion.handleNodes(nodesToInsert);\n    let newRange = insertion.getSelectionRange();\n    if (content.is('documentFragment') && fakeMarkerElements.length) {\n      // After insertion was done, the selection was set but the model contains fake <$marker> elements.\n      // These <$marker> elements will be now removed. Because of that, we will need to fix the selection.\n      // We will create a live range that will automatically be update as <$marker> elements are removed.\n      const selectionLiveRange = newRange ? LiveRange.fromRange(newRange) : null;\n      // Marker name -> [ start position, end position ].\n      const markersData = {};\n      // Note: `fakeMarkerElements` are sorted backwards. However, now, we want to handle the markers\n      // from the beginning, so that existing <$marker> elements do not affect markers positions.\n      // This is why we iterate from the end to the start.\n      for (let i = fakeMarkerElements.length - 1; i >= 0; i--) {\n        const {\n          name,\n          element,\n          collapsed\n        } = fakeMarkerElements[i];\n        const isStartBoundary = !markersData[name];\n        if (isStartBoundary) {\n          markersData[name] = [];\n        }\n        if (element) {\n          // Read fake marker element position to learn where the marker should be created.\n          const elementPosition = writer.createPositionAt(element, 'before');\n          markersData[name].push(elementPosition);\n          writer.remove(element);\n        } else {\n          // If the fake marker element does not exist, it means that the marker boundary was at the beginning or at the end.\n          const rangeOnInsertion = insertion.getAffectedRange();\n          if (!rangeOnInsertion) {\n            // If affected range is `null` it means that nothing was in the document fragment or all content was filtered out.\n            // Some markers that were in the filtered content may be removed (partially or totally).\n            // Let's handle only those markers that were at the beginning or at the end of the document fragment.\n            if (collapsed) {\n              markersData[name].push(insertion.position);\n            }\n            continue;\n          }\n          if (collapsed) {\n            // If the marker was collapsed at the beginning or at the end of the document fragment,\n            // put both boundaries at the beginning or at the end of inserted range (to keep the marker collapsed).\n            markersData[name].push(rangeOnInsertion[collapsed]);\n          } else {\n            markersData[name].push(isStartBoundary ? rangeOnInsertion.start : rangeOnInsertion.end);\n          }\n        }\n      }\n      for (const [name, [start, end]] of Object.entries(markersData)) {\n        // For now, we ignore markers if they are included in the filtered-out content.\n        // In the future implementation we will improve that case to create markers that are not filtered out completely.\n        if (start && end && start.root === end.root) {\n          writer.addMarker(name, {\n            usingOperation: true,\n            affectsData: true,\n            range: new Range(start, end)\n          });\n        }\n      }\n      if (selectionLiveRange) {\n        newRange = selectionLiveRange.toRange();\n        selectionLiveRange.detach();\n      }\n    }\n    /* istanbul ignore else */\n    if (newRange) {\n      if (selection instanceof DocumentSelection) {\n        writer.setSelection(newRange);\n      } else {\n        selection.setTo(newRange);\n      }\n    } else {\n      // We are not testing else because it's a safe check for unpredictable edge cases:\n      // an insertion without proper range to select.\n      //\n      // @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n    }\n    const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);\n    insertion.destroy();\n    return affectedRange;\n  });\n}\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\nclass Insertion {\n  constructor(model, writer, position) {\n    /**\n     * The model in context of which the insertion should be performed.\n     *\n     * @member {module:engine/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * Batch to which operations will be added.\n     *\n     * @member {module:engine/controller/writer~Batch} #writer\n     */\n    this.writer = writer;\n    /**\n     * The position at which (or near which) the next node will be inserted.\n     *\n     * @member {module:engine/model/position~Position} #position\n     */\n    this.position = position;\n    /**\n     * Elements with which the inserted elements can be merged.\n     *\n     *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n     *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n     *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n     *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n     *\n     *\n     * @member {Set} #canMergeWith\n     */\n    this.canMergeWith = new Set([this.position.parent]);\n    /**\n     * Schema of the model.\n     *\n     * @member {module:engine/model/schema~Schema} #schema\n     */\n    this.schema = model.schema;\n    /**\n     * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.\n     *\n     * @private\n     * @type {module:engine/model/documentfragment~DocumentFragment}\n     */\n    this._documentFragment = writer.createDocumentFragment();\n    /**\n     * The current position in the temporary DocumentFragment.\n     *\n     * @private\n     * @type {module:engine/model/position~Position}\n     */\n    this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);\n    /**\n     * The reference to the first inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n    this._firstNode = null;\n    /**\n     * The reference to the last inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n    this._lastNode = null;\n    /**\n     * The reference to the last auto paragraph node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n    this._lastAutoParagraph = null;\n    /**\n     * The array of nodes that should be cleaned of not allowed attributes.\n     *\n     * @private\n     * @type {Array.<module:engine/model/node~Node>}\n     */\n    this._filterAttributesOf = [];\n    /**\n     * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n     */\n    this._affectedStart = null;\n    /**\n     * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n     */\n    this._affectedEnd = null;\n  }\n  /**\n   * Handles insertion of a set of nodes.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n   */\n  handleNodes(nodes) {\n    for (const node of Array.from(nodes)) {\n      this._handleNode(node);\n    }\n    // Insert nodes collected in temporary DocumentFragment.\n    this._insertPartialFragment();\n    // If there was an auto paragraph then we might need to adjust the end of insertion.\n    if (this._lastAutoParagraph) {\n      this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);\n    }\n    // After the content was inserted we may try to merge it with its next sibling if the selection was in it initially.\n    // Merging with the previous sibling was performed just after inserting the first node to the document.\n    this._mergeOnRight();\n    // TMP this will become a post-fixer.\n    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);\n    this._filterAttributesOf = [];\n  }\n  /**\n   * Updates the last node after the auto paragraphing.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The last auto paragraphing node.\n   */\n  _updateLastNodeFromAutoParagraph(node) {\n    const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);\n    const positionAfterNode = this.writer.createPositionAfter(node);\n    // If the real end was after the last auto paragraph then update relevant properties.\n    if (positionAfterNode.isAfter(positionAfterLastNode)) {\n      this._lastNode = node;\n      /* istanbul ignore if */\n      if (this.position.parent != node || !this.position.isAtEnd) {\n        // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n        // At this point the insertion position should be at the end of the last auto paragraph.\n        // Note: This error is documented in other place in this file.\n        throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n      }\n      this.position = positionAfterNode;\n      this._setAffectedBoundaries(this.position);\n    }\n  }\n  /**\n   * Returns range to be selected after insertion.\n   * Returns `null` if there is no valid range to select after insertion.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n  getSelectionRange() {\n    if (this._nodeToSelect) {\n      return Range._createOn(this._nodeToSelect);\n    }\n    return this.model.schema.getNearestSelectionRange(this.position);\n  }\n  /**\n   * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n   * before the insertion. Returns `null` if no changes were done.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n  getAffectedRange() {\n    if (!this._affectedStart) {\n      return null;\n    }\n    return new Range(this._affectedStart, this._affectedEnd);\n  }\n  /**\n   * Destroys `Insertion` instance.\n   */\n  destroy() {\n    if (this._affectedStart) {\n      this._affectedStart.detach();\n    }\n    if (this._affectedEnd) {\n      this._affectedEnd.detach();\n    }\n  }\n  /**\n   * Handles insertion of a single node.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node\n   */\n  _handleNode(node) {\n    // Let's handle object in a special way.\n    // * They should never be merged with other elements.\n    // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n    if (this.schema.isObject(node)) {\n      this._handleObject(node);\n      return;\n    }\n    // Try to find a place for the given node.\n    // Check if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n    // Inserts the auto paragraph if it would allow for insertion.\n    let isAllowed = this._checkAndAutoParagraphToAllowedPosition(node);\n    if (!isAllowed) {\n      // Split the position.parent's branch up to a point where the node can be inserted.\n      // If it isn't allowed in the whole branch, then of course don't split anything.\n      isAllowed = this._checkAndSplitToAllowedPosition(node);\n      if (!isAllowed) {\n        this._handleDisallowedNode(node);\n        return;\n      }\n    }\n    // Add node to the current temporary DocumentFragment.\n    this._appendToFragment(node);\n    // Store the first and last nodes for easy access for merging with sibling nodes.\n    if (!this._firstNode) {\n      this._firstNode = node;\n    }\n    this._lastNode = node;\n  }\n  /**\n   * Inserts the temporary DocumentFragment into the model.\n   *\n   * @private\n   */\n  _insertPartialFragment() {\n    if (this._documentFragment.isEmpty) {\n      return;\n    }\n    const livePosition = LivePosition.fromPosition(this.position, 'toNext');\n    this._setAffectedBoundaries(this.position);\n    // If the very first node of the whole insertion process is inserted, insert it separately for OT reasons (undo).\n    // Note: there can be multiple calls to `_insertPartialFragment()` during one insertion process.\n    // Note: only the very first node can be merged so we have to do separate operation only for it.\n    if (this._documentFragment.getChild(0) == this._firstNode) {\n      this.writer.insert(this._firstNode, this.position);\n      // We must merge the first node just after inserting it to avoid problems with OT.\n      // (See: https://github.com/ckeditor/ckeditor5/pull/8773#issuecomment-760945652).\n      this._mergeOnLeft();\n      this.position = livePosition.toPosition();\n    }\n    // Insert the remaining nodes from document fragment.\n    if (!this._documentFragment.isEmpty) {\n      this.writer.insert(this._documentFragment, this.position);\n    }\n    this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);\n    this.position = livePosition.toPosition();\n    livePosition.detach();\n  }\n  /**\n   * @private\n   * @param {module:engine/model/element~Element} node The object element.\n   */\n  _handleObject(node) {\n    // Try finding it a place in the tree.\n    if (this._checkAndSplitToAllowedPosition(node)) {\n      this._appendToFragment(node);\n    }\n    // Try autoparagraphing.\n    else {\n      this._tryAutoparagraphing(node);\n    }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n   */\n  _handleDisallowedNode(node) {\n    // If the node is an element, try inserting its children (strip the parent).\n    if (node.is('element')) {\n      this.handleNodes(node.getChildren());\n    }\n    // If text is not allowed, try autoparagraphing it.\n    else {\n      this._tryAutoparagraphing(node);\n    }\n  }\n  /**\n   * Append a node to the temporary DocumentFragment.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node to insert.\n   */\n  _appendToFragment(node) {\n    /* istanbul ignore if */\n    if (!this.schema.checkChild(this.position, node)) {\n      // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n      // Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n      /**\n       * Given node cannot be inserted on the given position.\n       *\n       * @error insertcontent-wrong-position\n       * @param {module:engine/model/node~Node} node Node to insert.\n       * @param {module:engine/model/position~Position} position Position to insert the node at.\n       */\n      throw new CKEditorError('insertcontent-wrong-position', this, {\n        node,\n        position: this.position\n      });\n    }\n    this.writer.insert(node, this._documentFragmentPosition);\n    this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize);\n    // The last inserted object should be selected because we can't put a collapsed selection after it.\n    if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {\n      this._nodeToSelect = node;\n    } else {\n      this._nodeToSelect = null;\n    }\n    this._filterAttributesOf.push(node);\n  }\n  /**\n   * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n   * mark the affected range.\n   *\n   * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n   * during merging, but the logic there is more complicated so it is left out of this function.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position\n   */\n  _setAffectedBoundaries(position) {\n    // Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n    // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n    // This is why it cannot be a range but two separate positions.\n    if (!this._affectedStart) {\n      this._affectedStart = LivePosition.fromPosition(position, 'toPrevious');\n    }\n    // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n    // inserted into the parent but the next node is moved-out of that parent:\n    // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n    // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n    if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {\n      if (this._affectedEnd) {\n        this._affectedEnd.detach();\n      }\n      this._affectedEnd = LivePosition.fromPosition(position, 'toNext');\n    }\n  }\n  /**\n   * Merges the previous sibling of the first node if it should be merged.\n   *\n   * After the content was inserted we may try to merge it with its siblings.\n   * This should happen only if the selection was in those elements initially.\n   *\n   * @private\n   */\n  _mergeOnLeft() {\n    const node = this._firstNode;\n    if (!(node instanceof Element)) {\n      return;\n    }\n    if (!this._canMergeLeft(node)) {\n      return;\n    }\n    const mergePosLeft = LivePosition._createBefore(node);\n    mergePosLeft.stickiness = 'toNext';\n    const livePosition = LivePosition.fromPosition(this.position, 'toNext');\n    // If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n    // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n    // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n    // shown as `][`).\n    //\n    // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n    //\n    // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n    //\n    // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n    if (this._affectedStart.isEqual(mergePosLeft)) {\n      this._affectedStart.detach();\n      this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');\n    }\n    // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n    // because the reference would point to the removed node.\n    //\n    // <p>A^A</p> + <p>X</p>\n    //\n    // <p>A</p>^<p>A</p>\n    // <p>A</p><p>X</p><p>A</p>\n    // <p>AX</p><p>A</p>\n    // <p>AXA</p>\n    if (this._firstNode === this._lastNode) {\n      this._firstNode = mergePosLeft.nodeBefore;\n      this._lastNode = mergePosLeft.nodeBefore;\n    }\n    this.writer.merge(mergePosLeft);\n    // If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n    //\n    // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n    //\n    // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n    if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {\n      this._affectedEnd.detach();\n      this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');\n    }\n    this.position = livePosition.toPosition();\n    livePosition.detach();\n    // After merge elements that were marked by _insert() to be filtered might be gone so\n    // we need to mark the new container.\n    this._filterAttributesOf.push(this.position.parent);\n    mergePosLeft.detach();\n  }\n  /**\n   * Merges the next sibling of the last node if it should be merged.\n   *\n   * After the content was inserted we may try to merge it with its siblings.\n   * This should happen only if the selection was in those elements initially.\n   *\n   * @private\n   */\n  _mergeOnRight() {\n    const node = this._lastNode;\n    if (!(node instanceof Element)) {\n      return;\n    }\n    if (!this._canMergeRight(node)) {\n      return;\n    }\n    const mergePosRight = LivePosition._createAfter(node);\n    mergePosRight.stickiness = 'toNext';\n    /* istanbul ignore if */\n    if (!this.position.isEqual(mergePosRight)) {\n      // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n      // At this point the insertion position should be after the node we'll merge. If it isn't,\n      // it should need to be secured as in the left merge case.\n      /**\n       * An internal error occurred when merging inserted content with its siblings.\n       * The insertion position should equal the merge position.\n       *\n       * If you encountered this error, report it back to the CKEditor 5 team\n       * with as many details as possible regarding the content being inserted and the insertion position.\n       *\n       * @error insertcontent-invalid-insertion-position\n       */\n      throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n    }\n    // Move the position to the previous node, so it isn't moved to the graveyard on merge.\n    // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n    this.position = Position._createAt(mergePosRight.nodeBefore, 'end');\n    // Explanation of setting position stickiness to `'toPrevious'`:\n    // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n    // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n    const livePosition = LivePosition.fromPosition(this.position, 'toPrevious');\n    // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n    if (this._affectedEnd.isEqual(mergePosRight)) {\n      this._affectedEnd.detach();\n      this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');\n    }\n    // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n    // because the reference would point to the removed node.\n    //\n    // <p>A^A</p> + <p>X</p>\n    //\n    // <p>A</p>^<p>A</p>\n    // <p>A</p><p>X</p><p>A</p>\n    // <p>AX</p><p>A</p>\n    // <p>AXA</p>\n    if (this._firstNode === this._lastNode) {\n      this._firstNode = mergePosRight.nodeBefore;\n      this._lastNode = mergePosRight.nodeBefore;\n    }\n    this.writer.merge(mergePosRight);\n    // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n    if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {\n      this._affectedStart.detach();\n      this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');\n    }\n    this.position = livePosition.toPosition();\n    livePosition.detach();\n    // After merge elements that were marked by _insert() to be filtered might be gone so\n    // we need to mark the new container.\n    this._filterAttributesOf.push(this.position.parent);\n    mergePosRight.detach();\n  }\n  /**\n   * Checks whether specified node can be merged with previous sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @returns {Boolean}\n   */\n  _canMergeLeft(node) {\n    const previousSibling = node.previousSibling;\n    return previousSibling instanceof Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);\n  }\n  /**\n   * Checks whether specified node can be merged with next sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @returns {Boolean}\n   */\n  _canMergeRight(node) {\n    const nextSibling = node.nextSibling;\n    return nextSibling instanceof Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);\n  }\n  /**\n   * Tries wrapping the node in a new paragraph and inserting it this way.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n   */\n  _tryAutoparagraphing(node) {\n    const paragraph = this.writer.createElement('paragraph');\n    // Do not autoparagraph if the paragraph won't be allowed there,\n    // cause that would lead to an infinite loop. The paragraph would be rejected in\n    // the next _handleNode() call and we'd be here again.\n    if (this._getAllowedIn(this.position.parent, paragraph) && this.schema.checkChild(paragraph, node)) {\n      paragraph._appendChild(node);\n      this._handleNode(paragraph);\n    }\n  }\n  /**\n   * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n   * It also handles inserting the paragraph.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node.\n   * @returns {Boolean} Whether an allowed position was found.\n   * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.\n   */\n  _checkAndAutoParagraphToAllowedPosition(node) {\n    if (this.schema.checkChild(this.position.parent, node)) {\n      return true;\n    }\n    // Do not auto paragraph if the paragraph won't be allowed there,\n    // cause that would lead to an infinite loop. The paragraph would be rejected in\n    // the next _handleNode() call and we'd be here again.\n    if (!this.schema.checkChild(this.position.parent, 'paragraph') || !this.schema.checkChild('paragraph', node)) {\n      return false;\n    }\n    // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n    this._insertPartialFragment();\n    // Insert a paragraph and move insertion position to it.\n    const paragraph = this.writer.createElement('paragraph');\n    this.writer.insert(paragraph, this.position);\n    this._setAffectedBoundaries(this.position);\n    this._lastAutoParagraph = paragraph;\n    this.position = this.writer.createPositionAt(paragraph, 0);\n    return true;\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node\n   * @returns {Boolean} Whether an allowed position was found.\n   * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n   */\n  _checkAndSplitToAllowedPosition(node) {\n    const allowedIn = this._getAllowedIn(this.position.parent, node);\n    if (!allowedIn) {\n      return false;\n    }\n    // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n    if (allowedIn != this.position.parent) {\n      this._insertPartialFragment();\n    }\n    while (allowedIn != this.position.parent) {\n      if (this.position.isAtStart) {\n        // If insertion position is at the beginning of the parent, move it out instead of splitting.\n        // <p>^Foo</p> -> ^<p>Foo</p>\n        const parent = this.position.parent;\n        this.position = this.writer.createPositionBefore(parent);\n        // Special case â€“ parent is empty (<p>^</p>).\n        //\n        // 1. parent.isEmpty\n        // We can remove the element after moving insertion position out of it.\n        //\n        // 2. parent.parent === allowedIn\n        // However parent should remain in place when allowed element is above limit element in document tree.\n        // For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n        // content allowed in $root.\n        if (parent.isEmpty && parent.parent === allowedIn) {\n          this.writer.remove(parent);\n        }\n      } else if (this.position.isAtEnd) {\n        // If insertion position is at the end of the parent, move it out instead of splitting.\n        // <p>Foo^</p> -> <p>Foo</p>^\n        this.position = this.writer.createPositionAfter(this.position.parent);\n      } else {\n        const tempPos = this.writer.createPositionAfter(this.position.parent);\n        this._setAffectedBoundaries(this.position);\n        this.writer.split(this.position);\n        this.position = tempPos;\n        this.canMergeWith.add(this.position.nodeAfter);\n      }\n    }\n    return true;\n  }\n  /**\n   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} contextElement The element in which context the node should be checked.\n   * @param {module:engine/model/node~Node} childNode The node to check.\n   * @returns {module:engine/model/element~Element|null}\n   */\n  _getAllowedIn(contextElement, childNode) {\n    if (this.schema.checkChild(contextElement, childNode)) {\n      return contextElement;\n    }\n    // If the child wasn't allowed in the context element and the element is a limit there's no point in\n    // checking any further towards the root. This is it: the limit is unsplittable and there's nothing\n    // we can do about it. Without this check, the algorithm will analyze parent of the limit and may create\n    // an illusion of the child being allowed. There's no way to insert it down there, though. It results in\n    // infinite loops.\n    if (this.schema.isLimit(contextElement)) {\n      return null;\n    }\n    return this._getAllowedIn(contextElement.parent, childNode);\n  }\n}","map":{"version":3,"names":["DocumentSelection","Element","LivePosition","Position","Range","Selection","CKEditorError","LiveRange","insertContent","model","content","selectable","placeOrOffset","change","writer","selection","document","createSelection","isCollapsed","deleteContent","doNotAutoparagraph","insertion","Insertion","anchor","fakeMarkerElements","nodesToInsert","is","markers","size","markersPosition","name","range","start","end","isEqual","push","position","sort","posA","posB","isBefore","fakeElement","collapsed","isAtBeginning","parent","isAtStart","isAtEnd","createElement","insert","element","getChildren","handleNodes","newRange","getSelectionRange","length","selectionLiveRange","fromRange","markersData","i","isStartBoundary","elementPosition","createPositionAt","remove","rangeOnInsertion","getAffectedRange","Object","entries","root","addMarker","usingOperation","affectsData","toRange","detach","setSelection","setTo","affectedRange","createRange","destroy","constructor","canMergeWith","Set","schema","_documentFragment","createDocumentFragment","_documentFragmentPosition","_firstNode","_lastNode","_lastAutoParagraph","_filterAttributesOf","_affectedStart","_affectedEnd","nodes","node","Array","from","_handleNode","_insertPartialFragment","_updateLastNodeFromAutoParagraph","_mergeOnRight","removeDisallowedAttributes","positionAfterLastNode","createPositionAfter","positionAfterNode","isAfter","_setAffectedBoundaries","_nodeToSelect","_createOn","getNearestSelectionRange","isObject","_handleObject","isAllowed","_checkAndAutoParagraphToAllowedPosition","_checkAndSplitToAllowedPosition","_handleDisallowedNode","_appendToFragment","isEmpty","livePosition","fromPosition","getChild","_mergeOnLeft","toPosition","_tryAutoparagraphing","checkChild","getShiftedBy","offsetSize","_canMergeLeft","mergePosLeft","_createBefore","stickiness","_createAt","nodeBefore","merge","_canMergeRight","mergePosRight","_createAfter","previousSibling","has","checkMerge","nextSibling","paragraph","_getAllowedIn","_appendChild","allowedIn","createPositionBefore","tempPos","split","add","nodeAfter","contextElement","childNode","isLimit"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/insertcontent\n */\nimport DocumentSelection from '../documentselection';\nimport Element from '../element';\nimport LivePosition from '../liveposition';\nimport Position from '../position';\nimport Range from '../range';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { LiveRange } from '../../index';\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste functionality to work.\n *\n * It takes care of removing the selected content, splitting elements (if needed), inserting elements and merging elements appropriately.\n *\n * Some examples:\n *\n * \t\t<p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n * \t\t<p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n * \t\t<p>x^y</p> + <img /> => <p>x</p>^<p>y</p> + <img /> => <p>x</p><img /><p>y</p>\n * \t\t<p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p> (no merging)\n * \t\t<p>x</p>[<img />]<p>z</p> + <p>y</p> => <p>x</p>^<p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p>\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\nexport default function insertContent(model, content, selectable, placeOrOffset) {\n    return model.change(writer => {\n        let selection;\n        if (!selectable) {\n            selection = model.document.selection;\n        }\n        else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n            selection = selectable;\n        }\n        else {\n            selection = writer.createSelection(selectable, placeOrOffset);\n        }\n        if (!selection.isCollapsed) {\n            model.deleteContent(selection, { doNotAutoparagraph: true });\n        }\n        const insertion = new Insertion(model, writer, selection.anchor);\n        const fakeMarkerElements = [];\n        let nodesToInsert;\n        if (content.is('documentFragment')) {\n            // If document fragment has any markers, these markers should be inserted into the model as well.\n            if (content.markers.size) {\n                const markersPosition = [];\n                for (const [name, range] of content.markers) {\n                    const { start, end } = range;\n                    const isCollapsed = start.isEqual(end);\n                    markersPosition.push({ position: start, name, isCollapsed }, { position: end, name, isCollapsed });\n                }\n                // Markers position is sorted backwards to ensure that the insertion of fake markers will not change\n                // the position of the next markers.\n                markersPosition.sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);\n                for (const { position, name, isCollapsed } of markersPosition) {\n                    let fakeElement = null;\n                    let collapsed = null;\n                    const isAtBeginning = position.parent === content && position.isAtStart;\n                    const isAtEnd = position.parent === content && position.isAtEnd;\n                    // We have two ways of handling markers. In general, we want to add temporary <$marker> model elements to\n                    // represent marker boundaries. These elements will be inserted into content together with the rest\n                    // of the document fragment. After insertion is done, positions for these elements will be read\n                    // and proper, actual markers will be created in the model and fake elements will be removed.\n                    //\n                    // However, if the <$marker> element is at the beginning or at the end of the document fragment,\n                    // it may affect how the inserted content is merged with current model, impacting the insertion\n                    // result. To avoid that, we don't add <$marker> elements at these positions. Instead, we will use\n                    // `Insertion#getAffectedRange()` to figure out new positions for these marker boundaries.\n                    if (!isAtBeginning && !isAtEnd) {\n                        fakeElement = writer.createElement('$marker');\n                        writer.insert(fakeElement, position);\n                    }\n                    else if (isCollapsed) {\n                        // Save whether the collapsed marker was at the beginning or at the end of document fragment\n                        // to know where to create it after the insertion is done.\n                        collapsed = isAtBeginning ? 'start' : 'end';\n                    }\n                    fakeMarkerElements.push({\n                        name,\n                        element: fakeElement,\n                        collapsed\n                    });\n                }\n            }\n            nodesToInsert = content.getChildren();\n        }\n        else {\n            nodesToInsert = [content];\n        }\n        insertion.handleNodes(nodesToInsert);\n        let newRange = insertion.getSelectionRange();\n        if (content.is('documentFragment') && fakeMarkerElements.length) {\n            // After insertion was done, the selection was set but the model contains fake <$marker> elements.\n            // These <$marker> elements will be now removed. Because of that, we will need to fix the selection.\n            // We will create a live range that will automatically be update as <$marker> elements are removed.\n            const selectionLiveRange = newRange ? LiveRange.fromRange(newRange) : null;\n            // Marker name -> [ start position, end position ].\n            const markersData = {};\n            // Note: `fakeMarkerElements` are sorted backwards. However, now, we want to handle the markers\n            // from the beginning, so that existing <$marker> elements do not affect markers positions.\n            // This is why we iterate from the end to the start.\n            for (let i = fakeMarkerElements.length - 1; i >= 0; i--) {\n                const { name, element, collapsed } = fakeMarkerElements[i];\n                const isStartBoundary = !markersData[name];\n                if (isStartBoundary) {\n                    markersData[name] = [];\n                }\n                if (element) {\n                    // Read fake marker element position to learn where the marker should be created.\n                    const elementPosition = writer.createPositionAt(element, 'before');\n                    markersData[name].push(elementPosition);\n                    writer.remove(element);\n                }\n                else {\n                    // If the fake marker element does not exist, it means that the marker boundary was at the beginning or at the end.\n                    const rangeOnInsertion = insertion.getAffectedRange();\n                    if (!rangeOnInsertion) {\n                        // If affected range is `null` it means that nothing was in the document fragment or all content was filtered out.\n                        // Some markers that were in the filtered content may be removed (partially or totally).\n                        // Let's handle only those markers that were at the beginning or at the end of the document fragment.\n                        if (collapsed) {\n                            markersData[name].push(insertion.position);\n                        }\n                        continue;\n                    }\n                    if (collapsed) {\n                        // If the marker was collapsed at the beginning or at the end of the document fragment,\n                        // put both boundaries at the beginning or at the end of inserted range (to keep the marker collapsed).\n                        markersData[name].push(rangeOnInsertion[collapsed]);\n                    }\n                    else {\n                        markersData[name].push(isStartBoundary ? rangeOnInsertion.start : rangeOnInsertion.end);\n                    }\n                }\n            }\n            for (const [name, [start, end]] of Object.entries(markersData)) {\n                // For now, we ignore markers if they are included in the filtered-out content.\n                // In the future implementation we will improve that case to create markers that are not filtered out completely.\n                if (start && end && start.root === end.root) {\n                    writer.addMarker(name, {\n                        usingOperation: true,\n                        affectsData: true,\n                        range: new Range(start, end)\n                    });\n                }\n            }\n            if (selectionLiveRange) {\n                newRange = selectionLiveRange.toRange();\n                selectionLiveRange.detach();\n            }\n        }\n        /* istanbul ignore else */\n        if (newRange) {\n            if (selection instanceof DocumentSelection) {\n                writer.setSelection(newRange);\n            }\n            else {\n                selection.setTo(newRange);\n            }\n        }\n        else {\n            // We are not testing else because it's a safe check for unpredictable edge cases:\n            // an insertion without proper range to select.\n            //\n            // @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n        }\n        const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);\n        insertion.destroy();\n        return affectedRange;\n    });\n}\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\nclass Insertion {\n    constructor(model, writer, position) {\n        /**\n         * The model in context of which the insertion should be performed.\n         *\n         * @member {module:engine/model~Model} #model\n         */\n        this.model = model;\n        /**\n         * Batch to which operations will be added.\n         *\n         * @member {module:engine/controller/writer~Batch} #writer\n         */\n        this.writer = writer;\n        /**\n         * The position at which (or near which) the next node will be inserted.\n         *\n         * @member {module:engine/model/position~Position} #position\n         */\n        this.position = position;\n        /**\n         * Elements with which the inserted elements can be merged.\n         *\n         *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n         *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n         *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n         *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n         *\n         *\n         * @member {Set} #canMergeWith\n         */\n        this.canMergeWith = new Set([this.position.parent]);\n        /**\n         * Schema of the model.\n         *\n         * @member {module:engine/model/schema~Schema} #schema\n         */\n        this.schema = model.schema;\n        /**\n         * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.\n         *\n         * @private\n         * @type {module:engine/model/documentfragment~DocumentFragment}\n         */\n        this._documentFragment = writer.createDocumentFragment();\n        /**\n         * The current position in the temporary DocumentFragment.\n         *\n         * @private\n         * @type {module:engine/model/position~Position}\n         */\n        this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);\n        /**\n         * The reference to the first inserted node.\n         *\n         * @private\n         * @type {module:engine/model/node~Node}\n         */\n        this._firstNode = null;\n        /**\n         * The reference to the last inserted node.\n         *\n         * @private\n         * @type {module:engine/model/node~Node}\n         */\n        this._lastNode = null;\n        /**\n         * The reference to the last auto paragraph node.\n         *\n         * @private\n         * @type {module:engine/model/node~Node}\n         */\n        this._lastAutoParagraph = null;\n        /**\n         * The array of nodes that should be cleaned of not allowed attributes.\n         *\n         * @private\n         * @type {Array.<module:engine/model/node~Node>}\n         */\n        this._filterAttributesOf = [];\n        /**\n         * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n         *\n         * @private\n         * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n         */\n        this._affectedStart = null;\n        /**\n         * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n         *\n         * @private\n         * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n         */\n        this._affectedEnd = null;\n    }\n    /**\n     * Handles insertion of a set of nodes.\n     *\n     * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n     */\n    handleNodes(nodes) {\n        for (const node of Array.from(nodes)) {\n            this._handleNode(node);\n        }\n        // Insert nodes collected in temporary DocumentFragment.\n        this._insertPartialFragment();\n        // If there was an auto paragraph then we might need to adjust the end of insertion.\n        if (this._lastAutoParagraph) {\n            this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);\n        }\n        // After the content was inserted we may try to merge it with its next sibling if the selection was in it initially.\n        // Merging with the previous sibling was performed just after inserting the first node to the document.\n        this._mergeOnRight();\n        // TMP this will become a post-fixer.\n        this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);\n        this._filterAttributesOf = [];\n    }\n    /**\n     * Updates the last node after the auto paragraphing.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The last auto paragraphing node.\n     */\n    _updateLastNodeFromAutoParagraph(node) {\n        const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);\n        const positionAfterNode = this.writer.createPositionAfter(node);\n        // If the real end was after the last auto paragraph then update relevant properties.\n        if (positionAfterNode.isAfter(positionAfterLastNode)) {\n            this._lastNode = node;\n            /* istanbul ignore if */\n            if (this.position.parent != node || !this.position.isAtEnd) {\n                // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n                // At this point the insertion position should be at the end of the last auto paragraph.\n                // Note: This error is documented in other place in this file.\n                throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n            }\n            this.position = positionAfterNode;\n            this._setAffectedBoundaries(this.position);\n        }\n    }\n    /**\n     * Returns range to be selected after insertion.\n     * Returns `null` if there is no valid range to select after insertion.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n    getSelectionRange() {\n        if (this._nodeToSelect) {\n            return Range._createOn(this._nodeToSelect);\n        }\n        return this.model.schema.getNearestSelectionRange(this.position);\n    }\n    /**\n     * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n     * before the insertion. Returns `null` if no changes were done.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n    getAffectedRange() {\n        if (!this._affectedStart) {\n            return null;\n        }\n        return new Range(this._affectedStart, this._affectedEnd);\n    }\n    /**\n     * Destroys `Insertion` instance.\n     */\n    destroy() {\n        if (this._affectedStart) {\n            this._affectedStart.detach();\n        }\n        if (this._affectedEnd) {\n            this._affectedEnd.detach();\n        }\n    }\n    /**\n     * Handles insertion of a single node.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node\n     */\n    _handleNode(node) {\n        // Let's handle object in a special way.\n        // * They should never be merged with other elements.\n        // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n        if (this.schema.isObject(node)) {\n            this._handleObject(node);\n            return;\n        }\n        // Try to find a place for the given node.\n        // Check if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n        // Inserts the auto paragraph if it would allow for insertion.\n        let isAllowed = this._checkAndAutoParagraphToAllowedPosition(node);\n        if (!isAllowed) {\n            // Split the position.parent's branch up to a point where the node can be inserted.\n            // If it isn't allowed in the whole branch, then of course don't split anything.\n            isAllowed = this._checkAndSplitToAllowedPosition(node);\n            if (!isAllowed) {\n                this._handleDisallowedNode(node);\n                return;\n            }\n        }\n        // Add node to the current temporary DocumentFragment.\n        this._appendToFragment(node);\n        // Store the first and last nodes for easy access for merging with sibling nodes.\n        if (!this._firstNode) {\n            this._firstNode = node;\n        }\n        this._lastNode = node;\n    }\n    /**\n     * Inserts the temporary DocumentFragment into the model.\n     *\n     * @private\n     */\n    _insertPartialFragment() {\n        if (this._documentFragment.isEmpty) {\n            return;\n        }\n        const livePosition = LivePosition.fromPosition(this.position, 'toNext');\n        this._setAffectedBoundaries(this.position);\n        // If the very first node of the whole insertion process is inserted, insert it separately for OT reasons (undo).\n        // Note: there can be multiple calls to `_insertPartialFragment()` during one insertion process.\n        // Note: only the very first node can be merged so we have to do separate operation only for it.\n        if (this._documentFragment.getChild(0) == this._firstNode) {\n            this.writer.insert(this._firstNode, this.position);\n            // We must merge the first node just after inserting it to avoid problems with OT.\n            // (See: https://github.com/ckeditor/ckeditor5/pull/8773#issuecomment-760945652).\n            this._mergeOnLeft();\n            this.position = livePosition.toPosition();\n        }\n        // Insert the remaining nodes from document fragment.\n        if (!this._documentFragment.isEmpty) {\n            this.writer.insert(this._documentFragment, this.position);\n        }\n        this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);\n        this.position = livePosition.toPosition();\n        livePosition.detach();\n    }\n    /**\n     * @private\n     * @param {module:engine/model/element~Element} node The object element.\n     */\n    _handleObject(node) {\n        // Try finding it a place in the tree.\n        if (this._checkAndSplitToAllowedPosition(node)) {\n            this._appendToFragment(node);\n        }\n        // Try autoparagraphing.\n        else {\n            this._tryAutoparagraphing(node);\n        }\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n     */\n    _handleDisallowedNode(node) {\n        // If the node is an element, try inserting its children (strip the parent).\n        if (node.is('element')) {\n            this.handleNodes(node.getChildren());\n        }\n        // If text is not allowed, try autoparagraphing it.\n        else {\n            this._tryAutoparagraphing(node);\n        }\n    }\n    /**\n     * Append a node to the temporary DocumentFragment.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node to insert.\n     */\n    _appendToFragment(node) {\n        /* istanbul ignore if */\n        if (!this.schema.checkChild(this.position, node)) {\n            // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n            // Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n            /**\n             * Given node cannot be inserted on the given position.\n             *\n             * @error insertcontent-wrong-position\n             * @param {module:engine/model/node~Node} node Node to insert.\n             * @param {module:engine/model/position~Position} position Position to insert the node at.\n             */\n            throw new CKEditorError('insertcontent-wrong-position', this, { node, position: this.position });\n        }\n        this.writer.insert(node, this._documentFragmentPosition);\n        this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize);\n        // The last inserted object should be selected because we can't put a collapsed selection after it.\n        if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {\n            this._nodeToSelect = node;\n        }\n        else {\n            this._nodeToSelect = null;\n        }\n        this._filterAttributesOf.push(node);\n    }\n    /**\n     * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n     * mark the affected range.\n     *\n     * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n     * during merging, but the logic there is more complicated so it is left out of this function.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position\n     */\n    _setAffectedBoundaries(position) {\n        // Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n        // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n        // This is why it cannot be a range but two separate positions.\n        if (!this._affectedStart) {\n            this._affectedStart = LivePosition.fromPosition(position, 'toPrevious');\n        }\n        // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n        // inserted into the parent but the next node is moved-out of that parent:\n        // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n        // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n        if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {\n            if (this._affectedEnd) {\n                this._affectedEnd.detach();\n            }\n            this._affectedEnd = LivePosition.fromPosition(position, 'toNext');\n        }\n    }\n    /**\n     * Merges the previous sibling of the first node if it should be merged.\n     *\n     * After the content was inserted we may try to merge it with its siblings.\n     * This should happen only if the selection was in those elements initially.\n     *\n     * @private\n     */\n    _mergeOnLeft() {\n        const node = this._firstNode;\n        if (!(node instanceof Element)) {\n            return;\n        }\n        if (!this._canMergeLeft(node)) {\n            return;\n        }\n        const mergePosLeft = LivePosition._createBefore(node);\n        mergePosLeft.stickiness = 'toNext';\n        const livePosition = LivePosition.fromPosition(this.position, 'toNext');\n        // If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n        // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n        // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n        // shown as `][`).\n        //\n        // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n        //\n        // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n        //\n        // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n        if (this._affectedStart.isEqual(mergePosLeft)) {\n            this._affectedStart.detach();\n            this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');\n        }\n        // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n        // because the reference would point to the removed node.\n        //\n        // <p>A^A</p> + <p>X</p>\n        //\n        // <p>A</p>^<p>A</p>\n        // <p>A</p><p>X</p><p>A</p>\n        // <p>AX</p><p>A</p>\n        // <p>AXA</p>\n        if (this._firstNode === this._lastNode) {\n            this._firstNode = mergePosLeft.nodeBefore;\n            this._lastNode = mergePosLeft.nodeBefore;\n        }\n        this.writer.merge(mergePosLeft);\n        // If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n        //\n        // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n        //\n        // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n        if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {\n            this._affectedEnd.detach();\n            this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');\n        }\n        this.position = livePosition.toPosition();\n        livePosition.detach();\n        // After merge elements that were marked by _insert() to be filtered might be gone so\n        // we need to mark the new container.\n        this._filterAttributesOf.push(this.position.parent);\n        mergePosLeft.detach();\n    }\n    /**\n     * Merges the next sibling of the last node if it should be merged.\n     *\n     * After the content was inserted we may try to merge it with its siblings.\n     * This should happen only if the selection was in those elements initially.\n     *\n     * @private\n     */\n    _mergeOnRight() {\n        const node = this._lastNode;\n        if (!(node instanceof Element)) {\n            return;\n        }\n        if (!this._canMergeRight(node)) {\n            return;\n        }\n        const mergePosRight = LivePosition._createAfter(node);\n        mergePosRight.stickiness = 'toNext';\n        /* istanbul ignore if */\n        if (!this.position.isEqual(mergePosRight)) {\n            // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n            // At this point the insertion position should be after the node we'll merge. If it isn't,\n            // it should need to be secured as in the left merge case.\n            /**\n             * An internal error occurred when merging inserted content with its siblings.\n             * The insertion position should equal the merge position.\n             *\n             * If you encountered this error, report it back to the CKEditor 5 team\n             * with as many details as possible regarding the content being inserted and the insertion position.\n             *\n             * @error insertcontent-invalid-insertion-position\n             */\n            throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n        }\n        // Move the position to the previous node, so it isn't moved to the graveyard on merge.\n        // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n        this.position = Position._createAt(mergePosRight.nodeBefore, 'end');\n        // Explanation of setting position stickiness to `'toPrevious'`:\n        // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n        // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n        const livePosition = LivePosition.fromPosition(this.position, 'toPrevious');\n        // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n        if (this._affectedEnd.isEqual(mergePosRight)) {\n            this._affectedEnd.detach();\n            this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');\n        }\n        // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n        // because the reference would point to the removed node.\n        //\n        // <p>A^A</p> + <p>X</p>\n        //\n        // <p>A</p>^<p>A</p>\n        // <p>A</p><p>X</p><p>A</p>\n        // <p>AX</p><p>A</p>\n        // <p>AXA</p>\n        if (this._firstNode === this._lastNode) {\n            this._firstNode = mergePosRight.nodeBefore;\n            this._lastNode = mergePosRight.nodeBefore;\n        }\n        this.writer.merge(mergePosRight);\n        // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n        if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {\n            this._affectedStart.detach();\n            this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');\n        }\n        this.position = livePosition.toPosition();\n        livePosition.detach();\n        // After merge elements that were marked by _insert() to be filtered might be gone so\n        // we need to mark the new container.\n        this._filterAttributesOf.push(this.position.parent);\n        mergePosRight.detach();\n    }\n    /**\n     * Checks whether specified node can be merged with previous sibling element.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n     * @returns {Boolean}\n     */\n    _canMergeLeft(node) {\n        const previousSibling = node.previousSibling;\n        return (previousSibling instanceof Element) &&\n            this.canMergeWith.has(previousSibling) &&\n            this.model.schema.checkMerge(previousSibling, node);\n    }\n    /**\n     * Checks whether specified node can be merged with next sibling element.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n     * @returns {Boolean}\n     */\n    _canMergeRight(node) {\n        const nextSibling = node.nextSibling;\n        return (nextSibling instanceof Element) &&\n            this.canMergeWith.has(nextSibling) &&\n            this.model.schema.checkMerge(node, nextSibling);\n    }\n    /**\n     * Tries wrapping the node in a new paragraph and inserting it this way.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n     */\n    _tryAutoparagraphing(node) {\n        const paragraph = this.writer.createElement('paragraph');\n        // Do not autoparagraph if the paragraph won't be allowed there,\n        // cause that would lead to an infinite loop. The paragraph would be rejected in\n        // the next _handleNode() call and we'd be here again.\n        if (this._getAllowedIn(this.position.parent, paragraph) && this.schema.checkChild(paragraph, node)) {\n            paragraph._appendChild(node);\n            this._handleNode(paragraph);\n        }\n    }\n    /**\n     * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n     * It also handles inserting the paragraph.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node.\n     * @returns {Boolean} Whether an allowed position was found.\n     * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.\n     */\n    _checkAndAutoParagraphToAllowedPosition(node) {\n        if (this.schema.checkChild(this.position.parent, node)) {\n            return true;\n        }\n        // Do not auto paragraph if the paragraph won't be allowed there,\n        // cause that would lead to an infinite loop. The paragraph would be rejected in\n        // the next _handleNode() call and we'd be here again.\n        if (!this.schema.checkChild(this.position.parent, 'paragraph') || !this.schema.checkChild('paragraph', node)) {\n            return false;\n        }\n        // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n        this._insertPartialFragment();\n        // Insert a paragraph and move insertion position to it.\n        const paragraph = this.writer.createElement('paragraph');\n        this.writer.insert(paragraph, this.position);\n        this._setAffectedBoundaries(this.position);\n        this._lastAutoParagraph = paragraph;\n        this.position = this.writer.createPositionAt(paragraph, 0);\n        return true;\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node\n     * @returns {Boolean} Whether an allowed position was found.\n     * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n     */\n    _checkAndSplitToAllowedPosition(node) {\n        const allowedIn = this._getAllowedIn(this.position.parent, node);\n        if (!allowedIn) {\n            return false;\n        }\n        // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n        if (allowedIn != this.position.parent) {\n            this._insertPartialFragment();\n        }\n        while (allowedIn != this.position.parent) {\n            if (this.position.isAtStart) {\n                // If insertion position is at the beginning of the parent, move it out instead of splitting.\n                // <p>^Foo</p> -> ^<p>Foo</p>\n                const parent = this.position.parent;\n                this.position = this.writer.createPositionBefore(parent);\n                // Special case â€“ parent is empty (<p>^</p>).\n                //\n                // 1. parent.isEmpty\n                // We can remove the element after moving insertion position out of it.\n                //\n                // 2. parent.parent === allowedIn\n                // However parent should remain in place when allowed element is above limit element in document tree.\n                // For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n                // content allowed in $root.\n                if (parent.isEmpty && parent.parent === allowedIn) {\n                    this.writer.remove(parent);\n                }\n            }\n            else if (this.position.isAtEnd) {\n                // If insertion position is at the end of the parent, move it out instead of splitting.\n                // <p>Foo^</p> -> <p>Foo</p>^\n                this.position = this.writer.createPositionAfter(this.position.parent);\n            }\n            else {\n                const tempPos = this.writer.createPositionAfter(this.position.parent);\n                this._setAffectedBoundaries(this.position);\n                this.writer.split(this.position);\n                this.position = tempPos;\n                this.canMergeWith.add(this.position.nodeAfter);\n            }\n        }\n        return true;\n    }\n    /**\n     * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} contextElement The element in which context the node should be checked.\n     * @param {module:engine/model/node~Node} childNode The node to check.\n     * @returns {module:engine/model/element~Element|null}\n     */\n    _getAllowedIn(contextElement, childNode) {\n        if (this.schema.checkChild(contextElement, childNode)) {\n            return contextElement;\n        }\n        // If the child wasn't allowed in the context element and the element is a limit there's no point in\n        // checking any further towards the root. This is it: the limit is unsplittable and there's nothing\n        // we can do about it. Without this check, the algorithm will analyze parent of the limit and may create\n        // an illusion of the child being allowed. There's no way to insert it down there, though. It results in\n        // infinite loops.\n        if (this.schema.isLimit(contextElement)) {\n            return null;\n        }\n        return this._getAllowedIn(contextElement.parent, childNode);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}