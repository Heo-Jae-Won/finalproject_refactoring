{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/textproxy\n */\nimport TypeCheckable from './typecheckable';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n// @if CK_DEBUG_ENGINE // const { convertMapToStringifiedObject } = require( '../dev-utils/utils' );\n/**\n * `TextProxy` represents a part of {@link module:engine/model/text~Text text node}.\n *\n * Since {@link module:engine/model/position~Position positions} can be placed between characters of a text node,\n * {@link module:engine/model/range~Range ranges} may contain only parts of text nodes. When {@link module:engine/model/range~Range#getItems\n * getting items}\n * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.\n * `TextProxy` solves this issue.\n *\n * `TextProxy` has an API similar to {@link module:engine/model/text~Text Text} and allows to do most of the common tasks performed\n * on model nodes.\n *\n * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.\n * See {@link module:engine/model/textproxy~TextProxy#isPartial}.\n *\n * **Note:** `TextProxy` is not an instance of {@link module:engine/model/node~Node node}. Keep this in mind when using it as a\n * parameter of methods.\n *\n * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`\n * use {@link module:engine/model/writer~Writer model writer API}.\n *\n * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is\n * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when\n * model changes, so they might get invalidated. Instead, consider creating {@link module:engine/model/liveposition~LivePosition live\n * position}.\n *\n * `TextProxy` instances are created by {@link module:engine/model/treewalker~TreeWalker model tree walker}. You should not need to create\n * an instance of this class by your own.\n */\nexport default class TextProxy extends TypeCheckable {\n  /**\n   * Creates a text proxy.\n   *\n   * @protected\n   * @param {module:engine/model/text~Text} textNode Text node which part is represented by this text proxy.\n   * @param {Number} offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy\n   * starts.\n   * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.\n   * @constructor\n   */\n  constructor(textNode, offsetInText, length) {\n    super();\n    /**\n     * Text node which part is represented by this text proxy.\n     *\n     * @readonly\n     * @member {module:engine/model/text~Text}\n     */\n    this.textNode = textNode;\n    if (offsetInText < 0 || offsetInText > textNode.offsetSize) {\n      /**\n       * Given `offsetInText` value is incorrect.\n       *\n       * @error model-textproxy-wrong-offsetintext\n       */\n      throw new CKEditorError('model-textproxy-wrong-offsetintext', this);\n    }\n    if (length < 0 || offsetInText + length > textNode.offsetSize) {\n      /**\n       * Given `length` value is incorrect.\n       *\n       * @error model-textproxy-wrong-length\n       */\n      throw new CKEditorError('model-textproxy-wrong-length', this);\n    }\n    /**\n     * Text data represented by this text proxy.\n     *\n     * @readonly\n     * @member {String}\n     */\n    this.data = textNode.data.substring(offsetInText, offsetInText + length);\n    /**\n     * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.\n     *\n     * @readonly\n     * @member {Number}\n     */\n    this.offsetInText = offsetInText;\n  }\n  /**\n   * Offset at which this text proxy starts in it's parent.\n   *\n   * @see module:engine/model/node~Node#startOffset\n   * @readonly\n   * @type {Number|null}\n   */\n  get startOffset() {\n    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;\n  }\n  /**\n   * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.\n   *\n   * @see module:engine/model/node~Node#offsetSize\n   * @readonly\n   * @type {Number}\n   */\n  get offsetSize() {\n    return this.data.length;\n  }\n  /**\n   * Offset at which this text proxy ends in it's parent.\n   *\n   * @see module:engine/model/node~Node#endOffset\n   * @readonly\n   * @type {Number|null}\n   */\n  get endOffset() {\n    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;\n  }\n  /**\n   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}\n   * (`true`) or the whole text node (`false`).\n   *\n   * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}\n   * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to\n   * text node size.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isPartial() {\n    return this.offsetSize !== this.textNode.offsetSize;\n  }\n  /**\n   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.\n   *\n   * @readonly\n   * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n  get parent() {\n    return this.textNode.parent;\n  }\n  /**\n   * Root of this text proxy, which is same as root of text node represented by this text proxy.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n   */\n  get root() {\n    return this.textNode.root;\n  }\n  /**\n   * Gets path to this text proxy.\n   *\n   * @see module:engine/model/node~Node#getPath\n   * @returns {Array.<Number>}\n   */\n  getPath() {\n    const path = this.textNode.getPath();\n    if (path.length > 0) {\n      path[path.length - 1] += this.offsetInText;\n    }\n    return path;\n  }\n  /**\n   * Returns ancestors array of this text proxy.\n   *\n   * @param {Object} options Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` this text proxy will be also included in parent's array.\n   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,\n   * otherwise root element will be the first item in the array.\n   * @returns {Array} Array with ancestors.\n   */\n  getAncestors() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const ancestors = [];\n    let parent = options.includeSelf ? this : this.parent;\n    while (parent) {\n      ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n      parent = parent.parent;\n    }\n    return ancestors;\n  }\n  /**\n   * Checks if this text proxy has an attribute for given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.\n   */\n  hasAttribute(key) {\n    return this.textNode.hasAttribute(key);\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n  getAttribute(key) {\n    return this.textNode.getAttribute(key);\n  }\n  /**\n   * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two\n   * items. First one is attribute key and second is attribute value.\n   *\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n  getAttributes() {\n    return this.textNode.getAttributes();\n  }\n  /**\n   * Returns iterator that iterates over this node's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n  getAttributeKeys() {\n    return this.textNode.getAttributeKeys();\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\ttextProxy.is( '$textProxy' ); // -> true\n *\t\ttextProxy.is( 'model:$textProxy' ); // -> true\n *\n *\t\ttextProxy.is( 'view:$textProxy' ); // -> false\n *\t\ttextProxy.is( 'range' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * **Note:** Until version 20.0.0 this method wasn't accepting `'$textProxy'` type. The legacy `'textProxt'` type is still\n * accepted for backward compatibility.\n *\n * @param {String} type Type to check.\n * @returns {Boolean}\n */\nTextProxy.prototype.is = function (type) {\n  return type === '$textProxy' || type === 'model:$textProxy' ||\n  // This are legacy values kept for backward compatibility.\n  type === 'textProxy' || type === 'model:textProxy';\n};","map":{"version":3,"names":["TypeCheckable","CKEditorError","TextProxy","constructor","textNode","offsetInText","length","offsetSize","data","substring","startOffset","endOffset","isPartial","parent","root","getPath","path","getAncestors","options","ancestors","includeSelf","parentFirst","hasAttribute","key","getAttribute","getAttributes","getAttributeKeys","prototype","is","type"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/textproxy.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/textproxy\n */\nimport TypeCheckable from './typecheckable';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n// @if CK_DEBUG_ENGINE // const { convertMapToStringifiedObject } = require( '../dev-utils/utils' );\n/**\n * `TextProxy` represents a part of {@link module:engine/model/text~Text text node}.\n *\n * Since {@link module:engine/model/position~Position positions} can be placed between characters of a text node,\n * {@link module:engine/model/range~Range ranges} may contain only parts of text nodes. When {@link module:engine/model/range~Range#getItems\n * getting items}\n * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.\n * `TextProxy` solves this issue.\n *\n * `TextProxy` has an API similar to {@link module:engine/model/text~Text Text} and allows to do most of the common tasks performed\n * on model nodes.\n *\n * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.\n * See {@link module:engine/model/textproxy~TextProxy#isPartial}.\n *\n * **Note:** `TextProxy` is not an instance of {@link module:engine/model/node~Node node}. Keep this in mind when using it as a\n * parameter of methods.\n *\n * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`\n * use {@link module:engine/model/writer~Writer model writer API}.\n *\n * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is\n * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when\n * model changes, so they might get invalidated. Instead, consider creating {@link module:engine/model/liveposition~LivePosition live\n * position}.\n *\n * `TextProxy` instances are created by {@link module:engine/model/treewalker~TreeWalker model tree walker}. You should not need to create\n * an instance of this class by your own.\n */\nexport default class TextProxy extends TypeCheckable {\n    /**\n     * Creates a text proxy.\n     *\n     * @protected\n     * @param {module:engine/model/text~Text} textNode Text node which part is represented by this text proxy.\n     * @param {Number} offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy\n     * starts.\n     * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.\n     * @constructor\n     */\n    constructor(textNode, offsetInText, length) {\n        super();\n        /**\n         * Text node which part is represented by this text proxy.\n         *\n         * @readonly\n         * @member {module:engine/model/text~Text}\n         */\n        this.textNode = textNode;\n        if (offsetInText < 0 || offsetInText > textNode.offsetSize) {\n            /**\n             * Given `offsetInText` value is incorrect.\n             *\n             * @error model-textproxy-wrong-offsetintext\n             */\n            throw new CKEditorError('model-textproxy-wrong-offsetintext', this);\n        }\n        if (length < 0 || offsetInText + length > textNode.offsetSize) {\n            /**\n             * Given `length` value is incorrect.\n             *\n             * @error model-textproxy-wrong-length\n             */\n            throw new CKEditorError('model-textproxy-wrong-length', this);\n        }\n        /**\n         * Text data represented by this text proxy.\n         *\n         * @readonly\n         * @member {String}\n         */\n        this.data = textNode.data.substring(offsetInText, offsetInText + length);\n        /**\n         * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.\n         *\n         * @readonly\n         * @member {Number}\n         */\n        this.offsetInText = offsetInText;\n    }\n    /**\n     * Offset at which this text proxy starts in it's parent.\n     *\n     * @see module:engine/model/node~Node#startOffset\n     * @readonly\n     * @type {Number|null}\n     */\n    get startOffset() {\n        return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;\n    }\n    /**\n     * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.\n     *\n     * @see module:engine/model/node~Node#offsetSize\n     * @readonly\n     * @type {Number}\n     */\n    get offsetSize() {\n        return this.data.length;\n    }\n    /**\n     * Offset at which this text proxy ends in it's parent.\n     *\n     * @see module:engine/model/node~Node#endOffset\n     * @readonly\n     * @type {Number|null}\n     */\n    get endOffset() {\n        return this.startOffset !== null ? this.startOffset + this.offsetSize : null;\n    }\n    /**\n     * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}\n     * (`true`) or the whole text node (`false`).\n     *\n     * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}\n     * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to\n     * text node size.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isPartial() {\n        return this.offsetSize !== this.textNode.offsetSize;\n    }\n    /**\n     * Parent of this text proxy, which is same as parent of text node represented by this text proxy.\n     *\n     * @readonly\n     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n    get parent() {\n        return this.textNode.parent;\n    }\n    /**\n     * Root of this text proxy, which is same as root of text node represented by this text proxy.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n     */\n    get root() {\n        return this.textNode.root;\n    }\n    /**\n     * Gets path to this text proxy.\n     *\n     * @see module:engine/model/node~Node#getPath\n     * @returns {Array.<Number>}\n     */\n    getPath() {\n        const path = this.textNode.getPath();\n        if (path.length > 0) {\n            path[path.length - 1] += this.offsetInText;\n        }\n        return path;\n    }\n    /**\n     * Returns ancestors array of this text proxy.\n     *\n     * @param {Object} options Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` this text proxy will be also included in parent's array.\n     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,\n     * otherwise root element will be the first item in the array.\n     * @returns {Array} Array with ancestors.\n     */\n    getAncestors(options = {}) {\n        const ancestors = [];\n        let parent = options.includeSelf ? this : this.parent;\n        while (parent) {\n            ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n            parent = parent.parent;\n        }\n        return ancestors;\n    }\n    /**\n     * Checks if this text proxy has an attribute for given key.\n     *\n     * @param {String} key Key of attribute to check.\n     * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.\n     */\n    hasAttribute(key) {\n        return this.textNode.hasAttribute(key);\n    }\n    /**\n     * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.\n     *\n     * @param {String} key Key of attribute to look for.\n     * @returns {*} Attribute value or `undefined`.\n     */\n    getAttribute(key) {\n        return this.textNode.getAttribute(key);\n    }\n    /**\n     * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two\n     * items. First one is attribute key and second is attribute value.\n     *\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n    getAttributes() {\n        return this.textNode.getAttributes();\n    }\n    /**\n     * Returns iterator that iterates over this node's attribute keys.\n     *\n     * @returns {Iterable.<String>}\n     */\n    getAttributeKeys() {\n        return this.textNode.getAttributeKeys();\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\ttextProxy.is( '$textProxy' ); // -> true\n *\t\ttextProxy.is( 'model:$textProxy' ); // -> true\n *\n *\t\ttextProxy.is( 'view:$textProxy' ); // -> false\n *\t\ttextProxy.is( 'range' ); // -> false\n *\n * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n *\n * **Note:** Until version 20.0.0 this method wasn't accepting `'$textProxy'` type. The legacy `'textProxt'` type is still\n * accepted for backward compatibility.\n *\n * @param {String} type Type to check.\n * @returns {Boolean}\n */\nTextProxy.prototype.is = function (type) {\n    return type === '$textProxy' || type === 'model:$textProxy' ||\n        // This are legacy values kept for backward compatibility.\n        type === 'textProxy' || type === 'model:textProxy';\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}