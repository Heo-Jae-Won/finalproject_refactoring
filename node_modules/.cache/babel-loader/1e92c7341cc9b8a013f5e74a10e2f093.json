{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/uielement\n */\nimport Element from './element';\nimport Node from './node';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n/**\n * UI element class. It should be used to represent editing UI which needs to be injected into the editing view\n * If possible, you should keep your UI outside the editing view. However, if that is not possible,\n * UI elements can be used.\n *\n * How a UI element is rendered is in your control (you pass a callback to\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}).\n * The editor will ignore your UI element – the selection cannot be placed in it, it is skipped (invisible) when\n * the user modifies the selection by using arrow keys and the editor does not listen to any mutations which\n * happen inside your UI elements.\n *\n * The limitation is that you cannot convert a model element to a UI element. UI elements need to be\n * created for {@link module:engine/model/markercollection~Marker markers} or as additinal elements\n * inside normal {@link module:engine/view/containerelement~ContainerElement container elements}.\n *\n * To create a new UI element use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`} method.\n *\n * @extends module:engine/view/element~Element\n */\nexport default class UIElement extends Element {\n  /**\n   * Creates new instance of UIElement.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,\n   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement\n   * @protected\n   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n   * @param {String} name Node name.\n   * @param {Object|Iterable} [attributes] Collection of attributes.\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into created element.\n   */\n  constructor() {\n    super(...arguments);\n    /**\n     * Returns `null` because filler is not needed for UIElements.\n     *\n     * @method #getFillerOffset\n     * @returns {null} Always returns null.\n     */\n    this.getFillerOffset = getFillerOffset;\n  }\n  /**\n   * Overrides {@link module:engine/view/element~Element#_insertChild} method.\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes\n   * to UIElement.\n   *\n   * @protected\n   */\n  _insertChild(index, items) {\n    if (items && (items instanceof Node || Array.from(items).length > 0)) {\n      /**\n       * Cannot add children to {@link module:engine/view/uielement~UIElement}.\n       *\n       * @error view-uielement-cannot-add\n       */\n      throw new CKEditorError('view-uielement-cannot-add', [this, items]);\n    }\n    return 0;\n  }\n  /**\n   * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by\n   * {@link module:engine/view/domconverter~DomConverter}.\n   * Do not use inheritance to create custom rendering method, replace `render()` method instead:\n   *\n   *\t\tconst myUIElement = downcastWriter.createUIElement( 'span' );\n   *\t\tmyUIElement.render = function( domDocument, domConverter ) {\n   *\t\t\tconst domElement = this.toDomElement( domDocument );\n   *\n   *\t\t\tdomConverter.setContentOf( domElement, '<b>this is ui element</b>' );\n   *\n   *\t\t\treturn domElement;\n   *\t\t};\n   *\n   * If changes in your UI element should trigger some editor UI update you should call\n   * the {@link module:core/editor/editorui~EditorUI#update `editor.ui.update()`} method\n   * after rendering your UI element.\n   *\n   * @param {Document} domDocument\n   * @param {module:engine/view/domconverter~DomConverter} domConverter Instance of the DomConverter used to optimize the output.\n   * @returns {HTMLElement}\n   */\n  render(domDocument, domConverter) {\n    // Provide basic, default output.\n    return this.toDomElement(domDocument);\n  }\n  /**\n   * Creates DOM element based on this view UIElement.\n   * Note that each time this method is called new DOM element is created.\n   *\n   * @param {Document} domDocument\n   * @returns {HTMLElement}\n   */\n  toDomElement(domDocument) {\n    const domElement = domDocument.createElement(this.name);\n    for (const key of this.getAttributeKeys()) {\n      domElement.setAttribute(key, this.getAttribute(key));\n    }\n    return domElement;\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tuiElement.is( 'uiElement' ); // -> true\n *\t\tuiElement.is( 'element' ); // -> true\n *\t\tuiElement.is( 'node' ); // -> true\n *\t\tuiElement.is( 'view:uiElement' ); // -> true\n *\t\tuiElement.is( 'view:element' ); // -> true\n *\t\tuiElement.is( 'view:node' ); // -> true\n *\n *\t\tuiElement.is( 'model:element' ); // -> false\n *\t\tuiElement.is( 'documentFragment' ); // -> false\n *\n * Assuming that the object being checked is an ui element, you can also check its\n * {@link module:engine/view/uielement~UIElement#name name}:\n *\n *\t\tuiElement.is( 'element', 'span' ); // -> true if this is a span ui element\n *\t\tuiElement.is( 'uiElement', 'span' ); // -> same as above\n *\t\ttext.is( 'element', 'span' ); -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nUIElement.prototype.is = function (type, name) {\n  if (!name) {\n    return type === 'uiElement' || type === 'view:uiElement' ||\n    // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n    type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';\n  } else {\n    return name === this.name && (type === 'uiElement' || type === 'view:uiElement' || type === 'element' || type === 'view:element');\n  }\n};\n/**\n * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.\n *\n * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.\n * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.\n * Without this handler, it would be impossible to \"jump over\" UI element using right arrow key.\n *\n * @param {module:engine/view/view~View} view View controller to which the quirks handling will be injected.\n */\nexport function injectUiElementHandling(view) {\n  view.document.on('arrowKey', (evt, data) => jumpOverUiElement(evt, data, view.domConverter), {\n    priority: 'low'\n  });\n}\n// Returns `null` because block filler is not needed for UIElements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n  return null;\n}\n// Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This\n// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection\n// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.\nfunction jumpOverUiElement(evt, data, domConverter) {\n  if (data.keyCode == keyCodes.arrowright) {\n    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n    const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;\n    // Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.\n    if (domSelectionCollapsed || data.shiftKey) {\n      const domParent = domSelection.focusNode;\n      const domOffset = domSelection.focusOffset;\n      const viewPosition = domConverter.domPositionToView(domParent, domOffset);\n      // In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.\n      if (viewPosition === null) {\n        return;\n      }\n      // Skip all following ui elements.\n      let jumpedOverAnyUiElement = false;\n      const nextViewPosition = viewPosition.getLastMatchingPosition(value => {\n        if (value.item.is('uiElement')) {\n          // Remember that there was at least one ui element.\n          jumpedOverAnyUiElement = true;\n        }\n        // Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.\n        if (value.item.is('uiElement') || value.item.is('attributeElement')) {\n          return true;\n        }\n        // Don't jump over text or don't get out of container element.\n        return false;\n      });\n      // If anything has been skipped, fix position.\n      // This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.\n      if (jumpedOverAnyUiElement) {\n        const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);\n        if (domSelectionCollapsed) {\n          // Selection was collapsed, so collapse it at further position.\n          domSelection.collapse(newDomPosition.parent, newDomPosition.offset);\n        } else {\n          // Selection was not collapse, so extend it instead of collapsing.\n          domSelection.extend(newDomPosition.parent, newDomPosition.offset);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["Element","Node","CKEditorError","keyCodes","UIElement","constructor","getFillerOffset","_insertChild","index","items","Array","from","length","render","domDocument","domConverter","toDomElement","domElement","createElement","name","key","getAttributeKeys","setAttribute","getAttribute","prototype","is","type","injectUiElementHandling","view","document","on","evt","data","jumpOverUiElement","priority","keyCode","arrowright","domSelection","domTarget","ownerDocument","defaultView","getSelection","domSelectionCollapsed","rangeCount","getRangeAt","collapsed","shiftKey","domParent","focusNode","domOffset","focusOffset","viewPosition","domPositionToView","jumpedOverAnyUiElement","nextViewPosition","getLastMatchingPosition","value","item","newDomPosition","viewPositionToDom","collapse","parent","offset","extend"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/uielement.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/uielement\n */\nimport Element from './element';\nimport Node from './node';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n/**\n * UI element class. It should be used to represent editing UI which needs to be injected into the editing view\n * If possible, you should keep your UI outside the editing view. However, if that is not possible,\n * UI elements can be used.\n *\n * How a UI element is rendered is in your control (you pass a callback to\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}).\n * The editor will ignore your UI element – the selection cannot be placed in it, it is skipped (invisible) when\n * the user modifies the selection by using arrow keys and the editor does not listen to any mutations which\n * happen inside your UI elements.\n *\n * The limitation is that you cannot convert a model element to a UI element. UI elements need to be\n * created for {@link module:engine/model/markercollection~Marker markers} or as additinal elements\n * inside normal {@link module:engine/view/containerelement~ContainerElement container elements}.\n *\n * To create a new UI element use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`} method.\n *\n * @extends module:engine/view/element~Element\n */\nexport default class UIElement extends Element {\n    /**\n     * Creates new instance of UIElement.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,\n     * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement\n     * @protected\n     * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n     * @param {String} name Node name.\n     * @param {Object|Iterable} [attributes] Collection of attributes.\n     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n     * A list of nodes to be inserted into created element.\n     */\n    constructor(...args) {\n        super(...args);\n        /**\n         * Returns `null` because filler is not needed for UIElements.\n         *\n         * @method #getFillerOffset\n         * @returns {null} Always returns null.\n         */\n        this.getFillerOffset = getFillerOffset;\n    }\n    /**\n     * Overrides {@link module:engine/view/element~Element#_insertChild} method.\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes\n     * to UIElement.\n     *\n     * @protected\n     */\n    _insertChild(index, items) {\n        if (items && (items instanceof Node || Array.from(items).length > 0)) {\n            /**\n             * Cannot add children to {@link module:engine/view/uielement~UIElement}.\n             *\n             * @error view-uielement-cannot-add\n             */\n            throw new CKEditorError('view-uielement-cannot-add', [this, items]);\n        }\n        return 0;\n    }\n    /**\n     * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by\n     * {@link module:engine/view/domconverter~DomConverter}.\n     * Do not use inheritance to create custom rendering method, replace `render()` method instead:\n     *\n     *\t\tconst myUIElement = downcastWriter.createUIElement( 'span' );\n     *\t\tmyUIElement.render = function( domDocument, domConverter ) {\n     *\t\t\tconst domElement = this.toDomElement( domDocument );\n     *\n     *\t\t\tdomConverter.setContentOf( domElement, '<b>this is ui element</b>' );\n     *\n     *\t\t\treturn domElement;\n     *\t\t};\n     *\n     * If changes in your UI element should trigger some editor UI update you should call\n     * the {@link module:core/editor/editorui~EditorUI#update `editor.ui.update()`} method\n     * after rendering your UI element.\n     *\n     * @param {Document} domDocument\n     * @param {module:engine/view/domconverter~DomConverter} domConverter Instance of the DomConverter used to optimize the output.\n     * @returns {HTMLElement}\n     */\n    render(domDocument, domConverter) {\n        // Provide basic, default output.\n        return this.toDomElement(domDocument);\n    }\n    /**\n     * Creates DOM element based on this view UIElement.\n     * Note that each time this method is called new DOM element is created.\n     *\n     * @param {Document} domDocument\n     * @returns {HTMLElement}\n     */\n    toDomElement(domDocument) {\n        const domElement = domDocument.createElement(this.name);\n        for (const key of this.getAttributeKeys()) {\n            domElement.setAttribute(key, this.getAttribute(key));\n        }\n        return domElement;\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\tuiElement.is( 'uiElement' ); // -> true\n *\t\tuiElement.is( 'element' ); // -> true\n *\t\tuiElement.is( 'node' ); // -> true\n *\t\tuiElement.is( 'view:uiElement' ); // -> true\n *\t\tuiElement.is( 'view:element' ); // -> true\n *\t\tuiElement.is( 'view:node' ); // -> true\n *\n *\t\tuiElement.is( 'model:element' ); // -> false\n *\t\tuiElement.is( 'documentFragment' ); // -> false\n *\n * Assuming that the object being checked is an ui element, you can also check its\n * {@link module:engine/view/uielement~UIElement#name name}:\n *\n *\t\tuiElement.is( 'element', 'span' ); // -> true if this is a span ui element\n *\t\tuiElement.is( 'uiElement', 'span' ); // -> same as above\n *\t\ttext.is( 'element', 'span' ); -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nUIElement.prototype.is = function (type, name) {\n    if (!name) {\n        return type === 'uiElement' || type === 'view:uiElement' ||\n            // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n            type === 'element' || type === 'view:element' ||\n            type === 'node' || type === 'view:node';\n    }\n    else {\n        return name === this.name && (type === 'uiElement' || type === 'view:uiElement' ||\n            type === 'element' || type === 'view:element');\n    }\n};\n/**\n * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.\n *\n * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.\n * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.\n * Without this handler, it would be impossible to \"jump over\" UI element using right arrow key.\n *\n * @param {module:engine/view/view~View} view View controller to which the quirks handling will be injected.\n */\nexport function injectUiElementHandling(view) {\n    view.document.on('arrowKey', (evt, data) => jumpOverUiElement(evt, data, view.domConverter), { priority: 'low' });\n}\n// Returns `null` because block filler is not needed for UIElements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n    return null;\n}\n// Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This\n// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection\n// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.\nfunction jumpOverUiElement(evt, data, domConverter) {\n    if (data.keyCode == keyCodes.arrowright) {\n        const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n        const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;\n        // Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.\n        if (domSelectionCollapsed || data.shiftKey) {\n            const domParent = domSelection.focusNode;\n            const domOffset = domSelection.focusOffset;\n            const viewPosition = domConverter.domPositionToView(domParent, domOffset);\n            // In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.\n            if (viewPosition === null) {\n                return;\n            }\n            // Skip all following ui elements.\n            let jumpedOverAnyUiElement = false;\n            const nextViewPosition = viewPosition.getLastMatchingPosition(value => {\n                if (value.item.is('uiElement')) {\n                    // Remember that there was at least one ui element.\n                    jumpedOverAnyUiElement = true;\n                }\n                // Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.\n                if (value.item.is('uiElement') || value.item.is('attributeElement')) {\n                    return true;\n                }\n                // Don't jump over text or don't get out of container element.\n                return false;\n            });\n            // If anything has been skipped, fix position.\n            // This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.\n            if (jumpedOverAnyUiElement) {\n                const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);\n                if (domSelectionCollapsed) {\n                    // Selection was collapsed, so collapse it at further position.\n                    domSelection.collapse(newDomPosition.parent, newDomPosition.offset);\n                }\n                else {\n                    // Selection was not collapse, so extend it instead of collapsing.\n                    domSelection.extend(newDomPosition.parent, newDomPosition.offset);\n                }\n            }\n        }\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,WAAW;AAC/B,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,aAAa,MAAM,6CAA6C;AACvE,SAASC,QAAQ,QAAQ,wCAAwC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,SAAS,SAASJ,OAAO,CAAC;EAC3C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,WAAW,GAAU;IACjB,KAAK,CAAC,YAAO,CAAC;IACd;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAGA,eAAe;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACC,KAAK,EAAEC,KAAK,EAAE;IACvB,IAAIA,KAAK,KAAKA,KAAK,YAAYR,IAAI,IAAIS,KAAK,CAACC,IAAI,CAACF,KAAK,CAAC,CAACG,MAAM,GAAG,CAAC,CAAC,EAAE;MAClE;AACZ;AACA;AACA;AACA;MACY,MAAM,IAAIV,aAAa,CAAC,2BAA2B,EAAE,CAAC,IAAI,EAAEO,KAAK,CAAC,CAAC;IACvE;IACA,OAAO,CAAC;EACZ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,MAAM,CAACC,WAAW,EAAEC,YAAY,EAAE;IAC9B;IACA,OAAO,IAAI,CAACC,YAAY,CAACF,WAAW,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,YAAY,CAACF,WAAW,EAAE;IACtB,MAAMG,UAAU,GAAGH,WAAW,CAACI,aAAa,CAAC,IAAI,CAACC,IAAI,CAAC;IACvD,KAAK,MAAMC,GAAG,IAAI,IAAI,CAACC,gBAAgB,EAAE,EAAE;MACvCJ,UAAU,CAACK,YAAY,CAACF,GAAG,EAAE,IAAI,CAACG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"},"metadata":{},"sourceType":"module"}