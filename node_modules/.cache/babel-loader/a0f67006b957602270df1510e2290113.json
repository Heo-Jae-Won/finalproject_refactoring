{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/upcastdispatcher\n */\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema'; // eslint-disable-line no-duplicate-imports\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * Upcast dispatcher is a central point of the view-to-model conversion, which is a process of\n * converting a given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element view element} into a correct model structure.\n *\n * During the conversion process, the dispatcher fires events for all {@link module:engine/view/node~Node view nodes}\n * from the converted view document fragment.\n * Special callbacks called \"converters\" should listen to these events in order to convert the view nodes.\n *\n * The second parameter of the callback is the `data` object with the following properties:\n *\n * * `data.viewItem` contains a {@link module:engine/view/node~Node view node} or a\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback.\n * * `data.modelRange` is used to point to the result\n * of the current conversion (e.g. the element that is being inserted)\n * and is always a {@link module:engine/model/range~Range} when the conversion succeeds.\n * * `data.modelCursor` is a {@link module:engine/model/position~Position position} on which the converter should insert\n * the newly created items.\n *\n * The third parameter of the callback is an instance of {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n * which provides additional tools for converters.\n *\n * You can read more about conversion in the {@glink framework/guides/deep-dive/conversion/upcast Upcast conversion} guide.\n *\n * Examples of event-based converters:\n *\n *\t\t// A converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// The <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why you need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p> element's font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it is executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Do not go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into a paragraph (autoparagraphing).\n *\t\teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *\t\t\t// Check if an element can be converted.\n *\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *\t\t\t\t// When an element is already consumed by higher priority converters, do nothing.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *\t\t\t// Try to safely insert a paragraph at the model cursor - it will find an allowed parent for the current element.\n *\t\t\tif ( !conversionApi.safeInsert( paragraph, data.modelCursor ) ) {\n *\t\t\t\t// When an element was not inserted, it means that you cannot insert a paragraph at this position.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Consume the inserted element.\n *\t\t\tconversionApi.consumable.consume( data.viewItem, { name: data.viewItem.name } ) );\n *\n *\t\t\t// Convert the children to a paragraph.\n *\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem,  paragraph ) );\n *\n *\t\t\t// Update `modelRange` and `modelCursor` in the `data` as a conversion result.\n *\t\t\tconversionApi.updateConversionResult( paragraph, data );\n *\t\t}, { priority: 'low' } );\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher extends Emitter {\n  /**\n   * Creates an upcast dispatcher that operates using the passed API.\n   *\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n   * @param {Object} [conversionApi] Additional properties for an interface that will be passed to events fired\n   * by the upcast dispatcher.\n   */\n  constructor(conversionApi) {\n    super();\n    /**\n     * The list of elements that were created during splitting.\n     *\n     * After the conversion process, the list is cleared.\n     *\n     * @private\n     * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n     */\n    this._splitParts = new Map();\n    /**\n     * The list of cursor parent elements that were created during splitting.\n     *\n     * After the conversion process the list is cleared.\n     *\n     * @private\n     * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n     */\n    this._cursorParents = new Map();\n    /**\n     * The position in the temporary structure where the converted content is inserted. The structure reflects the context of\n     * the target position where the content will be inserted. This property is built based on the context parameter of the\n     * convert method.\n     *\n     * @private\n     * @type {module:engine/model/position~Position|null}\n     */\n    this._modelCursor = null;\n    /**\n     * The list of elements that were created during the splitting but should not get removed on conversion end even if they are empty.\n     *\n     * The list is cleared after the conversion process.\n     *\n     * @private\n     * @type {Set.<module:engine/model/element~Element>}\n     */\n    this._emptyElementsToKeep = new Set();\n    /**\n     * An interface passed by the dispatcher to the event callbacks.\n     *\n     * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n     */\n    this.conversionApi = {\n      ...conversionApi,\n      consumable: null,\n      writer: null,\n      store: null,\n      convertItem: (viewItem, modelCursor) => this._convertItem(viewItem, modelCursor),\n      convertChildren: (viewElement, positionOrElement) => this._convertChildren(viewElement, positionOrElement),\n      safeInsert: (modelElement, position) => this._safeInsert(modelElement, position),\n      updateConversionResult: (modelElement, data) => this._updateConversionResult(modelElement, data),\n      // Advanced API - use only if custom position handling is needed.\n      splitToAllowedParent: (modelElement, modelCursor) => this._splitToAllowedParent(modelElement, modelCursor),\n      getSplitParts: modelElement => this._getSplitParts(modelElement),\n      keepEmptyElement: modelElement => this._keepEmptyElement(modelElement)\n    };\n  }\n  /**\n   * Starts the conversion process. The entry point for the conversion.\n   *\n   * @fires element\n   * @fires text\n   * @fires documentFragment\n   * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewElement\n   * The part of the view to be converted.\n   * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is the result of the conversion process\n   * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   */\n  convert(viewElement, writer) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['$root'];\n    this.fire('viewCleanup', viewElement);\n    // Create context tree and set position in the top element.\n    // Items will be converted according to this position.\n    this._modelCursor = createContextTree(context, writer);\n    // Store writer in conversion as a conversion API\n    // to be sure that conversion process will use the same batch.\n    this.conversionApi.writer = writer;\n    // Create consumable values list for conversion process.\n    this.conversionApi.consumable = ViewConsumable.createFrom(viewElement);\n    // Custom data stored by converter for conversion process.\n    this.conversionApi.store = {};\n    // Do the conversion.\n    const {\n      modelRange\n    } = this._convertItem(viewElement, this._modelCursor);\n    // Conversion result is always a document fragment so let's create it.\n    const documentFragment = writer.createDocumentFragment();\n    // When there is a conversion result.\n    if (modelRange) {\n      // Remove all empty elements that were create while splitting.\n      this._removeEmptyElements();\n      // Move all items that were converted in context tree to the document fragment.\n      for (const item of Array.from(this._modelCursor.parent.getChildren())) {\n        writer.append(item, documentFragment);\n      }\n      // Extract temporary markers elements from model and set as static markers collection.\n      documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);\n    }\n    // Clear context position.\n    this._modelCursor = null;\n    // Clear split elements & parents lists.\n    this._splitParts.clear();\n    this._cursorParents.clear();\n    this._emptyElementsToKeep.clear();\n    // Clear conversion API.\n    this.conversionApi.writer = null;\n    this.conversionApi.store = null;\n    // Return fragment as conversion result.\n    return documentFragment;\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n   */\n  _convertItem(viewItem, modelCursor) {\n    const data = {\n      viewItem,\n      modelCursor,\n      modelRange: null\n    };\n    if (viewItem.is('element')) {\n      this.fire(`element:${viewItem.name}`, data, this.conversionApi);\n    } else if (viewItem.is('$text')) {\n      this.fire('text', data, this.conversionApi);\n    } else {\n      this.fire('documentFragment', data, this.conversionApi);\n    }\n    // Handle incorrect conversion result.\n    if (data.modelRange && !(data.modelRange instanceof ModelRange)) {\n      /**\n       * Incorrect conversion result was dropped.\n       *\n       * {@link module:engine/model/range~Range Model range} should be a conversion result.\n       *\n       * @error view-conversion-dispatcher-incorrect-result\n       */\n      throw new CKEditorError('view-conversion-dispatcher-incorrect-result', this);\n    }\n    return {\n      modelRange: data.modelRange,\n      modelCursor: data.modelCursor\n    };\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n   */\n  _convertChildren(viewItem, elementOrModelCursor) {\n    let nextModelCursor = elementOrModelCursor.is('position') ? elementOrModelCursor : ModelPosition._createAt(elementOrModelCursor, 0);\n    const modelRange = new ModelRange(nextModelCursor);\n    for (const viewChild of Array.from(viewItem.getChildren())) {\n      const result = this._convertItem(viewChild, nextModelCursor);\n      if (result.modelRange instanceof ModelRange) {\n        modelRange.end = result.modelRange.end;\n        nextModelCursor = result.modelCursor;\n      }\n    }\n    return {\n      modelRange,\n      modelCursor: nextModelCursor\n    };\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert\n   */\n  _safeInsert(modelElement, position) {\n    // Find allowed parent for element that we are going to insert.\n    // If current parent does not allow to insert element but one of the ancestors does\n    // then split nodes to allowed parent.\n    const splitResult = this._splitToAllowedParent(modelElement, position);\n    // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n    if (!splitResult) {\n      return false;\n    }\n    // Insert element on allowed position.\n    this.conversionApi.writer.insert(modelElement, splitResult.position);\n    return true;\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult\n   */\n  _updateConversionResult(modelElement, data) {\n    const parts = this._getSplitParts(modelElement);\n    const writer = this.conversionApi.writer;\n    // Set conversion result range - only if not set already.\n    if (!data.modelRange) {\n      data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));\n    }\n    const savedCursorParent = this._cursorParents.get(modelElement);\n    // Now we need to check where the `modelCursor` should be.\n    if (savedCursorParent) {\n      // If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n      //\n      // before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n      // after:  <allowed><notAllowed>foo</notAllowed> <converted></converted> <notAllowed>[]</notAllowed></allowed>\n      data.modelCursor = writer.createPositionAt(savedCursorParent, 0);\n    } else {\n      // Otherwise just continue after inserted element.\n      data.modelCursor = data.modelRange.end;\n    }\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n   */\n  _splitToAllowedParent(node, modelCursor) {\n    const {\n      schema,\n      writer\n    } = this.conversionApi;\n    // Try to find allowed parent.\n    let allowedParent = schema.findAllowedParent(modelCursor, node);\n    if (allowedParent) {\n      // When current position parent allows to insert node then return this position.\n      if (allowedParent === modelCursor.parent) {\n        return {\n          position: modelCursor\n        };\n      }\n      // When allowed parent is in context tree (it's outside the converted tree).\n      if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {\n        allowedParent = null;\n      }\n    }\n    if (!allowedParent) {\n      // Check if the node wrapped with a paragraph would be accepted by the schema.\n      if (!isParagraphable(modelCursor, node, schema)) {\n        return null;\n      }\n      return {\n        position: wrapInParagraph(modelCursor, writer)\n      };\n    }\n    // Split element to allowed parent.\n    const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent);\n    // Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n    //\n    // The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n    // that got split) to the beginning of the other part of that element:\n    //\n    // <limit><a><b><c>X[]Y</c></b><a></limit> ->\n    // <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n    //\n    // After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n    // Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n    // Also, since we split all those elements, each of them has to have the other part.\n    //\n    // With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n    // them with \"opening tags\" in the reverse order. For that we can use a stack.\n    const stack = [];\n    for (const treeWalkerValue of splitResult.range.getWalker()) {\n      if (treeWalkerValue.type == 'elementEnd') {\n        stack.push(treeWalkerValue.item);\n      } else {\n        // There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n        const originalPart = stack.pop();\n        const splitPart = treeWalkerValue.item;\n        this._registerSplitPair(originalPart, splitPart);\n      }\n    }\n    const cursorParent = splitResult.range.end.parent;\n    this._cursorParents.set(node, cursorParent);\n    return {\n      position: splitResult.position,\n      cursorParent\n    };\n  }\n  /**\n   * Registers that a `splitPart` element is a split part of the `originalPart` element.\n   *\n   * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} originalPart\n   * @param {module:engine/model/element~Element} splitPart\n   */\n  _registerSplitPair(originalPart, splitPart) {\n    if (!this._splitParts.has(originalPart)) {\n      this._splitParts.set(originalPart, [originalPart]);\n    }\n    const list = this._splitParts.get(originalPart);\n    this._splitParts.set(splitPart, list);\n    list.push(splitPart);\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n   */\n  _getSplitParts(element) {\n    let parts;\n    if (!this._splitParts.has(element)) {\n      parts = [element];\n    } else {\n      parts = this._splitParts.get(element);\n    }\n    return parts;\n  }\n  /**\n   * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.\n   *\n   * @private\n   */\n  _keepEmptyElement(element) {\n    this._emptyElementsToKeep.add(element);\n  }\n  /**\n   * Checks if there are any empty elements created while splitting and removes them.\n   *\n   * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n   * as some elements might have become empty after other empty elements were removed from them.\n   *\n   * @private\n   */\n  _removeEmptyElements() {\n    let anyRemoved = false;\n    for (const element of this._splitParts.keys()) {\n      if (element.isEmpty && !this._emptyElementsToKeep.has(element)) {\n        this.conversionApi.writer.remove(element);\n        this._splitParts.delete(element);\n        anyRemoved = true;\n      }\n    }\n    if (anyRemoved) {\n      this._removeEmptyElements();\n    }\n  }\n}\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment(modelItem, writer) {\n  const markerElements = new Set();\n  const markers = new Map();\n  // Create ModelTreeWalker.\n  const range = ModelRange._createIn(modelItem).getItems();\n  // Walk through DocumentFragment and collect marker elements.\n  for (const item of range) {\n    // Check if current element is a marker.\n    if (item.is('element', '$marker')) {\n      markerElements.add(item);\n    }\n  }\n  // Walk through collected marker elements store its path and remove its from the DocumentFragment.\n  for (const markerElement of markerElements) {\n    const markerName = markerElement.getAttribute('data-name');\n    const currentPosition = writer.createPositionBefore(markerElement);\n    // When marker of given name is not stored it means that we have found the beginning of the range.\n    if (!markers.has(markerName)) {\n      markers.set(markerName, new ModelRange(currentPosition.clone()));\n      // Otherwise is means that we have found end of the marker range.\n    } else {\n      markers.get(markerName).end = currentPosition.clone();\n    }\n    // Remove marker element from DocumentFragment.\n    writer.remove(markerElement);\n  }\n  return markers;\n}\n// Creates model fragment according to given context and returns position in the bottom (the deepest) element.\nfunction createContextTree(contextDefinition, writer) {\n  let position;\n  for (const item of new SchemaContext(contextDefinition)) {\n    const attributes = {};\n    for (const key of item.getAttributeKeys()) {\n      attributes[key] = item.getAttribute(key);\n    }\n    const current = writer.createElement(item.name, attributes);\n    if (position) {\n      writer.insert(current, position);\n    }\n    position = ModelPosition._createAt(current, 0);\n  }\n  return position;\n}","map":{"version":3,"names":["ViewConsumable","ModelRange","ModelPosition","SchemaContext","isParagraphable","wrapInParagraph","CKEditorError","Emitter","UpcastDispatcher","constructor","conversionApi","_splitParts","Map","_cursorParents","_modelCursor","_emptyElementsToKeep","Set","consumable","writer","store","convertItem","viewItem","modelCursor","_convertItem","convertChildren","viewElement","positionOrElement","_convertChildren","safeInsert","modelElement","position","_safeInsert","updateConversionResult","data","_updateConversionResult","splitToAllowedParent","_splitToAllowedParent","getSplitParts","_getSplitParts","keepEmptyElement","_keepEmptyElement","convert","context","fire","createContextTree","createFrom","modelRange","documentFragment","createDocumentFragment","_removeEmptyElements","item","Array","from","parent","getChildren","append","markers","extractMarkersFromModelFragment","clear","is","name","elementOrModelCursor","nextModelCursor","_createAt","viewChild","result","end","splitResult","insert","parts","createRange","createPositionBefore","createPositionAfter","length","savedCursorParent","get","createPositionAt","node","schema","allowedParent","findAllowedParent","getAncestors","includes","split","stack","treeWalkerValue","range","getWalker","type","push","originalPart","pop","splitPart","_registerSplitPair","cursorParent","set","has","list","element","add","anyRemoved","keys","isEmpty","remove","delete","modelItem","markerElements","_createIn","getItems","markerElement","markerName","getAttribute","currentPosition","clone","contextDefinition","attributes","key","getAttributeKeys","current","createElement"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/upcastdispatcher\n */\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema'; // eslint-disable-line no-duplicate-imports\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * Upcast dispatcher is a central point of the view-to-model conversion, which is a process of\n * converting a given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element view element} into a correct model structure.\n *\n * During the conversion process, the dispatcher fires events for all {@link module:engine/view/node~Node view nodes}\n * from the converted view document fragment.\n * Special callbacks called \"converters\" should listen to these events in order to convert the view nodes.\n *\n * The second parameter of the callback is the `data` object with the following properties:\n *\n * * `data.viewItem` contains a {@link module:engine/view/node~Node view node} or a\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback.\n * * `data.modelRange` is used to point to the result\n * of the current conversion (e.g. the element that is being inserted)\n * and is always a {@link module:engine/model/range~Range} when the conversion succeeds.\n * * `data.modelCursor` is a {@link module:engine/model/position~Position position} on which the converter should insert\n * the newly created items.\n *\n * The third parameter of the callback is an instance of {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n * which provides additional tools for converters.\n *\n * You can read more about conversion in the {@glink framework/guides/deep-dive/conversion/upcast Upcast conversion} guide.\n *\n * Examples of event-based converters:\n *\n *\t\t// A converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// The <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why you need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p> element's font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it is executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Do not go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into a paragraph (autoparagraphing).\n *\t\teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *\t\t\t// Check if an element can be converted.\n *\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *\t\t\t\t// When an element is already consumed by higher priority converters, do nothing.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *\t\t\t// Try to safely insert a paragraph at the model cursor - it will find an allowed parent for the current element.\n *\t\t\tif ( !conversionApi.safeInsert( paragraph, data.modelCursor ) ) {\n *\t\t\t\t// When an element was not inserted, it means that you cannot insert a paragraph at this position.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Consume the inserted element.\n *\t\t\tconversionApi.consumable.consume( data.viewItem, { name: data.viewItem.name } ) );\n *\n *\t\t\t// Convert the children to a paragraph.\n *\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem,  paragraph ) );\n *\n *\t\t\t// Update `modelRange` and `modelCursor` in the `data` as a conversion result.\n *\t\t\tconversionApi.updateConversionResult( paragraph, data );\n *\t\t}, { priority: 'low' } );\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher extends Emitter {\n    /**\n     * Creates an upcast dispatcher that operates using the passed API.\n     *\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n     * @param {Object} [conversionApi] Additional properties for an interface that will be passed to events fired\n     * by the upcast dispatcher.\n     */\n    constructor(conversionApi) {\n        super();\n        /**\n         * The list of elements that were created during splitting.\n         *\n         * After the conversion process, the list is cleared.\n         *\n         * @private\n         * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n         */\n        this._splitParts = new Map();\n        /**\n         * The list of cursor parent elements that were created during splitting.\n         *\n         * After the conversion process the list is cleared.\n         *\n         * @private\n         * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n         */\n        this._cursorParents = new Map();\n        /**\n         * The position in the temporary structure where the converted content is inserted. The structure reflects the context of\n         * the target position where the content will be inserted. This property is built based on the context parameter of the\n         * convert method.\n         *\n         * @private\n         * @type {module:engine/model/position~Position|null}\n         */\n        this._modelCursor = null;\n        /**\n         * The list of elements that were created during the splitting but should not get removed on conversion end even if they are empty.\n         *\n         * The list is cleared after the conversion process.\n         *\n         * @private\n         * @type {Set.<module:engine/model/element~Element>}\n         */\n        this._emptyElementsToKeep = new Set();\n        /**\n         * An interface passed by the dispatcher to the event callbacks.\n         *\n         * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n         */\n        this.conversionApi = {\n            ...conversionApi,\n            consumable: null,\n            writer: null,\n            store: null,\n            convertItem: (viewItem, modelCursor) => this._convertItem(viewItem, modelCursor),\n            convertChildren: (viewElement, positionOrElement) => this._convertChildren(viewElement, positionOrElement),\n            safeInsert: (modelElement, position) => this._safeInsert(modelElement, position),\n            updateConversionResult: (modelElement, data) => this._updateConversionResult(modelElement, data),\n            // Advanced API - use only if custom position handling is needed.\n            splitToAllowedParent: (modelElement, modelCursor) => this._splitToAllowedParent(modelElement, modelCursor),\n            getSplitParts: modelElement => this._getSplitParts(modelElement),\n            keepEmptyElement: modelElement => this._keepEmptyElement(modelElement)\n        };\n    }\n    /**\n     * Starts the conversion process. The entry point for the conversion.\n     *\n     * @fires element\n     * @fires text\n     * @fires documentFragment\n     * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewElement\n     * The part of the view to be converted.\n     * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n     * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is the result of the conversion process\n     * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's\n     * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n     */\n    convert(viewElement, writer, context = ['$root']) {\n        this.fire('viewCleanup', viewElement);\n        // Create context tree and set position in the top element.\n        // Items will be converted according to this position.\n        this._modelCursor = createContextTree(context, writer);\n        // Store writer in conversion as a conversion API\n        // to be sure that conversion process will use the same batch.\n        this.conversionApi.writer = writer;\n        // Create consumable values list for conversion process.\n        this.conversionApi.consumable = ViewConsumable.createFrom(viewElement);\n        // Custom data stored by converter for conversion process.\n        this.conversionApi.store = {};\n        // Do the conversion.\n        const { modelRange } = this._convertItem(viewElement, this._modelCursor);\n        // Conversion result is always a document fragment so let's create it.\n        const documentFragment = writer.createDocumentFragment();\n        // When there is a conversion result.\n        if (modelRange) {\n            // Remove all empty elements that were create while splitting.\n            this._removeEmptyElements();\n            // Move all items that were converted in context tree to the document fragment.\n            for (const item of Array.from(this._modelCursor.parent.getChildren())) {\n                writer.append(item, documentFragment);\n            }\n            // Extract temporary markers elements from model and set as static markers collection.\n            documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);\n        }\n        // Clear context position.\n        this._modelCursor = null;\n        // Clear split elements & parents lists.\n        this._splitParts.clear();\n        this._cursorParents.clear();\n        this._emptyElementsToKeep.clear();\n        // Clear conversion API.\n        this.conversionApi.writer = null;\n        this.conversionApi.store = null;\n        // Return fragment as conversion result.\n        return documentFragment;\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n     */\n    _convertItem(viewItem, modelCursor) {\n        const data = { viewItem, modelCursor, modelRange: null };\n        if (viewItem.is('element')) {\n            this.fire(`element:${viewItem.name}`, data, this.conversionApi);\n        }\n        else if (viewItem.is('$text')) {\n            this.fire('text', data, this.conversionApi);\n        }\n        else {\n            this.fire('documentFragment', data, this.conversionApi);\n        }\n        // Handle incorrect conversion result.\n        if (data.modelRange && !(data.modelRange instanceof ModelRange)) {\n            /**\n             * Incorrect conversion result was dropped.\n             *\n             * {@link module:engine/model/range~Range Model range} should be a conversion result.\n             *\n             * @error view-conversion-dispatcher-incorrect-result\n             */\n            throw new CKEditorError('view-conversion-dispatcher-incorrect-result', this);\n        }\n        return { modelRange: data.modelRange, modelCursor: data.modelCursor };\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n     */\n    _convertChildren(viewItem, elementOrModelCursor) {\n        let nextModelCursor = elementOrModelCursor.is('position') ?\n            elementOrModelCursor : ModelPosition._createAt(elementOrModelCursor, 0);\n        const modelRange = new ModelRange(nextModelCursor);\n        for (const viewChild of Array.from(viewItem.getChildren())) {\n            const result = this._convertItem(viewChild, nextModelCursor);\n            if (result.modelRange instanceof ModelRange) {\n                modelRange.end = result.modelRange.end;\n                nextModelCursor = result.modelCursor;\n            }\n        }\n        return { modelRange, modelCursor: nextModelCursor };\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert\n     */\n    _safeInsert(modelElement, position) {\n        // Find allowed parent for element that we are going to insert.\n        // If current parent does not allow to insert element but one of the ancestors does\n        // then split nodes to allowed parent.\n        const splitResult = this._splitToAllowedParent(modelElement, position);\n        // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n        if (!splitResult) {\n            return false;\n        }\n        // Insert element on allowed position.\n        this.conversionApi.writer.insert(modelElement, splitResult.position);\n        return true;\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult\n     */\n    _updateConversionResult(modelElement, data) {\n        const parts = this._getSplitParts(modelElement);\n        const writer = this.conversionApi.writer;\n        // Set conversion result range - only if not set already.\n        if (!data.modelRange) {\n            data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));\n        }\n        const savedCursorParent = this._cursorParents.get(modelElement);\n        // Now we need to check where the `modelCursor` should be.\n        if (savedCursorParent) {\n            // If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n            //\n            // before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n            // after:  <allowed><notAllowed>foo</notAllowed> <converted></converted> <notAllowed>[]</notAllowed></allowed>\n            data.modelCursor = writer.createPositionAt(savedCursorParent, 0);\n        }\n        else {\n            // Otherwise just continue after inserted element.\n            data.modelCursor = data.modelRange.end;\n        }\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n     */\n    _splitToAllowedParent(node, modelCursor) {\n        const { schema, writer } = this.conversionApi;\n        // Try to find allowed parent.\n        let allowedParent = schema.findAllowedParent(modelCursor, node);\n        if (allowedParent) {\n            // When current position parent allows to insert node then return this position.\n            if (allowedParent === modelCursor.parent) {\n                return { position: modelCursor };\n            }\n            // When allowed parent is in context tree (it's outside the converted tree).\n            if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {\n                allowedParent = null;\n            }\n        }\n        if (!allowedParent) {\n            // Check if the node wrapped with a paragraph would be accepted by the schema.\n            if (!isParagraphable(modelCursor, node, schema)) {\n                return null;\n            }\n            return {\n                position: wrapInParagraph(modelCursor, writer)\n            };\n        }\n        // Split element to allowed parent.\n        const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent);\n        // Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n        //\n        // The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n        // that got split) to the beginning of the other part of that element:\n        //\n        // <limit><a><b><c>X[]Y</c></b><a></limit> ->\n        // <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n        //\n        // After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n        // Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n        // Also, since we split all those elements, each of them has to have the other part.\n        //\n        // With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n        // them with \"opening tags\" in the reverse order. For that we can use a stack.\n        const stack = [];\n        for (const treeWalkerValue of splitResult.range.getWalker()) {\n            if (treeWalkerValue.type == 'elementEnd') {\n                stack.push(treeWalkerValue.item);\n            }\n            else {\n                // There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n                const originalPart = stack.pop();\n                const splitPart = treeWalkerValue.item;\n                this._registerSplitPair(originalPart, splitPart);\n            }\n        }\n        const cursorParent = splitResult.range.end.parent;\n        this._cursorParents.set(node, cursorParent);\n        return {\n            position: splitResult.position,\n            cursorParent\n        };\n    }\n    /**\n     * Registers that a `splitPart` element is a split part of the `originalPart` element.\n     *\n     * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} originalPart\n     * @param {module:engine/model/element~Element} splitPart\n     */\n    _registerSplitPair(originalPart, splitPart) {\n        if (!this._splitParts.has(originalPart)) {\n            this._splitParts.set(originalPart, [originalPart]);\n        }\n        const list = this._splitParts.get(originalPart);\n        this._splitParts.set(splitPart, list);\n        list.push(splitPart);\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n     */\n    _getSplitParts(element) {\n        let parts;\n        if (!this._splitParts.has(element)) {\n            parts = [element];\n        }\n        else {\n            parts = this._splitParts.get(element);\n        }\n        return parts;\n    }\n    /**\n     * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.\n     *\n     * @private\n     */\n    _keepEmptyElement(element) {\n        this._emptyElementsToKeep.add(element);\n    }\n    /**\n     * Checks if there are any empty elements created while splitting and removes them.\n     *\n     * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n     * as some elements might have become empty after other empty elements were removed from them.\n     *\n     * @private\n     */\n    _removeEmptyElements() {\n        let anyRemoved = false;\n        for (const element of this._splitParts.keys()) {\n            if (element.isEmpty && !this._emptyElementsToKeep.has(element)) {\n                this.conversionApi.writer.remove(element);\n                this._splitParts.delete(element);\n                anyRemoved = true;\n            }\n        }\n        if (anyRemoved) {\n            this._removeEmptyElements();\n        }\n    }\n}\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment(modelItem, writer) {\n    const markerElements = new Set();\n    const markers = new Map();\n    // Create ModelTreeWalker.\n    const range = ModelRange._createIn(modelItem).getItems();\n    // Walk through DocumentFragment and collect marker elements.\n    for (const item of range) {\n        // Check if current element is a marker.\n        if (item.is('element', '$marker')) {\n            markerElements.add(item);\n        }\n    }\n    // Walk through collected marker elements store its path and remove its from the DocumentFragment.\n    for (const markerElement of markerElements) {\n        const markerName = markerElement.getAttribute('data-name');\n        const currentPosition = writer.createPositionBefore(markerElement);\n        // When marker of given name is not stored it means that we have found the beginning of the range.\n        if (!markers.has(markerName)) {\n            markers.set(markerName, new ModelRange(currentPosition.clone()));\n            // Otherwise is means that we have found end of the marker range.\n        }\n        else {\n            markers.get(markerName).end = currentPosition.clone();\n        }\n        // Remove marker element from DocumentFragment.\n        writer.remove(markerElement);\n    }\n    return markers;\n}\n// Creates model fragment according to given context and returns position in the bottom (the deepest) element.\nfunction createContextTree(contextDefinition, writer) {\n    let position;\n    for (const item of new SchemaContext(contextDefinition)) {\n        const attributes = {};\n        for (const key of item.getAttributeKeys()) {\n            attributes[key] = item.getAttribute(key);\n        }\n        const current = writer.createElement(item.name, attributes);\n        if (position) {\n            writer.insert(current, position);\n        }\n        position = ModelPosition._createAt(current, 0);\n    }\n    return position;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,cAAc,MAAM,kBAAkB;AAC7C,OAAOC,UAAU,MAAM,gBAAgB;AACvC,OAAOC,aAAa,MAAM,mBAAmB;AAC7C,SAASC,aAAa,QAAQ,iBAAiB,CAAC,CAAC;AACjD,SAASC,eAAe,EAAEC,eAAe,QAAQ,iCAAiC;AAClF,OAAOC,aAAa,MAAM,6CAA6C;AACvE,SAASC,OAAO,QAAQ,4CAA4C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,gBAAgB,SAASD,OAAO,CAAC;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,WAAW,CAACC,aAAa,EAAE;IACvB,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,IAAIC,GAAG,EAAE;IAC5B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,IAAID,GAAG,EAAE;IAC/B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,YAAY,GAAG,IAAI;IACxB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,oBAAoB,GAAG,IAAIC,GAAG,EAAE;IACrC;AACR;AACA;AACA;AACA;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"},"metadata":{},"sourceType":"module"}