{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/observer/mutationobserver\n */\n/* globals window */\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { startsWithFiller, getDataWithoutFiller } from '../filler';\nimport { isEqualWith } from 'lodash-es';\n/**\n * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view\n * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.\n * Because all mutated nodes are marked as \"to be rendered\" and the\n * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the\n * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor\n * will block all changes which are not handled.\n *\n * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and\n * mutations on elements which do not have corresponding view elements. Also\n * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class MutationObserver extends Observer {\n  constructor(view) {\n    super(view);\n    /**\n     * Native mutation observer config.\n     *\n     * @private\n     * @member {Object}\n     */\n    this._config = {\n      childList: true,\n      characterData: true,\n      characterDataOldValue: true,\n      subtree: true\n    };\n    /**\n     * Reference to the {@link module:engine/view/view~View#domConverter}.\n     *\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n    this.domConverter = view.domConverter;\n    /**\n     * Reference to the {@link module:engine/view/view~View#_renderer}.\n     *\n     * @member {module:engine/view/renderer~Renderer}\n     */\n    this.renderer = view._renderer;\n    /**\n     * Observed DOM elements.\n     *\n     * @private\n     * @member {Array.<HTMLElement>}\n     */\n    this._domElements = [];\n    /**\n     * Native mutation observer.\n     *\n     * @private\n     * @member {MutationObserver}\n     */\n    this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));\n  }\n  /**\n   * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.\n   * At the same time empties the queue so mutations will not be fired twice.\n   */\n  flush() {\n    this._onMutations(this._mutationObserver.takeRecords());\n  }\n  /**\n   * @inheritDoc\n   */\n  observe(domElement) {\n    this._domElements.push(domElement);\n    if (this.isEnabled) {\n      this._mutationObserver.observe(domElement, this._config);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  enable() {\n    super.enable();\n    for (const domElement of this._domElements) {\n      this._mutationObserver.observe(domElement, this._config);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  disable() {\n    super.disable();\n    this._mutationObserver.disconnect();\n  }\n  /**\n   * @inheritDoc\n   */\n  destroy() {\n    super.destroy();\n    this._mutationObserver.disconnect();\n  }\n  /**\n   * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.\n   *\n   * @private\n   * @param {Array.<Object>} domMutations Array of native mutations.\n   */\n  _onMutations(domMutations) {\n    // As a result of this.flush() we can have an empty collection.\n    if (domMutations.length === 0) {\n      return;\n    }\n    const domConverter = this.domConverter;\n    // Use map and set for deduplication.\n    const mutatedTexts = new Map();\n    const mutatedElements = new Set();\n    // Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the\n    // element with changed structure anyway.\n    for (const mutation of domMutations) {\n      if (mutation.type === 'childList') {\n        const element = domConverter.mapDomToView(mutation.target);\n        // Do not collect mutations from UIElements and RawElements.\n        if (element && (element.is('uiElement') || element.is('rawElement'))) {\n          continue;\n        }\n        if (element && !this._isBogusBrMutation(mutation)) {\n          mutatedElements.add(element);\n        }\n      }\n    }\n    // Handle `characterData` mutations later, when we have the full list of nodes which changed structure.\n    for (const mutation of domMutations) {\n      const element = domConverter.mapDomToView(mutation.target);\n      // Do not collect mutations from UIElements and RawElements.\n      if (element && (element.is('uiElement') || element.is('rawElement'))) {\n        continue;\n      }\n      if (mutation.type === 'characterData') {\n        const text = domConverter.findCorrespondingViewText(mutation.target);\n        if (text && !mutatedElements.has(text.parent)) {\n          // Use text as a key, for deduplication. If there will be another mutation on the same text element\n          // we will have only one in the map.\n          mutatedTexts.set(text, {\n            type: 'text',\n            oldText: text.data,\n            newText: getDataWithoutFiller(mutation.target),\n            node: text\n          });\n        }\n        // When we added first letter to the text node which had only inline filler, for the DOM it is mutation\n        // on text, but for the view, where filler text node did not existed, new text node was created, so we\n        // need to fire 'children' mutation instead of 'text'.\n        else if (!text && startsWithFiller(mutation.target)) {\n          mutatedElements.add(domConverter.mapDomToView(mutation.target.parentNode));\n        }\n      }\n    }\n    // Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the\n    // same node multiple times in case of duplication.\n    // List of mutations we will fire.\n    const viewMutations = [];\n    for (const mutatedText of mutatedTexts.values()) {\n      this.renderer.markToSync('text', mutatedText.node);\n      viewMutations.push(mutatedText);\n    }\n    for (const viewElement of mutatedElements) {\n      const domElement = domConverter.mapViewToDom(viewElement);\n      const viewChildren = Array.from(viewElement.getChildren());\n      const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {\n        withChildren: false\n      }));\n      // It may happen that as a result of many changes (sth was inserted and then removed),\n      // both elements haven't really changed. #1031\n      if (!isEqualWith(viewChildren, newViewChildren, sameNodes)) {\n        this.renderer.markToSync('children', viewElement);\n        viewMutations.push({\n          type: 'children',\n          oldChildren: viewChildren,\n          newChildren: newViewChildren,\n          node: viewElement\n        });\n      }\n    }\n    // Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.\n    // There should not be simultaneous mutation in multiple documents, so it's fine.\n    const domSelection = domMutations[0].target.ownerDocument.getSelection();\n    let viewSelection = null;\n    if (domSelection && domSelection.anchorNode) {\n      // If `domSelection` is inside a dom node that is already bound to a view node from view tree, get\n      // corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may\n      // be used by features handling mutations.\n      // Only one range is supported.\n      const viewSelectionAnchor = domConverter.domPositionToView(domSelection.anchorNode, domSelection.anchorOffset);\n      const viewSelectionFocus = domConverter.domPositionToView(domSelection.focusNode, domSelection.focusOffset);\n      // Anchor and focus has to be properly mapped to view.\n      if (viewSelectionAnchor && viewSelectionFocus) {\n        viewSelection = new ViewSelection(viewSelectionAnchor);\n        viewSelection.setFocus(viewSelectionFocus);\n      }\n    }\n    // In case only non-relevant mutations were recorded it skips the event and force render (#5600).\n    if (viewMutations.length) {\n      this.document.fire('mutations', viewMutations, viewSelection);\n      // If nothing changes on `mutations` event, at this point we have \"dirty DOM\" (changed) and de-synched\n      // view (which has not been changed). In order to \"reset DOM\" we render the view again.\n      this.view.forceRender();\n    }\n    function sameNodes(child1, child2) {\n      // First level of comparison (array of children vs array of children) – use the Lodash's default behavior.\n      if (Array.isArray(child1)) {\n        return;\n      }\n      // Elements.\n      if (child1 === child2) {\n        return true;\n      }\n      // Texts.\n      else if (child1.is('$text') && child2.is('$text')) {\n        return child1.data === child2.data;\n      }\n      // Not matching types.\n      return false;\n    }\n  }\n  /**\n   * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.\n   * Such mutations are generated while pressing space or performing native spellchecker correction\n   * on the end of the block element in Firefox browser.\n   *\n   * @private\n   * @param {Object} mutation Native mutation object.\n   * @returns {Boolean}\n   */\n  _isBogusBrMutation(mutation) {\n    let addedNode = null;\n    // Check if mutation added only one node on the end of its parent.\n    if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {\n      addedNode = this.domConverter.domToView(mutation.addedNodes[0], {\n        withChildren: false\n      });\n    }\n    return addedNode && addedNode.is('element', 'br');\n  }\n}","map":{"version":3,"names":["Observer","ViewSelection","startsWithFiller","getDataWithoutFiller","isEqualWith","MutationObserver","constructor","view","_config","childList","characterData","characterDataOldValue","subtree","domConverter","renderer","_renderer","_domElements","_mutationObserver","window","_onMutations","bind","flush","takeRecords","observe","domElement","push","isEnabled","enable","disable","disconnect","destroy","domMutations","length","mutatedTexts","Map","mutatedElements","Set","mutation","type","element","mapDomToView","target","is","_isBogusBrMutation","add","text","findCorrespondingViewText","has","parent","set","oldText","data","newText","node","parentNode","viewMutations","mutatedText","values","markToSync","viewElement","mapViewToDom","viewChildren","Array","from","getChildren","newViewChildren","domChildrenToView","withChildren","sameNodes","oldChildren","newChildren","domSelection","ownerDocument","getSelection","viewSelection","anchorNode","viewSelectionAnchor","domPositionToView","anchorOffset","viewSelectionFocus","focusNode","focusOffset","setFocus","document","fire","forceRender","child1","child2","isArray","addedNode","nextSibling","removedNodes","addedNodes","domToView"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mutationobserver.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/observer/mutationobserver\n */\n/* globals window */\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { startsWithFiller, getDataWithoutFiller } from '../filler';\nimport { isEqualWith } from 'lodash-es';\n/**\n * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view\n * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.\n * Because all mutated nodes are marked as \"to be rendered\" and the\n * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the\n * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor\n * will block all changes which are not handled.\n *\n * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and\n * mutations on elements which do not have corresponding view elements. Also\n * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class MutationObserver extends Observer {\n    constructor(view) {\n        super(view);\n        /**\n         * Native mutation observer config.\n         *\n         * @private\n         * @member {Object}\n         */\n        this._config = {\n            childList: true,\n            characterData: true,\n            characterDataOldValue: true,\n            subtree: true\n        };\n        /**\n         * Reference to the {@link module:engine/view/view~View#domConverter}.\n         *\n         * @member {module:engine/view/domconverter~DomConverter}\n         */\n        this.domConverter = view.domConverter;\n        /**\n         * Reference to the {@link module:engine/view/view~View#_renderer}.\n         *\n         * @member {module:engine/view/renderer~Renderer}\n         */\n        this.renderer = view._renderer;\n        /**\n         * Observed DOM elements.\n         *\n         * @private\n         * @member {Array.<HTMLElement>}\n         */\n        this._domElements = [];\n        /**\n         * Native mutation observer.\n         *\n         * @private\n         * @member {MutationObserver}\n         */\n        this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));\n    }\n    /**\n     * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.\n     * At the same time empties the queue so mutations will not be fired twice.\n     */\n    flush() {\n        this._onMutations(this._mutationObserver.takeRecords());\n    }\n    /**\n     * @inheritDoc\n     */\n    observe(domElement) {\n        this._domElements.push(domElement);\n        if (this.isEnabled) {\n            this._mutationObserver.observe(domElement, this._config);\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    enable() {\n        super.enable();\n        for (const domElement of this._domElements) {\n            this._mutationObserver.observe(domElement, this._config);\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    disable() {\n        super.disable();\n        this._mutationObserver.disconnect();\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._mutationObserver.disconnect();\n    }\n    /**\n     * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.\n     *\n     * @private\n     * @param {Array.<Object>} domMutations Array of native mutations.\n     */\n    _onMutations(domMutations) {\n        // As a result of this.flush() we can have an empty collection.\n        if (domMutations.length === 0) {\n            return;\n        }\n        const domConverter = this.domConverter;\n        // Use map and set for deduplication.\n        const mutatedTexts = new Map();\n        const mutatedElements = new Set();\n        // Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the\n        // element with changed structure anyway.\n        for (const mutation of domMutations) {\n            if (mutation.type === 'childList') {\n                const element = domConverter.mapDomToView(mutation.target);\n                // Do not collect mutations from UIElements and RawElements.\n                if (element && (element.is('uiElement') || element.is('rawElement'))) {\n                    continue;\n                }\n                if (element && !this._isBogusBrMutation(mutation)) {\n                    mutatedElements.add(element);\n                }\n            }\n        }\n        // Handle `characterData` mutations later, when we have the full list of nodes which changed structure.\n        for (const mutation of domMutations) {\n            const element = domConverter.mapDomToView(mutation.target);\n            // Do not collect mutations from UIElements and RawElements.\n            if (element && (element.is('uiElement') || element.is('rawElement'))) {\n                continue;\n            }\n            if (mutation.type === 'characterData') {\n                const text = domConverter.findCorrespondingViewText(mutation.target);\n                if (text && !mutatedElements.has(text.parent)) {\n                    // Use text as a key, for deduplication. If there will be another mutation on the same text element\n                    // we will have only one in the map.\n                    mutatedTexts.set(text, {\n                        type: 'text',\n                        oldText: text.data,\n                        newText: getDataWithoutFiller(mutation.target),\n                        node: text\n                    });\n                }\n                // When we added first letter to the text node which had only inline filler, for the DOM it is mutation\n                // on text, but for the view, where filler text node did not existed, new text node was created, so we\n                // need to fire 'children' mutation instead of 'text'.\n                else if (!text && startsWithFiller(mutation.target)) {\n                    mutatedElements.add(domConverter.mapDomToView(mutation.target.parentNode));\n                }\n            }\n        }\n        // Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the\n        // same node multiple times in case of duplication.\n        // List of mutations we will fire.\n        const viewMutations = [];\n        for (const mutatedText of mutatedTexts.values()) {\n            this.renderer.markToSync('text', mutatedText.node);\n            viewMutations.push(mutatedText);\n        }\n        for (const viewElement of mutatedElements) {\n            const domElement = domConverter.mapViewToDom(viewElement);\n            const viewChildren = Array.from(viewElement.getChildren());\n            const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, { withChildren: false }));\n            // It may happen that as a result of many changes (sth was inserted and then removed),\n            // both elements haven't really changed. #1031\n            if (!isEqualWith(viewChildren, newViewChildren, sameNodes)) {\n                this.renderer.markToSync('children', viewElement);\n                viewMutations.push({\n                    type: 'children',\n                    oldChildren: viewChildren,\n                    newChildren: newViewChildren,\n                    node: viewElement\n                });\n            }\n        }\n        // Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.\n        // There should not be simultaneous mutation in multiple documents, so it's fine.\n        const domSelection = domMutations[0].target.ownerDocument.getSelection();\n        let viewSelection = null;\n        if (domSelection && domSelection.anchorNode) {\n            // If `domSelection` is inside a dom node that is already bound to a view node from view tree, get\n            // corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may\n            // be used by features handling mutations.\n            // Only one range is supported.\n            const viewSelectionAnchor = domConverter.domPositionToView(domSelection.anchorNode, domSelection.anchorOffset);\n            const viewSelectionFocus = domConverter.domPositionToView(domSelection.focusNode, domSelection.focusOffset);\n            // Anchor and focus has to be properly mapped to view.\n            if (viewSelectionAnchor && viewSelectionFocus) {\n                viewSelection = new ViewSelection(viewSelectionAnchor);\n                viewSelection.setFocus(viewSelectionFocus);\n            }\n        }\n        // In case only non-relevant mutations were recorded it skips the event and force render (#5600).\n        if (viewMutations.length) {\n            this.document.fire('mutations', viewMutations, viewSelection);\n            // If nothing changes on `mutations` event, at this point we have \"dirty DOM\" (changed) and de-synched\n            // view (which has not been changed). In order to \"reset DOM\" we render the view again.\n            this.view.forceRender();\n        }\n        function sameNodes(child1, child2) {\n            // First level of comparison (array of children vs array of children) – use the Lodash's default behavior.\n            if (Array.isArray(child1)) {\n                return;\n            }\n            // Elements.\n            if (child1 === child2) {\n                return true;\n            }\n            // Texts.\n            else if (child1.is('$text') && child2.is('$text')) {\n                return child1.data === child2.data;\n            }\n            // Not matching types.\n            return false;\n        }\n    }\n    /**\n     * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.\n     * Such mutations are generated while pressing space or performing native spellchecker correction\n     * on the end of the block element in Firefox browser.\n     *\n     * @private\n     * @param {Object} mutation Native mutation object.\n     * @returns {Boolean}\n     */\n    _isBogusBrMutation(mutation) {\n        let addedNode = null;\n        // Check if mutation added only one node on the end of its parent.\n        if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {\n            addedNode = this.domConverter.domToView(mutation.addedNodes[0], {\n                withChildren: false\n            });\n        }\n        return addedNode && addedNode.is('element', 'br');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}