{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/deletecontent\n */\nimport DocumentSelection from '../documentselection';\nimport LivePosition from '../liveposition';\nimport Range from '../range';\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** If there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n */\nexport default function deleteContent(model, selection) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (selection.isCollapsed) {\n    return;\n  }\n  const selRange = selection.getFirstRange();\n  // If the selection is already removed, don't do anything.\n  if (selRange.root.rootName == '$graveyard') {\n    return;\n  }\n  const schema = model.schema;\n  model.change(writer => {\n    // 1. Replace the entire content with paragraph.\n    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n      replaceEntireContentWithParagraph(writer, selection);\n      return;\n    }\n    // Collect attributes to copy in case of autoparagraphing.\n    const attributesForAutoparagraph = {};\n    if (!options.doNotAutoparagraph) {\n      const selectedElement = selection.getSelectedElement();\n      if (selectedElement) {\n        Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, 'copyOnReplace', true));\n      }\n    }\n    // Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n    const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange);\n    // 2. Remove the content if there is any.\n    if (!startPosition.isTouching(endPosition)) {\n      writer.remove(writer.createRange(startPosition, endPosition));\n    }\n    // 3. Merge elements in the right branch to the elements in the left branch.\n    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n    //\n    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n    //\n    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n    // want to override that behavior anyway.\n    if (!options.leaveUnmerged) {\n      mergeBranches(writer, startPosition, endPosition);\n      // TMP this will be replaced with a postfixer.\n      // We need to check and strip disallowed attributes in all nested nodes because after merge\n      // some attributes could end up in a path where are disallowed.\n      //\n      // e.g. bold is disallowed for <H1>\n      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);\n    }\n    collapseSelectionAt(writer, selection, startPosition);\n    // 4. Add a paragraph to set selection in it.\n    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n    // If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {\n      insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);\n    }\n    startPosition.detach();\n    endPosition.detach();\n  });\n}\n// Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\nfunction getLivePositionsForSelectedBlocks(range) {\n  const model = range.root.document.model;\n  const startPosition = range.start;\n  let endPosition = range.end;\n  // If the end of selection is at the start position of last block in the selection, then\n  // shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n  if (model.hasContent(range, {\n    ignoreMarkers: true\n  })) {\n    const endBlock = getParentBlock(endPosition);\n    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {\n      // Create forward selection as a probe to find a valid position after excluding last block from the range.\n      const selection = model.createSelection(range);\n      // Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n      // This is how modifySelection works and here we are making use of it.\n      model.modifySelection(selection, {\n        direction: 'backward'\n      });\n      const newEndPosition = selection.getLastPosition();\n      // For such a model and selection:\n      //     <paragraph>A[</paragraph><imageBlock></imageBlock><paragraph>]B</paragraph>\n      //\n      // After modifySelection(), we would end up with this:\n      //     <paragraph>A[</paragraph>]<imageBlock></imageBlock><paragraph>B</paragraph>\n      //\n      // So we need to check if there is no content in the skipped range (because we want to include the <imageBlock>).\n      const skippedRange = model.createRange(newEndPosition, endPosition);\n      if (!model.hasContent(skippedRange, {\n        ignoreMarkers: true\n      })) {\n        endPosition = newEndPosition;\n      }\n    }\n  }\n  return [LivePosition.fromPosition(startPosition, 'toPrevious'), LivePosition.fromPosition(endPosition, 'toNext')];\n}\n// Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\nfunction getParentBlock(position) {\n  const element = position.parent;\n  const schema = element.root.document.model.schema;\n  const ancestors = element.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n  for (const element of ancestors) {\n    if (schema.isLimit(element)) {\n      return null;\n    }\n    if (schema.isBlock(element)) {\n      return element;\n    }\n  }\n}\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches(writer, startPosition, endPosition) {\n  const model = writer.model;\n  // Verify if there is a need and possibility to merge.\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  }\n  // If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n  // then merge those to the right element so that it's properties are preserved (name, attributes).\n  // Because of OT merging is used instead of removing elements.\n  //\n  // Merge left:\n  //     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n  //     <paragraph>]bar</paragraph>  ->               --^\n  //\n  // Merge right:\n  //     <heading1>[</heading1>       ->\n  //     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n  //\n  // Merge left:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n  //         <paragraph>]bar</paragraph>  ->                   --^\n  //     </blockQuote>                    ->  </blockQuote>\n  //\n  // Merge right:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>[</heading1>       ->\n  //         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n  //     </blockQuote>                    ->  </blockQuote>\n  // Merging should not go deeper than common ancestor.\n  const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);\n  // Branches can't be merged if one of the positions is directly inside a common ancestor.\n  //\n  // Example:\n  //     <blockQuote>\n  //         <paragraph>[foo</paragraph>]\n  //         <table> ... </table>\n  //     <blockQuote>\n  //\n  if (!startAncestor || !endAncestor) {\n    return;\n  }\n  if (!model.hasContent(startAncestor, {\n    ignoreMarkers: true\n  }) && model.hasContent(endAncestor, {\n    ignoreMarkers: true\n  })) {\n    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);\n  } else {\n    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);\n  }\n}\n// Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\nfunction mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent;\n  // Merging reached the common ancestor element, stop here.\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  }\n  // Remember next positions to merge in next recursive step (also used as modification points pointers).\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement);\n  // Move endElement just after startElement if they aren't siblings.\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n    //     </blockQuote>                    ->  </blockQuote>                ^\n    //     <blockBlock>                     ->  <blockBlock>                 |\n    //         <paragraph>]bar</paragraph>  ->      ]                     ---\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(endElement, startPosition);\n  }\n  // Merge two siblings (nodes on sides of startPosition):\n  //\n  //     <blockQuote>                                             ->  <blockQuote>\n  //         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                                            ->  </blockQuote>\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         ]                                                    ->      ]\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n  //\n  writer.merge(startPosition);\n  // Remove empty end ancestors:\n  //\n  //     <blockQuote>                      ->  <blockQuote>\n  //         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                     ->  </blockQuote>\n  //     <blockBlock>                      ->\n  //         ]                             ->  ]\n  //     </blockBlock>                     ->\n  //\n  while (endPosition.parent.isEmpty) {\n    const parentToRemove = endPosition.parent;\n    endPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  }\n  // Verify if there is a need and possibility to merge next level.\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  }\n  // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);\n}\n// Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\nfunction mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent;\n  // Merging reached the common ancestor element, stop here.\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  }\n  // Remember next positions to merge in next recursive step (also used as modification points pointers).\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement);\n  // Move startElement just before endElement if they aren't siblings.\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      [                   ---\n    //     </blockQuote>                    ->  </blockQuote>              |\n    //     <blockBlock>                     ->  <blockBlock>               v\n    //         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(startElement, endPosition);\n  }\n  // Remove empty end ancestors:\n  //\n  //     <blockQuote>                                             ->\n  //         [                                                    ->  [\n  //     </blockQuote>                                            ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  while (startPosition.parent.isEmpty) {\n    const parentToRemove = startPosition.parent;\n    startPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  }\n  // Update endPosition after inserting and removing elements.\n  endPosition = writer.createPositionBefore(endElement);\n  // Merge right two siblings (nodes on sides of endPosition):\n  //                                                              ->\n  //     [                                                        ->  [\n  //                                                              ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n  //\n  mergeRight(writer, endPosition);\n  // Verify if there is a need and possibility to merge next level.\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  }\n  // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);\n}\n// There is no right merge operation so we need to simulate it.\nfunction mergeRight(writer, position) {\n  const startElement = position.nodeBefore;\n  const endElement = position.nodeAfter;\n  if (startElement.name != endElement.name) {\n    writer.rename(startElement, endElement.name);\n  }\n  writer.clearAttributes(startElement);\n  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);\n  writer.merge(position);\n}\n// Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\nfunction checkShouldMerge(schema, startPosition, endPosition) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent;\n  // If both positions ended up in the same parent, then there's nothing more to merge:\n  // <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n  if (startElement == endElement) {\n    return false;\n  }\n  // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {\n    return false;\n  }\n  // Check if operations we'll need to do won't need to cross object or limit boundaries.\n  // E.g., we can't merge endElement into startElement in this case:\n  // <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n  return isCrossingLimitElement(startPosition, endPosition, schema);\n}\n// Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\nfunction getAncestorsJustBelowCommonAncestor(positionA, positionB) {\n  const ancestorsA = positionA.getAncestors();\n  const ancestorsB = positionB.getAncestors();\n  let i = 0;\n  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {\n    i++;\n  }\n  return [ancestorsA[i], ancestorsB[i]];\n}\nfunction shouldAutoparagraph(schema, position) {\n  const isTextAllowed = schema.checkChild(position, '$text');\n  const isParagraphAllowed = schema.checkChild(position, 'paragraph');\n  return !isTextAllowed && isParagraphAllowed;\n}\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction isCrossingLimitElement(leftPos, rightPos, schema) {\n  const rangeToCheck = new Range(leftPos, rightPos);\n  for (const value of rangeToCheck.getWalker()) {\n    if (schema.isLimit(value.item)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction insertParagraph(writer, position, selection) {\n  let attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const paragraph = writer.createElement('paragraph');\n  writer.model.schema.setAllowedAttributes(paragraph, attributes, writer);\n  writer.insert(paragraph, position);\n  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\nfunction replaceEntireContentWithParagraph(writer, selection) {\n  const limitElement = writer.model.schema.getLimitElement(selection);\n  writer.remove(writer.createRangeIn(limitElement));\n  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n}\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n  const limitElement = schema.getLimitElement(selection);\n  if (!selection.containsEntireContent(limitElement)) {\n    return false;\n  }\n  const range = selection.getFirstRange();\n  if (range.start.parent == range.end.parent) {\n    return false;\n  }\n  return schema.checkChild(limitElement, 'paragraph');\n}\n// Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n  if (selection instanceof DocumentSelection) {\n    writer.setSelection(positionOrRange);\n  } else {\n    selection.setTo(positionOrRange);\n  }\n}","map":{"version":3,"names":["DocumentSelection","LivePosition","Range","deleteContent","model","selection","options","isCollapsed","selRange","getFirstRange","root","rootName","schema","change","writer","doNotResetEntireContent","shouldEntireContentBeReplacedWithParagraph","replaceEntireContentWithParagraph","attributesForAutoparagraph","doNotAutoparagraph","selectedElement","getSelectedElement","Object","assign","getAttributesWithProperty","startPosition","endPosition","getLivePositionsForSelectedBlocks","isTouching","remove","createRange","leaveUnmerged","mergeBranches","removeDisallowedAttributes","parent","getChildren","collapseSelectionAt","shouldAutoparagraph","insertParagraph","detach","range","document","start","end","hasContent","ignoreMarkers","endBlock","getParentBlock","createPositionAt","createSelection","modifySelection","direction","newEndPosition","getLastPosition","skippedRange","fromPosition","position","element","ancestors","getAncestors","parentFirst","includeSelf","isLimit","isBlock","checkShouldMerge","startAncestor","endAncestor","getAncestorsJustBelowCommonAncestor","mergeBranchesRight","mergeBranchesLeft","commonAncestor","startElement","endElement","createPositionAfter","createPositionBefore","isEqual","insert","merge","isEmpty","parentToRemove","mergeRight","nodeBefore","nodeAfter","name","rename","clearAttributes","setAttributes","fromEntries","getAttributes","isCrossingLimitElement","positionA","positionB","ancestorsA","ancestorsB","i","isTextAllowed","checkChild","isParagraphAllowed","leftPos","rightPos","rangeToCheck","value","getWalker","item","attributes","paragraph","createElement","setAllowedAttributes","limitElement","getLimitElement","createRangeIn","containsEntireContent","positionOrRange","setSelection","setTo"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/utils/deletecontent\n */\nimport DocumentSelection from '../documentselection';\nimport LivePosition from '../liveposition';\nimport Range from '../range';\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** If there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n */\nexport default function deleteContent(model, selection, options = {}) {\n    if (selection.isCollapsed) {\n        return;\n    }\n    const selRange = selection.getFirstRange();\n    // If the selection is already removed, don't do anything.\n    if (selRange.root.rootName == '$graveyard') {\n        return;\n    }\n    const schema = model.schema;\n    model.change(writer => {\n        // 1. Replace the entire content with paragraph.\n        // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n        if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n            replaceEntireContentWithParagraph(writer, selection);\n            return;\n        }\n        // Collect attributes to copy in case of autoparagraphing.\n        const attributesForAutoparagraph = {};\n        if (!options.doNotAutoparagraph) {\n            const selectedElement = selection.getSelectedElement();\n            if (selectedElement) {\n                Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, 'copyOnReplace', true));\n            }\n        }\n        // Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n        const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange);\n        // 2. Remove the content if there is any.\n        if (!startPosition.isTouching(endPosition)) {\n            writer.remove(writer.createRange(startPosition, endPosition));\n        }\n        // 3. Merge elements in the right branch to the elements in the left branch.\n        // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n        //\n        // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n        //\n        // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n        // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n        // want to override that behavior anyway.\n        if (!options.leaveUnmerged) {\n            mergeBranches(writer, startPosition, endPosition);\n            // TMP this will be replaced with a postfixer.\n            // We need to check and strip disallowed attributes in all nested nodes because after merge\n            // some attributes could end up in a path where are disallowed.\n            //\n            // e.g. bold is disallowed for <H1>\n            // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n            schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);\n        }\n        collapseSelectionAt(writer, selection, startPosition);\n        // 4. Add a paragraph to set selection in it.\n        // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n        // If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n        if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {\n            insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);\n        }\n        startPosition.detach();\n        endPosition.detach();\n    });\n}\n// Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\nfunction getLivePositionsForSelectedBlocks(range) {\n    const model = range.root.document.model;\n    const startPosition = range.start;\n    let endPosition = range.end;\n    // If the end of selection is at the start position of last block in the selection, then\n    // shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n    if (model.hasContent(range, { ignoreMarkers: true })) {\n        const endBlock = getParentBlock(endPosition);\n        if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {\n            // Create forward selection as a probe to find a valid position after excluding last block from the range.\n            const selection = model.createSelection(range);\n            // Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n            // This is how modifySelection works and here we are making use of it.\n            model.modifySelection(selection, { direction: 'backward' });\n            const newEndPosition = selection.getLastPosition();\n            // For such a model and selection:\n            //     <paragraph>A[</paragraph><imageBlock></imageBlock><paragraph>]B</paragraph>\n            //\n            // After modifySelection(), we would end up with this:\n            //     <paragraph>A[</paragraph>]<imageBlock></imageBlock><paragraph>B</paragraph>\n            //\n            // So we need to check if there is no content in the skipped range (because we want to include the <imageBlock>).\n            const skippedRange = model.createRange(newEndPosition, endPosition);\n            if (!model.hasContent(skippedRange, { ignoreMarkers: true })) {\n                endPosition = newEndPosition;\n            }\n        }\n    }\n    return [\n        LivePosition.fromPosition(startPosition, 'toPrevious'),\n        LivePosition.fromPosition(endPosition, 'toNext')\n    ];\n}\n// Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\nfunction getParentBlock(position) {\n    const element = position.parent;\n    const schema = element.root.document.model.schema;\n    const ancestors = element.getAncestors({ parentFirst: true, includeSelf: true });\n    for (const element of ancestors) {\n        if (schema.isLimit(element)) {\n            return null;\n        }\n        if (schema.isBlock(element)) {\n            return element;\n        }\n    }\n}\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches(writer, startPosition, endPosition) {\n    const model = writer.model;\n    // Verify if there is a need and possibility to merge.\n    if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n        return;\n    }\n    // If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n    // then merge those to the right element so that it's properties are preserved (name, attributes).\n    // Because of OT merging is used instead of removing elements.\n    //\n    // Merge left:\n    //     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n    //     <paragraph>]bar</paragraph>  ->               --^\n    //\n    // Merge right:\n    //     <heading1>[</heading1>       ->\n    //     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n    //\n    // Merge left:\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n    //         <paragraph>]bar</paragraph>  ->                   --^\n    //     </blockQuote>                    ->  </blockQuote>\n    //\n    // Merge right:\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>[</heading1>       ->\n    //         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n    //     </blockQuote>                    ->  </blockQuote>\n    // Merging should not go deeper than common ancestor.\n    const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);\n    // Branches can't be merged if one of the positions is directly inside a common ancestor.\n    //\n    // Example:\n    //     <blockQuote>\n    //         <paragraph>[foo</paragraph>]\n    //         <table> ... </table>\n    //     <blockQuote>\n    //\n    if (!startAncestor || !endAncestor) {\n        return;\n    }\n    if (!model.hasContent(startAncestor, { ignoreMarkers: true }) && model.hasContent(endAncestor, { ignoreMarkers: true })) {\n        mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);\n    }\n    else {\n        mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);\n    }\n}\n// Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\nfunction mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {\n    const startElement = startPosition.parent;\n    const endElement = endPosition.parent;\n    // Merging reached the common ancestor element, stop here.\n    if (startElement == commonAncestor || endElement == commonAncestor) {\n        return;\n    }\n    // Remember next positions to merge in next recursive step (also used as modification points pointers).\n    startPosition = writer.createPositionAfter(startElement);\n    endPosition = writer.createPositionBefore(endElement);\n    // Move endElement just after startElement if they aren't siblings.\n    if (!endPosition.isEqual(startPosition)) {\n        //\n        //     <blockQuote>                     ->  <blockQuote>\n        //         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n        //     </blockQuote>                    ->  </blockQuote>                ^\n        //     <blockBlock>                     ->  <blockBlock>                 |\n        //         <paragraph>]bar</paragraph>  ->      ]                     ---\n        //     </blockBlock>                    ->  </blockBlock>\n        //\n        writer.insert(endElement, startPosition);\n    }\n    // Merge two siblings (nodes on sides of startPosition):\n    //\n    //     <blockQuote>                                             ->  <blockQuote>\n    //         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n    //     </blockQuote>                                            ->  </blockQuote>\n    //     <blockBlock>                                             ->  <blockBlock>\n    //         ]                                                    ->      ]\n    //     </blockBlock>                                            ->  </blockBlock>\n    //\n    // Or in simple case (without moving elements in above if):\n    //     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n    //\n    writer.merge(startPosition);\n    // Remove empty end ancestors:\n    //\n    //     <blockQuote>                      ->  <blockQuote>\n    //         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n    //     </blockQuote>                     ->  </blockQuote>\n    //     <blockBlock>                      ->\n    //         ]                             ->  ]\n    //     </blockBlock>                     ->\n    //\n    while (endPosition.parent.isEmpty) {\n        const parentToRemove = endPosition.parent;\n        endPosition = writer.createPositionBefore(parentToRemove);\n        writer.remove(parentToRemove);\n    }\n    // Verify if there is a need and possibility to merge next level.\n    if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n        return;\n    }\n    // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n    mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);\n}\n// Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\nfunction mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {\n    const startElement = startPosition.parent;\n    const endElement = endPosition.parent;\n    // Merging reached the common ancestor element, stop here.\n    if (startElement == commonAncestor || endElement == commonAncestor) {\n        return;\n    }\n    // Remember next positions to merge in next recursive step (also used as modification points pointers).\n    startPosition = writer.createPositionAfter(startElement);\n    endPosition = writer.createPositionBefore(endElement);\n    // Move startElement just before endElement if they aren't siblings.\n    if (!endPosition.isEqual(startPosition)) {\n        //\n        //     <blockQuote>                     ->  <blockQuote>\n        //         <heading1>foo[</heading1>    ->      [                   ---\n        //     </blockQuote>                    ->  </blockQuote>              |\n        //     <blockBlock>                     ->  <blockBlock>               v\n        //         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n        //     </blockBlock>                    ->  </blockBlock>\n        //\n        writer.insert(startElement, endPosition);\n    }\n    // Remove empty end ancestors:\n    //\n    //     <blockQuote>                                             ->\n    //         [                                                    ->  [\n    //     </blockQuote>                                            ->\n    //     <blockBlock>                                             ->  <blockBlock>\n    //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n    //     </blockBlock>                                            ->  </blockBlock>\n    //\n    while (startPosition.parent.isEmpty) {\n        const parentToRemove = startPosition.parent;\n        startPosition = writer.createPositionBefore(parentToRemove);\n        writer.remove(parentToRemove);\n    }\n    // Update endPosition after inserting and removing elements.\n    endPosition = writer.createPositionBefore(endElement);\n    // Merge right two siblings (nodes on sides of endPosition):\n    //                                                              ->\n    //     [                                                        ->  [\n    //                                                              ->\n    //     <blockBlock>                                             ->  <blockBlock>\n    //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n    //     </blockBlock>                                            ->  </blockBlock>\n    //\n    // Or in simple case (without moving elements in above if):\n    //     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n    //\n    mergeRight(writer, endPosition);\n    // Verify if there is a need and possibility to merge next level.\n    if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n        return;\n    }\n    // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n    mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);\n}\n// There is no right merge operation so we need to simulate it.\nfunction mergeRight(writer, position) {\n    const startElement = position.nodeBefore;\n    const endElement = position.nodeAfter;\n    if (startElement.name != endElement.name) {\n        writer.rename(startElement, endElement.name);\n    }\n    writer.clearAttributes(startElement);\n    writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);\n    writer.merge(position);\n}\n// Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\nfunction checkShouldMerge(schema, startPosition, endPosition) {\n    const startElement = startPosition.parent;\n    const endElement = endPosition.parent;\n    // If both positions ended up in the same parent, then there's nothing more to merge:\n    // <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n    if (startElement == endElement) {\n        return false;\n    }\n    // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n    if (schema.isLimit(startElement) || schema.isLimit(endElement)) {\n        return false;\n    }\n    // Check if operations we'll need to do won't need to cross object or limit boundaries.\n    // E.g., we can't merge endElement into startElement in this case:\n    // <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n    return isCrossingLimitElement(startPosition, endPosition, schema);\n}\n// Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\nfunction getAncestorsJustBelowCommonAncestor(positionA, positionB) {\n    const ancestorsA = positionA.getAncestors();\n    const ancestorsB = positionB.getAncestors();\n    let i = 0;\n    while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {\n        i++;\n    }\n    return [ancestorsA[i], ancestorsB[i]];\n}\nfunction shouldAutoparagraph(schema, position) {\n    const isTextAllowed = schema.checkChild(position, '$text');\n    const isParagraphAllowed = schema.checkChild(position, 'paragraph');\n    return !isTextAllowed && isParagraphAllowed;\n}\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction isCrossingLimitElement(leftPos, rightPos, schema) {\n    const rangeToCheck = new Range(leftPos, rightPos);\n    for (const value of rangeToCheck.getWalker()) {\n        if (schema.isLimit(value.item)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction insertParagraph(writer, position, selection, attributes = {}) {\n    const paragraph = writer.createElement('paragraph');\n    writer.model.schema.setAllowedAttributes(paragraph, attributes, writer);\n    writer.insert(paragraph, position);\n    collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\nfunction replaceEntireContentWithParagraph(writer, selection) {\n    const limitElement = writer.model.schema.getLimitElement(selection);\n    writer.remove(writer.createRangeIn(limitElement));\n    insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n}\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n    const limitElement = schema.getLimitElement(selection);\n    if (!selection.containsEntireContent(limitElement)) {\n        return false;\n    }\n    const range = selection.getFirstRange();\n    if (range.start.parent == range.end.parent) {\n        return false;\n    }\n    return schema.checkChild(limitElement, 'paragraph');\n}\n// Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n    if (selection instanceof DocumentSelection) {\n        writer.setSelection(positionOrRange);\n    }\n    else {\n        selection.setTo(positionOrRange);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}