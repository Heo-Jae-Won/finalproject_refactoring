{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/observer/selectionobserver\n */\n/* global setInterval, clearInterval */\nimport Observer from './observer';\nimport MutationObserver from './mutationobserver';\nimport { debounce } from 'lodash-es';\n/**\n * Selection observer class observes selection changes in the document. If a selection changes on the document this\n * observer checks if there are any mutations and if the DOM selection is different from the\n * {@link module:engine/view/document~Document#selection view selection}. The selection observer fires\n * {@link module:engine/view/document~Document#event:selectionChange} event only if a selection change was the only change in the document\n * and the DOM selection is different then the view selection.\n *\n * This observer also manages the {@link module:engine/view/document~Document#isSelecting} property of the view document.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class SelectionObserver extends Observer {\n  constructor(view) {\n    super(view);\n    /**\n     * Instance of the mutation observer. Selection observer calls\n     * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled\n     * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.\n     *\n     * @readonly\n     * @member {module:engine/view/observer/mutationobserver~MutationObserver}\n     * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver\n     */\n    this.mutationObserver = view.getObserver(MutationObserver);\n    /**\n     * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare\n     * new selection with it.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     * module:engine/view/observer/selectionobserver~SelectionObserver#selection\n     */\n    this.selection = this.document.selection;\n    /* eslint-disable max-len */\n    /**\n     * Reference to the {@link module:engine/view/view~View#domConverter}.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter\n     */\n    /* eslint-enable max-len */\n    this.domConverter = view.domConverter;\n    /**\n     * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same\n     * document.\n     *\n     * @private\n     * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents\n     */\n    this._documents = new WeakSet();\n    /**\n     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n     *\n     * @private\n     * @param {Object} data Selection change data.\n     * @method #_fireSelectionChangeDoneDebounced\n     */\n    this._fireSelectionChangeDoneDebounced = debounce(data => {\n      this.document.fire('selectionChangeDone', data);\n    }, 200);\n    /**\n     * When called, starts clearing the {@link #_loopbackCounter} counter in time intervals. When the number of selection\n     * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about\n     * possible infinite selection loop.\n     *\n     * @private\n     * @member {Number} #_clearInfiniteLoopInterval\n     */\n    this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1000);\n    /**\n     * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact\n     * correctly (for whatever reason). It is a safeguard (paranoid check), that returns document to the normal state\n     * after a certain period of time (debounced, postponed by each selectionchange event).\n     *\n     * @private\n     * @method #_documentIsSelectingInactivityTimeoutDebounced\n     */\n    this._documentIsSelectingInactivityTimeoutDebounced = debounce(() => this.document.isSelecting = false, 5000);\n    /**\n     * Private property to check if the code does not enter infinite loop.\n     *\n     * @private\n     * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter\n     */\n    this._loopbackCounter = 0;\n  }\n  /**\n   * @inheritDoc\n   */\n  observe(domElement) {\n    const domDocument = domElement.ownerDocument;\n    const startDocumentIsSelecting = () => {\n      this.document.isSelecting = true;\n      // Let's activate the safety timeout each time the document enters the \"is selecting\" state.\n      this._documentIsSelectingInactivityTimeoutDebounced();\n    };\n    const endDocumentIsSelecting = () => {\n      if (!this.document.isSelecting) {\n        return;\n      }\n      // Make sure that model selection is up-to-date at the end of selecting process.\n      // Sometimes `selectionchange` events could arrive after the `mouseup` event and that selection could be already outdated.\n      this._handleSelectionChange(null, domDocument);\n      this.document.isSelecting = false;\n      // The safety timeout can be canceled when the document leaves the \"is selecting\" state.\n      this._documentIsSelectingInactivityTimeoutDebounced.cancel();\n    };\n    // The document has the \"is selecting\" state while the user keeps making (extending) the selection\n    // (e.g. by holding the mouse button and moving the cursor). The state resets when they either released\n    // the mouse button or interrupted the process by pressing or releasing any key.\n    this.listenTo(domElement, 'selectstart', startDocumentIsSelecting, {\n      priority: 'highest'\n    });\n    this.listenTo(domElement, 'keydown', endDocumentIsSelecting, {\n      priority: 'highest',\n      useCapture: true\n    });\n    this.listenTo(domElement, 'keyup', endDocumentIsSelecting, {\n      priority: 'highest',\n      useCapture: true\n    });\n    // Add document-wide listeners only once. This method could be called for multiple editing roots.\n    if (this._documents.has(domDocument)) {\n      return;\n    }\n    // This listener is using capture mode to make sure that selection is upcasted before any other\n    // handler would like to check it and update (for example table multi cell selection).\n    this.listenTo(domDocument, 'mouseup', endDocumentIsSelecting, {\n      priority: 'highest',\n      useCapture: true\n    });\n    this.listenTo(domDocument, 'selectionchange', (evt, domEvent) => {\n      this._handleSelectionChange(domEvent, domDocument);\n      // Defer the safety timeout when the selection changes (e.g. the user keeps extending the selection\n      // using their mouse).\n      this._documentIsSelectingInactivityTimeoutDebounced();\n    });\n    this._documents.add(domDocument);\n  }\n  /**\n   * @inheritDoc\n   */\n  destroy() {\n    super.destroy();\n    clearInterval(this._clearInfiniteLoopInterval);\n    this._fireSelectionChangeDoneDebounced.cancel();\n    this._documentIsSelectingInactivityTimeoutDebounced.cancel();\n  }\n  /**\n   * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if\n   * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change\n   * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.\n   *\n   * @private\n   * @param {Event} domEvent DOM event.\n   * @param {Document} domDocument DOM document.\n   */\n  _handleSelectionChange(domEvent, domDocument) {\n    if (!this.isEnabled) {\n      return;\n    }\n    const domSelection = domDocument.defaultView.getSelection();\n    if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {\n      return;\n    }\n    // Ensure the mutation event will be before selection event on all browsers.\n    this.mutationObserver.flush();\n    // If there were mutations then the view will be re-rendered by the mutation observer and the selection\n    // will be updated, so the selections will equal and the event will not be fired, as expected.\n    const newViewSelection = this.domConverter.domSelectionToView(domSelection);\n    // Do not convert selection change if the new view selection has no ranges in it.\n    //\n    // It means that the DOM selection is in some way incorrect. Ranges that were in the DOM selection could not be\n    // converted to the view. This happens when the DOM selection was moved outside of the editable element.\n    if (newViewSelection.rangeCount == 0) {\n      this.view.hasDomSelection = false;\n      return;\n    }\n    this.view.hasDomSelection = true;\n    if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {\n      return;\n    }\n    // Ensure we are not in the infinite loop (#400).\n    // This counter is reset each second. 60 selection changes in 1 second is enough high number\n    // to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).\n    if (++this._loopbackCounter > 60) {\n      // Selection change observer detected an infinite rendering loop.\n      // Most probably you try to put the selection in the position which is not allowed\n      // by the browser and browser fixes it automatically what causes `selectionchange` event on\n      // which a loopback through a model tries to re-render the wrong selection and again.\n      //\n      // @if CK_DEBUG // console.warn( 'Selection change observer detected an infinite rendering loop.' );\n      return;\n    }\n    if (this.selection.isSimilar(newViewSelection)) {\n      // If selection was equal and we are at this point of algorithm, it means that it was incorrect.\n      // Just re-render it, no need to fire any events, etc.\n      this.view.forceRender();\n    } else {\n      const data = {\n        oldSelection: this.selection,\n        newSelection: newViewSelection,\n        domSelection: domSelection\n      };\n      // Prepare data for new selection and fire appropriate events.\n      this.document.fire('selectionChange', data);\n      // Call `#_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n      // This function is debounced what means that `selectionChangeDone` event will be fired only when\n      // defined int the function time will elapse since the last time the function was called.\n      // So `selectionChangeDone` will be fired when selection will stop changing.\n      this._fireSelectionChangeDoneDebounced(data);\n    }\n  }\n  /**\n   * Clears `SelectionObserver` internal properties connected with preventing infinite loop.\n   *\n   * @protected\n   */\n  _clearInfiniteLoop() {\n    this._loopbackCounter = 0;\n  }\n}\n/**\n * Fired when selection stops changing.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChangeDone\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */","map":{"version":3,"names":["Observer","MutationObserver","debounce","SelectionObserver","constructor","view","mutationObserver","getObserver","selection","document","domConverter","_documents","WeakSet","_fireSelectionChangeDoneDebounced","data","fire","_clearInfiniteLoopInterval","setInterval","_clearInfiniteLoop","_documentIsSelectingInactivityTimeoutDebounced","isSelecting","_loopbackCounter","observe","domElement","domDocument","ownerDocument","startDocumentIsSelecting","endDocumentIsSelecting","_handleSelectionChange","cancel","listenTo","priority","useCapture","has","evt","domEvent","add","destroy","clearInterval","isEnabled","domSelection","defaultView","getSelection","checkShouldIgnoreEventFromTarget","anchorNode","flush","newViewSelection","domSelectionToView","rangeCount","hasDomSelection","isEqual","isDomSelectionCorrect","isSimilar","forceRender","oldSelection","newSelection"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/selectionobserver.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/observer/selectionobserver\n */\n/* global setInterval, clearInterval */\nimport Observer from './observer';\nimport MutationObserver from './mutationobserver';\nimport { debounce } from 'lodash-es';\n/**\n * Selection observer class observes selection changes in the document. If a selection changes on the document this\n * observer checks if there are any mutations and if the DOM selection is different from the\n * {@link module:engine/view/document~Document#selection view selection}. The selection observer fires\n * {@link module:engine/view/document~Document#event:selectionChange} event only if a selection change was the only change in the document\n * and the DOM selection is different then the view selection.\n *\n * This observer also manages the {@link module:engine/view/document~Document#isSelecting} property of the view document.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class SelectionObserver extends Observer {\n    constructor(view) {\n        super(view);\n        /**\n         * Instance of the mutation observer. Selection observer calls\n         * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled\n         * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.\n         *\n         * @readonly\n         * @member {module:engine/view/observer/mutationobserver~MutationObserver}\n         * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver\n         */\n        this.mutationObserver = view.getObserver(MutationObserver);\n        /**\n         * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare\n         * new selection with it.\n         *\n         * @readonly\n         * @member {module:engine/view/documentselection~DocumentSelection}\n         * module:engine/view/observer/selectionobserver~SelectionObserver#selection\n         */\n        this.selection = this.document.selection;\n        /* eslint-disable max-len */\n        /**\n         * Reference to the {@link module:engine/view/view~View#domConverter}.\n         *\n         * @readonly\n         * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter\n         */\n        /* eslint-enable max-len */\n        this.domConverter = view.domConverter;\n        /**\n         * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same\n         * document.\n         *\n         * @private\n         * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents\n         */\n        this._documents = new WeakSet();\n        /**\n         * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n         *\n         * @private\n         * @param {Object} data Selection change data.\n         * @method #_fireSelectionChangeDoneDebounced\n         */\n        this._fireSelectionChangeDoneDebounced = debounce(data => {\n            this.document.fire('selectionChangeDone', data);\n        }, 200);\n        /**\n         * When called, starts clearing the {@link #_loopbackCounter} counter in time intervals. When the number of selection\n         * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about\n         * possible infinite selection loop.\n         *\n         * @private\n         * @member {Number} #_clearInfiniteLoopInterval\n         */\n        this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1000);\n        /**\n         * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact\n         * correctly (for whatever reason). It is a safeguard (paranoid check), that returns document to the normal state\n         * after a certain period of time (debounced, postponed by each selectionchange event).\n         *\n         * @private\n         * @method #_documentIsSelectingInactivityTimeoutDebounced\n         */\n        this._documentIsSelectingInactivityTimeoutDebounced = debounce(() => (this.document.isSelecting = false), 5000);\n        /**\n         * Private property to check if the code does not enter infinite loop.\n         *\n         * @private\n         * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter\n         */\n        this._loopbackCounter = 0;\n    }\n    /**\n     * @inheritDoc\n     */\n    observe(domElement) {\n        const domDocument = domElement.ownerDocument;\n        const startDocumentIsSelecting = () => {\n            this.document.isSelecting = true;\n            // Let's activate the safety timeout each time the document enters the \"is selecting\" state.\n            this._documentIsSelectingInactivityTimeoutDebounced();\n        };\n        const endDocumentIsSelecting = () => {\n            if (!this.document.isSelecting) {\n                return;\n            }\n            // Make sure that model selection is up-to-date at the end of selecting process.\n            // Sometimes `selectionchange` events could arrive after the `mouseup` event and that selection could be already outdated.\n            this._handleSelectionChange(null, domDocument);\n            this.document.isSelecting = false;\n            // The safety timeout can be canceled when the document leaves the \"is selecting\" state.\n            this._documentIsSelectingInactivityTimeoutDebounced.cancel();\n        };\n        // The document has the \"is selecting\" state while the user keeps making (extending) the selection\n        // (e.g. by holding the mouse button and moving the cursor). The state resets when they either released\n        // the mouse button or interrupted the process by pressing or releasing any key.\n        this.listenTo(domElement, 'selectstart', startDocumentIsSelecting, { priority: 'highest' });\n        this.listenTo(domElement, 'keydown', endDocumentIsSelecting, { priority: 'highest', useCapture: true });\n        this.listenTo(domElement, 'keyup', endDocumentIsSelecting, { priority: 'highest', useCapture: true });\n        // Add document-wide listeners only once. This method could be called for multiple editing roots.\n        if (this._documents.has(domDocument)) {\n            return;\n        }\n        // This listener is using capture mode to make sure that selection is upcasted before any other\n        // handler would like to check it and update (for example table multi cell selection).\n        this.listenTo(domDocument, 'mouseup', endDocumentIsSelecting, { priority: 'highest', useCapture: true });\n        this.listenTo(domDocument, 'selectionchange', (evt, domEvent) => {\n            this._handleSelectionChange(domEvent, domDocument);\n            // Defer the safety timeout when the selection changes (e.g. the user keeps extending the selection\n            // using their mouse).\n            this._documentIsSelectingInactivityTimeoutDebounced();\n        });\n        this._documents.add(domDocument);\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        clearInterval(this._clearInfiniteLoopInterval);\n        this._fireSelectionChangeDoneDebounced.cancel();\n        this._documentIsSelectingInactivityTimeoutDebounced.cancel();\n    }\n    /**\n     * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if\n     * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change\n     * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.\n     *\n     * @private\n     * @param {Event} domEvent DOM event.\n     * @param {Document} domDocument DOM document.\n     */\n    _handleSelectionChange(domEvent, domDocument) {\n        if (!this.isEnabled) {\n            return;\n        }\n        const domSelection = domDocument.defaultView.getSelection();\n        if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {\n            return;\n        }\n        // Ensure the mutation event will be before selection event on all browsers.\n        this.mutationObserver.flush();\n        // If there were mutations then the view will be re-rendered by the mutation observer and the selection\n        // will be updated, so the selections will equal and the event will not be fired, as expected.\n        const newViewSelection = this.domConverter.domSelectionToView(domSelection);\n        // Do not convert selection change if the new view selection has no ranges in it.\n        //\n        // It means that the DOM selection is in some way incorrect. Ranges that were in the DOM selection could not be\n        // converted to the view. This happens when the DOM selection was moved outside of the editable element.\n        if (newViewSelection.rangeCount == 0) {\n            this.view.hasDomSelection = false;\n            return;\n        }\n        this.view.hasDomSelection = true;\n        if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {\n            return;\n        }\n        // Ensure we are not in the infinite loop (#400).\n        // This counter is reset each second. 60 selection changes in 1 second is enough high number\n        // to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).\n        if (++this._loopbackCounter > 60) {\n            // Selection change observer detected an infinite rendering loop.\n            // Most probably you try to put the selection in the position which is not allowed\n            // by the browser and browser fixes it automatically what causes `selectionchange` event on\n            // which a loopback through a model tries to re-render the wrong selection and again.\n            //\n            // @if CK_DEBUG // console.warn( 'Selection change observer detected an infinite rendering loop.' );\n            return;\n        }\n        if (this.selection.isSimilar(newViewSelection)) {\n            // If selection was equal and we are at this point of algorithm, it means that it was incorrect.\n            // Just re-render it, no need to fire any events, etc.\n            this.view.forceRender();\n        }\n        else {\n            const data = {\n                oldSelection: this.selection,\n                newSelection: newViewSelection,\n                domSelection: domSelection\n            };\n            // Prepare data for new selection and fire appropriate events.\n            this.document.fire('selectionChange', data);\n            // Call `#_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n            // This function is debounced what means that `selectionChangeDone` event will be fired only when\n            // defined int the function time will elapse since the last time the function was called.\n            // So `selectionChangeDone` will be fired when selection will stop changing.\n            this._fireSelectionChangeDoneDebounced(data);\n        }\n    }\n    /**\n     * Clears `SelectionObserver` internal properties connected with preventing infinite loop.\n     *\n     * @protected\n     */\n    _clearInfiniteLoop() {\n        this._loopbackCounter = 0;\n    }\n}\n/**\n * Fired when selection stops changing.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChangeDone\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}