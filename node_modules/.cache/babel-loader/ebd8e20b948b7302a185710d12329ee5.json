{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/controller/datacontroller\n */\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertAttributesAndChildren, insertText } from '../conversion/downcasthelpers';\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using the given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class DataController extends Emitter {\n  /**\n   * Creates a data controller instance.\n   *\n   * @param {module:engine/model/model~Model} model Data model.\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  constructor(model, stylesProcessor) {\n    super();\n    /**\n     * Data model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and\n     * ae cleared directly after the data are converted. However, the mapper is defined as a class property, because\n     * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n     *\n     * @readonly\n     * @member {module:engine/conversion/mapper~Mapper}\n     */\n    this.mapper = new Mapper();\n    /**\n     * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n     */\n    this.downcastDispatcher = new DowncastDispatcher({\n      mapper: this.mapper,\n      schema: model.schema\n    });\n    this.downcastDispatcher.on('insert:$text', insertText(), {\n      priority: 'lowest'\n    });\n    this.downcastDispatcher.on('insert', insertAttributesAndChildren(), {\n      priority: 'lowest'\n    });\n    /**\n     * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n     */\n    this.upcastDispatcher = new UpcastDispatcher({\n      schema: model.schema\n    });\n    /**\n     * The view document used by the data controller.\n     *\n     * @readonly\n     * @member {module:engine/view/document~Document}\n     */\n    this.viewDocument = new ViewDocument(stylesProcessor);\n    /**\n     * Styles processor used during the conversion.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Data processor used specifically for HTML conversion.\n     *\n     * @readonly\n     * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n     */\n    this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);\n    /**\n     * Data processor used during the conversion.\n     * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n     *\n     * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n     */\n    this.processor = this.htmlProcessor;\n    /**\n     * The view downcast writer just for data conversion purposes, i.e. to modify\n     * the {@link #viewDocument}.\n     *\n     * @private\n     * @readonly\n     * @member {module:engine/view/downcastwriter~DowncastWriter}\n     */\n    this._viewWriter = new ViewDowncastWriter(this.viewDocument);\n    // Define default converters for text and elements.\n    //\n    // Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n    // converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n    // element to the document fragment so `<b>foo</b>` will still be converted to `foo` even if there is no converter for `<b>`.\n    this.upcastDispatcher.on('text', convertText(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('element', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('documentFragment', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    Observable.prototype.decorate.call(this, 'init');\n    Observable.prototype.decorate.call(this, 'set');\n    Observable.prototype.decorate.call(this, 'get');\n    // Fire the `ready` event when the initialization has completed. Such low-level listener offers the possibility\n    // to plug into the initialization pipeline without interrupting the initialization flow.\n    this.on('init', () => {\n      this.fire('ready');\n    }, {\n      priority: 'lowest'\n    });\n    // Fix empty roots after DataController is 'ready' (note that the init method could be decorated and stopped).\n    // We need to handle this event because initial data could be empty and the post-fixer would not get triggered.\n    this.on('ready', () => {\n      this.model.enqueueChange({\n        isUndoable: false\n      }, autoParagraphEmptyRoots);\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n   * formatted by the {@link #processor data processor}.\n   *\n   * @fires get\n   * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n   * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n   * @param {String} [options.rootName='main'] Root name.\n   * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n   * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).\n   * @returns {String} Output data.\n   */\n  get() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      rootName = 'main',\n      trim = 'empty'\n    } = options;\n    if (!this._checkIfRootsExists([rootName])) {\n      /**\n       * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n       * is called with a non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #get} like:\n       *\n       *\t\tdata.get( { rootName: 'root2' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-get-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-get-non-existent-root', this);\n    }\n    const root = this.model.document.getRoot(rootName);\n    if (trim === 'empty' && !this.model.hasContent(root, {\n      ignoreWhitespaces: true\n    })) {\n      return '';\n    }\n    return this.stringify(root, options);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n   * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * The element whose content will be stringified.\n   * @param {Object} [options] Additional configuration passed to the conversion process.\n   * @returns {String} Output data.\n   */\n  stringify(modelElementOrFragment) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Model -> view.\n    const viewDocumentFragment = this.toView(modelElementOrFragment, options);\n    // View -> data.\n    return this.processor.toData(viewDocumentFragment);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n   * converters attached to {@link #downcastDispatcher} into a\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * Element or document fragment whose content will be converted.\n   * @param {Object} [options={}] Additional configuration that will be available through the\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n   */\n  toView(modelElementOrFragment) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const viewDocument = this.viewDocument;\n    const viewWriter = this._viewWriter;\n    // Clear bindings so the call to this method returns correct results.\n    this.mapper.clearBindings();\n    // First, convert elements.\n    const modelRange = ModelRange._createIn(modelElementOrFragment);\n    const viewDocumentFragment = new ViewDocumentFragment(viewDocument);\n    this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment);\n    // Prepare list of markers.\n    // For document fragment, simply take the markers assigned to this document fragment.\n    // For model root, all markers in that root will be taken.\n    // For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n    // Collapsed markers at element boundary, although considered as not intersecting with the element, will also be returned.\n    const markers = modelElementOrFragment.is('documentFragment') ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);\n    this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);\n    return viewDocumentFragment;\n  }\n  /**\n   * Sets the initial input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.\n   *\n   * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n   * used by e.g. collaborative editing plugin that syncs remote data on init.\n   *\n   * When data is passed as a string, it is initialized on the default `main` root:\n   *\n   *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.\n   *\n   * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.\n   *\n   * @fires init\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n   * pairs to initialize data on multiple roots at once.\n   * @returns {Promise} Promise that is resolved after the data is set on the editor.\n   */\n  init(data) {\n    if (this.model.document.version) {\n      /**\n       * Cannot set initial data to a non-empty {@link module:engine/model/document~Document}.\n       * Initial data should be set once, during the {@link module:core/editor/editor~Editor} initialization,\n       * when the {@link module:engine/model/document~Document#version} is equal 0.\n       *\n       * @error datacontroller-init-document-not-empty\n       */\n      throw new CKEditorError('datacontroller-init-document-not-empty', this);\n    }\n    let initialData = {};\n    if (typeof data === 'string') {\n      initialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n    } else {\n      initialData = data;\n    }\n    if (!this._checkIfRootsExists(Object.keys(initialData))) {\n      /**\n       * Cannot init data on a non-existent root. This error is thrown when {@link #init DataController#init() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #init} like:\n       *\n       * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-init-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-init-non-existent-root', this);\n    }\n    this.model.enqueueChange({\n      isUndoable: false\n    }, writer => {\n      for (const rootName of Object.keys(initialData)) {\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n    return Promise.resolve();\n  }\n  /**\n   * Sets the input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * This method can be used any time to replace existing editor data with the new one without clearing the\n   * {@link module:engine/model/document~Document#history document history}.\n   *\n   * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n   * the {@link #parse} method.\n   *\n   * When data is passed as a string it is set on the default `main` root:\n   *\n   *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.\n   *\n   * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.\n   *\n   * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.\n   *\n   *\t\tdataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );\n   *\n   * @fires set\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n   * pairs to set data on multiple roots at once.\n   * @param {Object} [options={}] Options for setting data.\n   * @param {Object} [options.batchType] The batch type that will be used to create a batch for the changes applied by this method.\n   * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be\n   * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,\n   * the undo stack will be preserved instead and not cleared when new data is applied.\n   */\n  set(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let newData = {};\n    if (typeof data === 'string') {\n      newData.main = data; // The default root is 'main'. To set data on a different root, an object should be passed.\n    } else {\n      newData = data;\n    }\n    if (!this._checkIfRootsExists(Object.keys(newData))) {\n      /**\n       * Cannot set data on a non-existent root. This error is thrown when the {@link #set DataController#set() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only the default `main` root,\n       * calling {@link #set} like:\n       *\n       * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-set-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-set-non-existent-root', this);\n    }\n    this.model.enqueueChange(options.batchType || {}, writer => {\n      writer.setSelection(null);\n      writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());\n      for (const rootName of Object.keys(newData)) {\n        // Save to model.\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.remove(writer.createRangeIn(modelRoot));\n        writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n  }\n  /**\n   * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n   * attached to the {@link #upcastDispatcher}.\n   *\n   * @see #set\n   * @param {String} data Data to parse.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n   */\n  parse(data) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n    // data -> view\n    const viewDocumentFragment = this.processor.toView(data);\n    // view -> model\n    return this.toModel(viewDocumentFragment, context);\n  }\n  /**\n   * Returns the result of the given {@link module:engine/view/element~Element view element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n   * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n   *\n   * When marker elements were converted during the conversion process, it will be set as a document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n   * The element or document fragment whose content will be converted.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n   */\n  toModel(viewElementOrFragment) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n    return this.model.change(writer => {\n      return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);\n    });\n  }\n  /**\n   * Adds the style processor normalization rules.\n   *\n   * You can implement your own rules as well as use one of the available processor rules:\n   *\n   * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n   * * border: {@link module:engine/view/styles/border~addBorderRules}\n   * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n   * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n   *\n   * @param {Function} callback\n   */\n  addStyleProcessorRules(callback) {\n    callback(this.stylesProcessor);\n  }\n  /**\n   * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}\n   * and a {@link #processor processor} for view elements whose content should be treated as raw data\n   * and not processed during the conversion from DOM to view elements.\n   *\n   * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n   * `\"$rawContent\"`.\n   *\n   * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n   * be treated as a raw data.\n   */\n  registerRawContentMatcher(pattern) {\n    // No need to register the pattern if both the `htmlProcessor` and `processor` are the same instances.\n    if (this.processor && this.processor !== this.htmlProcessor) {\n      this.processor.registerRawContentMatcher(pattern);\n    }\n    this.htmlProcessor.registerRawContentMatcher(pattern);\n  }\n  /**\n   * Removes all event listeners set by the DataController.\n   */\n  destroy() {\n    this.stopListening();\n  }\n  /**\n   * Checks whether all provided root names are actually existing editor roots.\n   *\n   * @private\n   * @param {Array.<String>} rootNames Root names to check.\n   * @returns {Boolean} Whether all provided root names are existing editor roots.\n   */\n  _checkIfRootsExists(rootNames) {\n    for (const rootName of rootNames) {\n      if (!this.model.document.getRootNames().includes(rootName)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it. If the marker is collapsed\n// at element boundary, it is considered as contained inside the element and marker range is returned. Otherwise, if the marker is\n// intersecting with the element, the intersection is returned.\nfunction _getMarkersRelativeToElement(element) {\n  const result = [];\n  const doc = element.root.document;\n  if (!doc) {\n    return new Map();\n  }\n  const elementRange = ModelRange._createIn(element);\n  for (const marker of doc.model.markers) {\n    const markerRange = marker.getRange();\n    const isMarkerCollapsed = markerRange.isCollapsed;\n    const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);\n    if (isMarkerCollapsed && isMarkerAtElementBoundary) {\n      result.push([marker.name, markerRange]);\n    } else {\n      const updatedMarkerRange = elementRange.getIntersection(markerRange);\n      if (updatedMarkerRange) {\n        result.push([marker.name, updatedMarkerRange]);\n      }\n    }\n  }\n  // Sort the markers in a stable fashion to ensure that the order in which they are\n  // added to the model's marker collection does not affect how they are\n  // downcast. One particular use case that we are targeting here, is one where\n  // two markers are adjacent but not overlapping, such as an insertion/deletion\n  // suggestion pair representing the replacement of a range of text. In this\n  // case, putting the markers in DOM order causes the first marker's end to be\n  // serialized right after the second marker's start, while putting the markers\n  // in reverse DOM order causes it to be right before the second marker's\n  // start. So, we sort these in a way that ensures non-intersecting ranges are in\n  // reverse DOM order, and intersecting ranges are in something approximating\n  // reverse DOM order (since reverse DOM order doesn't have a precise meaning\n  // when working with intersecting ranges).\n  result.sort((_ref, _ref2) => {\n    let [n1, r1] = _ref;\n    let [n2, r2] = _ref2;\n    if (r1.end.compareWith(r2.start) !== 'after') {\n      // m1.end <= m2.start -- m1 is entirely <= m2\n      return 1;\n    } else if (r1.start.compareWith(r2.end) !== 'before') {\n      // m1.start >= m2.end -- m1 is entirely >= m2\n      return -1;\n    } else {\n      // they overlap, so use their start positions as the primary sort key and\n      // end positions as the secondary sort key\n      switch (r1.start.compareWith(r2.start)) {\n        case 'before':\n          return 1;\n        case 'after':\n          return -1;\n        default:\n          switch (r1.end.compareWith(r2.end)) {\n            case 'before':\n              return 1;\n            case 'after':\n              return -1;\n            default:\n              return n2.localeCompare(n1);\n          }\n      }\n    }\n  });\n  return new Map(result);\n}","map":{"version":3,"names":["Observable","CKEditorError","Emitter","Mapper","DowncastDispatcher","insertAttributesAndChildren","insertText","UpcastDispatcher","convertText","convertToModelFragment","ViewDocumentFragment","ViewDocument","ViewDowncastWriter","ModelRange","autoParagraphEmptyRoots","HtmlDataProcessor","DataController","constructor","model","stylesProcessor","mapper","downcastDispatcher","schema","on","priority","upcastDispatcher","viewDocument","htmlProcessor","processor","_viewWriter","prototype","decorate","call","fire","enqueueChange","isUndoable","get","options","rootName","trim","_checkIfRootsExists","root","document","getRoot","hasContent","ignoreWhitespaces","stringify","modelElementOrFragment","viewDocumentFragment","toView","toData","viewWriter","clearBindings","modelRange","_createIn","bindElements","markers","is","_getMarkersRelativeToElement","convert","init","data","version","initialData","main","Object","keys","writer","modelRoot","insert","parse","Promise","resolve","set","newData","batchType","setSelection","removeSelectionAttribute","selection","getAttributeKeys","remove","createRangeIn","context","toModel","viewElementOrFragment","change","addStyleProcessorRules","callback","registerRawContentMatcher","pattern","destroy","stopListening","rootNames","getRootNames","includes","element","result","doc","Map","elementRange","marker","markerRange","getRange","isMarkerCollapsed","isCollapsed","isMarkerAtElementBoundary","start","isEqual","end","push","name","updatedMarkerRange","getIntersection","sort","n1","r1","n2","r2","compareWith","localeCompare"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/controller/datacontroller\n */\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertAttributesAndChildren, insertText } from '../conversion/downcasthelpers';\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using the given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class DataController extends Emitter {\n    /**\n     * Creates a data controller instance.\n     *\n     * @param {module:engine/model/model~Model} model Data model.\n     * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n     */\n    constructor(model, stylesProcessor) {\n        super();\n        /**\n         * Data model.\n         *\n         * @readonly\n         * @member {module:engine/model/model~Model}\n         */\n        this.model = model;\n        /**\n         * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and\n         * ae cleared directly after the data are converted. However, the mapper is defined as a class property, because\n         * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n         *\n         * @readonly\n         * @member {module:engine/conversion/mapper~Mapper}\n         */\n        this.mapper = new Mapper();\n        /**\n         * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n         *\n         * @readonly\n         * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n         */\n        this.downcastDispatcher = new DowncastDispatcher({\n            mapper: this.mapper,\n            schema: model.schema\n        });\n        this.downcastDispatcher.on('insert:$text', insertText(), { priority: 'lowest' });\n        this.downcastDispatcher.on('insert', insertAttributesAndChildren(), { priority: 'lowest' });\n        /**\n         * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n         *\n         * @readonly\n         * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n         */\n        this.upcastDispatcher = new UpcastDispatcher({\n            schema: model.schema\n        });\n        /**\n         * The view document used by the data controller.\n         *\n         * @readonly\n         * @member {module:engine/view/document~Document}\n         */\n        this.viewDocument = new ViewDocument(stylesProcessor);\n        /**\n         * Styles processor used during the conversion.\n         *\n         * @readonly\n         * @member {module:engine/view/stylesmap~StylesProcessor}\n         */\n        this.stylesProcessor = stylesProcessor;\n        /**\n         * Data processor used specifically for HTML conversion.\n         *\n         * @readonly\n         * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n         */\n        this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);\n        /**\n         * Data processor used during the conversion.\n         * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n         *\n         * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n         */\n        this.processor = this.htmlProcessor;\n        /**\n         * The view downcast writer just for data conversion purposes, i.e. to modify\n         * the {@link #viewDocument}.\n         *\n         * @private\n         * @readonly\n         * @member {module:engine/view/downcastwriter~DowncastWriter}\n         */\n        this._viewWriter = new ViewDowncastWriter(this.viewDocument);\n        // Define default converters for text and elements.\n        //\n        // Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n        // converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n        // element to the document fragment so `<b>foo</b>` will still be converted to `foo` even if there is no converter for `<b>`.\n        this.upcastDispatcher.on('text', convertText(), { priority: 'lowest' });\n        this.upcastDispatcher.on('element', convertToModelFragment(), { priority: 'lowest' });\n        this.upcastDispatcher.on('documentFragment', convertToModelFragment(), { priority: 'lowest' });\n        Observable.prototype.decorate.call(this, 'init');\n        Observable.prototype.decorate.call(this, 'set');\n        Observable.prototype.decorate.call(this, 'get');\n        // Fire the `ready` event when the initialization has completed. Such low-level listener offers the possibility\n        // to plug into the initialization pipeline without interrupting the initialization flow.\n        this.on('init', () => {\n            this.fire('ready');\n        }, { priority: 'lowest' });\n        // Fix empty roots after DataController is 'ready' (note that the init method could be decorated and stopped).\n        // We need to handle this event because initial data could be empty and the post-fixer would not get triggered.\n        this.on('ready', () => {\n            this.model.enqueueChange({ isUndoable: false }, autoParagraphEmptyRoots);\n        }, { priority: 'lowest' });\n    }\n    /**\n     * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n     * formatted by the {@link #processor data processor}.\n     *\n     * @fires get\n     * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n     * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n     * @param {String} [options.rootName='main'] Root name.\n     * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n     * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n     * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).\n     * @returns {String} Output data.\n     */\n    get(options = {}) {\n        const { rootName = 'main', trim = 'empty' } = options;\n        if (!this._checkIfRootsExists([rootName])) {\n            /**\n             * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n             * is called with a non-existent root name. For example, if there is an editor instance with only `main` root,\n             * calling {@link #get} like:\n             *\n             *\t\tdata.get( { rootName: 'root2' } );\n             *\n             * will throw this error.\n             *\n             * @error datacontroller-get-non-existent-root\n             */\n            throw new CKEditorError('datacontroller-get-non-existent-root', this);\n        }\n        const root = this.model.document.getRoot(rootName);\n        if (trim === 'empty' && !this.model.hasContent(root, { ignoreWhitespaces: true })) {\n            return '';\n        }\n        return this.stringify(root, options);\n    }\n    /**\n     * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n     * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n     * The element whose content will be stringified.\n     * @param {Object} [options] Additional configuration passed to the conversion process.\n     * @returns {String} Output data.\n     */\n    stringify(modelElementOrFragment, options = {}) {\n        // Model -> view.\n        const viewDocumentFragment = this.toView(modelElementOrFragment, options);\n        // View -> data.\n        return this.processor.toData(viewDocumentFragment);\n    }\n    /**\n     * Returns the content of the given {@link module:engine/model/element~Element model element} or\n     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n     * converters attached to {@link #downcastDispatcher} into a\n     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n     * Element or document fragment whose content will be converted.\n     * @param {Object} [options={}] Additional configuration that will be available through the\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n     */\n    toView(modelElementOrFragment, options = {}) {\n        const viewDocument = this.viewDocument;\n        const viewWriter = this._viewWriter;\n        // Clear bindings so the call to this method returns correct results.\n        this.mapper.clearBindings();\n        // First, convert elements.\n        const modelRange = ModelRange._createIn(modelElementOrFragment);\n        const viewDocumentFragment = new ViewDocumentFragment(viewDocument);\n        this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment);\n        // Prepare list of markers.\n        // For document fragment, simply take the markers assigned to this document fragment.\n        // For model root, all markers in that root will be taken.\n        // For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n        // Collapsed markers at element boundary, although considered as not intersecting with the element, will also be returned.\n        const markers = modelElementOrFragment.is('documentFragment') ?\n            modelElementOrFragment.markers :\n            _getMarkersRelativeToElement(modelElementOrFragment);\n        this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);\n        return viewDocumentFragment;\n    }\n    /**\n     * Sets the initial input data parsed by the {@link #processor data processor} and\n     * converted by the {@link #upcastDispatcher view-to-model converters}.\n     * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.\n     *\n     * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n     * used by e.g. collaborative editing plugin that syncs remote data on init.\n     *\n     * When data is passed as a string, it is initialized on the default `main` root:\n     *\n     *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.\n     *\n     * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n     *\n     *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.\n     *\n     * @fires init\n     * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n     * pairs to initialize data on multiple roots at once.\n     * @returns {Promise} Promise that is resolved after the data is set on the editor.\n     */\n    init(data) {\n        if (this.model.document.version) {\n            /**\n             * Cannot set initial data to a non-empty {@link module:engine/model/document~Document}.\n             * Initial data should be set once, during the {@link module:core/editor/editor~Editor} initialization,\n             * when the {@link module:engine/model/document~Document#version} is equal 0.\n             *\n             * @error datacontroller-init-document-not-empty\n             */\n            throw new CKEditorError('datacontroller-init-document-not-empty', this);\n        }\n        let initialData = {};\n        if (typeof data === 'string') {\n            initialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n        }\n        else {\n            initialData = data;\n        }\n        if (!this._checkIfRootsExists(Object.keys(initialData))) {\n            /**\n             * Cannot init data on a non-existent root. This error is thrown when {@link #init DataController#init() method}\n             * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n             * calling {@link #init} like:\n             *\n             * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n             *\n             * will throw this error.\n             *\n             * @error datacontroller-init-non-existent-root\n             */\n            throw new CKEditorError('datacontroller-init-non-existent-root', this);\n        }\n        this.model.enqueueChange({ isUndoable: false }, writer => {\n            for (const rootName of Object.keys(initialData)) {\n                const modelRoot = this.model.document.getRoot(rootName);\n                writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);\n            }\n        });\n        return Promise.resolve();\n    }\n    /**\n     * Sets the input data parsed by the {@link #processor data processor} and\n     * converted by the {@link #upcastDispatcher view-to-model converters}.\n     * This method can be used any time to replace existing editor data with the new one without clearing the\n     * {@link module:engine/model/document~Document#history document history}.\n     *\n     * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n     * the {@link #parse} method.\n     *\n     * When data is passed as a string it is set on the default `main` root:\n     *\n     *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.\n     *\n     * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n     *\n     *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.\n     *\n     * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.\n     *\n     *\t\tdataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );\n     *\n     * @fires set\n     * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n     * pairs to set data on multiple roots at once.\n     * @param {Object} [options={}] Options for setting data.\n     * @param {Object} [options.batchType] The batch type that will be used to create a batch for the changes applied by this method.\n     * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be\n     * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,\n     * the undo stack will be preserved instead and not cleared when new data is applied.\n     */\n    set(data, options = {}) {\n        let newData = {};\n        if (typeof data === 'string') {\n            newData.main = data; // The default root is 'main'. To set data on a different root, an object should be passed.\n        }\n        else {\n            newData = data;\n        }\n        if (!this._checkIfRootsExists(Object.keys(newData))) {\n            /**\n             * Cannot set data on a non-existent root. This error is thrown when the {@link #set DataController#set() method}\n             * is called with non-existent root name. For example, if there is an editor instance with only the default `main` root,\n             * calling {@link #set} like:\n             *\n             * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n             *\n             * will throw this error.\n             *\n             * @error datacontroller-set-non-existent-root\n             */\n            throw new CKEditorError('datacontroller-set-non-existent-root', this);\n        }\n        this.model.enqueueChange(options.batchType || {}, writer => {\n            writer.setSelection(null);\n            writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());\n            for (const rootName of Object.keys(newData)) {\n                // Save to model.\n                const modelRoot = this.model.document.getRoot(rootName);\n                writer.remove(writer.createRangeIn(modelRoot));\n                writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);\n            }\n        });\n    }\n    /**\n     * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n     * attached to the {@link #upcastDispatcher}.\n     *\n     * @see #set\n     * @param {String} data Data to parse.\n     * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n     * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n     */\n    parse(data, context = '$root') {\n        // data -> view\n        const viewDocumentFragment = this.processor.toView(data);\n        // view -> model\n        return this.toModel(viewDocumentFragment, context);\n    }\n    /**\n     * Returns the result of the given {@link module:engine/view/element~Element view element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n     * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n     *\n     * When marker elements were converted during the conversion process, it will be set as a document fragment's\n     * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n     * The element or document fragment whose content will be converted.\n     * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n     * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n     */\n    toModel(viewElementOrFragment, context = '$root') {\n        return this.model.change(writer => {\n            return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);\n        });\n    }\n    /**\n     * Adds the style processor normalization rules.\n     *\n     * You can implement your own rules as well as use one of the available processor rules:\n     *\n     * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n     * * border: {@link module:engine/view/styles/border~addBorderRules}\n     * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n     * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n     *\n     * @param {Function} callback\n     */\n    addStyleProcessorRules(callback) {\n        callback(this.stylesProcessor);\n    }\n    /**\n     * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}\n     * and a {@link #processor processor} for view elements whose content should be treated as raw data\n     * and not processed during the conversion from DOM to view elements.\n     *\n     * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n     * `\"$rawContent\"`.\n     *\n     * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n     * be treated as a raw data.\n     */\n    registerRawContentMatcher(pattern) {\n        // No need to register the pattern if both the `htmlProcessor` and `processor` are the same instances.\n        if (this.processor && this.processor !== this.htmlProcessor) {\n            this.processor.registerRawContentMatcher(pattern);\n        }\n        this.htmlProcessor.registerRawContentMatcher(pattern);\n    }\n    /**\n     * Removes all event listeners set by the DataController.\n     */\n    destroy() {\n        this.stopListening();\n    }\n    /**\n     * Checks whether all provided root names are actually existing editor roots.\n     *\n     * @private\n     * @param {Array.<String>} rootNames Root names to check.\n     * @returns {Boolean} Whether all provided root names are existing editor roots.\n     */\n    _checkIfRootsExists(rootNames) {\n        for (const rootName of rootNames) {\n            if (!this.model.document.getRootNames().includes(rootName)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it. If the marker is collapsed\n// at element boundary, it is considered as contained inside the element and marker range is returned. Otherwise, if the marker is\n// intersecting with the element, the intersection is returned.\nfunction _getMarkersRelativeToElement(element) {\n    const result = [];\n    const doc = element.root.document;\n    if (!doc) {\n        return new Map();\n    }\n    const elementRange = ModelRange._createIn(element);\n    for (const marker of doc.model.markers) {\n        const markerRange = marker.getRange();\n        const isMarkerCollapsed = markerRange.isCollapsed;\n        const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);\n        if (isMarkerCollapsed && isMarkerAtElementBoundary) {\n            result.push([marker.name, markerRange]);\n        }\n        else {\n            const updatedMarkerRange = elementRange.getIntersection(markerRange);\n            if (updatedMarkerRange) {\n                result.push([marker.name, updatedMarkerRange]);\n            }\n        }\n    }\n    // Sort the markers in a stable fashion to ensure that the order in which they are\n    // added to the model's marker collection does not affect how they are\n    // downcast. One particular use case that we are targeting here, is one where\n    // two markers are adjacent but not overlapping, such as an insertion/deletion\n    // suggestion pair representing the replacement of a range of text. In this\n    // case, putting the markers in DOM order causes the first marker's end to be\n    // serialized right after the second marker's start, while putting the markers\n    // in reverse DOM order causes it to be right before the second marker's\n    // start. So, we sort these in a way that ensures non-intersecting ranges are in\n    // reverse DOM order, and intersecting ranges are in something approximating\n    // reverse DOM order (since reverse DOM order doesn't have a precise meaning\n    // when working with intersecting ranges).\n    result.sort(([n1, r1], [n2, r2]) => {\n        if (r1.end.compareWith(r2.start) !== 'after') {\n            // m1.end <= m2.start -- m1 is entirely <= m2\n            return 1;\n        }\n        else if (r1.start.compareWith(r2.end) !== 'before') {\n            // m1.start >= m2.end -- m1 is entirely >= m2\n            return -1;\n        }\n        else {\n            // they overlap, so use their start positions as the primary sort key and\n            // end positions as the secondary sort key\n            switch (r1.start.compareWith(r2.start)) {\n                case 'before':\n                    return 1;\n                case 'after':\n                    return -1;\n                default:\n                    switch (r1.end.compareWith(r2.end)) {\n                        case 'before':\n                            return 1;\n                        case 'after':\n                            return -1;\n                        default:\n                            return n2.localeCompare(n1);\n                    }\n            }\n        }\n    });\n    return new Map(result);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}