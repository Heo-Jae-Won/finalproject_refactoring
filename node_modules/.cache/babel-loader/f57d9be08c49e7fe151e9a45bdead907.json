{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelDocumentSelection from '../model/documentselection';\nimport ModelElement from '../model/element';\nimport ModelPosition from '../model/position';\nimport ViewAttributeElement from '../view/attributeelement';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n/**\n * Downcast conversion helper functions.\n *\n * Learn more about {@glink framework/guides/deep-dive/conversion/downcast downcast helpers}.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class DowncastHelpers extends ConversionHelpers {\n  /**\n   * Model element to view element conversion helper.\n   *\n   * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tview: 'p'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tview: 'div',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'fancyParagraph',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'p',\n   *\t\t\t\tclasses: 'fancy'\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'heading',\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or\n   * the `children` props on a model description. You will find a couple examples below.\n   *\n   * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`\n   * description. For example, this model:\n   *\n   *\t\t<box>\n   *\t\t\t<paragraph>Some text.</paragraph>\n   *\t\t</box>\n   *\n   * will be converted into this structure in the view:\n   *\n   *\t\t<div class=\"box\" data-type=\"single\">\n   *\t\t\t<p>Some text.</p>\n   *\t\t</div>\n   *\n   * But if more items were inserted in the model:\n   *\n   *\t\t<box>\n   *\t\t\t<paragraph>Some text.</paragraph>\n   *\t\t\t<paragraph>Other item.</paragraph>\n   *\t\t</box>\n   *\n   * it will be converted into this structure in the view (note the element `data-type` change):\n   *\n   *\t\t<div class=\"box\" data-type=\"multiple\">\n   *\t\t\t<p>Some text.</p>\n   *\t\t\t<p>Other item.</p>\n   *\t\t</div>\n   *\n   * Such a converter would look like this (note that the `paragraph` elements are converted separately):\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: {\n   *\t \t\t\tname: 'box',\n   *\t \t\t\tchildren: true\n   *\t\t\t},\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createContainerElement( 'div', {\n   *\t\t\t\t\tclass: 'box',\n   *\t\t\t\t\t'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`\n   * description. For example, this model:\n   *\n   *\t\t<heading level=\"2\">Some text.</heading>\n   *\n   * will be converted into this structure in the view:\n   *\n   *\t\t<h2>Some text.</h2>\n   *\n   * But if the `heading` element's `level` attribute has been updated to `3` for example, then\n   * it will be converted into this structure in the view:\n   *\n   *\t\t<h3>Some text.</h3>\n   *\n   * Such a converter would look as follows:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: {\n   *\t \t\t\tname: 'heading',\n   *\t \t\t\tattributes: 'level'\n   *\t\t\t},\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * You can read more about the element-to-element conversion in the\n   * {@glink framework/guides/deep-dive/conversion/downcast downcast conversion} guide.\n   *\n   * @method #elementToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The description or a name of the model element to convert.\n   * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n   * the view element. Note that the view will be reconverted if any of the listed attributes changes.\n   * @param {Boolean} [config.model.children] Specifies whether the view element requires reconversion if the list\n   * of the model child nodes changed.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n   * config.view A view element definition or a function that takes the model element and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as parameters and returns a view container element.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  elementToElement(config) {\n    return this.add(downcastElementToElement(config));\n  }\n  /**\n   * The model element to view structure (several elements) conversion helper.\n   *\n   * This conversion results in creating a view structure with one or more slots defined for the child nodes.\n   * For example, a model `<table>` may become this structure in the view:\n   *\n   *\t\t<figure class=\"table\">\n   *\t\t\t<table>\n   *\t\t\t\t<tbody>${ slot for table rows }</tbody>\n   *\t\t\t</table>\n   *\t\t</figure>\n   *\n   * The children of the model's `<table>` element will be inserted into the `<tbody>` element.\n   * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.\n   *\n   * An example converter that converts the following model structure:\n   *\n   *\t\t<wrappedParagraph>Some text.</wrappedParagraph>\n   *\n   * into this structure in the view:\n   *\n   *\t\t<div class=\"wrapper\">\n   *\t\t\t<p>Some text.</p>\n   *\t\t</div>\n   *\n   * would look like this:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n   *\t\t\tmodel: 'wrappedParagraph',\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\tconst wrapperViewElement = writer.createContainerElement( 'div', { class: 'wrapper' } );\n   *\t\t\t\tconst paragraphViewElement = writer.createContainerElement( 'p' );\n   *\n   *\t\t\t\twriter.insert( writer.createPositionAt( wrapperViewElement, 0 ), paragraphViewElement );\n   *\t\t\t\twriter.insert( writer.createPositionAt( paragraphViewElement, 0 ), writer.createSlot() );\n   *\n   *\t\t\t\treturn wrapperViewElement;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * The `slorFor()` function can also take a callback that allows filtering which children of the model element\n   * should be converted into this slot.\n   *\n   * Imagine a table feature where for this model structure:\n   *\n   *\t\t<table headingRows=\"1\">\n   *\t\t\t<tableRow> ... table cells 1 ... </tableRow>\n   *\t\t\t<tableRow> ... table cells 2 ... </tableRow>\n   *\t\t\t<tableRow> ... table cells 3 ... </tableRow>\n   *\t\t\t<caption>Caption text</caption>\n   *\t\t</table>\n   *\n   * we want to generate this view structure:\n   *\n   *\t\t<figure class=\"table\">\n   *\t\t\t<table>\n   *\t\t\t\t<thead>\n   *\t\t\t\t\t<tr> ... table cells 1 ... </tr>\n   *\t\t\t\t</thead>\n   *\t\t\t\t<tbody>\n   *\t\t\t\t\t<tr> ... table cells 2 ... </tr>\n   *\t\t\t\t\t<tr> ... table cells 3 ... </tr>\n   *\t\t\t\t</tbody>\n   *\t\t\t</table>\n   *\t\t\t<figcaption>Caption text</figcaption>\n   *\t\t</figure>\n   *\n   * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements\n   * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.\n   *\n   * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.\n   * In the example above, this will handle the table caption.\n   *\n   * Such a converter would look like this:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'table',\n   *\t\t\t\tattributes: [ 'headingRows' ]\n   *\t\t\t},\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\tconst figureElement = writer.createContainerElement( 'figure', { class: 'table' } );\n   *\t\t\t\tconst tableElement = writer.createContainerElement( 'table' );\n   *\n   *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 0 ), tableElement );\n   *\n   *\t\t\t\tconst headingRows = modelElement.getAttribute( 'headingRows' ) || 0;\n   *\n   *\t\t\t\tif ( headingRows > 0 ) {\n   *\t\t\t\t\tconst tableHead = writer.createContainerElement( 'thead' );\n   *\n   *\t\t\t\t\tconst headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );\n   *\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableHead, 0 ), headSlot );\n   *\t\t\t\t}\n   *\n   *\t\t\t\tif ( headingRows < tableUtils.getRows( table ) ) {\n   *\t\t\t\t\tconst tableBody = writer.createContainerElement( 'tbody' );\n   *\n   *\t\t\t\t\tconst bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );\n   *\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );\n   *\t\t\t\t}\n   *\n   *\t\t\t\tconst restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );\n   *\n   *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );\n   *\n   *\t\t\t\treturn figureElement;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Note: The children of a model element that's being converted must be allocated in the same order in the view\n   * in which they are placed in the model.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToStructure\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The description or a name of the model element to convert.\n   * @param {String} [config.model.name] The name of the model element to convert.\n   * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n   * the view structure. Note that the view will be reconverted if any of the listed attributes will change.\n   * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view A function\n   * that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n   * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  elementToStructure(config) {\n    return this.add(downcastElementToStructure(config));\n  }\n  /**\n   * Model attribute to view element conversion helper.\n   *\n   * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n   * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: 'strong'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: 'b',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'invert',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'fontSize',\n   *\t\t\t\tvalues: [ 'big', 'small' ]\n   *\t\t\t},\n   *\t\t\tview: {\n   *\t\t\t\tbig: {\n   *\t\t\t\t\tname: 'span',\n   *\t\t\t\t\tstyles: {\n   *\t\t\t\t\t\t'font-size': '1.2em'\n   *\t\t\t\t\t}\n   *\t\t\t\t},\n   *\t\t\t\tsmall: {\n   *\t\t\t\t\tname: 'span',\n   *\t\t\t\t\tstyles: {\n   *\t\t\t\t\t\t'font-size': '0.8em'\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createAttributeElement( 'span', {\n   *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'color',\n   *\t\t\t\tname: '$text'\n   *\t\t\t},\n   *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createAttributeElement( 'span', {\n   *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n   * of `String`s with possible values if the model attribute is an enumerable.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|Object|\n   * module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction} config.view A view element definition or a function\n   * that takes the model attribute value and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n   * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`\n   * to view element definitions or functions.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  attributeToElement(config) {\n    return this.add(downcastAttributeToElement(config));\n  }\n  /**\n   * Model attribute to view attribute conversion helper.\n   *\n   * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n   * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'source',\n   *\t\t\tview: 'src'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'source',\n   *\t\t\tview: 'href',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'imageInline',\n   *\t\t\t\tkey: 'source'\n   *\t\t\t},\n   *\t\t\tview: 'src'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'styled',\n   *\t\t\t\tvalues: [ 'dark', 'light' ]\n   *\t\t\t},\n   *\t\t\tview: {\n   *\t\t\t\tdark: {\n   *\t\t\t\t\tkey: 'class',\n   *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n   *\t\t\t\t},\n   *\t\t\t\tlight: {\n   *\t\t\t\t\tkey: 'class',\n   *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'styled',\n   *\t\t\tview: modelAttributeValue => ( {\n   *\t\t\t\tkey: 'class',\n   *\t\t\t\tvalue: 'styled-' + modelAttributeValue\n   *\t\t\t} )\n   *\t\t} );\n   *\n   * **Note**: Downcasting to a style property requires providing `value` as an object:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'lineHeight',\n   *\t\t\tview: modelAttributeValue => ( {\n   *\t\t\t\tkey: 'style',\n   *\t\t\t\tvalue: {\n   *\t\t\t\t\t'line-height': modelAttributeValue,\n   *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n   *\t\t\t\t}\n   *\t\t\t} )\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToAttribute\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n   * the attribute key, possible values and, optionally, an element name to convert from.\n   * @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n   * or a `{ key, value }` object or a function that takes the model attribute value and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an\n   * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n   * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n   * `{ key, value }` objects or a functions.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  attributeToAttribute(config) {\n    return this.add(downcastAttributeToAttribute(config));\n  }\n  /**\n   * Model marker to view element conversion helper.\n   *\n   * **Note**: This method should be used mainly for editing the downcast and it is recommended\n   * to use the {@link #markerToData `#markerToData()`} helper instead.\n   *\n   * This helper may produce invalid HTML code (e.g. a span between table cells).\n   * It should only be used when you are sure that the produced HTML will be semantically correct.\n   *\n   * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n   * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n   * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: 'marker-search'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: 'search-result',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tattributes: {\n   *\t\t\t\t\t'data-marker': 'search'\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: ( markerData, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createUIElement( 'span', {\n   *\t\t\t\t\t'data-marker': 'search',\n   *\t\t\t\t\t'data-start': markerData.isOpening\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as a parameters and should return an instance of the\n   * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n   * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n   * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for\n   * the marker end boundary element.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #markerToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or model marker group) to convert.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function that\n   * takes the model marker data and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as a parameters and returns a view UI element.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  markerToElement(config) {\n    return this.add(downcastMarkerToElement(config));\n  }\n  /**\n   * Model marker to highlight conversion helper.\n   *\n   * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n   * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n   *\n   * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n   * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n   * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n   *\n   * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n   * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n   * For example, a model marker set like this:\n   * `[<imageInline src=\"foo.jpg\"></imageInline>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>` in the view.\n   *\n   * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n   * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n   * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n   *\t\t\tmodel: 'comment',\n   *\t\t\tview: { classes: 'comment' },\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n   *\t\t\tmodel: 'comment',\n   *\t\t\tview: ( data, conversionApi ) => {\n   *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType:commentId.\n   *\t\t\t\tconst [ , commentType, commentId ] = data.markerName.split( ':' );\n   *\n   *\t\t\t\treturn {\n   *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ],\n   *\t\t\t\t\tattributes: { 'data-comment-id': commentId }\n   *\t\t\t\t};\n   *\t\t\t}\n   *\t\t} );\n   *\n   * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as the parameters and should return a\n   * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n   * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #markerToHighlight\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or model marker group) to convert.\n   * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n   * that will be used for highlighting or a function that takes the model marker data and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters\n   * and returns a highlight descriptor.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  markerToHighlight(config) {\n    return this.add(downcastMarkerToHighlight(config));\n  }\n  /**\n   * Model marker converter for data downcast.\n   *\n   * This conversion creates a representation for model marker boundaries in the view:\n   *\n   * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.\n   * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.\n   *\n   * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.\n   * The default configuration for this conversion is that the first part is the `group` part and the rest of\n   * the marker name becomes the `name` part.\n   *\n   * Tag and attribute names and values are generated from the marker name:\n   *\n   * * The templates for attributes are `data-[group]-start-before=\"[name]\"`, `data-[group]-start-after=\"[name]\"`,\n   * `data-[group]-end-before=\"[name]\"` and `data-[group]-end-after=\"[name]\"`.\n   * * The templates for view elements are `<[group]-start name=\"[name]\">` and `<[group]-end name=\"[name]\">`.\n   *\n   * Attributes mark whether the given marker's start or end boundary is before or after the given element.\n   * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.\n   * The other two are used when the former two cannot be used.\n   *\n   * The conversion configuration can take a function that will generate different group and name parts.\n   * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two\n   * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.\n   *\n   * Basic usage:\n   *\n   *\t\t// Using the default conversion.\n   *\t\t// In this case, all markers with names starting with 'comment:' will be converted.\n   *\t\t// The `group` parameter will be set to `comment`.\n   *\t\t// The `name` parameter will be the rest of the marker name (without the `:`).\n   *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n   *\t\t\tmodel: 'comment'\n   *\t\t} );\n   *\n   * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked\n   * by `[]`):\n   *\n   *\t\t// Model:\n   *\t\t<paragraph>Foo[bar</paragraph>\n   *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n   *\n   *\t\t// View:\n   *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n   *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n   *\n   * In the example above, the comment starts before \"bar\" and ends after the image.\n   *\n   * If the `name` part is empty, the following view may be generated:\n   *\n   *\t\t<p>Foo <myMarker-start></myMarker-start>bar</p>\n   *\t\t<figure data-myMarker-end-after=\"\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n   *\n   * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.\n   *\n   * Examples where `data-group-start-after` and `data-group-end-before` are used:\n   *\n   *\t\t// Model:\n   *\t\t<blockQuote>[]<paragraph>Foo</paragraph></blockQuote>\n   *\n   *\t\t// View:\n   *\t\t<blockquote><p data-group-end-before=\"name\" data-group-start-before=\"name\">Foo</p></blockquote>\n   *\n   * Similarly, when a marker is collapsed after the last element:\n   *\n   *\t\t// Model:\n   *\t\t<blockQuote><paragraph>Foo</paragraph>[]</blockQuote>\n   *\n   *\t\t// View:\n   *\t\t<blockquote><p data-group-end-after=\"name\" data-group-start-after=\"name\">Foo</p></blockquote>\n   *\n   * When there are multiple markers from the same group stored in the same attribute of the same element, their\n   * name parts are put together in the attribute value, for example: `data-group-start-before=\"name1,name2,name3\"`.\n   *\n   * Other examples of usage:\n   *\n   *\t\t// Using a custom function which is the same as the default conversion:\n   *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n   *\t\t\tmodel: 'comment'\n   *\t\t\tview: markerName => ( {\n   *\t\t\t\tgroup: 'comment',\n   *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n   *\t\t\t} )\n   *\t\t} );\n   *\n   *\t\t// Using the converter priority:\n   *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n   *\t\t\tmodel: 'comment'\n   *\t\t\tview: markerName => ( {\n   *\t\t\t\tgroup: 'comment',\n   *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n   *\t\t\t} ),\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n   *\n   * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to\n   * add a converter to the conversion process.\n   *\n   * @method #markerToData\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or the model marker group) to convert.\n   * @param {Function} [config.view] A function that takes the model marker name and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters\n   * and returns an object with the `group` and `name` properties.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  markerToData(config) {\n    return this.add(downcastMarkerToData(config));\n  }\n}\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\nexport function insertText() {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n    const viewWriter = conversionApi.writer;\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    const viewText = viewWriter.createText(data.item.data);\n    viewWriter.insert(viewPosition, viewText);\n  };\n}\n/**\n * Function factory that creates a default downcast converter for triggering attributes and children conversion.\n *\n * @returns {Function} The converter.\n */\nexport function insertAttributesAndChildren() {\n  return (evt, data, conversionApi) => {\n    conversionApi.convertAttributes(data.item);\n    // Start converting children of the current item.\n    // In case of reconversion children were already re-inserted or converted separately.\n    if (!data.reconversion && data.item.is('element') && !data.item.isEmpty) {\n      conversionApi.convertChildren(data.item);\n    }\n  };\n}\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\nexport function remove() {\n  return (evt, data, conversionApi) => {\n    // Find the view range start position by mapping the model position at which the remove happened.\n    const viewStart = conversionApi.mapper.toViewPosition(data.position);\n    const modelEnd = data.position.getShiftedBy(data.length);\n    const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {\n      isPhantom: true\n    });\n    const viewRange = conversionApi.writer.createRange(viewStart, viewEnd);\n    // Trim the range to remove in case some UI elements are on the view range boundaries.\n    const removed = conversionApi.writer.remove(viewRange.getTrimmed());\n    // After the range is removed, unbind all view elements from the model.\n    // Range inside view document fragment is used to unbind deeply.\n    for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {\n      conversionApi.mapper.unbindViewElement(child, {\n        defer: true\n      });\n    }\n  };\n}\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If the priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\nexport function createViewElementFromHighlightDescriptor(writer, descriptor) {\n  const viewElement = writer.createAttributeElement('span', descriptor.attributes);\n  if (descriptor.classes) {\n    viewElement._addClass(descriptor.classes);\n  }\n  if (typeof descriptor.priority === 'number') {\n    viewElement._priority = descriptor.priority;\n  }\n  viewElement._id = descriptor.id;\n  return viewElement;\n}\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\nexport function convertRangeSelection() {\n  return (evt, data, conversionApi) => {\n    const selection = data.selection;\n    if (selection.isCollapsed) {\n      return;\n    }\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n    const viewRanges = [];\n    for (const range of selection.getRanges()) {\n      viewRanges.push(conversionApi.mapper.toViewRange(range));\n    }\n    conversionApi.writer.setSelection(viewRanges, {\n      backward: selection.isBackward\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\nexport function convertCollapsedSelection() {\n  return (evt, data, conversionApi) => {\n    const selection = data.selection;\n    if (!selection.isCollapsed) {\n      return;\n    }\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n    const viewWriter = conversionApi.writer;\n    const modelPosition = selection.getFirstPosition();\n    const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n    const brokenPosition = viewWriter.breakAttributes(viewPosition);\n    viewWriter.setSelection(brokenPosition);\n  };\n}\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\nexport function clearAttributes() {\n  return (evt, data, conversionApi) => {\n    const viewWriter = conversionApi.writer;\n    const viewSelection = viewWriter.document.selection;\n    for (const range of viewSelection.getRanges()) {\n      // Not collapsed selection should not have artifacts.\n      if (range.isCollapsed) {\n        // Position might be in the node removed by the view writer.\n        if (range.end.parent.isAttached()) {\n          conversionApi.writer.mergeAttributes(range.start);\n        }\n      }\n    }\n    viewWriter.setSelection(null);\n  };\n}\n/**\n * Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, { writer } ) => {\n *\t\t\treturn writer.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\nexport function wrap(elementCreator) {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n    // Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n    // or the attribute was removed.\n    const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data);\n    // Create node to wrap with.\n    const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);\n    if (!oldViewElement && !newViewElement) {\n      return;\n    }\n    conversionApi.consumable.consume(data.item, evt.name);\n    const viewWriter = conversionApi.writer;\n    const viewSelection = viewWriter.document.selection;\n    if (data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) {\n      // Selection attribute conversion.\n      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);\n    } else {\n      // Node attribute conversion.\n      let viewRange = conversionApi.mapper.toViewRange(data.range);\n      // First, unwrap the range from current wrapper.\n      if (data.attributeOldValue !== null && oldViewElement) {\n        viewRange = viewWriter.unwrap(viewRange, oldViewElement);\n      }\n      if (data.attributeNewValue !== null && newViewElement) {\n        viewWriter.wrap(viewRange, newViewElement);\n      }\n    }\n  };\n}\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, { writer } ) => {\n *\t\t\t\tconst text = writer.createText( 'myText' );\n *\t\t\t\tconst myElem = writer.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} [consumer] Function defining element consumption process.\n * By default this function just consume passed item insertion.\n * @returns {Function} Insert element event converter.\n */\nexport function insertElement(elementCreator) {\n  let consumer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConsumer;\n  return (evt, data, conversionApi) => {\n    if (!consumer(data.item, conversionApi.consumable, {\n      preflight: true\n    })) {\n      return;\n    }\n    const viewElement = elementCreator(data.item, conversionApi, data);\n    if (!viewElement) {\n      return;\n    }\n    // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n    consumer(data.item, conversionApi.consumable);\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement);\n    // Convert attributes before converting children.\n    conversionApi.convertAttributes(data.item);\n    // Convert children or reinsert previous view elements.\n    reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, {\n      reconversion: data.reconversion\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a single model node insertion to a view structure.\n *\n * It is expected that the passed element creator function returns an {@link module:engine/view/element~Element} with attached slots\n * created with `writer.createSlot()` to indicate where child nodes should be converted.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n *\n * @protected\n * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} elementCreator Function returning a view structure,\n * which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} consumer A callback that is expected to consume all the consumables\n * that were used by the element creator.\n * @returns {Function} Insert element event converter.\n*/\nexport function insertStructure(elementCreator, consumer) {\n  return (evt, data, conversionApi) => {\n    if (!consumer(data.item, conversionApi.consumable, {\n      preflight: true\n    })) {\n      return;\n    }\n    const slotsMap = new Map();\n    conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi));\n    // View creation.\n    const viewElement = elementCreator(data.item, conversionApi, data);\n    conversionApi.writer._clearSlotFactory();\n    if (!viewElement) {\n      return;\n    }\n    // Check if all children are covered by slots and there is no child that landed in multiple slots.\n    validateSlotsChildren(data.item, slotsMap, conversionApi);\n    // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n    consumer(data.item, conversionApi.consumable);\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement);\n    // Convert attributes before converting children.\n    conversionApi.convertAttributes(data.item);\n    // Fill view slots with previous view elements or create new ones.\n    fillSlots(viewElement, slotsMap, conversionApi, {\n      reconversion: data.reconversion\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertUIElement(elementCreator) {\n  return (evt, data, conversionApi) => {\n    // Create two view elements. One will be inserted at the beginning of marker, one at the end.\n    // If marker is collapsed, only \"opening\" element will be inserted.\n    data.isOpening = true;\n    const viewStartElement = elementCreator(data, conversionApi);\n    data.isOpening = false;\n    const viewEndElement = elementCreator(data, conversionApi);\n    if (!viewStartElement || !viewEndElement) {\n      return;\n    }\n    const markerRange = data.markerRange;\n    // Marker that is collapsed has consumable build differently that non-collapsed one.\n    // For more information see `addMarker` event description.\n    // If marker's range is collapsed - check if it can be consumed.\n    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    }\n    // If marker's range is not collapsed - consume all items inside.\n    for (const value of markerRange) {\n      if (!conversionApi.consumable.consume(value.item, evt.name)) {\n        return;\n      }\n    }\n    const mapper = conversionApi.mapper;\n    const viewWriter = conversionApi.writer;\n    // Add \"opening\" element.\n    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);\n    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName);\n    // Add \"closing\" element only if range is not collapsed.\n    if (!markerRange.isCollapsed) {\n      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);\n      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);\n    }\n    evt.stop();\n  };\n}\n// Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// based on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\nfunction removeUIElement() {\n  return (evt, data, conversionApi) => {\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n    if (!elements) {\n      return;\n    }\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n      conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n    }\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n}\n// Function factory that creates a default converter for model markers.\n//\n// See {@link DowncastHelpers#markerToData} for more information what type of view is generated.\n//\n// This converter binds created UI elements and affected view elements with the marker name\n// using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n//\n// @returns {Function} Add marker converter.\nfunction insertMarkerData(viewCreator) {\n  return (evt, data, conversionApi) => {\n    const viewMarkerData = viewCreator(data.markerName, conversionApi);\n    if (!viewMarkerData) {\n      return;\n    }\n    const markerRange = data.markerRange;\n    if (!conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    }\n    // Adding closing data first to keep the proper order in the view.\n    handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);\n    handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);\n    evt.stop();\n  };\n}\n// Helper function for `insertMarkerData()` that marks a marker boundary at the beginning or end of given `range`.\nfunction handleMarkerBoundary(range, isStart, conversionApi, data, viewMarkerData) {\n  const modelPosition = isStart ? range.start : range.end;\n  const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is('element') ? modelPosition.nodeAfter : null;\n  const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is('element') ? modelPosition.nodeBefore : null;\n  if (elementAfter || elementBefore) {\n    let modelElement;\n    let isBefore;\n    // If possible, we want to add `data-group-start-before` and `data-group-end-after` attributes.\n    if (isStart && elementAfter || !isStart && !elementBefore) {\n      // [<elementAfter>...</elementAfter> -> <elementAfter data-group-start-before=\"...\">...</elementAfter>\n      // <parent>]<elementAfter> -> <parent><elementAfter data-group-end-before=\"...\">\n      modelElement = elementAfter;\n      isBefore = true;\n    } else {\n      // <elementBefore>...</elementBefore>] -> <elementBefore data-group-end-after=\"...\">...</elementBefore>\n      // </elementBefore>[</parent> -> </elementBefore data-group-start-after=\"...\"></parent>\n      modelElement = elementBefore;\n      isBefore = false;\n    }\n    const viewElement = conversionApi.mapper.toViewElement(modelElement);\n    // In rare circumstances, the model element may be not mapped to any view element and that would cause an error.\n    // One of those situations is a soft break inside code block.\n    if (viewElement) {\n      insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);\n      return;\n    }\n  }\n  const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n  insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);\n}\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as an attribute on a view element.\nfunction insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {\n  const attributeName = `data-${viewMarkerData.group}-${isStart ? 'start' : 'end'}-${isBefore ? 'before' : 'after'}`;\n  const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(',') : [];\n  // Adding marker name at the beginning to have the same order in the attribute as there is with marker elements.\n  markerNames.unshift(viewMarkerData.name);\n  conversionApi.writer.setAttribute(attributeName, markerNames.join(','), viewElement);\n  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n}\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as a separate view ui element.\nfunction insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {\n  const viewElementName = `${viewMarkerData.group}-${isStart ? 'start' : 'end'}`;\n  const attrs = viewMarkerData.name ? {\n    'name': viewMarkerData.name\n  } : null;\n  const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);\n  conversionApi.writer.insert(position, viewElement);\n  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n}\n// Function factory that creates a converter for removing a model marker data added by the {@link #insertMarkerData} converter.\n//\n// @returns {Function} Remove marker converter.\nfunction removeMarkerData(viewCreator) {\n  return (evt, data, conversionApi) => {\n    const viewData = viewCreator(data.markerName, conversionApi);\n    if (!viewData) {\n      return;\n    }\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n    if (!elements) {\n      return;\n    }\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n      if (element.is('containerElement')) {\n        removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element);\n        removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element);\n        removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element);\n        removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element);\n      } else {\n        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n      }\n    }\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n    function removeMarkerFromAttribute(attributeName, element) {\n      if (element.hasAttribute(attributeName)) {\n        const markerNames = new Set(element.getAttribute(attributeName).split(','));\n        markerNames.delete(viewData.name);\n        if (markerNames.size == 0) {\n          conversionApi.writer.removeAttribute(attributeName, element);\n        } else {\n          conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(','), element);\n        }\n      }\n    }\n  };\n}\n// Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\nfunction changeAttribute(attributeCreator) {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n    const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);\n    const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);\n    if (!oldAttribute && !newAttribute) {\n      return;\n    }\n    conversionApi.consumable.consume(data.item, evt.name);\n    const viewElement = conversionApi.mapper.toViewElement(data.item);\n    const viewWriter = conversionApi.writer;\n    // If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n    // Only elements can have attributes in a view so do not proceed for anything else (#1587).\n    if (!viewElement) {\n      /**\n       * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n       * by an {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n       * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n       *\t\t\tmodel: 'attribute-name',\n       *\t\t\tview: 'attribute-name'\n       *\t\t} ) );\n       *\n       * and given attribute is used on text node, for example:\n       *\n       *\t\tmodel.change( writer => {\n       *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n       *\t\t} );\n       *\n       * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n       * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n       * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n       * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n       *\t\t\tmodel: {\n       *\t\t\t\tkey: 'attribute-name',\n       *\t\t\t\tname: '$text'\n       *\t\t\t},\n       *\t\t\tview: ( value, { writer } ) => {\n       *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n       *\t\t\t},\n       *\t\t\tconverterPriority: 'high'\n       *\t\t} ) );\n       *\n       * @error conversion-attribute-to-attribute-on-text\n       */\n      throw new CKEditorError('conversion-attribute-to-attribute-on-text', conversionApi.dispatcher, data);\n    }\n    // First remove the old attribute if there was one.\n    if (data.attributeOldValue !== null && oldAttribute) {\n      if (oldAttribute.key == 'class') {\n        const classes = toArray(oldAttribute.value);\n        for (const className of classes) {\n          viewWriter.removeClass(className, viewElement);\n        }\n      } else if (oldAttribute.key == 'style') {\n        const keys = Object.keys(oldAttribute.value);\n        for (const key of keys) {\n          viewWriter.removeStyle(key, viewElement);\n        }\n      } else {\n        viewWriter.removeAttribute(oldAttribute.key, viewElement);\n      }\n    }\n    // Then set the new attribute.\n    if (data.attributeNewValue !== null && newAttribute) {\n      if (newAttribute.key == 'class') {\n        const classes = toArray(newAttribute.value);\n        for (const className of classes) {\n          viewWriter.addClass(className, viewElement);\n        }\n      } else if (newAttribute.key == 'style') {\n        const keys = Object.keys(newAttribute.value);\n        for (const key of keys) {\n          viewWriter.setStyle(key, newAttribute.value[key], viewElement);\n        }\n      } else {\n        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);\n      }\n    }\n  };\n}\n// Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightText(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    if (!data.item) {\n      return;\n    }\n    if (!(data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) && !data.item.is('$textProxy')) {\n      return;\n    }\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n    if (!descriptor) {\n      return;\n    }\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n    const viewWriter = conversionApi.writer;\n    const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);\n    const viewSelection = viewWriter.document.selection;\n    if (data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) {\n      viewWriter.wrap(viewSelection.getFirstRange(), viewElement);\n    } else {\n      const viewRange = conversionApi.mapper.toViewRange(data.range);\n      const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);\n      for (const element of rangeAfterWrap.getItems()) {\n        if (element.is('attributeElement') && element.isSimilar(viewElement)) {\n          conversionApi.mapper.bindElementToMarker(element, data.markerName);\n          // One attribute element is enough, because all of them are bound together by the view writer.\n          // Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n          break;\n        }\n      }\n    }\n  };\n}\n// Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightElement(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    if (!data.item) {\n      return;\n    }\n    if (!(data.item instanceof ModelElement)) {\n      return;\n    }\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n    if (!descriptor) {\n      return;\n    }\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n    const viewElement = conversionApi.mapper.toViewElement(data.item);\n    if (viewElement && viewElement.getCustomProperty('addHighlight')) {\n      // Consume element itself.\n      conversionApi.consumable.consume(data.item, evt.name);\n      // Consume all children nodes.\n      for (const value of ModelRange._createIn(data.item)) {\n        conversionApi.consumable.consume(value.item, evt.name);\n      }\n      const addHighlightCallback = viewElement.getCustomProperty('addHighlight');\n      addHighlightCallback(viewElement, descriptor, conversionApi.writer);\n      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n    }\n  };\n}\n// Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction removeHighlight(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    // This conversion makes sense only for non-collapsed range.\n    if (data.markerRange.isCollapsed) {\n      return;\n    }\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n    if (!descriptor) {\n      return;\n    }\n    // View element that will be used to unwrap `AttributeElement`s.\n    const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor);\n    // Get all elements bound with given marker name.\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n    if (!elements) {\n      return;\n    }\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n      if (element.is('attributeElement')) {\n        conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);\n      } else {\n        // if element.is( 'containerElement' ).\n        const removeHighlightCallback = element.getCustomProperty('removeHighlight');\n        removeHighlightCallback(element, descriptor.id, conversionApi.writer);\n      }\n    }\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n}\n// Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The description or a name of the model element to convert.\n// @param {String|Array.<String>} [config.model.attributes] List of attributes triggering element reconversion.\n// @param {Boolean} [config.model.children] Should reconvert element if the list of model child nodes changed.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n// config.view\n// @returns {Function} Conversion helper.\nfunction downcastElementToElement(config) {\n  const model = normalizeModelElementConfig(config.model);\n  const view = normalizeToElementConfig(config.view, 'container');\n  // Trigger reconversion on children list change if element is a subject to any reconversion.\n  // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n  if (model.attributes.length) {\n    model.children = true;\n  }\n  return dispatcher => {\n    dispatcher.on(`insert:${model.name}`, insertElement(view, createConsumer(model)), {\n      priority: config.converterPriority || 'normal'\n    });\n    if (model.children || model.attributes.length) {\n      dispatcher.on('reduceChanges', createChangeReducer(model), {\n        priority: 'low'\n      });\n    }\n  };\n}\n// Model element to view structure conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToStructure `.elementToStructure()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model\n// @param {String} [config.model.name]\n// @param {Array.<String>} [config.model.attributes]\n// @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view\n// @returns {Function} Conversion helper.\nfunction downcastElementToStructure(config) {\n  const model = normalizeModelElementConfig(config.model);\n  const view = normalizeToElementConfig(config.view, 'container');\n  // Trigger reconversion on children list change because it always needs to use slots to put children in proper places.\n  // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n  model.children = true;\n  return dispatcher => {\n    if (dispatcher._conversionApi.schema.checkChild(model.name, '$text')) {\n      /**\n       * This error occurs when a {@link module:engine/model/element~Element model element} is downcasted\n       * via {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure} helper but the element was\n       * allowed to host `$text` by the {@link module:engine/model/schema~Schema model schema}.\n       *\n       * For instance, this may be the result of `myElement` allowing the content of\n       * {@glink framework/guides/deep-dive/schema#generic-items `$block`} in its schema definition:\n       *\n       *\t\t// Element definition in schema.\n       *\t\tschema.register( 'myElement', {\n       *\t\t\tallowContentOf: '$block',\n       *\n       *\t\t\t// ...\n       *\t\t} );\n       *\n       *\t\t// ...\n       *\n       *\t\t// Conversion of myElement with the use of elementToStructure().\n       *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n       *\t\t\tmodel: 'myElement',\n       *\t\t\tview: ( modelElement, { writer } ) => {\n       *\t\t\t\t// ...\n       *\t\t\t}\n       *\t\t} );\n       *\n       * In such case, {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} helper\n       * can be used instead to get around this problem:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n       *\t\t\tmodel: 'myElement',\n       *\t\t\tview: ( modelElement, { writer } ) => {\n       *\t\t\t\t// ...\n       *\t\t\t}\n       *\t\t} );\n       *\n       * @error conversion-element-to-structure-disallowed-text\n       * @param {String} elementName The name of the element the structure is to be created for.\n       */\n      throw new CKEditorError('conversion-element-to-structure-disallowed-text', dispatcher, {\n        elementName: model.name\n      });\n    }\n    dispatcher.on(`insert:${model.name}`, insertStructure(view, createConsumer(model)), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('reduceChanges', createChangeReducer(model), {\n      priority: 'low'\n    });\n  };\n}\n// Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction|\n// Object} config.view A view element definition or a function that takes the model attribute value and\n// {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} as parameters and returns a view attribute element.\n// If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values` to view element\n// definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToElement(config) {\n  config = cloneDeep(config);\n  let model = config.model;\n  if (typeof model == 'string') {\n    model = {\n      key: model\n    };\n  }\n  let eventName = `attribute:${model.key}`;\n  if (model.name) {\n    eventName += ':' + model.name;\n  }\n  if (model.values) {\n    for (const modelValue of model.values) {\n      config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], 'attribute');\n    }\n  } else {\n    config.view = normalizeToElementConfig(config.view, 'attribute');\n  }\n  const elementCreator = getFromAttributeCreator(config);\n  return dispatcher => {\n    dispatcher.on(eventName, wrap(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n}\n// Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n// or a `{ key, value }` object or a function that takes the model attribute value and returns a `{ key, value }` object.\n// If `key` is `'class'`, `value` can be a `String` or an array of `String`s. If `key` is `'style'`, `value` is an object with\n// key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  let model = config.model;\n  if (typeof model == 'string') {\n    model = {\n      key: model\n    };\n  }\n  let eventName = `attribute:${model.key}`;\n  if (model.name) {\n    eventName += ':' + model.name;\n  }\n  if (model.values) {\n    for (const modelValue of model.values) {\n      config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);\n    }\n  } else {\n    config.view = normalizeToAttributeConfig(config.view);\n  }\n  const elementCreator = getFromAttributeCreator(config);\n  return dispatcher => {\n    dispatcher.on(eventName, changeAttribute(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n}\n// Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToElement(config) {\n  const view = normalizeToElementConfig(config.view, 'ui');\n  return dispatcher => {\n    dispatcher.on(`addMarker:${config.model}`, insertUIElement(view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on(`removeMarker:${config.model}`, removeUIElement(), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n}\n// Model marker to view data conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToData `markerToData()` downcast helper} to learn more.\n//\n// @param {Object} config\n// @param {String} config.model\n// @param {Function} [config.view]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToData(config) {\n  config = cloneDeep(config);\n  const group = config.model;\n  let view = config.view;\n  // Default conversion.\n  if (!view) {\n    view = markerName => ({\n      group,\n      name: markerName.substr(config.model.length + 1)\n    });\n  }\n  return dispatcher => {\n    dispatcher.on(`addMarker:${group}`, insertMarkerData(view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on(`removeMarker:${group}`, removeMarkerData(view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n}\n// Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToHighlight(config) {\n  return dispatcher => {\n    dispatcher.on(`addMarker:${config.model}`, highlightText(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on(`addMarker:${config.model}`, highlightElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on(`removeMarker:${config.model}`, removeHighlight(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n}\n// Takes `config.model`, and converts it to an object with normalized structure.\n//\n// @param {String|Object} model Model configuration or element name.\n// @param {String} model.name\n// @param {Array.<String>} [model.attributes]\n// @param {Boolean} [model.children]\n// @returns {Object}\nfunction normalizeModelElementConfig(model) {\n  if (typeof model == 'string') {\n    model = {\n      name: model\n    };\n  }\n  // List of attributes that should trigger reconversion.\n  if (!model.attributes) {\n    model.attributes = [];\n  } else if (!Array.isArray(model.attributes)) {\n    model.attributes = [model.attributes];\n  }\n  // Whether a children insertion/deletion should trigger reconversion.\n  model.children = !!model.children;\n  return model;\n}\n// Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\nfunction normalizeToElementConfig(view, viewElementType) {\n  if (typeof view == 'function') {\n    // If `view` is already a function, don't do anything.\n    return view;\n  }\n  return (modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType);\n}\n// Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\nfunction createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {\n  if (typeof viewElementDefinition == 'string') {\n    // If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n    viewElementDefinition = {\n      name: viewElementDefinition\n    };\n  }\n  let element;\n  const viewWriter = conversionApi.writer;\n  const attributes = Object.assign({}, viewElementDefinition.attributes);\n  if (viewElementType == 'container') {\n    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);\n  } else if (viewElementType == 'attribute') {\n    const options = {\n      priority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n    };\n    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);\n  } else {\n    // 'ui'.\n    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);\n  }\n  if (viewElementDefinition.styles) {\n    const keys = Object.keys(viewElementDefinition.styles);\n    for (const key of keys) {\n      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);\n    }\n  }\n  if (viewElementDefinition.classes) {\n    const classes = viewElementDefinition.classes;\n    if (typeof classes == 'string') {\n      viewWriter.addClass(classes, element);\n    } else {\n      for (const className of classes) {\n        viewWriter.addClass(className, element);\n      }\n    }\n  }\n  return element;\n}\nfunction getFromAttributeCreator(config) {\n  if (config.model.values) {\n    return (modelAttributeValue, conversionApi, data) => {\n      const view = config.view[modelAttributeValue];\n      if (view) {\n        return view(modelAttributeValue, conversionApi, data);\n      }\n      return null;\n    };\n  } else {\n    return config.view;\n  }\n}\n// Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\nfunction normalizeToAttributeConfig(view) {\n  if (typeof view == 'string') {\n    return modelAttributeValue => ({\n      key: view,\n      value: modelAttributeValue\n    });\n  } else if (typeof view == 'object') {\n    // { key, value, ... }\n    if (view.value) {\n      return () => view;\n    }\n    // { key, ... }\n    else {\n      return modelAttributeValue => ({\n        key: view.key,\n        value: modelAttributeValue\n      });\n    }\n  } else {\n    // function.\n    return view;\n  }\n}\n// Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\nfunction prepareDescriptor(highlightDescriptor, data, conversionApi) {\n  // If passed descriptor is a creator function, call it. If not, just use passed value.\n  const descriptor = typeof highlightDescriptor == 'function' ? highlightDescriptor(data, conversionApi) : highlightDescriptor;\n  if (!descriptor) {\n    return null;\n  }\n  // Apply default descriptor priority.\n  if (!descriptor.priority) {\n    descriptor.priority = 10;\n  }\n  // Default descriptor id is marker name.\n  if (!descriptor.id) {\n    descriptor.id = data.markerName;\n  }\n  return descriptor;\n}\n// Creates a function that checks a single differ diff item whether it should trigger reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\nfunction createChangeReducerCallback(model) {\n  return (node, change) => {\n    if (!node.is('element', model.name)) {\n      return false;\n    }\n    if (change.type == 'attribute') {\n      if (model.attributes.includes(change.attributeKey)) {\n        return true;\n      }\n    } else {\n      /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. */\n      if (model.children) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n// Creates a `reduceChanges` event handler for reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\nfunction createChangeReducer(model) {\n  const shouldReplace = createChangeReducerCallback(model);\n  return (evt, data) => {\n    const reducedChanges = [];\n    if (!data.reconvertedElements) {\n      data.reconvertedElements = new Set();\n    }\n    for (const change of data.changes) {\n      // For attribute use node affected by the change.\n      // For insert or remove use parent element because we need to check if it's added/removed child.\n      const node = change.type == 'attribute' ? change.range.start.nodeAfter : change.position.parent;\n      if (!node || !shouldReplace(node, change)) {\n        reducedChanges.push(change);\n        continue;\n      }\n      // If it's already marked for reconversion, so skip this change, otherwise add the diff items.\n      if (!data.reconvertedElements.has(node)) {\n        data.reconvertedElements.add(node);\n        const position = ModelPosition._createBefore(node);\n        reducedChanges.push({\n          type: 'remove',\n          name: node.name,\n          position,\n          length: 1\n        }, {\n          type: 'reinsert',\n          name: node.name,\n          position,\n          length: 1\n        });\n      }\n    }\n    data.changes = reducedChanges;\n  };\n}\n// Creates a function that checks if an element and its watched attributes can be consumed and consumes them.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {module:engine/conversion/downcasthelpers~ConsumerFunction}\nfunction createConsumer(model) {\n  return function (node, consumable) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const events = ['insert'];\n    // Collect all set attributes that are triggering conversion.\n    for (const attributeName of model.attributes) {\n      if (node.hasAttribute(attributeName)) {\n        events.push(`attribute:${attributeName}`);\n      }\n    }\n    if (!events.every(event => consumable.test(node, event))) {\n      return false;\n    }\n    if (!options.preflight) {\n      events.forEach(event => consumable.consume(node, event));\n    }\n    return true;\n  };\n}\n// Creates a function that create view slots.\n//\n// @param {module:engine/model/element~Element} element\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {Function} Exposed by writer as createSlot().\nfunction createSlotFactory(element, slotsMap, conversionApi) {\n  return function (writer) {\n    let modeOrFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'children';\n    const slot = writer.createContainerElement('$slot');\n    let children = null;\n    if (modeOrFilter === 'children') {\n      children = Array.from(element.getChildren());\n    } else if (typeof modeOrFilter == 'function') {\n      children = Array.from(element.getChildren()).filter(element => modeOrFilter(element));\n    } else {\n      /**\n       * Unknown slot mode was provided to `writer.createSlot()` in downcast converter.\n       *\n       * @error conversion-slot-mode-unknown\n       */\n      throw new CKEditorError('conversion-slot-mode-unknown', conversionApi.dispatcher, {\n        modeOrFilter\n      });\n    }\n    slotsMap.set(slot, children);\n    return slot;\n  };\n}\n// Checks if all children are covered by slots and there is no child that landed in multiple slots.\n//\n// @param {module:engine/model/element~Element}\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction validateSlotsChildren(element, slotsMap, conversionApi) {\n  const childrenInSlots = Array.from(slotsMap.values()).flat();\n  const uniqueChildrenInSlots = new Set(childrenInSlots);\n  if (uniqueChildrenInSlots.size != childrenInSlots.length) {\n    /**\n     * Filters provided to `writer.createSlot()` overlap (at least two filters accept the same child element).\n     *\n     * @error conversion-slot-filter-overlap\n     * @param {module:engine/model/element~Element} element The element of which children would not be properly\n     * allocated to multiple slots.\n     */\n    throw new CKEditorError('conversion-slot-filter-overlap', conversionApi.dispatcher, {\n      element\n    });\n  }\n  if (uniqueChildrenInSlots.size != element.childCount) {\n    /**\n     * Filters provided to `writer.createSlot()` are incomplete and exclude at least one children element (one of\n     * the children elements would not be assigned to any of the slots).\n     *\n     * @error conversion-slot-filter-incomplete\n     * @param {module:engine/model/element~Element} element The element of which children would not be properly\n     * allocated to multiple slots.\n     */\n    throw new CKEditorError('conversion-slot-filter-incomplete', conversionApi.dispatcher, {\n      element\n    });\n  }\n}\n// Fill slots with appropriate view elements.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\nfunction fillSlots(viewElement, slotsMap, conversionApi, options) {\n  // Set temporary position mapping to redirect child view elements into a proper slots.\n  conversionApi.mapper.on('modelToViewPosition', toViewPositionMapping, {\n    priority: 'highest'\n  });\n  let currentSlot = null;\n  let currentSlotNodes = null;\n  // Fill slots with nested view nodes.\n  for ([currentSlot, currentSlotNodes] of slotsMap) {\n    reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);\n    conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));\n    conversionApi.writer.remove(currentSlot);\n  }\n  conversionApi.mapper.off('modelToViewPosition', toViewPositionMapping);\n  function toViewPositionMapping(evt, data) {\n    const element = data.modelPosition.nodeAfter;\n    // Find the proper offset within the slot.\n    const index = currentSlotNodes.indexOf(element);\n    if (index < 0) {\n      return;\n    }\n    data.viewPosition = data.mapper.findPositionIn(currentSlot, index);\n  }\n}\n// Inserts view representation of `nodes` into the `viewElement` either by bringing back just removed view nodes\n// or by triggering conversion for them.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Iterable.<module:engine/model/element~Element>} modelNodes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\nfunction reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {\n  // Fill with nested view nodes.\n  for (const modelChildNode of modelNodes) {\n    // Try reinserting the view node for the specified model node...\n    if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {\n      // ...or else convert the model element to the view.\n      conversionApi.convertItem(modelChildNode);\n    }\n  }\n}\n// Checks if the view for the given model element could be reused and reinserts it to the view.\n//\n// @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewRoot\n// @param {module:engine/model/element~Element} modelElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n// @returns {Boolean} `false` if view element can't be reused.\nfunction reinsertNode(viewRoot, modelNode, conversionApi, options) {\n  const {\n    writer,\n    mapper\n  } = conversionApi;\n  // Don't reinsert if this is not a reconversion...\n  if (!options.reconversion) {\n    return false;\n  }\n  const viewChildNode = mapper.toViewElement(modelNode);\n  // ...or there is no view to reinsert or it was already inserted to the view structure...\n  if (!viewChildNode || viewChildNode.root == viewRoot) {\n    return false;\n  }\n  // ...or it was strictly marked as not to be reused.\n  if (!conversionApi.canReuseView(viewChildNode)) {\n    return false;\n  }\n  // Otherwise reinsert the view node.\n  writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(ModelPosition._createBefore(modelNode)));\n  return true;\n}\n// The default consumer for insert events.\n// @param {module:engine/model/item~Item} item Model item.\n// @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The model consumable.\n// @param {Object} [options]\n// @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n// @returns {Boolean}\nfunction defaultConsumer(item, consumable) {\n  let {\n    preflight\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (preflight) {\n    return consumable.test(item, 'insert');\n  } else {\n    return consumable.consume(item, 'insert');\n  }\n}","map":{"version":3,"names":["ModelRange","ModelSelection","ModelDocumentSelection","ModelElement","ModelPosition","ViewAttributeElement","ConversionHelpers","cloneDeep","CKEditorError","toArray","DowncastHelpers","elementToElement","config","add","downcastElementToElement","elementToStructure","downcastElementToStructure","attributeToElement","downcastAttributeToElement","attributeToAttribute","downcastAttributeToAttribute","markerToElement","downcastMarkerToElement","markerToHighlight","downcastMarkerToHighlight","markerToData","downcastMarkerToData","insertText","evt","data","conversionApi","consumable","consume","item","name","viewWriter","writer","viewPosition","mapper","toViewPosition","range","start","viewText","createText","insert","insertAttributesAndChildren","convertAttributes","reconversion","is","isEmpty","convertChildren","remove","viewStart","position","modelEnd","getShiftedBy","length","viewEnd","isPhantom","viewRange","createRange","removed","getTrimmed","child","createRangeIn","getItems","unbindViewElement","defer","createViewElementFromHighlightDescriptor","descriptor","viewElement","createAttributeElement","attributes","classes","_addClass","priority","_priority","_id","id","convertRangeSelection","selection","isCollapsed","viewRanges","getRanges","push","toViewRange","setSelection","backward","isBackward","convertCollapsedSelection","modelPosition","getFirstPosition","brokenPosition","breakAttributes","clearAttributes","viewSelection","document","end","parent","isAttached","mergeAttributes","wrap","elementCreator","test","oldViewElement","attributeOldValue","newViewElement","attributeNewValue","getFirstRange","unwrap","insertElement","consumer","defaultConsumer","preflight","bindElements","reinsertOrConvertNodes","getChildren","insertStructure","slotsMap","Map","_registerSlotFactory","createSlotFactory","_clearSlotFactory","validateSlotsChildren","fillSlots","insertUIElement","isOpening","viewStartElement","viewEndElement","markerRange","value","bindElementToMarker","markerName","stop","removeUIElement","elements","markerNameToElements","element","unbindElementFromMarkerName","clear","createRangeOn","clearClonedElementsGroup","insertMarkerData","viewCreator","viewMarkerData","handleMarkerBoundary","isStart","elementAfter","nodeAfter","elementBefore","nodeBefore","modelElement","isBefore","toViewElement","insertMarkerAsAttribute","insertMarkerAsElement","attributeName","group","markerNames","hasAttribute","getAttribute","split","unshift","setAttribute","join","viewElementName","attrs","createUIElement","removeMarkerData","viewData","removeMarkerFromAttribute","Set","delete","size","removeAttribute","Array","from","changeAttribute","attributeCreator","oldAttribute","newAttribute","dispatcher","key","className","removeClass","keys","Object","removeStyle","addClass","setStyle","highlightText","highlightDescriptor","prepareDescriptor","rangeAfterWrap","isSimilar","highlightElement","getCustomProperty","_createIn","addHighlightCallback","removeHighlight","viewHighlightElement","removeHighlightCallback","model","normalizeModelElementConfig","view","normalizeToElementConfig","children","on","createConsumer","converterPriority","createChangeReducer","_conversionApi","schema","checkChild","elementName","eventName","values","modelValue","getFromAttributeCreator","normalizeToAttributeConfig","substr","isArray","viewElementType","modelData","createViewElementFromDefinition","viewElementDefinition","assign","createContainerElement","options","DEFAULT_PRIORITY","styles","modelAttributeValue","createChangeReducerCallback","node","change","type","includes","attributeKey","shouldReplace","reducedChanges","reconvertedElements","changes","has","_createBefore","events","every","event","forEach","modeOrFilter","slot","filter","set","childrenInSlots","flat","uniqueChildrenInSlots","childCount","toViewPositionMapping","currentSlot","currentSlotNodes","move","createPositionBefore","off","index","indexOf","findPositionIn","modelNodes","modelChildNode","reinsertNode","root","convertItem","viewRoot","modelNode","viewChildNode","canReuseView"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelDocumentSelection from '../model/documentselection';\nimport ModelElement from '../model/element';\nimport ModelPosition from '../model/position';\nimport ViewAttributeElement from '../view/attributeelement';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n/**\n * Downcast conversion helper functions.\n *\n * Learn more about {@glink framework/guides/deep-dive/conversion/downcast downcast helpers}.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class DowncastHelpers extends ConversionHelpers {\n    /**\n     * Model element to view element conversion helper.\n     *\n     * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'p'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'div',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'fancyParagraph',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'fancy'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'heading',\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or\n     * the `children` props on a model description. You will find a couple examples below.\n     *\n     * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`\n     * description. For example, this model:\n     *\n     *\t\t<box>\n     *\t\t\t<paragraph>Some text.</paragraph>\n     *\t\t</box>\n     *\n     * will be converted into this structure in the view:\n     *\n     *\t\t<div class=\"box\" data-type=\"single\">\n     *\t\t\t<p>Some text.</p>\n     *\t\t</div>\n     *\n     * But if more items were inserted in the model:\n     *\n     *\t\t<box>\n     *\t\t\t<paragraph>Some text.</paragraph>\n     *\t\t\t<paragraph>Other item.</paragraph>\n     *\t\t</box>\n     *\n     * it will be converted into this structure in the view (note the element `data-type` change):\n     *\n     *\t\t<div class=\"box\" data-type=\"multiple\">\n     *\t\t\t<p>Some text.</p>\n     *\t\t\t<p>Other item.</p>\n     *\t\t</div>\n     *\n     * Such a converter would look like this (note that the `paragraph` elements are converted separately):\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: {\n     *\t \t\t\tname: 'box',\n     *\t \t\t\tchildren: true\n     *\t\t\t},\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createContainerElement( 'div', {\n     *\t\t\t\t\tclass: 'box',\n     *\t\t\t\t\t'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`\n     * description. For example, this model:\n     *\n     *\t\t<heading level=\"2\">Some text.</heading>\n     *\n     * will be converted into this structure in the view:\n     *\n     *\t\t<h2>Some text.</h2>\n     *\n     * But if the `heading` element's `level` attribute has been updated to `3` for example, then\n     * it will be converted into this structure in the view:\n     *\n     *\t\t<h3>Some text.</h3>\n     *\n     * Such a converter would look as follows:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: {\n     *\t \t\t\tname: 'heading',\n     *\t \t\t\tattributes: 'level'\n     *\t\t\t},\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * You can read more about the element-to-element conversion in the\n     * {@glink framework/guides/deep-dive/conversion/downcast downcast conversion} guide.\n     *\n     * @method #elementToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The description or a name of the model element to convert.\n     * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n     * the view element. Note that the view will be reconverted if any of the listed attributes changes.\n     * @param {Boolean} [config.model.children] Specifies whether the view element requires reconversion if the list\n     * of the model child nodes changed.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n     * config.view A view element definition or a function that takes the model element and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as parameters and returns a view container element.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    elementToElement(config) {\n        return this.add(downcastElementToElement(config));\n    }\n    /**\n     * The model element to view structure (several elements) conversion helper.\n     *\n     * This conversion results in creating a view structure with one or more slots defined for the child nodes.\n     * For example, a model `<table>` may become this structure in the view:\n     *\n     *\t\t<figure class=\"table\">\n     *\t\t\t<table>\n     *\t\t\t\t<tbody>${ slot for table rows }</tbody>\n     *\t\t\t</table>\n     *\t\t</figure>\n     *\n     * The children of the model's `<table>` element will be inserted into the `<tbody>` element.\n     * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.\n     *\n     * An example converter that converts the following model structure:\n     *\n     *\t\t<wrappedParagraph>Some text.</wrappedParagraph>\n     *\n     * into this structure in the view:\n     *\n     *\t\t<div class=\"wrapper\">\n     *\t\t\t<p>Some text.</p>\n     *\t\t</div>\n     *\n     * would look like this:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n     *\t\t\tmodel: 'wrappedParagraph',\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\tconst wrapperViewElement = writer.createContainerElement( 'div', { class: 'wrapper' } );\n     *\t\t\t\tconst paragraphViewElement = writer.createContainerElement( 'p' );\n     *\n     *\t\t\t\twriter.insert( writer.createPositionAt( wrapperViewElement, 0 ), paragraphViewElement );\n     *\t\t\t\twriter.insert( writer.createPositionAt( paragraphViewElement, 0 ), writer.createSlot() );\n     *\n     *\t\t\t\treturn wrapperViewElement;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The `slorFor()` function can also take a callback that allows filtering which children of the model element\n     * should be converted into this slot.\n     *\n     * Imagine a table feature where for this model structure:\n     *\n     *\t\t<table headingRows=\"1\">\n     *\t\t\t<tableRow> ... table cells 1 ... </tableRow>\n     *\t\t\t<tableRow> ... table cells 2 ... </tableRow>\n     *\t\t\t<tableRow> ... table cells 3 ... </tableRow>\n     *\t\t\t<caption>Caption text</caption>\n     *\t\t</table>\n     *\n     * we want to generate this view structure:\n     *\n     *\t\t<figure class=\"table\">\n     *\t\t\t<table>\n     *\t\t\t\t<thead>\n     *\t\t\t\t\t<tr> ... table cells 1 ... </tr>\n     *\t\t\t\t</thead>\n     *\t\t\t\t<tbody>\n     *\t\t\t\t\t<tr> ... table cells 2 ... </tr>\n     *\t\t\t\t\t<tr> ... table cells 3 ... </tr>\n     *\t\t\t\t</tbody>\n     *\t\t\t</table>\n     *\t\t\t<figcaption>Caption text</figcaption>\n     *\t\t</figure>\n     *\n     * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements\n     * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.\n     *\n     * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.\n     * In the example above, this will handle the table caption.\n     *\n     * Such a converter would look like this:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'table',\n     *\t\t\t\tattributes: [ 'headingRows' ]\n     *\t\t\t},\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\tconst figureElement = writer.createContainerElement( 'figure', { class: 'table' } );\n     *\t\t\t\tconst tableElement = writer.createContainerElement( 'table' );\n     *\n     *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 0 ), tableElement );\n     *\n     *\t\t\t\tconst headingRows = modelElement.getAttribute( 'headingRows' ) || 0;\n     *\n     *\t\t\t\tif ( headingRows > 0 ) {\n     *\t\t\t\t\tconst tableHead = writer.createContainerElement( 'thead' );\n     *\n     *\t\t\t\t\tconst headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );\n     *\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableHead, 0 ), headSlot );\n     *\t\t\t\t}\n     *\n     *\t\t\t\tif ( headingRows < tableUtils.getRows( table ) ) {\n     *\t\t\t\t\tconst tableBody = writer.createContainerElement( 'tbody' );\n     *\n     *\t\t\t\t\tconst bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );\n     *\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );\n     *\t\t\t\t}\n     *\n     *\t\t\t\tconst restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );\n     *\n     *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );\n     *\n     *\t\t\t\treturn figureElement;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Note: The children of a model element that's being converted must be allocated in the same order in the view\n     * in which they are placed in the model.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToStructure\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The description or a name of the model element to convert.\n     * @param {String} [config.model.name] The name of the model element to convert.\n     * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n     * the view structure. Note that the view will be reconverted if any of the listed attributes will change.\n     * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view A function\n     * that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n     * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    elementToStructure(config) {\n        return this.add(downcastElementToStructure(config));\n    }\n    /**\n     * Model attribute to view element conversion helper.\n     *\n     * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n     * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'strong'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'b',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'invert',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'fontSize',\n     *\t\t\t\tvalues: [ 'big', 'small' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tbig: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '1.2em'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tsmall: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '0.8em'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createAttributeElement( 'span', {\n     *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'color',\n     *\t\t\t\tname: '$text'\n     *\t\t\t},\n     *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createAttributeElement( 'span', {\n     *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n     * of `String`s with possible values if the model attribute is an enumerable.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|Object|\n     * module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction} config.view A view element definition or a function\n     * that takes the model attribute value and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n     * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`\n     * to view element definitions or functions.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    attributeToElement(config) {\n        return this.add(downcastAttributeToElement(config));\n    }\n    /**\n     * Model attribute to view attribute conversion helper.\n     *\n     * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n     * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'source',\n     *\t\t\tview: 'src'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'source',\n     *\t\t\tview: 'href',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'imageInline',\n     *\t\t\t\tkey: 'source'\n     *\t\t\t},\n     *\t\t\tview: 'src'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'styled',\n     *\t\t\t\tvalues: [ 'dark', 'light' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tdark: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n     *\t\t\t\t},\n     *\t\t\t\tlight: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'styled',\n     *\t\t\tview: modelAttributeValue => ( {\n     *\t\t\t\tkey: 'class',\n     *\t\t\t\tvalue: 'styled-' + modelAttributeValue\n     *\t\t\t} )\n     *\t\t} );\n     *\n     * **Note**: Downcasting to a style property requires providing `value` as an object:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'lineHeight',\n     *\t\t\tview: modelAttributeValue => ( {\n     *\t\t\t\tkey: 'style',\n     *\t\t\t\tvalue: {\n     *\t\t\t\t\t'line-height': modelAttributeValue,\n     *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n     *\t\t\t\t}\n     *\t\t\t} )\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToAttribute\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n     * the attribute key, possible values and, optionally, an element name to convert from.\n     * @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n     * or a `{ key, value }` object or a function that takes the model attribute value and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an\n     * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n     * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n     * `{ key, value }` objects or a functions.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    attributeToAttribute(config) {\n        return this.add(downcastAttributeToAttribute(config));\n    }\n    /**\n     * Model marker to view element conversion helper.\n     *\n     * **Note**: This method should be used mainly for editing the downcast and it is recommended\n     * to use the {@link #markerToData `#markerToData()`} helper instead.\n     *\n     * This helper may produce invalid HTML code (e.g. a span between table cells).\n     * It should only be used when you are sure that the produced HTML will be semantically correct.\n     *\n     * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n     * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n     * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: 'marker-search'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: 'search-result',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tattributes: {\n     *\t\t\t\t\t'data-marker': 'search'\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: ( markerData, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createUIElement( 'span', {\n     *\t\t\t\t\t'data-marker': 'search',\n     *\t\t\t\t\t'data-start': markerData.isOpening\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n     * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as a parameters and should return an instance of the\n     * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n     * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n     * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for\n     * the marker end boundary element.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #markerToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or model marker group) to convert.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function that\n     * takes the model marker data and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as a parameters and returns a view UI element.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    markerToElement(config) {\n        return this.add(downcastMarkerToElement(config));\n    }\n    /**\n     * Model marker to highlight conversion helper.\n     *\n     * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n     * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n     *\n     * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n     * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n     * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n     *\n     * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n     * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n     * For example, a model marker set like this:\n     * `[<imageInline src=\"foo.jpg\"></imageInline>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>` in the view.\n     *\n     * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n     * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n     * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n     *\t\t\tmodel: 'comment',\n     *\t\t\tview: { classes: 'comment' },\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n     *\t\t\tmodel: 'comment',\n     *\t\t\tview: ( data, conversionApi ) => {\n     *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType:commentId.\n     *\t\t\t\tconst [ , commentType, commentId ] = data.markerName.split( ':' );\n     *\n     *\t\t\t\treturn {\n     *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ],\n     *\t\t\t\t\tattributes: { 'data-comment-id': commentId }\n     *\t\t\t\t};\n     *\t\t\t}\n     *\t\t} );\n     *\n     * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n     * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as the parameters and should return a\n     * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n     * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #markerToHighlight\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or model marker group) to convert.\n     * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n     * that will be used for highlighting or a function that takes the model marker data and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters\n     * and returns a highlight descriptor.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    markerToHighlight(config) {\n        return this.add(downcastMarkerToHighlight(config));\n    }\n    /**\n     * Model marker converter for data downcast.\n     *\n     * This conversion creates a representation for model marker boundaries in the view:\n     *\n     * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.\n     * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.\n     *\n     * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.\n     * The default configuration for this conversion is that the first part is the `group` part and the rest of\n     * the marker name becomes the `name` part.\n     *\n     * Tag and attribute names and values are generated from the marker name:\n     *\n     * * The templates for attributes are `data-[group]-start-before=\"[name]\"`, `data-[group]-start-after=\"[name]\"`,\n     * `data-[group]-end-before=\"[name]\"` and `data-[group]-end-after=\"[name]\"`.\n     * * The templates for view elements are `<[group]-start name=\"[name]\">` and `<[group]-end name=\"[name]\">`.\n     *\n     * Attributes mark whether the given marker's start or end boundary is before or after the given element.\n     * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.\n     * The other two are used when the former two cannot be used.\n     *\n     * The conversion configuration can take a function that will generate different group and name parts.\n     * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two\n     * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.\n     *\n     * Basic usage:\n     *\n     *\t\t// Using the default conversion.\n     *\t\t// In this case, all markers with names starting with 'comment:' will be converted.\n     *\t\t// The `group` parameter will be set to `comment`.\n     *\t\t// The `name` parameter will be the rest of the marker name (without the `:`).\n     *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n     *\t\t\tmodel: 'comment'\n     *\t\t} );\n     *\n     * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked\n     * by `[]`):\n     *\n     *\t\t// Model:\n     *\t\t<paragraph>Foo[bar</paragraph>\n     *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n     *\n     *\t\t// View:\n     *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n     *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n     *\n     * In the example above, the comment starts before \"bar\" and ends after the image.\n     *\n     * If the `name` part is empty, the following view may be generated:\n     *\n     *\t\t<p>Foo <myMarker-start></myMarker-start>bar</p>\n     *\t\t<figure data-myMarker-end-after=\"\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n     *\n     * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.\n     *\n     * Examples where `data-group-start-after` and `data-group-end-before` are used:\n     *\n     *\t\t// Model:\n     *\t\t<blockQuote>[]<paragraph>Foo</paragraph></blockQuote>\n     *\n     *\t\t// View:\n     *\t\t<blockquote><p data-group-end-before=\"name\" data-group-start-before=\"name\">Foo</p></blockquote>\n     *\n     * Similarly, when a marker is collapsed after the last element:\n     *\n     *\t\t// Model:\n     *\t\t<blockQuote><paragraph>Foo</paragraph>[]</blockQuote>\n     *\n     *\t\t// View:\n     *\t\t<blockquote><p data-group-end-after=\"name\" data-group-start-after=\"name\">Foo</p></blockquote>\n     *\n     * When there are multiple markers from the same group stored in the same attribute of the same element, their\n     * name parts are put together in the attribute value, for example: `data-group-start-before=\"name1,name2,name3\"`.\n     *\n     * Other examples of usage:\n     *\n     *\t\t// Using a custom function which is the same as the default conversion:\n     *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n     *\t\t\tmodel: 'comment'\n     *\t\t\tview: markerName => ( {\n     *\t\t\t\tgroup: 'comment',\n     *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n     *\t\t\t} )\n     *\t\t} );\n     *\n     *\t\t// Using the converter priority:\n     *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n     *\t\t\tmodel: 'comment'\n     *\t\t\tview: markerName => ( {\n     *\t\t\t\tgroup: 'comment',\n     *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n     *\t\t\t} ),\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n     *\n     * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to\n     * add a converter to the conversion process.\n     *\n     * @method #markerToData\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or the model marker group) to convert.\n     * @param {Function} [config.view] A function that takes the model marker name and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters\n     * and returns an object with the `group` and `name` properties.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    markerToData(config) {\n        return this.add(downcastMarkerToData(config));\n    }\n}\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\nexport function insertText() {\n    return (evt, data, conversionApi) => {\n        if (!conversionApi.consumable.consume(data.item, evt.name)) {\n            return;\n        }\n        const viewWriter = conversionApi.writer;\n        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n        const viewText = viewWriter.createText(data.item.data);\n        viewWriter.insert(viewPosition, viewText);\n    };\n}\n/**\n * Function factory that creates a default downcast converter for triggering attributes and children conversion.\n *\n * @returns {Function} The converter.\n */\nexport function insertAttributesAndChildren() {\n    return (evt, data, conversionApi) => {\n        conversionApi.convertAttributes(data.item);\n        // Start converting children of the current item.\n        // In case of reconversion children were already re-inserted or converted separately.\n        if (!data.reconversion && data.item.is('element') && !data.item.isEmpty) {\n            conversionApi.convertChildren(data.item);\n        }\n    };\n}\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\nexport function remove() {\n    return (evt, data, conversionApi) => {\n        // Find the view range start position by mapping the model position at which the remove happened.\n        const viewStart = conversionApi.mapper.toViewPosition(data.position);\n        const modelEnd = data.position.getShiftedBy(data.length);\n        const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, { isPhantom: true });\n        const viewRange = conversionApi.writer.createRange(viewStart, viewEnd);\n        // Trim the range to remove in case some UI elements are on the view range boundaries.\n        const removed = conversionApi.writer.remove(viewRange.getTrimmed());\n        // After the range is removed, unbind all view elements from the model.\n        // Range inside view document fragment is used to unbind deeply.\n        for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {\n            conversionApi.mapper.unbindViewElement(child, { defer: true });\n        }\n    };\n}\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If the priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\nexport function createViewElementFromHighlightDescriptor(writer, descriptor) {\n    const viewElement = writer.createAttributeElement('span', descriptor.attributes);\n    if (descriptor.classes) {\n        viewElement._addClass(descriptor.classes);\n    }\n    if (typeof descriptor.priority === 'number') {\n        viewElement._priority = descriptor.priority;\n    }\n    viewElement._id = descriptor.id;\n    return viewElement;\n}\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\nexport function convertRangeSelection() {\n    return (evt, data, conversionApi) => {\n        const selection = data.selection;\n        if (selection.isCollapsed) {\n            return;\n        }\n        if (!conversionApi.consumable.consume(selection, 'selection')) {\n            return;\n        }\n        const viewRanges = [];\n        for (const range of selection.getRanges()) {\n            viewRanges.push(conversionApi.mapper.toViewRange(range));\n        }\n        conversionApi.writer.setSelection(viewRanges, { backward: selection.isBackward });\n    };\n}\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\nexport function convertCollapsedSelection() {\n    return (evt, data, conversionApi) => {\n        const selection = data.selection;\n        if (!selection.isCollapsed) {\n            return;\n        }\n        if (!conversionApi.consumable.consume(selection, 'selection')) {\n            return;\n        }\n        const viewWriter = conversionApi.writer;\n        const modelPosition = selection.getFirstPosition();\n        const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n        const brokenPosition = viewWriter.breakAttributes(viewPosition);\n        viewWriter.setSelection(brokenPosition);\n    };\n}\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\nexport function clearAttributes() {\n    return (evt, data, conversionApi) => {\n        const viewWriter = conversionApi.writer;\n        const viewSelection = viewWriter.document.selection;\n        for (const range of viewSelection.getRanges()) {\n            // Not collapsed selection should not have artifacts.\n            if (range.isCollapsed) {\n                // Position might be in the node removed by the view writer.\n                if (range.end.parent.isAttached()) {\n                    conversionApi.writer.mergeAttributes(range.start);\n                }\n            }\n        }\n        viewWriter.setSelection(null);\n    };\n}\n/**\n * Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, { writer } ) => {\n *\t\t\treturn writer.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\nexport function wrap(elementCreator) {\n    return (evt, data, conversionApi) => {\n        if (!conversionApi.consumable.test(data.item, evt.name)) {\n            return;\n        }\n        // Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n        // or the attribute was removed.\n        const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data);\n        // Create node to wrap with.\n        const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);\n        if (!oldViewElement && !newViewElement) {\n            return;\n        }\n        conversionApi.consumable.consume(data.item, evt.name);\n        const viewWriter = conversionApi.writer;\n        const viewSelection = viewWriter.document.selection;\n        if (data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) {\n            // Selection attribute conversion.\n            viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);\n        }\n        else {\n            // Node attribute conversion.\n            let viewRange = conversionApi.mapper.toViewRange(data.range);\n            // First, unwrap the range from current wrapper.\n            if (data.attributeOldValue !== null && oldViewElement) {\n                viewRange = viewWriter.unwrap(viewRange, oldViewElement);\n            }\n            if (data.attributeNewValue !== null && newViewElement) {\n                viewWriter.wrap(viewRange, newViewElement);\n            }\n        }\n    };\n}\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, { writer } ) => {\n *\t\t\t\tconst text = writer.createText( 'myText' );\n *\t\t\t\tconst myElem = writer.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} [consumer] Function defining element consumption process.\n * By default this function just consume passed item insertion.\n * @returns {Function} Insert element event converter.\n */\nexport function insertElement(elementCreator, consumer = defaultConsumer) {\n    return (evt, data, conversionApi) => {\n        if (!consumer(data.item, conversionApi.consumable, { preflight: true })) {\n            return;\n        }\n        const viewElement = elementCreator(data.item, conversionApi, data);\n        if (!viewElement) {\n            return;\n        }\n        // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n        consumer(data.item, conversionApi.consumable);\n        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n        conversionApi.mapper.bindElements(data.item, viewElement);\n        conversionApi.writer.insert(viewPosition, viewElement);\n        // Convert attributes before converting children.\n        conversionApi.convertAttributes(data.item);\n        // Convert children or reinsert previous view elements.\n        reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, { reconversion: data.reconversion });\n    };\n}\n/**\n * Function factory that creates a converter which converts a single model node insertion to a view structure.\n *\n * It is expected that the passed element creator function returns an {@link module:engine/view/element~Element} with attached slots\n * created with `writer.createSlot()` to indicate where child nodes should be converted.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n *\n * @protected\n * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} elementCreator Function returning a view structure,\n * which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} consumer A callback that is expected to consume all the consumables\n * that were used by the element creator.\n * @returns {Function} Insert element event converter.\n*/\nexport function insertStructure(elementCreator, consumer) {\n    return (evt, data, conversionApi) => {\n        if (!consumer(data.item, conversionApi.consumable, { preflight: true })) {\n            return;\n        }\n        const slotsMap = new Map();\n        conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi));\n        // View creation.\n        const viewElement = elementCreator(data.item, conversionApi, data);\n        conversionApi.writer._clearSlotFactory();\n        if (!viewElement) {\n            return;\n        }\n        // Check if all children are covered by slots and there is no child that landed in multiple slots.\n        validateSlotsChildren(data.item, slotsMap, conversionApi);\n        // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n        consumer(data.item, conversionApi.consumable);\n        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n        conversionApi.mapper.bindElements(data.item, viewElement);\n        conversionApi.writer.insert(viewPosition, viewElement);\n        // Convert attributes before converting children.\n        conversionApi.convertAttributes(data.item);\n        // Fill view slots with previous view elements or create new ones.\n        fillSlots(viewElement, slotsMap, conversionApi, { reconversion: data.reconversion });\n    };\n}\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertUIElement(elementCreator) {\n    return (evt, data, conversionApi) => {\n        // Create two view elements. One will be inserted at the beginning of marker, one at the end.\n        // If marker is collapsed, only \"opening\" element will be inserted.\n        data.isOpening = true;\n        const viewStartElement = elementCreator(data, conversionApi);\n        data.isOpening = false;\n        const viewEndElement = elementCreator(data, conversionApi);\n        if (!viewStartElement || !viewEndElement) {\n            return;\n        }\n        const markerRange = data.markerRange;\n        // Marker that is collapsed has consumable build differently that non-collapsed one.\n        // For more information see `addMarker` event description.\n        // If marker's range is collapsed - check if it can be consumed.\n        if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {\n            return;\n        }\n        // If marker's range is not collapsed - consume all items inside.\n        for (const value of markerRange) {\n            if (!conversionApi.consumable.consume(value.item, evt.name)) {\n                return;\n            }\n        }\n        const mapper = conversionApi.mapper;\n        const viewWriter = conversionApi.writer;\n        // Add \"opening\" element.\n        viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);\n        conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName);\n        // Add \"closing\" element only if range is not collapsed.\n        if (!markerRange.isCollapsed) {\n            viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);\n            conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);\n        }\n        evt.stop();\n    };\n}\n// Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// based on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\nfunction removeUIElement() {\n    return (evt, data, conversionApi) => {\n        const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n        if (!elements) {\n            return;\n        }\n        for (const element of elements) {\n            conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n            conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n        }\n        conversionApi.writer.clearClonedElementsGroup(data.markerName);\n        evt.stop();\n    };\n}\n// Function factory that creates a default converter for model markers.\n//\n// See {@link DowncastHelpers#markerToData} for more information what type of view is generated.\n//\n// This converter binds created UI elements and affected view elements with the marker name\n// using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n//\n// @returns {Function} Add marker converter.\nfunction insertMarkerData(viewCreator) {\n    return (evt, data, conversionApi) => {\n        const viewMarkerData = viewCreator(data.markerName, conversionApi);\n        if (!viewMarkerData) {\n            return;\n        }\n        const markerRange = data.markerRange;\n        if (!conversionApi.consumable.consume(markerRange, evt.name)) {\n            return;\n        }\n        // Adding closing data first to keep the proper order in the view.\n        handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);\n        handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);\n        evt.stop();\n    };\n}\n// Helper function for `insertMarkerData()` that marks a marker boundary at the beginning or end of given `range`.\nfunction handleMarkerBoundary(range, isStart, conversionApi, data, viewMarkerData) {\n    const modelPosition = isStart ? range.start : range.end;\n    const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is('element') ? modelPosition.nodeAfter : null;\n    const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is('element') ? modelPosition.nodeBefore : null;\n    if (elementAfter || elementBefore) {\n        let modelElement;\n        let isBefore;\n        // If possible, we want to add `data-group-start-before` and `data-group-end-after` attributes.\n        if (isStart && elementAfter || !isStart && !elementBefore) {\n            // [<elementAfter>...</elementAfter> -> <elementAfter data-group-start-before=\"...\">...</elementAfter>\n            // <parent>]<elementAfter> -> <parent><elementAfter data-group-end-before=\"...\">\n            modelElement = elementAfter;\n            isBefore = true;\n        }\n        else {\n            // <elementBefore>...</elementBefore>] -> <elementBefore data-group-end-after=\"...\">...</elementBefore>\n            // </elementBefore>[</parent> -> </elementBefore data-group-start-after=\"...\"></parent>\n            modelElement = elementBefore;\n            isBefore = false;\n        }\n        const viewElement = conversionApi.mapper.toViewElement(modelElement);\n        // In rare circumstances, the model element may be not mapped to any view element and that would cause an error.\n        // One of those situations is a soft break inside code block.\n        if (viewElement) {\n            insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);\n            return;\n        }\n    }\n    const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n    insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);\n}\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as an attribute on a view element.\nfunction insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {\n    const attributeName = `data-${viewMarkerData.group}-${isStart ? 'start' : 'end'}-${isBefore ? 'before' : 'after'}`;\n    const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(',') : [];\n    // Adding marker name at the beginning to have the same order in the attribute as there is with marker elements.\n    markerNames.unshift(viewMarkerData.name);\n    conversionApi.writer.setAttribute(attributeName, markerNames.join(','), viewElement);\n    conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n}\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as a separate view ui element.\nfunction insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {\n    const viewElementName = `${viewMarkerData.group}-${isStart ? 'start' : 'end'}`;\n    const attrs = viewMarkerData.name ? { 'name': viewMarkerData.name } : null;\n    const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);\n    conversionApi.writer.insert(position, viewElement);\n    conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n}\n// Function factory that creates a converter for removing a model marker data added by the {@link #insertMarkerData} converter.\n//\n// @returns {Function} Remove marker converter.\nfunction removeMarkerData(viewCreator) {\n    return (evt, data, conversionApi) => {\n        const viewData = viewCreator(data.markerName, conversionApi);\n        if (!viewData) {\n            return;\n        }\n        const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n        if (!elements) {\n            return;\n        }\n        for (const element of elements) {\n            conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n            if (element.is('containerElement')) {\n                removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element);\n                removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element);\n                removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element);\n                removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element);\n            }\n            else {\n                conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n            }\n        }\n        conversionApi.writer.clearClonedElementsGroup(data.markerName);\n        evt.stop();\n        function removeMarkerFromAttribute(attributeName, element) {\n            if (element.hasAttribute(attributeName)) {\n                const markerNames = new Set(element.getAttribute(attributeName).split(','));\n                markerNames.delete(viewData.name);\n                if (markerNames.size == 0) {\n                    conversionApi.writer.removeAttribute(attributeName, element);\n                }\n                else {\n                    conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(','), element);\n                }\n            }\n        }\n    };\n}\n// Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\nfunction changeAttribute(attributeCreator) {\n    return (evt, data, conversionApi) => {\n        if (!conversionApi.consumable.test(data.item, evt.name)) {\n            return;\n        }\n        const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);\n        const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);\n        if (!oldAttribute && !newAttribute) {\n            return;\n        }\n        conversionApi.consumable.consume(data.item, evt.name);\n        const viewElement = conversionApi.mapper.toViewElement(data.item);\n        const viewWriter = conversionApi.writer;\n        // If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n        // Only elements can have attributes in a view so do not proceed for anything else (#1587).\n        if (!viewElement) {\n            /**\n             * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n             * by an {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n             * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n             *\n             *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n             *\t\t\tmodel: 'attribute-name',\n             *\t\t\tview: 'attribute-name'\n             *\t\t} ) );\n             *\n             * and given attribute is used on text node, for example:\n             *\n             *\t\tmodel.change( writer => {\n             *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n             *\t\t} );\n             *\n             * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n             * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n             * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n             * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n             *\n             *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n             *\t\t\tmodel: {\n             *\t\t\t\tkey: 'attribute-name',\n             *\t\t\t\tname: '$text'\n             *\t\t\t},\n             *\t\t\tview: ( value, { writer } ) => {\n             *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n             *\t\t\t},\n             *\t\t\tconverterPriority: 'high'\n             *\t\t} ) );\n             *\n             * @error conversion-attribute-to-attribute-on-text\n             */\n            throw new CKEditorError('conversion-attribute-to-attribute-on-text', conversionApi.dispatcher, data);\n        }\n        // First remove the old attribute if there was one.\n        if (data.attributeOldValue !== null && oldAttribute) {\n            if (oldAttribute.key == 'class') {\n                const classes = toArray(oldAttribute.value);\n                for (const className of classes) {\n                    viewWriter.removeClass(className, viewElement);\n                }\n            }\n            else if (oldAttribute.key == 'style') {\n                const keys = Object.keys(oldAttribute.value);\n                for (const key of keys) {\n                    viewWriter.removeStyle(key, viewElement);\n                }\n            }\n            else {\n                viewWriter.removeAttribute(oldAttribute.key, viewElement);\n            }\n        }\n        // Then set the new attribute.\n        if (data.attributeNewValue !== null && newAttribute) {\n            if (newAttribute.key == 'class') {\n                const classes = toArray(newAttribute.value);\n                for (const className of classes) {\n                    viewWriter.addClass(className, viewElement);\n                }\n            }\n            else if (newAttribute.key == 'style') {\n                const keys = Object.keys(newAttribute.value);\n                for (const key of keys) {\n                    viewWriter.setStyle(key, newAttribute.value[key], viewElement);\n                }\n            }\n            else {\n                viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);\n            }\n        }\n    };\n}\n// Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightText(highlightDescriptor) {\n    return (evt, data, conversionApi) => {\n        if (!data.item) {\n            return;\n        }\n        if (!(data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) && !data.item.is('$textProxy')) {\n            return;\n        }\n        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n        if (!descriptor) {\n            return;\n        }\n        if (!conversionApi.consumable.consume(data.item, evt.name)) {\n            return;\n        }\n        const viewWriter = conversionApi.writer;\n        const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);\n        const viewSelection = viewWriter.document.selection;\n        if (data.item instanceof ModelSelection || data.item instanceof ModelDocumentSelection) {\n            viewWriter.wrap(viewSelection.getFirstRange(), viewElement);\n        }\n        else {\n            const viewRange = conversionApi.mapper.toViewRange(data.range);\n            const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);\n            for (const element of rangeAfterWrap.getItems()) {\n                if (element.is('attributeElement') && element.isSimilar(viewElement)) {\n                    conversionApi.mapper.bindElementToMarker(element, data.markerName);\n                    // One attribute element is enough, because all of them are bound together by the view writer.\n                    // Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n                    break;\n                }\n            }\n        }\n    };\n}\n// Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightElement(highlightDescriptor) {\n    return (evt, data, conversionApi) => {\n        if (!data.item) {\n            return;\n        }\n        if (!(data.item instanceof ModelElement)) {\n            return;\n        }\n        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n        if (!descriptor) {\n            return;\n        }\n        if (!conversionApi.consumable.test(data.item, evt.name)) {\n            return;\n        }\n        const viewElement = conversionApi.mapper.toViewElement(data.item);\n        if (viewElement && viewElement.getCustomProperty('addHighlight')) {\n            // Consume element itself.\n            conversionApi.consumable.consume(data.item, evt.name);\n            // Consume all children nodes.\n            for (const value of ModelRange._createIn(data.item)) {\n                conversionApi.consumable.consume(value.item, evt.name);\n            }\n            const addHighlightCallback = viewElement.getCustomProperty('addHighlight');\n            addHighlightCallback(viewElement, descriptor, conversionApi.writer);\n            conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n        }\n    };\n}\n// Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction removeHighlight(highlightDescriptor) {\n    return (evt, data, conversionApi) => {\n        // This conversion makes sense only for non-collapsed range.\n        if (data.markerRange.isCollapsed) {\n            return;\n        }\n        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n        if (!descriptor) {\n            return;\n        }\n        // View element that will be used to unwrap `AttributeElement`s.\n        const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor);\n        // Get all elements bound with given marker name.\n        const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n        if (!elements) {\n            return;\n        }\n        for (const element of elements) {\n            conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n            if (element.is('attributeElement')) {\n                conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);\n            }\n            else {\n                // if element.is( 'containerElement' ).\n                const removeHighlightCallback = element.getCustomProperty('removeHighlight');\n                removeHighlightCallback(element, descriptor.id, conversionApi.writer);\n            }\n        }\n        conversionApi.writer.clearClonedElementsGroup(data.markerName);\n        evt.stop();\n    };\n}\n// Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The description or a name of the model element to convert.\n// @param {String|Array.<String>} [config.model.attributes] List of attributes triggering element reconversion.\n// @param {Boolean} [config.model.children] Should reconvert element if the list of model child nodes changed.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n// config.view\n// @returns {Function} Conversion helper.\nfunction downcastElementToElement(config) {\n    const model = normalizeModelElementConfig(config.model);\n    const view = normalizeToElementConfig(config.view, 'container');\n    // Trigger reconversion on children list change if element is a subject to any reconversion.\n    // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n    if (model.attributes.length) {\n        model.children = true;\n    }\n    return (dispatcher) => {\n        dispatcher.on(`insert:${model.name}`, insertElement(view, createConsumer(model)), { priority: config.converterPriority || 'normal' });\n        if (model.children || model.attributes.length) {\n            dispatcher.on('reduceChanges', createChangeReducer(model), { priority: 'low' });\n        }\n    };\n}\n// Model element to view structure conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToStructure `.elementToStructure()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model\n// @param {String} [config.model.name]\n// @param {Array.<String>} [config.model.attributes]\n// @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view\n// @returns {Function} Conversion helper.\nfunction downcastElementToStructure(config) {\n    const model = normalizeModelElementConfig(config.model);\n    const view = normalizeToElementConfig(config.view, 'container');\n    // Trigger reconversion on children list change because it always needs to use slots to put children in proper places.\n    // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n    model.children = true;\n    return (dispatcher) => {\n        if (dispatcher._conversionApi.schema.checkChild(model.name, '$text')) {\n            /**\n             * This error occurs when a {@link module:engine/model/element~Element model element} is downcasted\n             * via {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure} helper but the element was\n             * allowed to host `$text` by the {@link module:engine/model/schema~Schema model schema}.\n             *\n             * For instance, this may be the result of `myElement` allowing the content of\n             * {@glink framework/guides/deep-dive/schema#generic-items `$block`} in its schema definition:\n             *\n             *\t\t// Element definition in schema.\n             *\t\tschema.register( 'myElement', {\n             *\t\t\tallowContentOf: '$block',\n             *\n             *\t\t\t// ...\n             *\t\t} );\n             *\n             *\t\t// ...\n             *\n             *\t\t// Conversion of myElement with the use of elementToStructure().\n             *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n             *\t\t\tmodel: 'myElement',\n             *\t\t\tview: ( modelElement, { writer } ) => {\n             *\t\t\t\t// ...\n             *\t\t\t}\n             *\t\t} );\n             *\n             * In such case, {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} helper\n             * can be used instead to get around this problem:\n             *\n             *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n             *\t\t\tmodel: 'myElement',\n             *\t\t\tview: ( modelElement, { writer } ) => {\n             *\t\t\t\t// ...\n             *\t\t\t}\n             *\t\t} );\n             *\n             * @error conversion-element-to-structure-disallowed-text\n             * @param {String} elementName The name of the element the structure is to be created for.\n             */\n            throw new CKEditorError('conversion-element-to-structure-disallowed-text', dispatcher, { elementName: model.name });\n        }\n        dispatcher.on(`insert:${model.name}`, insertStructure(view, createConsumer(model)), { priority: config.converterPriority || 'normal' });\n        dispatcher.on('reduceChanges', createChangeReducer(model), { priority: 'low' });\n    };\n}\n// Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction|\n// Object} config.view A view element definition or a function that takes the model attribute value and\n// {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} as parameters and returns a view attribute element.\n// If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values` to view element\n// definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToElement(config) {\n    config = cloneDeep(config);\n    let model = config.model;\n    if (typeof model == 'string') {\n        model = { key: model };\n    }\n    let eventName = `attribute:${model.key}`;\n    if (model.name) {\n        eventName += ':' + model.name;\n    }\n    if (model.values) {\n        for (const modelValue of model.values) {\n            config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], 'attribute');\n        }\n    }\n    else {\n        config.view = normalizeToElementConfig(config.view, 'attribute');\n    }\n    const elementCreator = getFromAttributeCreator(config);\n    return (dispatcher) => {\n        dispatcher.on(eventName, wrap(elementCreator), { priority: config.converterPriority || 'normal' });\n    };\n}\n// Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n// or a `{ key, value }` object or a function that takes the model attribute value and returns a `{ key, value }` object.\n// If `key` is `'class'`, `value` can be a `String` or an array of `String`s. If `key` is `'style'`, `value` is an object with\n// key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToAttribute(config) {\n    config = cloneDeep(config);\n    let model = config.model;\n    if (typeof model == 'string') {\n        model = { key: model };\n    }\n    let eventName = `attribute:${model.key}`;\n    if (model.name) {\n        eventName += ':' + model.name;\n    }\n    if (model.values) {\n        for (const modelValue of model.values) {\n            config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);\n        }\n    }\n    else {\n        config.view = normalizeToAttributeConfig(config.view);\n    }\n    const elementCreator = getFromAttributeCreator(config);\n    return (dispatcher) => {\n        dispatcher.on(eventName, changeAttribute(elementCreator), { priority: config.converterPriority || 'normal' });\n    };\n}\n// Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToElement(config) {\n    const view = normalizeToElementConfig(config.view, 'ui');\n    return (dispatcher) => {\n        dispatcher.on(`addMarker:${config.model}`, insertUIElement(view), { priority: config.converterPriority || 'normal' });\n        dispatcher.on(`removeMarker:${config.model}`, removeUIElement(), { priority: config.converterPriority || 'normal' });\n    };\n}\n// Model marker to view data conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToData `markerToData()` downcast helper} to learn more.\n//\n// @param {Object} config\n// @param {String} config.model\n// @param {Function} [config.view]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToData(config) {\n    config = cloneDeep(config);\n    const group = config.model;\n    let view = config.view;\n    // Default conversion.\n    if (!view) {\n        view = markerName => ({\n            group,\n            name: markerName.substr(config.model.length + 1)\n        });\n    }\n    return (dispatcher) => {\n        dispatcher.on(`addMarker:${group}`, insertMarkerData(view), { priority: config.converterPriority || 'normal' });\n        dispatcher.on(`removeMarker:${group}`, removeMarkerData(view), { priority: config.converterPriority || 'normal' });\n    };\n}\n// Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToHighlight(config) {\n    return (dispatcher) => {\n        dispatcher.on(`addMarker:${config.model}`, highlightText(config.view), { priority: config.converterPriority || 'normal' });\n        dispatcher.on(`addMarker:${config.model}`, highlightElement(config.view), { priority: config.converterPriority || 'normal' });\n        dispatcher.on(`removeMarker:${config.model}`, removeHighlight(config.view), { priority: config.converterPriority || 'normal' });\n    };\n}\n// Takes `config.model`, and converts it to an object with normalized structure.\n//\n// @param {String|Object} model Model configuration or element name.\n// @param {String} model.name\n// @param {Array.<String>} [model.attributes]\n// @param {Boolean} [model.children]\n// @returns {Object}\nfunction normalizeModelElementConfig(model) {\n    if (typeof model == 'string') {\n        model = { name: model };\n    }\n    // List of attributes that should trigger reconversion.\n    if (!model.attributes) {\n        model.attributes = [];\n    }\n    else if (!Array.isArray(model.attributes)) {\n        model.attributes = [model.attributes];\n    }\n    // Whether a children insertion/deletion should trigger reconversion.\n    model.children = !!model.children;\n    return model;\n}\n// Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\nfunction normalizeToElementConfig(view, viewElementType) {\n    if (typeof view == 'function') {\n        // If `view` is already a function, don't do anything.\n        return view;\n    }\n    return ((modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType));\n}\n// Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\nfunction createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {\n    if (typeof viewElementDefinition == 'string') {\n        // If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n        viewElementDefinition = { name: viewElementDefinition };\n    }\n    let element;\n    const viewWriter = conversionApi.writer;\n    const attributes = Object.assign({}, viewElementDefinition.attributes);\n    if (viewElementType == 'container') {\n        element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);\n    }\n    else if (viewElementType == 'attribute') {\n        const options = {\n            priority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n        };\n        element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);\n    }\n    else {\n        // 'ui'.\n        element = viewWriter.createUIElement(viewElementDefinition.name, attributes);\n    }\n    if (viewElementDefinition.styles) {\n        const keys = Object.keys(viewElementDefinition.styles);\n        for (const key of keys) {\n            viewWriter.setStyle(key, viewElementDefinition.styles[key], element);\n        }\n    }\n    if (viewElementDefinition.classes) {\n        const classes = viewElementDefinition.classes;\n        if (typeof classes == 'string') {\n            viewWriter.addClass(classes, element);\n        }\n        else {\n            for (const className of classes) {\n                viewWriter.addClass(className, element);\n            }\n        }\n    }\n    return element;\n}\nfunction getFromAttributeCreator(config) {\n    if (config.model.values) {\n        return ((modelAttributeValue, conversionApi, data) => {\n            const view = config.view[modelAttributeValue];\n            if (view) {\n                return view(modelAttributeValue, conversionApi, data);\n            }\n            return null;\n        });\n    }\n    else {\n        return config.view;\n    }\n}\n// Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\nfunction normalizeToAttributeConfig(view) {\n    if (typeof view == 'string') {\n        return modelAttributeValue => ({ key: view, value: modelAttributeValue });\n    }\n    else if (typeof view == 'object') {\n        // { key, value, ... }\n        if (view.value) {\n            return () => view;\n        }\n        // { key, ... }\n        else {\n            return modelAttributeValue => ({ key: view.key, value: modelAttributeValue });\n        }\n    }\n    else {\n        // function.\n        return view;\n    }\n}\n// Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\nfunction prepareDescriptor(highlightDescriptor, data, conversionApi) {\n    // If passed descriptor is a creator function, call it. If not, just use passed value.\n    const descriptor = typeof highlightDescriptor == 'function' ?\n        highlightDescriptor(data, conversionApi) :\n        highlightDescriptor;\n    if (!descriptor) {\n        return null;\n    }\n    // Apply default descriptor priority.\n    if (!descriptor.priority) {\n        descriptor.priority = 10;\n    }\n    // Default descriptor id is marker name.\n    if (!descriptor.id) {\n        descriptor.id = data.markerName;\n    }\n    return descriptor;\n}\n// Creates a function that checks a single differ diff item whether it should trigger reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\nfunction createChangeReducerCallback(model) {\n    return (node, change) => {\n        if (!node.is('element', model.name)) {\n            return false;\n        }\n        if (change.type == 'attribute') {\n            if (model.attributes.includes(change.attributeKey)) {\n                return true;\n            }\n        }\n        else {\n            /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. */\n            if (model.children) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n// Creates a `reduceChanges` event handler for reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\nfunction createChangeReducer(model) {\n    const shouldReplace = createChangeReducerCallback(model);\n    return (evt, data) => {\n        const reducedChanges = [];\n        if (!data.reconvertedElements) {\n            data.reconvertedElements = new Set();\n        }\n        for (const change of data.changes) {\n            // For attribute use node affected by the change.\n            // For insert or remove use parent element because we need to check if it's added/removed child.\n            const node = change.type == 'attribute' ? change.range.start.nodeAfter : change.position.parent;\n            if (!node || !shouldReplace(node, change)) {\n                reducedChanges.push(change);\n                continue;\n            }\n            // If it's already marked for reconversion, so skip this change, otherwise add the diff items.\n            if (!data.reconvertedElements.has(node)) {\n                data.reconvertedElements.add(node);\n                const position = ModelPosition._createBefore(node);\n                reducedChanges.push({\n                    type: 'remove',\n                    name: node.name,\n                    position,\n                    length: 1\n                }, {\n                    type: 'reinsert',\n                    name: node.name,\n                    position,\n                    length: 1\n                });\n            }\n        }\n        data.changes = reducedChanges;\n    };\n}\n// Creates a function that checks if an element and its watched attributes can be consumed and consumes them.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {module:engine/conversion/downcasthelpers~ConsumerFunction}\nfunction createConsumer(model) {\n    return (node, consumable, options = {}) => {\n        const events = ['insert'];\n        // Collect all set attributes that are triggering conversion.\n        for (const attributeName of model.attributes) {\n            if (node.hasAttribute(attributeName)) {\n                events.push(`attribute:${attributeName}`);\n            }\n        }\n        if (!events.every(event => consumable.test(node, event))) {\n            return false;\n        }\n        if (!options.preflight) {\n            events.forEach(event => consumable.consume(node, event));\n        }\n        return true;\n    };\n}\n// Creates a function that create view slots.\n//\n// @param {module:engine/model/element~Element} element\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {Function} Exposed by writer as createSlot().\nfunction createSlotFactory(element, slotsMap, conversionApi) {\n    return (writer, modeOrFilter = 'children') => {\n        const slot = writer.createContainerElement('$slot');\n        let children = null;\n        if (modeOrFilter === 'children') {\n            children = Array.from(element.getChildren());\n        }\n        else if (typeof modeOrFilter == 'function') {\n            children = Array.from(element.getChildren()).filter(element => modeOrFilter(element));\n        }\n        else {\n            /**\n             * Unknown slot mode was provided to `writer.createSlot()` in downcast converter.\n             *\n             * @error conversion-slot-mode-unknown\n             */\n            throw new CKEditorError('conversion-slot-mode-unknown', conversionApi.dispatcher, { modeOrFilter });\n        }\n        slotsMap.set(slot, children);\n        return slot;\n    };\n}\n// Checks if all children are covered by slots and there is no child that landed in multiple slots.\n//\n// @param {module:engine/model/element~Element}\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction validateSlotsChildren(element, slotsMap, conversionApi) {\n    const childrenInSlots = Array.from(slotsMap.values()).flat();\n    const uniqueChildrenInSlots = new Set(childrenInSlots);\n    if (uniqueChildrenInSlots.size != childrenInSlots.length) {\n        /**\n         * Filters provided to `writer.createSlot()` overlap (at least two filters accept the same child element).\n         *\n         * @error conversion-slot-filter-overlap\n         * @param {module:engine/model/element~Element} element The element of which children would not be properly\n         * allocated to multiple slots.\n         */\n        throw new CKEditorError('conversion-slot-filter-overlap', conversionApi.dispatcher, { element });\n    }\n    if (uniqueChildrenInSlots.size != element.childCount) {\n        /**\n         * Filters provided to `writer.createSlot()` are incomplete and exclude at least one children element (one of\n         * the children elements would not be assigned to any of the slots).\n         *\n         * @error conversion-slot-filter-incomplete\n         * @param {module:engine/model/element~Element} element The element of which children would not be properly\n         * allocated to multiple slots.\n         */\n        throw new CKEditorError('conversion-slot-filter-incomplete', conversionApi.dispatcher, { element });\n    }\n}\n// Fill slots with appropriate view elements.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\nfunction fillSlots(viewElement, slotsMap, conversionApi, options) {\n    // Set temporary position mapping to redirect child view elements into a proper slots.\n    conversionApi.mapper.on('modelToViewPosition', toViewPositionMapping, { priority: 'highest' });\n    let currentSlot = null;\n    let currentSlotNodes = null;\n    // Fill slots with nested view nodes.\n    for ([currentSlot, currentSlotNodes] of slotsMap) {\n        reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);\n        conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));\n        conversionApi.writer.remove(currentSlot);\n    }\n    conversionApi.mapper.off('modelToViewPosition', toViewPositionMapping);\n    function toViewPositionMapping(evt, data) {\n        const element = data.modelPosition.nodeAfter;\n        // Find the proper offset within the slot.\n        const index = currentSlotNodes.indexOf(element);\n        if (index < 0) {\n            return;\n        }\n        data.viewPosition = data.mapper.findPositionIn(currentSlot, index);\n    }\n}\n// Inserts view representation of `nodes` into the `viewElement` either by bringing back just removed view nodes\n// or by triggering conversion for them.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Iterable.<module:engine/model/element~Element>} modelNodes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\nfunction reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {\n    // Fill with nested view nodes.\n    for (const modelChildNode of modelNodes) {\n        // Try reinserting the view node for the specified model node...\n        if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {\n            // ...or else convert the model element to the view.\n            conversionApi.convertItem(modelChildNode);\n        }\n    }\n}\n// Checks if the view for the given model element could be reused and reinserts it to the view.\n//\n// @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewRoot\n// @param {module:engine/model/element~Element} modelElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n// @returns {Boolean} `false` if view element can't be reused.\nfunction reinsertNode(viewRoot, modelNode, conversionApi, options) {\n    const { writer, mapper } = conversionApi;\n    // Don't reinsert if this is not a reconversion...\n    if (!options.reconversion) {\n        return false;\n    }\n    const viewChildNode = mapper.toViewElement(modelNode);\n    // ...or there is no view to reinsert or it was already inserted to the view structure...\n    if (!viewChildNode || viewChildNode.root == viewRoot) {\n        return false;\n    }\n    // ...or it was strictly marked as not to be reused.\n    if (!conversionApi.canReuseView(viewChildNode)) {\n        return false;\n    }\n    // Otherwise reinsert the view node.\n    writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(ModelPosition._createBefore(modelNode)));\n    return true;\n}\n// The default consumer for insert events.\n// @param {module:engine/model/item~Item} item Model item.\n// @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The model consumable.\n// @param {Object} [options]\n// @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n// @returns {Boolean}\nfunction defaultConsumer(item, consumable, { preflight } = {}) {\n    if (preflight) {\n        return consumable.test(item, 'insert');\n    }\n    else {\n        return consumable.consume(item, 'insert');\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,UAAU,MAAM,gBAAgB;AACvC,OAAOC,cAAc,MAAM,oBAAoB;AAC/C,OAAOC,sBAAsB,MAAM,4BAA4B;AAC/D,OAAOC,YAAY,MAAM,kBAAkB;AAC3C,OAAOC,aAAa,MAAM,mBAAmB;AAC7C,OAAOC,oBAAoB,MAAM,0BAA0B;AAC3D,OAAOC,iBAAiB,MAAM,qBAAqB;AACnD,SAASC,SAAS,QAAQ,WAAW;AACrC,OAAOC,aAAa,MAAM,6CAA6C;AACvE,OAAOC,OAAO,MAAM,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,eAAe,SAASJ,iBAAiB,CAAC;EAC3D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,gBAAgB,CAACC,MAAM,EAAE;IACrB,OAAO,IAAI,CAACC,GAAG,CAACC,wBAAwB,CAACF,MAAM,CAAC,CAAC;EACrD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,kBAAkB,CAACH,MAAM,EAAE;IACvB,OAAO,IAAI,CAACC,GAAG,CAACG,0BAA0B,CAACJ,MAAM,CAAC,CAAC;EACvD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,kBAAkB,CAACL,MAAM,EAAE;IACvB,OAAO,IAAI,CAACC,GAAG,CAACK,0BAA0B,CAACN,MAAM,CAAC,CAAC;EACvD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,oBAAoB,CAACP,MAAM,EAAE;IACzB,OAAO,IAAI,CAACC,GAAG,CAACO,4BAA4B,CAACR,MAAM,CAAC,CAAC;EACzD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIS,eAAe,CAACT,MAAM,EAAE;IACpB,OAAO,IAAI,CAACC,GAAG,CAACS,uBAAuB,CAACV,MAAM,CAAC,CAAC;EACpD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIW,iBAAiB,CAACX,MAAM,EAAE;IACtB,OAAO,IAAI,CAACC,GAAG,CAACW,yBAAyB,CAACZ,MAAM,CAAC,CAAC;EACtD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIa,YAAY,CAACb,MAAM,EAAE;IACjB,OAAO,IAAI,CAACC,GAAG,CAACa,oBAAoB,CAACd,MAAM,CAAC,CAAC;EACjD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASe,UAAU,GAAG;EACzB,OAAO,CAACC,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,IAAI,CAACA,aAAa,CAACC,UAAU,CAACC,OAAO,CAACH,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC,EAAE;MACxD;IACJ;IACA,MAAMC,UAAU,GAAGL,aAAa,CAACM,MAAM;IACvC,MAAMC,YAAY,GAAGP,aAAa,CAACQ,MAAM,CAACC,cAAc,CAACV,IAAI,CAACW,KAAK,CAACC,KAAK,CAAC;IAC1E,MAAMC,QAAQ,GAAGP,UAAU,CAACQ,UAAU,CAACd,IAAI,CAACI,IAAI,CAACJ,IAAI,CAAC;IACtDM,UAAU,CAACS,MAAM,CAACP,YAAY,EAAEK,QAAQ,CAAC;EAC7C,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,2BAA2B,GAAG;EAC1C,OAAO,CAACjB,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjCA,aAAa,CAACgB,iBAAiB,CAACjB,IAAI,CAACI,IAAI,CAAC;IAC1C;IACA;IACA,IAAI,CAACJ,IAAI,CAACkB,YAAY,IAAIlB,IAAI,CAACI,IAAI,CAACe,EAAE,CAAC,SAAS,CAAC,IAAI,CAACnB,IAAI,CAACI,IAAI,CAACgB,OAAO,EAAE;MACrEnB,aAAa,CAACoB,eAAe,CAACrB,IAAI,CAACI,IAAI,CAAC;IAC5C;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkB,MAAM,GAAG;EACrB,OAAO,CAACvB,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC;IACA,MAAMsB,SAAS,GAAGtB,aAAa,CAACQ,MAAM,CAACC,cAAc,CAACV,IAAI,CAACwB,QAAQ,CAAC;IACpE,MAAMC,QAAQ,GAAGzB,IAAI,CAACwB,QAAQ,CAACE,YAAY,CAAC1B,IAAI,CAAC2B,MAAM,CAAC;IACxD,MAAMC,OAAO,GAAG3B,aAAa,CAACQ,MAAM,CAACC,cAAc,CAACe,QAAQ,EAAE;MAAEI,SAAS,EAAE;IAAK,CAAC,CAAC;IAClF,MAAMC,SAAS,GAAG7B,aAAa,CAACM,MAAM,CAACwB,WAAW,CAACR,SAAS,EAAEK,OAAO,CAAC;IACtE;IACA,MAAMI,OAAO,GAAG/B,aAAa,CAACM,MAAM,CAACe,MAAM,CAACQ,SAAS,CAACG,UAAU,EAAE,CAAC;IACnE;IACA;IACA,KAAK,MAAMC,KAAK,IAAIjC,aAAa,CAACM,MAAM,CAAC4B,aAAa,CAACH,OAAO,CAAC,CAACI,QAAQ,EAAE,EAAE;MACxEnC,aAAa,CAACQ,MAAM,CAAC4B,iBAAiB,CAACH,KAAK,EAAE;QAAEI,KAAK,EAAE;MAAK,CAAC,CAAC;IAClE;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,wCAAwC,CAAChC,MAAM,EAAEiC,UAAU,EAAE;EACzE,MAAMC,WAAW,GAAGlC,MAAM,CAACmC,sBAAsB,CAAC,MAAM,EAAEF,UAAU,CAACG,UAAU,CAAC;EAChF,IAAIH,UAAU,CAACI,OAAO,EAAE;IACpBH,WAAW,CAACI,SAAS,CAACL,UAAU,CAACI,OAAO,CAAC;EAC7C;EACA,IAAI,OAAOJ,UAAU,CAACM,QAAQ,KAAK,QAAQ,EAAE;IACzCL,WAAW,CAACM,SAAS,GAAGP,UAAU,CAACM,QAAQ;EAC/C;EACAL,WAAW,CAACO,GAAG,GAAGR,UAAU,CAACS,EAAE;EAC/B,OAAOR,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,qBAAqB,GAAG;EACpC,OAAO,CAACnD,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,MAAMkD,SAAS,GAAGnD,IAAI,CAACmD,SAAS;IAChC,IAAIA,SAAS,CAACC,WAAW,EAAE;MACvB;IACJ;IACA,IAAI,CAACnD,aAAa,CAACC,UAAU,CAACC,OAAO,CAACgD,SAAS,EAAE,WAAW,CAAC,EAAE;MAC3D;IACJ;IACA,MAAME,UAAU,GAAG,EAAE;IACrB,KAAK,MAAM1C,KAAK,IAAIwC,SAAS,CAACG,SAAS,EAAE,EAAE;MACvCD,UAAU,CAACE,IAAI,CAACtD,aAAa,CAACQ,MAAM,CAAC+C,WAAW,CAAC7C,KAAK,CAAC,CAAC;IAC5D;IACAV,aAAa,CAACM,MAAM,CAACkD,YAAY,CAACJ,UAAU,EAAE;MAAEK,QAAQ,EAAEP,SAAS,CAACQ;IAAW,CAAC,CAAC;EACrF,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,yBAAyB,GAAG;EACxC,OAAO,CAAC7D,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,MAAMkD,SAAS,GAAGnD,IAAI,CAACmD,SAAS;IAChC,IAAI,CAACA,SAAS,CAACC,WAAW,EAAE;MACxB;IACJ;IACA,IAAI,CAACnD,aAAa,CAACC,UAAU,CAACC,OAAO,CAACgD,SAAS,EAAE,WAAW,CAAC,EAAE;MAC3D;IACJ;IACA,MAAM7C,UAAU,GAAGL,aAAa,CAACM,MAAM;IACvC,MAAMsD,aAAa,GAAGV,SAAS,CAACW,gBAAgB,EAAE;IAClD,MAAMtD,YAAY,GAAGP,aAAa,CAACQ,MAAM,CAACC,cAAc,CAACmD,aAAa,CAAC;IACvE,MAAME,cAAc,GAAGzD,UAAU,CAAC0D,eAAe,CAACxD,YAAY,CAAC;IAC/DF,UAAU,CAACmD,YAAY,CAACM,cAAc,CAAC;EAC3C,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,eAAe,GAAG;EAC9B,OAAO,CAAClE,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,MAAMK,UAAU,GAAGL,aAAa,CAACM,MAAM;IACvC,MAAM2D,aAAa,GAAG5D,UAAU,CAAC6D,QAAQ,CAAChB,SAAS;IACnD,KAAK,MAAMxC,KAAK,IAAIuD,aAAa,CAACZ,SAAS,EAAE,EAAE;MAC3C;MACA,IAAI3C,KAAK,CAACyC,WAAW,EAAE;QACnB;QACA,IAAIzC,KAAK,CAACyD,GAAG,CAACC,MAAM,CAACC,UAAU,EAAE,EAAE;UAC/BrE,aAAa,CAACM,MAAM,CAACgE,eAAe,CAAC5D,KAAK,CAACC,KAAK,CAAC;QACrD;MACJ;IACJ;IACAN,UAAU,CAACmD,YAAY,CAAC,IAAI,CAAC;EACjC,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASe,IAAI,CAACC,cAAc,EAAE;EACjC,OAAO,CAAC1E,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,IAAI,CAACA,aAAa,CAACC,UAAU,CAACwE,IAAI,CAAC1E,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC,EAAE;MACrD;IACJ;IACA;IACA;IACA,MAAMsE,cAAc,GAAGF,cAAc,CAACzE,IAAI,CAAC4E,iBAAiB,EAAE3E,aAAa,EAAED,IAAI,CAAC;IAClF;IACA,MAAM6E,cAAc,GAAGJ,cAAc,CAACzE,IAAI,CAAC8E,iBAAiB,EAAE7E,aAAa,EAAED,IAAI,CAAC;IAClF,IAAI,CAAC2E,cAAc,IAAI,CAACE,cAAc,EAAE;MACpC;IACJ;IACA5E,aAAa,CAACC,UAAU,CAACC,OAAO,CAACH,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC;IACrD,MAAMC,UAAU,GAAGL,aAAa,CAACM,MAAM;IACvC,MAAM2D,aAAa,GAAG5D,UAAU,CAAC6D,QAAQ,CAAChB,SAAS;IACnD,IAAInD,IAAI,CAACI,IAAI,YAAYhC,cAAc,IAAI4B,IAAI,CAACI,IAAI,YAAY/B,sBAAsB,EAAE;MACpF;MACAiC,UAAU,CAACkE,IAAI,CAACN,aAAa,CAACa,aAAa,EAAE,EAAEF,cAAc,CAAC;IAClE,CAAC,MACI;MACD;MACA,IAAI/C,SAAS,GAAG7B,aAAa,CAACQ,MAAM,CAAC+C,WAAW,CAACxD,IAAI,CAACW,KAAK,CAAC;MAC5D;MACA,IAAIX,IAAI,CAAC4E,iBAAiB,KAAK,IAAI,IAAID,cAAc,EAAE;QACnD7C,SAAS,GAAGxB,UAAU,CAAC0E,MAAM,CAAClD,SAAS,EAAE6C,cAAc,CAAC;MAC5D;MACA,IAAI3E,IAAI,CAAC8E,iBAAiB,KAAK,IAAI,IAAID,cAAc,EAAE;QACnDvE,UAAU,CAACkE,IAAI,CAAC1C,SAAS,EAAE+C,cAAc,CAAC;MAC9C;IACJ;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,aAAa,CAACR,cAAc,EAA8B;EAAA,IAA5BS,QAAQ,uEAAGC,eAAe;EACpE,OAAO,CAACpF,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,IAAI,CAACiF,QAAQ,CAAClF,IAAI,CAACI,IAAI,EAAEH,aAAa,CAACC,UAAU,EAAE;MAAEkF,SAAS,EAAE;IAAK,CAAC,CAAC,EAAE;MACrE;IACJ;IACA,MAAM3C,WAAW,GAAGgC,cAAc,CAACzE,IAAI,CAACI,IAAI,EAAEH,aAAa,EAAED,IAAI,CAAC;IAClE,IAAI,CAACyC,WAAW,EAAE;MACd;IACJ;IACA;IACAyC,QAAQ,CAAClF,IAAI,CAACI,IAAI,EAAEH,aAAa,CAACC,UAAU,CAAC;IAC7C,MAAMM,YAAY,GAAGP,aAAa,CAACQ,MAAM,CAACC,cAAc,CAACV,IAAI,CAACW,KAAK,CAACC,KAAK,CAAC;IAC1EX,aAAa,CAACQ,MAAM,CAAC4E,YAAY,CAACrF,IAAI,CAACI,IAAI,EAAEqC,WAAW,CAAC;IACzDxC,aAAa,CAACM,MAAM,CAACQ,MAAM,CAACP,YAAY,EAAEiC,WAAW,CAAC;IACtD;IACAxC,aAAa,CAACgB,iBAAiB,CAACjB,IAAI,CAACI,IAAI,CAAC;IAC1C;IACAkF,sBAAsB,CAAC7C,WAAW,EAAEzC,IAAI,CAACI,IAAI,CAACmF,WAAW,EAAE,EAAEtF,aAAa,EAAE;MAAEiB,YAAY,EAAElB,IAAI,CAACkB;IAAa,CAAC,CAAC;EACpH,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsE,eAAe,CAACf,cAAc,EAAES,QAAQ,EAAE;EACtD,OAAO,CAACnF,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,IAAI,CAACiF,QAAQ,CAAClF,IAAI,CAACI,IAAI,EAAEH,aAAa,CAACC,UAAU,EAAE;MAAEkF,SAAS,EAAE;IAAK,CAAC,CAAC,EAAE;MACrE;IACJ;IACA,MAAMK,QAAQ,GAAG,IAAIC,GAAG,EAAE;IAC1BzF,aAAa,CAACM,MAAM,CAACoF,oBAAoB,CAACC,iBAAiB,CAAC5F,IAAI,CAACI,IAAI,EAAEqF,QAAQ,EAAExF,aAAa,CAAC,CAAC;IAChG;IACA,MAAMwC,WAAW,GAAGgC,cAAc,CAACzE,IAAI,CAACI,IAAI,EAAEH,aAAa,EAAED,IAAI,CAAC;IAClEC,aAAa,CAACM,MAAM,CAACsF,iBAAiB,EAAE;IACxC,IAAI,CAACpD,WAAW,EAAE;MACd;IACJ;IACA;IACAqD,qBAAqB,CAAC9F,IAAI,CAACI,IAAI,EAAEqF,QAAQ,EAAExF,aAAa,CAAC;IACzD;IACAiF,QAAQ,CAAClF,IAAI,CAACI,IAAI,EAAEH,aAAa,CAACC,UAAU,CAAC;IAC7C,MAAMM,YAAY,GAAGP,aAAa,CAACQ,MAAM,CAACC,cAAc,CAACV,IAAI,CAACW,KAAK,CAACC,KAAK,CAAC;IAC1EX,aAAa,CAACQ,MAAM,CAAC4E,YAAY,CAACrF,IAAI,CAACI,IAAI,EAAEqC,WAAW,CAAC;IACzDxC,aAAa,CAACM,MAAM,CAACQ,MAAM,CAACP,YAAY,EAAEiC,WAAW,CAAC;IACtD;IACAxC,aAAa,CAACgB,iBAAiB,CAACjB,IAAI,CAACI,IAAI,CAAC;IAC1C;IACA2F,SAAS,CAACtD,WAAW,EAAEgD,QAAQ,EAAExF,aAAa,EAAE;MAAEiB,YAAY,EAAElB,IAAI,CAACkB;IAAa,CAAC,CAAC;EACxF,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS8E,eAAe,CAACvB,cAAc,EAAE;EAC5C,OAAO,CAAC1E,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC;IACA;IACAD,IAAI,CAACiG,SAAS,GAAG,IAAI;IACrB,MAAMC,gBAAgB,GAAGzB,cAAc,CAACzE,IAAI,EAAEC,aAAa,CAAC;IAC5DD,IAAI,CAACiG,SAAS,GAAG,KAAK;IACtB,MAAME,cAAc,GAAG1B,cAAc,CAACzE,IAAI,EAAEC,aAAa,CAAC;IAC1D,IAAI,CAACiG,gBAAgB,IAAI,CAACC,cAAc,EAAE;MACtC;IACJ;IACA,MAAMC,WAAW,GAAGpG,IAAI,CAACoG,WAAW;IACpC;IACA;IACA;IACA,IAAIA,WAAW,CAAChD,WAAW,IAAI,CAACnD,aAAa,CAACC,UAAU,CAACC,OAAO,CAACiG,WAAW,EAAErG,GAAG,CAACM,IAAI,CAAC,EAAE;MACrF;IACJ;IACA;IACA,KAAK,MAAMgG,KAAK,IAAID,WAAW,EAAE;MAC7B,IAAI,CAACnG,aAAa,CAACC,UAAU,CAACC,OAAO,CAACkG,KAAK,CAACjG,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC,EAAE;QACzD;MACJ;IACJ;IACA,MAAMI,MAAM,GAAGR,aAAa,CAACQ,MAAM;IACnC,MAAMH,UAAU,GAAGL,aAAa,CAACM,MAAM;IACvC;IACAD,UAAU,CAACS,MAAM,CAACN,MAAM,CAACC,cAAc,CAAC0F,WAAW,CAACxF,KAAK,CAAC,EAAEsF,gBAAgB,CAAC;IAC7EjG,aAAa,CAACQ,MAAM,CAAC6F,mBAAmB,CAACJ,gBAAgB,EAAElG,IAAI,CAACuG,UAAU,CAAC;IAC3E;IACA,IAAI,CAACH,WAAW,CAAChD,WAAW,EAAE;MAC1B9C,UAAU,CAACS,MAAM,CAACN,MAAM,CAACC,cAAc,CAAC0F,WAAW,CAAChC,GAAG,CAAC,EAAE+B,cAAc,CAAC;MACzElG,aAAa,CAACQ,MAAM,CAAC6F,mBAAmB,CAACH,cAAc,EAAEnG,IAAI,CAACuG,UAAU,CAAC;IAC7E;IACAxG,GAAG,CAACyG,IAAI,EAAE;EACd,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAe,GAAG;EACvB,OAAO,CAAC1G,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,MAAMyG,QAAQ,GAAGzG,aAAa,CAACQ,MAAM,CAACkG,oBAAoB,CAAC3G,IAAI,CAACuG,UAAU,CAAC;IAC3E,IAAI,CAACG,QAAQ,EAAE;MACX;IACJ;IACA,KAAK,MAAME,OAAO,IAAIF,QAAQ,EAAE;MAC5BzG,aAAa,CAACQ,MAAM,CAACoG,2BAA2B,CAACD,OAAO,EAAE5G,IAAI,CAACuG,UAAU,CAAC;MAC1EtG,aAAa,CAACM,MAAM,CAACuG,KAAK,CAAC7G,aAAa,CAACM,MAAM,CAACwG,aAAa,CAACH,OAAO,CAAC,EAAEA,OAAO,CAAC;IACpF;IACA3G,aAAa,CAACM,MAAM,CAACyG,wBAAwB,CAAChH,IAAI,CAACuG,UAAU,CAAC;IAC9DxG,GAAG,CAACyG,IAAI,EAAE;EACd,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,gBAAgB,CAACC,WAAW,EAAE;EACnC,OAAO,CAACnH,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,MAAMkH,cAAc,GAAGD,WAAW,CAAClH,IAAI,CAACuG,UAAU,EAAEtG,aAAa,CAAC;IAClE,IAAI,CAACkH,cAAc,EAAE;MACjB;IACJ;IACA,MAAMf,WAAW,GAAGpG,IAAI,CAACoG,WAAW;IACpC,IAAI,CAACnG,aAAa,CAACC,UAAU,CAACC,OAAO,CAACiG,WAAW,EAAErG,GAAG,CAACM,IAAI,CAAC,EAAE;MAC1D;IACJ;IACA;IACA+G,oBAAoB,CAAChB,WAAW,EAAE,KAAK,EAAEnG,aAAa,EAAED,IAAI,EAAEmH,cAAc,CAAC;IAC7EC,oBAAoB,CAAChB,WAAW,EAAE,IAAI,EAAEnG,aAAa,EAAED,IAAI,EAAEmH,cAAc,CAAC;IAC5EpH,GAAG,CAACyG,IAAI,EAAE;EACd,CAAC;AACL;AACA;AACA,SAASY,oBAAoB,CAACzG,KAAK,EAAE0G,OAAO,EAAEpH,aAAa,EAAED,IAAI,EAAEmH,cAAc,EAAE;EAC/E,MAAMtD,aAAa,GAAGwD,OAAO,GAAG1G,KAAK,CAACC,KAAK,GAAGD,KAAK,CAACyD,GAAG;EACvD,MAAMkD,YAAY,GAAGzD,aAAa,CAAC0D,SAAS,IAAI1D,aAAa,CAAC0D,SAAS,CAACpG,EAAE,CAAC,SAAS,CAAC,GAAG0C,aAAa,CAAC0D,SAAS,GAAG,IAAI;EACtH,MAAMC,aAAa,GAAG3D,aAAa,CAAC4D,UAAU,IAAI5D,aAAa,CAAC4D,UAAU,CAACtG,EAAE,CAAC,SAAS,CAAC,GAAG0C,aAAa,CAAC4D,UAAU,GAAG,IAAI;EAC1H,IAAIH,YAAY,IAAIE,aAAa,EAAE;IAC/B,IAAIE,YAAY;IAChB,IAAIC,QAAQ;IACZ;IACA,IAAIN,OAAO,IAAIC,YAAY,IAAI,CAACD,OAAO,IAAI,CAACG,aAAa,EAAE;MACvD;MACA;MACAE,YAAY,GAAGJ,YAAY;MAC3BK,QAAQ,GAAG,IAAI;IACnB,CAAC,MACI;MACD;MACA;MACAD,YAAY,GAAGF,aAAa;MAC5BG,QAAQ,GAAG,KAAK;IACpB;IACA,MAAMlF,WAAW,GAAGxC,aAAa,CAACQ,MAAM,CAACmH,aAAa,CAACF,YAAY,CAAC;IACpE;IACA;IACA,IAAIjF,WAAW,EAAE;MACboF,uBAAuB,CAACpF,WAAW,EAAE4E,OAAO,EAAEM,QAAQ,EAAE1H,aAAa,EAAED,IAAI,EAAEmH,cAAc,CAAC;MAC5F;IACJ;EACJ;EACA,MAAM3G,YAAY,GAAGP,aAAa,CAACQ,MAAM,CAACC,cAAc,CAACmD,aAAa,CAAC;EACvEiE,qBAAqB,CAACtH,YAAY,EAAE6G,OAAO,EAAEpH,aAAa,EAAED,IAAI,EAAEmH,cAAc,CAAC;AACrF;AACA;AACA,SAASU,uBAAuB,CAACpF,WAAW,EAAE4E,OAAO,EAAEM,QAAQ,EAAE1H,aAAa,EAAED,IAAI,EAAEmH,cAAc,EAAE;EAClG,MAAMY,aAAa,GAAI,QAAOZ,cAAc,CAACa,KAAM,IAAGX,OAAO,GAAG,OAAO,GAAG,KAAM,IAAGM,QAAQ,GAAG,QAAQ,GAAG,OAAQ,EAAC;EAClH,MAAMM,WAAW,GAAGxF,WAAW,CAACyF,YAAY,CAACH,aAAa,CAAC,GAAGtF,WAAW,CAAC0F,YAAY,CAACJ,aAAa,CAAC,CAACK,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;EACrH;EACAH,WAAW,CAACI,OAAO,CAAClB,cAAc,CAAC9G,IAAI,CAAC;EACxCJ,aAAa,CAACM,MAAM,CAAC+H,YAAY,CAACP,aAAa,EAAEE,WAAW,CAACM,IAAI,CAAC,GAAG,CAAC,EAAE9F,WAAW,CAAC;EACpFxC,aAAa,CAACQ,MAAM,CAAC6F,mBAAmB,CAAC7D,WAAW,EAAEzC,IAAI,CAACuG,UAAU,CAAC;AAC1E;AACA;AACA,SAASuB,qBAAqB,CAACtG,QAAQ,EAAE6F,OAAO,EAAEpH,aAAa,EAAED,IAAI,EAAEmH,cAAc,EAAE;EACnF,MAAMqB,eAAe,GAAI,GAAErB,cAAc,CAACa,KAAM,IAAGX,OAAO,GAAG,OAAO,GAAG,KAAM,EAAC;EAC9E,MAAMoB,KAAK,GAAGtB,cAAc,CAAC9G,IAAI,GAAG;IAAE,MAAM,EAAE8G,cAAc,CAAC9G;EAAK,CAAC,GAAG,IAAI;EAC1E,MAAMoC,WAAW,GAAGxC,aAAa,CAACM,MAAM,CAACmI,eAAe,CAACF,eAAe,EAAEC,KAAK,CAAC;EAChFxI,aAAa,CAACM,MAAM,CAACQ,MAAM,CAACS,QAAQ,EAAEiB,WAAW,CAAC;EAClDxC,aAAa,CAACQ,MAAM,CAAC6F,mBAAmB,CAAC7D,WAAW,EAAEzC,IAAI,CAACuG,UAAU,CAAC;AAC1E;AACA;AACA;AACA;AACA,SAASoC,gBAAgB,CAACzB,WAAW,EAAE;EACnC,OAAO,CAACnH,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,MAAM2I,QAAQ,GAAG1B,WAAW,CAAClH,IAAI,CAACuG,UAAU,EAAEtG,aAAa,CAAC;IAC5D,IAAI,CAAC2I,QAAQ,EAAE;MACX;IACJ;IACA,MAAMlC,QAAQ,GAAGzG,aAAa,CAACQ,MAAM,CAACkG,oBAAoB,CAAC3G,IAAI,CAACuG,UAAU,CAAC;IAC3E,IAAI,CAACG,QAAQ,EAAE;MACX;IACJ;IACA,KAAK,MAAME,OAAO,IAAIF,QAAQ,EAAE;MAC5BzG,aAAa,CAACQ,MAAM,CAACoG,2BAA2B,CAACD,OAAO,EAAE5G,IAAI,CAACuG,UAAU,CAAC;MAC1E,IAAIK,OAAO,CAACzF,EAAE,CAAC,kBAAkB,CAAC,EAAE;QAChC0H,yBAAyB,CAAE,QAAOD,QAAQ,CAACZ,KAAM,eAAc,EAAEpB,OAAO,CAAC;QACzEiC,yBAAyB,CAAE,QAAOD,QAAQ,CAACZ,KAAM,cAAa,EAAEpB,OAAO,CAAC;QACxEiC,yBAAyB,CAAE,QAAOD,QAAQ,CAACZ,KAAM,aAAY,EAAEpB,OAAO,CAAC;QACvEiC,yBAAyB,CAAE,QAAOD,QAAQ,CAACZ,KAAM,YAAW,EAAEpB,OAAO,CAAC;MAC1E,CAAC,MACI;QACD3G,aAAa,CAACM,MAAM,CAACuG,KAAK,CAAC7G,aAAa,CAACM,MAAM,CAACwG,aAAa,CAACH,OAAO,CAAC,EAAEA,OAAO,CAAC;MACpF;IACJ;IACA3G,aAAa,CAACM,MAAM,CAACyG,wBAAwB,CAAChH,IAAI,CAACuG,UAAU,CAAC;IAC9DxG,GAAG,CAACyG,IAAI,EAAE;IACV,SAASqC,yBAAyB,CAACd,aAAa,EAAEnB,OAAO,EAAE;MACvD,IAAIA,OAAO,CAACsB,YAAY,CAACH,aAAa,CAAC,EAAE;QACrC,MAAME,WAAW,GAAG,IAAIa,GAAG,CAAClC,OAAO,CAACuB,YAAY,CAACJ,aAAa,CAAC,CAACK,KAAK,CAAC,GAAG,CAAC,CAAC;QAC3EH,WAAW,CAACc,MAAM,CAACH,QAAQ,CAACvI,IAAI,CAAC;QACjC,IAAI4H,WAAW,CAACe,IAAI,IAAI,CAAC,EAAE;UACvB/I,aAAa,CAACM,MAAM,CAAC0I,eAAe,CAAClB,aAAa,EAAEnB,OAAO,CAAC;QAChE,CAAC,MACI;UACD3G,aAAa,CAACM,MAAM,CAAC+H,YAAY,CAACP,aAAa,EAAEmB,KAAK,CAACC,IAAI,CAAClB,WAAW,CAAC,CAACM,IAAI,CAAC,GAAG,CAAC,EAAE3B,OAAO,CAAC;QAChG;MACJ;IACJ;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwC,eAAe,CAACC,gBAAgB,EAAE;EACvC,OAAO,CAACtJ,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,IAAI,CAACA,aAAa,CAACC,UAAU,CAACwE,IAAI,CAAC1E,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC,EAAE;MACrD;IACJ;IACA,MAAMiJ,YAAY,GAAGD,gBAAgB,CAACrJ,IAAI,CAAC4E,iBAAiB,EAAE3E,aAAa,EAAED,IAAI,CAAC;IAClF,MAAMuJ,YAAY,GAAGF,gBAAgB,CAACrJ,IAAI,CAAC8E,iBAAiB,EAAE7E,aAAa,EAAED,IAAI,CAAC;IAClF,IAAI,CAACsJ,YAAY,IAAI,CAACC,YAAY,EAAE;MAChC;IACJ;IACAtJ,aAAa,CAACC,UAAU,CAACC,OAAO,CAACH,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC;IACrD,MAAMoC,WAAW,GAAGxC,aAAa,CAACQ,MAAM,CAACmH,aAAa,CAAC5H,IAAI,CAACI,IAAI,CAAC;IACjE,MAAME,UAAU,GAAGL,aAAa,CAACM,MAAM;IACvC;IACA;IACA,IAAI,CAACkC,WAAW,EAAE;MACd;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACY,MAAM,IAAI9D,aAAa,CAAC,2CAA2C,EAAEsB,aAAa,CAACuJ,UAAU,EAAExJ,IAAI,CAAC;IACxG;IACA;IACA,IAAIA,IAAI,CAAC4E,iBAAiB,KAAK,IAAI,IAAI0E,YAAY,EAAE;MACjD,IAAIA,YAAY,CAACG,GAAG,IAAI,OAAO,EAAE;QAC7B,MAAM7G,OAAO,GAAGhE,OAAO,CAAC0K,YAAY,CAACjD,KAAK,CAAC;QAC3C,KAAK,MAAMqD,SAAS,IAAI9G,OAAO,EAAE;UAC7BtC,UAAU,CAACqJ,WAAW,CAACD,SAAS,EAAEjH,WAAW,CAAC;QAClD;MACJ,CAAC,MACI,IAAI6G,YAAY,CAACG,GAAG,IAAI,OAAO,EAAE;QAClC,MAAMG,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACN,YAAY,CAACjD,KAAK,CAAC;QAC5C,KAAK,MAAMoD,GAAG,IAAIG,IAAI,EAAE;UACpBtJ,UAAU,CAACwJ,WAAW,CAACL,GAAG,EAAEhH,WAAW,CAAC;QAC5C;MACJ,CAAC,MACI;QACDnC,UAAU,CAAC2I,eAAe,CAACK,YAAY,CAACG,GAAG,EAAEhH,WAAW,CAAC;MAC7D;IACJ;IACA;IACA,IAAIzC,IAAI,CAAC8E,iBAAiB,KAAK,IAAI,IAAIyE,YAAY,EAAE;MACjD,IAAIA,YAAY,CAACE,GAAG,IAAI,OAAO,EAAE;QAC7B,MAAM7G,OAAO,GAAGhE,OAAO,CAAC2K,YAAY,CAAClD,KAAK,CAAC;QAC3C,KAAK,MAAMqD,SAAS,IAAI9G,OAAO,EAAE;UAC7BtC,UAAU,CAACyJ,QAAQ,CAACL,SAAS,EAAEjH,WAAW,CAAC;QAC/C;MACJ,CAAC,MACI,IAAI8G,YAAY,CAACE,GAAG,IAAI,OAAO,EAAE;QAClC,MAAMG,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACL,YAAY,CAAClD,KAAK,CAAC;QAC5C,KAAK,MAAMoD,GAAG,IAAIG,IAAI,EAAE;UACpBtJ,UAAU,CAAC0J,QAAQ,CAACP,GAAG,EAAEF,YAAY,CAAClD,KAAK,CAACoD,GAAG,CAAC,EAAEhH,WAAW,CAAC;QAClE;MACJ,CAAC,MACI;QACDnC,UAAU,CAACgI,YAAY,CAACiB,YAAY,CAACE,GAAG,EAAEF,YAAY,CAAClD,KAAK,EAAE5D,WAAW,CAAC;MAC9E;IACJ;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwH,aAAa,CAACC,mBAAmB,EAAE;EACxC,OAAO,CAACnK,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,IAAI,CAACD,IAAI,CAACI,IAAI,EAAE;MACZ;IACJ;IACA,IAAI,EAAEJ,IAAI,CAACI,IAAI,YAAYhC,cAAc,IAAI4B,IAAI,CAACI,IAAI,YAAY/B,sBAAsB,CAAC,IAAI,CAAC2B,IAAI,CAACI,IAAI,CAACe,EAAE,CAAC,YAAY,CAAC,EAAE;MACtH;IACJ;IACA,MAAMqB,UAAU,GAAG2H,iBAAiB,CAACD,mBAAmB,EAAElK,IAAI,EAAEC,aAAa,CAAC;IAC9E,IAAI,CAACuC,UAAU,EAAE;MACb;IACJ;IACA,IAAI,CAACvC,aAAa,CAACC,UAAU,CAACC,OAAO,CAACH,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC,EAAE;MACxD;IACJ;IACA,MAAMC,UAAU,GAAGL,aAAa,CAACM,MAAM;IACvC,MAAMkC,WAAW,GAAGF,wCAAwC,CAACjC,UAAU,EAAEkC,UAAU,CAAC;IACpF,MAAM0B,aAAa,GAAG5D,UAAU,CAAC6D,QAAQ,CAAChB,SAAS;IACnD,IAAInD,IAAI,CAACI,IAAI,YAAYhC,cAAc,IAAI4B,IAAI,CAACI,IAAI,YAAY/B,sBAAsB,EAAE;MACpFiC,UAAU,CAACkE,IAAI,CAACN,aAAa,CAACa,aAAa,EAAE,EAAEtC,WAAW,CAAC;IAC/D,CAAC,MACI;MACD,MAAMX,SAAS,GAAG7B,aAAa,CAACQ,MAAM,CAAC+C,WAAW,CAACxD,IAAI,CAACW,KAAK,CAAC;MAC9D,MAAMyJ,cAAc,GAAG9J,UAAU,CAACkE,IAAI,CAAC1C,SAAS,EAAEW,WAAW,CAAC;MAC9D,KAAK,MAAMmE,OAAO,IAAIwD,cAAc,CAAChI,QAAQ,EAAE,EAAE;QAC7C,IAAIwE,OAAO,CAACzF,EAAE,CAAC,kBAAkB,CAAC,IAAIyF,OAAO,CAACyD,SAAS,CAAC5H,WAAW,CAAC,EAAE;UAClExC,aAAa,CAACQ,MAAM,CAAC6F,mBAAmB,CAACM,OAAO,EAAE5G,IAAI,CAACuG,UAAU,CAAC;UAClE;UACA;UACA;QACJ;MACJ;IACJ;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+D,gBAAgB,CAACJ,mBAAmB,EAAE;EAC3C,OAAO,CAACnK,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC,IAAI,CAACD,IAAI,CAACI,IAAI,EAAE;MACZ;IACJ;IACA,IAAI,EAAEJ,IAAI,CAACI,IAAI,YAAY9B,YAAY,CAAC,EAAE;MACtC;IACJ;IACA,MAAMkE,UAAU,GAAG2H,iBAAiB,CAACD,mBAAmB,EAAElK,IAAI,EAAEC,aAAa,CAAC;IAC9E,IAAI,CAACuC,UAAU,EAAE;MACb;IACJ;IACA,IAAI,CAACvC,aAAa,CAACC,UAAU,CAACwE,IAAI,CAAC1E,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC,EAAE;MACrD;IACJ;IACA,MAAMoC,WAAW,GAAGxC,aAAa,CAACQ,MAAM,CAACmH,aAAa,CAAC5H,IAAI,CAACI,IAAI,CAAC;IACjE,IAAIqC,WAAW,IAAIA,WAAW,CAAC8H,iBAAiB,CAAC,cAAc,CAAC,EAAE;MAC9D;MACAtK,aAAa,CAACC,UAAU,CAACC,OAAO,CAACH,IAAI,CAACI,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC;MACrD;MACA,KAAK,MAAMgG,KAAK,IAAIlI,UAAU,CAACqM,SAAS,CAACxK,IAAI,CAACI,IAAI,CAAC,EAAE;QACjDH,aAAa,CAACC,UAAU,CAACC,OAAO,CAACkG,KAAK,CAACjG,IAAI,EAAEL,GAAG,CAACM,IAAI,CAAC;MAC1D;MACA,MAAMoK,oBAAoB,GAAGhI,WAAW,CAAC8H,iBAAiB,CAAC,cAAc,CAAC;MAC1EE,oBAAoB,CAAChI,WAAW,EAAED,UAAU,EAAEvC,aAAa,CAACM,MAAM,CAAC;MACnEN,aAAa,CAACQ,MAAM,CAAC6F,mBAAmB,CAAC7D,WAAW,EAAEzC,IAAI,CAACuG,UAAU,CAAC;IAC1E;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmE,eAAe,CAACR,mBAAmB,EAAE;EAC1C,OAAO,CAACnK,GAAG,EAAEC,IAAI,EAAEC,aAAa,KAAK;IACjC;IACA,IAAID,IAAI,CAACoG,WAAW,CAAChD,WAAW,EAAE;MAC9B;IACJ;IACA,MAAMZ,UAAU,GAAG2H,iBAAiB,CAACD,mBAAmB,EAAElK,IAAI,EAAEC,aAAa,CAAC;IAC9E,IAAI,CAACuC,UAAU,EAAE;MACb;IACJ;IACA;IACA,MAAMmI,oBAAoB,GAAGpI,wCAAwC,CAACtC,aAAa,CAACM,MAAM,EAAEiC,UAAU,CAAC;IACvG;IACA,MAAMkE,QAAQ,GAAGzG,aAAa,CAACQ,MAAM,CAACkG,oBAAoB,CAAC3G,IAAI,CAACuG,UAAU,CAAC;IAC3E,IAAI,CAACG,QAAQ,EAAE;MACX;IACJ;IACA,KAAK,MAAME,OAAO,IAAIF,QAAQ,EAAE;MAC5BzG,aAAa,CAACQ,MAAM,CAACoG,2BAA2B,CAACD,OAAO,EAAE5G,IAAI,CAACuG,UAAU,CAAC;MAC1E,IAAIK,OAAO,CAACzF,EAAE,CAAC,kBAAkB,CAAC,EAAE;QAChClB,aAAa,CAACM,MAAM,CAACyE,MAAM,CAAC/E,aAAa,CAACM,MAAM,CAACwG,aAAa,CAACH,OAAO,CAAC,EAAE+D,oBAAoB,CAAC;MAClG,CAAC,MACI;QACD;QACA,MAAMC,uBAAuB,GAAGhE,OAAO,CAAC2D,iBAAiB,CAAC,iBAAiB,CAAC;QAC5EK,uBAAuB,CAAChE,OAAO,EAAEpE,UAAU,CAACS,EAAE,EAAEhD,aAAa,CAACM,MAAM,CAAC;MACzE;IACJ;IACAN,aAAa,CAACM,MAAM,CAACyG,wBAAwB,CAAChH,IAAI,CAACuG,UAAU,CAAC;IAC9DxG,GAAG,CAACyG,IAAI,EAAE;EACd,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvH,wBAAwB,CAACF,MAAM,EAAE;EACtC,MAAM8L,KAAK,GAAGC,2BAA2B,CAAC/L,MAAM,CAAC8L,KAAK,CAAC;EACvD,MAAME,IAAI,GAAGC,wBAAwB,CAACjM,MAAM,CAACgM,IAAI,EAAE,WAAW,CAAC;EAC/D;EACA;EACA,IAAIF,KAAK,CAAClI,UAAU,CAAChB,MAAM,EAAE;IACzBkJ,KAAK,CAACI,QAAQ,GAAG,IAAI;EACzB;EACA,OAAQzB,UAAU,IAAK;IACnBA,UAAU,CAAC0B,EAAE,CAAE,UAASL,KAAK,CAACxK,IAAK,EAAC,EAAE4E,aAAa,CAAC8F,IAAI,EAAEI,cAAc,CAACN,KAAK,CAAC,CAAC,EAAE;MAAE/H,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;IACrI,IAAIP,KAAK,CAACI,QAAQ,IAAIJ,KAAK,CAAClI,UAAU,CAAChB,MAAM,EAAE;MAC3C6H,UAAU,CAAC0B,EAAE,CAAC,eAAe,EAAEG,mBAAmB,CAACR,KAAK,CAAC,EAAE;QAAE/H,QAAQ,EAAE;MAAM,CAAC,CAAC;IACnF;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS3D,0BAA0B,CAACJ,MAAM,EAAE;EACxC,MAAM8L,KAAK,GAAGC,2BAA2B,CAAC/L,MAAM,CAAC8L,KAAK,CAAC;EACvD,MAAME,IAAI,GAAGC,wBAAwB,CAACjM,MAAM,CAACgM,IAAI,EAAE,WAAW,CAAC;EAC/D;EACA;EACAF,KAAK,CAACI,QAAQ,GAAG,IAAI;EACrB,OAAQzB,UAAU,IAAK;IACnB,IAAIA,UAAU,CAAC8B,cAAc,CAACC,MAAM,CAACC,UAAU,CAACX,KAAK,CAACxK,IAAI,EAAE,OAAO,CAAC,EAAE;MAClE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACY,MAAM,IAAI1B,aAAa,CAAC,iDAAiD,EAAE6K,UAAU,EAAE;QAAEiC,WAAW,EAAEZ,KAAK,CAACxK;MAAK,CAAC,CAAC;IACvH;IACAmJ,UAAU,CAAC0B,EAAE,CAAE,UAASL,KAAK,CAACxK,IAAK,EAAC,EAAEmF,eAAe,CAACuF,IAAI,EAAEI,cAAc,CAACN,KAAK,CAAC,CAAC,EAAE;MAAE/H,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;IACvI5B,UAAU,CAAC0B,EAAE,CAAC,eAAe,EAAEG,mBAAmB,CAACR,KAAK,CAAC,EAAE;MAAE/H,QAAQ,EAAE;IAAM,CAAC,CAAC;EACnF,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASzD,0BAA0B,CAACN,MAAM,EAAE;EACxCA,MAAM,GAAGL,SAAS,CAACK,MAAM,CAAC;EAC1B,IAAI8L,KAAK,GAAG9L,MAAM,CAAC8L,KAAK;EACxB,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;IAC1BA,KAAK,GAAG;MAAEpB,GAAG,EAAEoB;IAAM,CAAC;EAC1B;EACA,IAAIa,SAAS,GAAI,aAAYb,KAAK,CAACpB,GAAI,EAAC;EACxC,IAAIoB,KAAK,CAACxK,IAAI,EAAE;IACZqL,SAAS,IAAI,GAAG,GAAGb,KAAK,CAACxK,IAAI;EACjC;EACA,IAAIwK,KAAK,CAACc,MAAM,EAAE;IACd,KAAK,MAAMC,UAAU,IAAIf,KAAK,CAACc,MAAM,EAAE;MACnC5M,MAAM,CAACgM,IAAI,CAACa,UAAU,CAAC,GAAGZ,wBAAwB,CAACjM,MAAM,CAACgM,IAAI,CAACa,UAAU,CAAC,EAAE,WAAW,CAAC;IAC5F;EACJ,CAAC,MACI;IACD7M,MAAM,CAACgM,IAAI,GAAGC,wBAAwB,CAACjM,MAAM,CAACgM,IAAI,EAAE,WAAW,CAAC;EACpE;EACA,MAAMtG,cAAc,GAAGoH,uBAAuB,CAAC9M,MAAM,CAAC;EACtD,OAAQyK,UAAU,IAAK;IACnBA,UAAU,CAAC0B,EAAE,CAACQ,SAAS,EAAElH,IAAI,CAACC,cAAc,CAAC,EAAE;MAAE3B,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;EACtG,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7L,4BAA4B,CAACR,MAAM,EAAE;EAC1CA,MAAM,GAAGL,SAAS,CAACK,MAAM,CAAC;EAC1B,IAAI8L,KAAK,GAAG9L,MAAM,CAAC8L,KAAK;EACxB,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;IAC1BA,KAAK,GAAG;MAAEpB,GAAG,EAAEoB;IAAM,CAAC;EAC1B;EACA,IAAIa,SAAS,GAAI,aAAYb,KAAK,CAACpB,GAAI,EAAC;EACxC,IAAIoB,KAAK,CAACxK,IAAI,EAAE;IACZqL,SAAS,IAAI,GAAG,GAAGb,KAAK,CAACxK,IAAI;EACjC;EACA,IAAIwK,KAAK,CAACc,MAAM,EAAE;IACd,KAAK,MAAMC,UAAU,IAAIf,KAAK,CAACc,MAAM,EAAE;MACnC5M,MAAM,CAACgM,IAAI,CAACa,UAAU,CAAC,GAAGE,0BAA0B,CAAC/M,MAAM,CAACgM,IAAI,CAACa,UAAU,CAAC,CAAC;IACjF;EACJ,CAAC,MACI;IACD7M,MAAM,CAACgM,IAAI,GAAGe,0BAA0B,CAAC/M,MAAM,CAACgM,IAAI,CAAC;EACzD;EACA,MAAMtG,cAAc,GAAGoH,uBAAuB,CAAC9M,MAAM,CAAC;EACtD,OAAQyK,UAAU,IAAK;IACnBA,UAAU,CAAC0B,EAAE,CAACQ,SAAS,EAAEtC,eAAe,CAAC3E,cAAc,CAAC,EAAE;MAAE3B,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;EACjH,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS3L,uBAAuB,CAACV,MAAM,EAAE;EACrC,MAAMgM,IAAI,GAAGC,wBAAwB,CAACjM,MAAM,CAACgM,IAAI,EAAE,IAAI,CAAC;EACxD,OAAQvB,UAAU,IAAK;IACnBA,UAAU,CAAC0B,EAAE,CAAE,aAAYnM,MAAM,CAAC8L,KAAM,EAAC,EAAE7E,eAAe,CAAC+E,IAAI,CAAC,EAAE;MAAEjI,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;IACrH5B,UAAU,CAAC0B,EAAE,CAAE,gBAAenM,MAAM,CAAC8L,KAAM,EAAC,EAAEpE,eAAe,EAAE,EAAE;MAAE3D,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;EACxH,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvL,oBAAoB,CAACd,MAAM,EAAE;EAClCA,MAAM,GAAGL,SAAS,CAACK,MAAM,CAAC;EAC1B,MAAMiJ,KAAK,GAAGjJ,MAAM,CAAC8L,KAAK;EAC1B,IAAIE,IAAI,GAAGhM,MAAM,CAACgM,IAAI;EACtB;EACA,IAAI,CAACA,IAAI,EAAE;IACPA,IAAI,GAAGxE,UAAU,KAAK;MAClByB,KAAK;MACL3H,IAAI,EAAEkG,UAAU,CAACwF,MAAM,CAAChN,MAAM,CAAC8L,KAAK,CAAClJ,MAAM,GAAG,CAAC;IACnD,CAAC,CAAC;EACN;EACA,OAAQ6H,UAAU,IAAK;IACnBA,UAAU,CAAC0B,EAAE,CAAE,aAAYlD,KAAM,EAAC,EAAEf,gBAAgB,CAAC8D,IAAI,CAAC,EAAE;MAAEjI,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;IAC/G5B,UAAU,CAAC0B,EAAE,CAAE,gBAAelD,KAAM,EAAC,EAAEW,gBAAgB,CAACoC,IAAI,CAAC,EAAE;MAAEjI,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;EACtH,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASzL,yBAAyB,CAACZ,MAAM,EAAE;EACvC,OAAQyK,UAAU,IAAK;IACnBA,UAAU,CAAC0B,EAAE,CAAE,aAAYnM,MAAM,CAAC8L,KAAM,EAAC,EAAEZ,aAAa,CAAClL,MAAM,CAACgM,IAAI,CAAC,EAAE;MAAEjI,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;IAC1H5B,UAAU,CAAC0B,EAAE,CAAE,aAAYnM,MAAM,CAAC8L,KAAM,EAAC,EAAEP,gBAAgB,CAACvL,MAAM,CAACgM,IAAI,CAAC,EAAE;MAAEjI,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;IAC7H5B,UAAU,CAAC0B,EAAE,CAAE,gBAAenM,MAAM,CAAC8L,KAAM,EAAC,EAAEH,eAAe,CAAC3L,MAAM,CAACgM,IAAI,CAAC,EAAE;MAAEjI,QAAQ,EAAE/D,MAAM,CAACqM,iBAAiB,IAAI;IAAS,CAAC,CAAC;EACnI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,2BAA2B,CAACD,KAAK,EAAE;EACxC,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;IAC1BA,KAAK,GAAG;MAAExK,IAAI,EAAEwK;IAAM,CAAC;EAC3B;EACA;EACA,IAAI,CAACA,KAAK,CAAClI,UAAU,EAAE;IACnBkI,KAAK,CAAClI,UAAU,GAAG,EAAE;EACzB,CAAC,MACI,IAAI,CAACuG,KAAK,CAAC8C,OAAO,CAACnB,KAAK,CAAClI,UAAU,CAAC,EAAE;IACvCkI,KAAK,CAAClI,UAAU,GAAG,CAACkI,KAAK,CAAClI,UAAU,CAAC;EACzC;EACA;EACAkI,KAAK,CAACI,QAAQ,GAAG,CAAC,CAACJ,KAAK,CAACI,QAAQ;EACjC,OAAOJ,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,wBAAwB,CAACD,IAAI,EAAEkB,eAAe,EAAE;EACrD,IAAI,OAAOlB,IAAI,IAAI,UAAU,EAAE;IAC3B;IACA,OAAOA,IAAI;EACf;EACA,OAAQ,CAACmB,SAAS,EAAEjM,aAAa,KAAKkM,+BAA+B,CAACpB,IAAI,EAAE9K,aAAa,EAAEgM,eAAe,CAAC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,+BAA+B,CAACC,qBAAqB,EAAEnM,aAAa,EAAEgM,eAAe,EAAE;EAC5F,IAAI,OAAOG,qBAAqB,IAAI,QAAQ,EAAE;IAC1C;IACAA,qBAAqB,GAAG;MAAE/L,IAAI,EAAE+L;IAAsB,CAAC;EAC3D;EACA,IAAIxF,OAAO;EACX,MAAMtG,UAAU,GAAGL,aAAa,CAACM,MAAM;EACvC,MAAMoC,UAAU,GAAGkH,MAAM,CAACwC,MAAM,CAAC,CAAC,CAAC,EAAED,qBAAqB,CAACzJ,UAAU,CAAC;EACtE,IAAIsJ,eAAe,IAAI,WAAW,EAAE;IAChCrF,OAAO,GAAGtG,UAAU,CAACgM,sBAAsB,CAACF,qBAAqB,CAAC/L,IAAI,EAAEsC,UAAU,CAAC;EACvF,CAAC,MACI,IAAIsJ,eAAe,IAAI,WAAW,EAAE;IACrC,MAAMM,OAAO,GAAG;MACZzJ,QAAQ,EAAEsJ,qBAAqB,CAACtJ,QAAQ,IAAItE,oBAAoB,CAACgO;IACrE,CAAC;IACD5F,OAAO,GAAGtG,UAAU,CAACoC,sBAAsB,CAAC0J,qBAAqB,CAAC/L,IAAI,EAAEsC,UAAU,EAAE4J,OAAO,CAAC;EAChG,CAAC,MACI;IACD;IACA3F,OAAO,GAAGtG,UAAU,CAACoI,eAAe,CAAC0D,qBAAqB,CAAC/L,IAAI,EAAEsC,UAAU,CAAC;EAChF;EACA,IAAIyJ,qBAAqB,CAACK,MAAM,EAAE;IAC9B,MAAM7C,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACwC,qBAAqB,CAACK,MAAM,CAAC;IACtD,KAAK,MAAMhD,GAAG,IAAIG,IAAI,EAAE;MACpBtJ,UAAU,CAAC0J,QAAQ,CAACP,GAAG,EAAE2C,qBAAqB,CAACK,MAAM,CAAChD,GAAG,CAAC,EAAE7C,OAAO,CAAC;IACxE;EACJ;EACA,IAAIwF,qBAAqB,CAACxJ,OAAO,EAAE;IAC/B,MAAMA,OAAO,GAAGwJ,qBAAqB,CAACxJ,OAAO;IAC7C,IAAI,OAAOA,OAAO,IAAI,QAAQ,EAAE;MAC5BtC,UAAU,CAACyJ,QAAQ,CAACnH,OAAO,EAAEgE,OAAO,CAAC;IACzC,CAAC,MACI;MACD,KAAK,MAAM8C,SAAS,IAAI9G,OAAO,EAAE;QAC7BtC,UAAU,CAACyJ,QAAQ,CAACL,SAAS,EAAE9C,OAAO,CAAC;MAC3C;IACJ;EACJ;EACA,OAAOA,OAAO;AAClB;AACA,SAASiF,uBAAuB,CAAC9M,MAAM,EAAE;EACrC,IAAIA,MAAM,CAAC8L,KAAK,CAACc,MAAM,EAAE;IACrB,OAAQ,CAACe,mBAAmB,EAAEzM,aAAa,EAAED,IAAI,KAAK;MAClD,MAAM+K,IAAI,GAAGhM,MAAM,CAACgM,IAAI,CAAC2B,mBAAmB,CAAC;MAC7C,IAAI3B,IAAI,EAAE;QACN,OAAOA,IAAI,CAAC2B,mBAAmB,EAAEzM,aAAa,EAAED,IAAI,CAAC;MACzD;MACA,OAAO,IAAI;IACf,CAAC;EACL,CAAC,MACI;IACD,OAAOjB,MAAM,CAACgM,IAAI;EACtB;AACJ;AACA;AACA;AACA;AACA;AACA,SAASe,0BAA0B,CAACf,IAAI,EAAE;EACtC,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAE;IACzB,OAAO2B,mBAAmB,KAAK;MAAEjD,GAAG,EAAEsB,IAAI;MAAE1E,KAAK,EAAEqG;IAAoB,CAAC,CAAC;EAC7E,CAAC,MACI,IAAI,OAAO3B,IAAI,IAAI,QAAQ,EAAE;IAC9B;IACA,IAAIA,IAAI,CAAC1E,KAAK,EAAE;MACZ,OAAO,MAAM0E,IAAI;IACrB;IACA;IAAA,KACK;MACD,OAAO2B,mBAAmB,KAAK;QAAEjD,GAAG,EAAEsB,IAAI,CAACtB,GAAG;QAAEpD,KAAK,EAAEqG;MAAoB,CAAC,CAAC;IACjF;EACJ,CAAC,MACI;IACD;IACA,OAAO3B,IAAI;EACf;AACJ;AACA;AACA,SAASZ,iBAAiB,CAACD,mBAAmB,EAAElK,IAAI,EAAEC,aAAa,EAAE;EACjE;EACA,MAAMuC,UAAU,GAAG,OAAO0H,mBAAmB,IAAI,UAAU,GACvDA,mBAAmB,CAAClK,IAAI,EAAEC,aAAa,CAAC,GACxCiK,mBAAmB;EACvB,IAAI,CAAC1H,UAAU,EAAE;IACb,OAAO,IAAI;EACf;EACA;EACA,IAAI,CAACA,UAAU,CAACM,QAAQ,EAAE;IACtBN,UAAU,CAACM,QAAQ,GAAG,EAAE;EAC5B;EACA;EACA,IAAI,CAACN,UAAU,CAACS,EAAE,EAAE;IAChBT,UAAU,CAACS,EAAE,GAAGjD,IAAI,CAACuG,UAAU;EACnC;EACA,OAAO/D,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmK,2BAA2B,CAAC9B,KAAK,EAAE;EACxC,OAAO,CAAC+B,IAAI,EAAEC,MAAM,KAAK;IACrB,IAAI,CAACD,IAAI,CAACzL,EAAE,CAAC,SAAS,EAAE0J,KAAK,CAACxK,IAAI,CAAC,EAAE;MACjC,OAAO,KAAK;IAChB;IACA,IAAIwM,MAAM,CAACC,IAAI,IAAI,WAAW,EAAE;MAC5B,IAAIjC,KAAK,CAAClI,UAAU,CAACoK,QAAQ,CAACF,MAAM,CAACG,YAAY,CAAC,EAAE;QAChD,OAAO,IAAI;MACf;IACJ,CAAC,MACI;MACD;MACA,IAAInC,KAAK,CAACI,QAAQ,EAAE;QAChB,OAAO,IAAI;MACf;IACJ;IACA,OAAO,KAAK;EAChB,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,mBAAmB,CAACR,KAAK,EAAE;EAChC,MAAMoC,aAAa,GAAGN,2BAA2B,CAAC9B,KAAK,CAAC;EACxD,OAAO,CAAC9K,GAAG,EAAEC,IAAI,KAAK;IAClB,MAAMkN,cAAc,GAAG,EAAE;IACzB,IAAI,CAAClN,IAAI,CAACmN,mBAAmB,EAAE;MAC3BnN,IAAI,CAACmN,mBAAmB,GAAG,IAAIrE,GAAG,EAAE;IACxC;IACA,KAAK,MAAM+D,MAAM,IAAI7M,IAAI,CAACoN,OAAO,EAAE;MAC/B;MACA;MACA,MAAMR,IAAI,GAAGC,MAAM,CAACC,IAAI,IAAI,WAAW,GAAGD,MAAM,CAAClM,KAAK,CAACC,KAAK,CAAC2G,SAAS,GAAGsF,MAAM,CAACrL,QAAQ,CAAC6C,MAAM;MAC/F,IAAI,CAACuI,IAAI,IAAI,CAACK,aAAa,CAACL,IAAI,EAAEC,MAAM,CAAC,EAAE;QACvCK,cAAc,CAAC3J,IAAI,CAACsJ,MAAM,CAAC;QAC3B;MACJ;MACA;MACA,IAAI,CAAC7M,IAAI,CAACmN,mBAAmB,CAACE,GAAG,CAACT,IAAI,CAAC,EAAE;QACrC5M,IAAI,CAACmN,mBAAmB,CAACnO,GAAG,CAAC4N,IAAI,CAAC;QAClC,MAAMpL,QAAQ,GAAGjD,aAAa,CAAC+O,aAAa,CAACV,IAAI,CAAC;QAClDM,cAAc,CAAC3J,IAAI,CAAC;UAChBuJ,IAAI,EAAE,QAAQ;UACdzM,IAAI,EAAEuM,IAAI,CAACvM,IAAI;UACfmB,QAAQ;UACRG,MAAM,EAAE;QACZ,CAAC,EAAE;UACCmL,IAAI,EAAE,UAAU;UAChBzM,IAAI,EAAEuM,IAAI,CAACvM,IAAI;UACfmB,QAAQ;UACRG,MAAM,EAAE;QACZ,CAAC,CAAC;MACN;IACJ;IACA3B,IAAI,CAACoN,OAAO,GAAGF,cAAc;EACjC,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/B,cAAc,CAACN,KAAK,EAAE;EAC3B,OAAO,UAAC+B,IAAI,EAAE1M,UAAU,EAAmB;IAAA,IAAjBqM,OAAO,uEAAG,CAAC,CAAC;IAClC,MAAMgB,MAAM,GAAG,CAAC,QAAQ,CAAC;IACzB;IACA,KAAK,MAAMxF,aAAa,IAAI8C,KAAK,CAAClI,UAAU,EAAE;MAC1C,IAAIiK,IAAI,CAAC1E,YAAY,CAACH,aAAa,CAAC,EAAE;QAClCwF,MAAM,CAAChK,IAAI,CAAE,aAAYwE,aAAc,EAAC,CAAC;MAC7C;IACJ;IACA,IAAI,CAACwF,MAAM,CAACC,KAAK,CAACC,KAAK,IAAIvN,UAAU,CAACwE,IAAI,CAACkI,IAAI,EAAEa,KAAK,CAAC,CAAC,EAAE;MACtD,OAAO,KAAK;IAChB;IACA,IAAI,CAAClB,OAAO,CAACnH,SAAS,EAAE;MACpBmI,MAAM,CAACG,OAAO,CAACD,KAAK,IAAIvN,UAAU,CAACC,OAAO,CAACyM,IAAI,EAAEa,KAAK,CAAC,CAAC;IAC5D;IACA,OAAO,IAAI;EACf,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7H,iBAAiB,CAACgB,OAAO,EAAEnB,QAAQ,EAAExF,aAAa,EAAE;EACzD,OAAO,UAACM,MAAM,EAAgC;IAAA,IAA9BoN,YAAY,uEAAG,UAAU;IACrC,MAAMC,IAAI,GAAGrN,MAAM,CAAC+L,sBAAsB,CAAC,OAAO,CAAC;IACnD,IAAIrB,QAAQ,GAAG,IAAI;IACnB,IAAI0C,YAAY,KAAK,UAAU,EAAE;MAC7B1C,QAAQ,GAAG/B,KAAK,CAACC,IAAI,CAACvC,OAAO,CAACrB,WAAW,EAAE,CAAC;IAChD,CAAC,MACI,IAAI,OAAOoI,YAAY,IAAI,UAAU,EAAE;MACxC1C,QAAQ,GAAG/B,KAAK,CAACC,IAAI,CAACvC,OAAO,CAACrB,WAAW,EAAE,CAAC,CAACsI,MAAM,CAACjH,OAAO,IAAI+G,YAAY,CAAC/G,OAAO,CAAC,CAAC;IACzF,CAAC,MACI;MACD;AACZ;AACA;AACA;AACA;MACY,MAAM,IAAIjI,aAAa,CAAC,8BAA8B,EAAEsB,aAAa,CAACuJ,UAAU,EAAE;QAAEmE;MAAa,CAAC,CAAC;IACvG;IACAlI,QAAQ,CAACqI,GAAG,CAACF,IAAI,EAAE3C,QAAQ,CAAC;IAC5B,OAAO2C,IAAI;EACf,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9H,qBAAqB,CAACc,OAAO,EAAEnB,QAAQ,EAAExF,aAAa,EAAE;EAC7D,MAAM8N,eAAe,GAAG7E,KAAK,CAACC,IAAI,CAAC1D,QAAQ,CAACkG,MAAM,EAAE,CAAC,CAACqC,IAAI,EAAE;EAC5D,MAAMC,qBAAqB,GAAG,IAAInF,GAAG,CAACiF,eAAe,CAAC;EACtD,IAAIE,qBAAqB,CAACjF,IAAI,IAAI+E,eAAe,CAACpM,MAAM,EAAE;IACtD;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,MAAM,IAAIhD,aAAa,CAAC,gCAAgC,EAAEsB,aAAa,CAACuJ,UAAU,EAAE;MAAE5C;IAAQ,CAAC,CAAC;EACpG;EACA,IAAIqH,qBAAqB,CAACjF,IAAI,IAAIpC,OAAO,CAACsH,UAAU,EAAE;IAClD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,MAAM,IAAIvP,aAAa,CAAC,mCAAmC,EAAEsB,aAAa,CAACuJ,UAAU,EAAE;MAAE5C;IAAQ,CAAC,CAAC;EACvG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,SAAS,CAACtD,WAAW,EAAEgD,QAAQ,EAAExF,aAAa,EAAEsM,OAAO,EAAE;EAC9D;EACAtM,aAAa,CAACQ,MAAM,CAACyK,EAAE,CAAC,qBAAqB,EAAEiD,qBAAqB,EAAE;IAAErL,QAAQ,EAAE;EAAU,CAAC,CAAC;EAC9F,IAAIsL,WAAW,GAAG,IAAI;EACtB,IAAIC,gBAAgB,GAAG,IAAI;EAC3B;EACA,KAAK,CAACD,WAAW,EAAEC,gBAAgB,CAAC,IAAI5I,QAAQ,EAAE;IAC9CH,sBAAsB,CAAC7C,WAAW,EAAE4L,gBAAgB,EAAEpO,aAAa,EAAEsM,OAAO,CAAC;IAC7EtM,aAAa,CAACM,MAAM,CAAC+N,IAAI,CAACrO,aAAa,CAACM,MAAM,CAAC4B,aAAa,CAACiM,WAAW,CAAC,EAAEnO,aAAa,CAACM,MAAM,CAACgO,oBAAoB,CAACH,WAAW,CAAC,CAAC;IAClInO,aAAa,CAACM,MAAM,CAACe,MAAM,CAAC8M,WAAW,CAAC;EAC5C;EACAnO,aAAa,CAACQ,MAAM,CAAC+N,GAAG,CAAC,qBAAqB,EAAEL,qBAAqB,CAAC;EACtE,SAASA,qBAAqB,CAACpO,GAAG,EAAEC,IAAI,EAAE;IACtC,MAAM4G,OAAO,GAAG5G,IAAI,CAAC6D,aAAa,CAAC0D,SAAS;IAC5C;IACA,MAAMkH,KAAK,GAAGJ,gBAAgB,CAACK,OAAO,CAAC9H,OAAO,CAAC;IAC/C,IAAI6H,KAAK,GAAG,CAAC,EAAE;MACX;IACJ;IACAzO,IAAI,CAACQ,YAAY,GAAGR,IAAI,CAACS,MAAM,CAACkO,cAAc,CAACP,WAAW,EAAEK,KAAK,CAAC;EACtE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASnJ,sBAAsB,CAAC7C,WAAW,EAAEmM,UAAU,EAAE3O,aAAa,EAAEsM,OAAO,EAAE;EAC7E;EACA,KAAK,MAAMsC,cAAc,IAAID,UAAU,EAAE;IACrC;IACA,IAAI,CAACE,YAAY,CAACrM,WAAW,CAACsM,IAAI,EAAEF,cAAc,EAAE5O,aAAa,EAAEsM,OAAO,CAAC,EAAE;MACzE;MACAtM,aAAa,CAAC+O,WAAW,CAACH,cAAc,CAAC;IAC7C;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAY,CAACG,QAAQ,EAAEC,SAAS,EAAEjP,aAAa,EAAEsM,OAAO,EAAE;EAC/D,MAAM;IAAEhM,MAAM;IAAEE;EAAO,CAAC,GAAGR,aAAa;EACxC;EACA,IAAI,CAACsM,OAAO,CAACrL,YAAY,EAAE;IACvB,OAAO,KAAK;EAChB;EACA,MAAMiO,aAAa,GAAG1O,MAAM,CAACmH,aAAa,CAACsH,SAAS,CAAC;EACrD;EACA,IAAI,CAACC,aAAa,IAAIA,aAAa,CAACJ,IAAI,IAAIE,QAAQ,EAAE;IAClD,OAAO,KAAK;EAChB;EACA;EACA,IAAI,CAAChP,aAAa,CAACmP,YAAY,CAACD,aAAa,CAAC,EAAE;IAC5C,OAAO,KAAK;EAChB;EACA;EACA5O,MAAM,CAAC+N,IAAI,CAAC/N,MAAM,CAACwG,aAAa,CAACoI,aAAa,CAAC,EAAE1O,MAAM,CAACC,cAAc,CAACnC,aAAa,CAAC+O,aAAa,CAAC4B,SAAS,CAAC,CAAC,CAAC;EAC/G,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/J,eAAe,CAAC/E,IAAI,EAAEF,UAAU,EAAsB;EAAA,IAApB;IAAEkF;EAAU,CAAC,uEAAG,CAAC,CAAC;EACzD,IAAIA,SAAS,EAAE;IACX,OAAOlF,UAAU,CAACwE,IAAI,CAACtE,IAAI,EAAE,QAAQ,CAAC;EAC1C,CAAC,MACI;IACD,OAAOF,UAAU,CAACC,OAAO,CAACC,IAAI,EAAE,QAAQ,CAAC;EAC7C;AACJ"},"metadata":{},"sourceType":"module"}