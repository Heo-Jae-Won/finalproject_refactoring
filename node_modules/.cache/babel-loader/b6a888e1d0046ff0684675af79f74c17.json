{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/observer/bubblingemittermixin\n */\nimport EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport BubblingEventInfo from './bubblingeventinfo';\nconst contextsSymbol = Symbol('bubbling contexts');\n/**\n * Bubbling emitter mixin for the view document as described in the\n * {@link ~BubblingEmitter} interface.\n *\n * @mixin BubblingEmitterMixin\n * @implements module:engine/view/observer/bubblingemittermixin~BubblingEmitter\n */\nexport default function BubblingEmitterMixin(base) {\n  class Mixin extends base {\n    fire(eventOrInfo) {\n      try {\n        const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);\n        const eventContexts = getBubblingContexts(this);\n        if (!eventContexts.size) {\n          return;\n        }\n        updateEventInfo(eventInfo, 'capturing', this);\n        // The capture phase of the event.\n        for (var _len = arguments.length, eventArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          eventArgs[_key - 1] = arguments[_key];\n        }\n        if (fireListenerFor(eventContexts, '$capture', eventInfo, ...eventArgs)) {\n          return eventInfo.return;\n        }\n        const startRange = eventInfo.startRange || this.selection.getFirstRange();\n        const selectedElement = startRange ? startRange.getContainedElement() : null;\n        const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;\n        let node = selectedElement || getDeeperRangeParent(startRange);\n        updateEventInfo(eventInfo, 'atTarget', node);\n        // For the not yet bubbling event trigger for $text node if selection can be there and it's not a custom context selected.\n        if (!isCustomContext) {\n          if (fireListenerFor(eventContexts, '$text', eventInfo, ...eventArgs)) {\n            return eventInfo.return;\n          }\n          updateEventInfo(eventInfo, 'bubbling', node);\n        }\n        while (node) {\n          // Root node handling.\n          if (node.is('rootElement')) {\n            if (fireListenerFor(eventContexts, '$root', eventInfo, ...eventArgs)) {\n              return eventInfo.return;\n            }\n          }\n          // Element node handling.\n          else if (node.is('element')) {\n            if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {\n              return eventInfo.return;\n            }\n          }\n          // Check custom contexts (i.e., a widget).\n          if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {\n            return eventInfo.return;\n          }\n          node = node.parent;\n          updateEventInfo(eventInfo, 'bubbling', node);\n        }\n        updateEventInfo(eventInfo, 'bubbling', this);\n        // Document context.\n        fireListenerFor(eventContexts, '$document', eventInfo, ...eventArgs);\n        return eventInfo.return;\n      } catch (err) {\n        // @if CK_DEBUG // throw err;\n        /* istanbul ignore next */\n        CKEditorError.rethrowUnexpectedError(err, this);\n      }\n    }\n    _addEventListener(event, callback, options) {\n      const contexts = toArray(options.context || '$document');\n      const eventContexts = getBubblingContexts(this);\n      for (const context of contexts) {\n        let emitter = eventContexts.get(context);\n        if (!emitter) {\n          emitter = new Emitter();\n          eventContexts.set(context, emitter);\n        }\n        this.listenTo(emitter, event, callback, options);\n      }\n    }\n    _removeEventListener(event, callback) {\n      const eventContexts = getBubblingContexts(this);\n      for (const emitter of eventContexts.values()) {\n        this.stopListening(emitter, event, callback);\n      }\n    }\n  }\n  return Mixin;\n}\n// Backward compatibility with `mix`.\n{\n  const mixin = BubblingEmitterMixin(Object);\n  ['fire', '_addEventListener', '_removeEventListener'].forEach(key => {\n    BubblingEmitterMixin[key] = mixin.prototype[key];\n  });\n}\n// Update the event info bubbling fields.\n//\n// @param {module:utils/eventinfo~EventInfo} eventInfo The event info object to update.\n// @param {'none'|'capturing'|'atTarget'|'bubbling'} eventPhase The current event phase.\n// @param {module:engine/view/document~Document|module:engine/view/node~Node} currentTarget The current bubbling target.\nfunction updateEventInfo(eventInfo, eventPhase, currentTarget) {\n  if (eventInfo instanceof BubblingEventInfo) {\n    eventInfo._eventPhase = eventPhase;\n    eventInfo._currentTarget = currentTarget;\n  }\n}\n// Fires the listener for the specified context. Returns `true` if event was stopped.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {String|module:engine/view/node~Node} context\n// @param {module:utils/eventinfo~EventInfo} eventInfo The `EventInfo` object.\n// @param {...*} [eventArgs] Additional arguments to be passed to the callbacks.\n// @returns {Boolean} True if event stop was called.\nfunction fireListenerFor(eventContexts, context, eventInfo) {\n  const emitter = typeof context == 'string' ? eventContexts.get(context) : getCustomContext(eventContexts, context);\n  if (!emitter) {\n    return false;\n  }\n  for (var _len2 = arguments.length, eventArgs = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    eventArgs[_key2 - 3] = arguments[_key2];\n  }\n  emitter.fire(eventInfo, ...eventArgs);\n  return eventInfo.stop.called;\n}\n// Returns an emitter for a specified view node.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {module:engine/view/node~Node} node\n// @returns {module:utils/emittermixin~Emitter|null}\nfunction getCustomContext(eventContexts, node) {\n  for (const [context, emitter] of eventContexts) {\n    if (typeof context == 'function' && context(node)) {\n      return emitter;\n    }\n  }\n  return null;\n}\n// Returns bubbling contexts map for the source (emitter).\nfunction getBubblingContexts(source) {\n  if (!source[contextsSymbol]) {\n    source[contextsSymbol] = new Map();\n  }\n  return source[contextsSymbol];\n}\n// Returns the deeper parent element for the range.\nfunction getDeeperRangeParent(range) {\n  if (!range) {\n    return null;\n  }\n  const startParent = range.start.parent;\n  const endParent = range.end.parent;\n  const startPath = startParent.getPath();\n  const endPath = endParent.getPath();\n  return startPath.length > endPath.length ? startParent : endParent;\n}","map":{"version":3,"names":["EventInfo","CKEditorError","Emitter","toArray","BubblingEventInfo","contextsSymbol","Symbol","BubblingEmitterMixin","base","Mixin","fire","eventOrInfo","eventInfo","eventContexts","getBubblingContexts","size","updateEventInfo","eventArgs","fireListenerFor","return","startRange","selection","getFirstRange","selectedElement","getContainedElement","isCustomContext","Boolean","getCustomContext","node","getDeeperRangeParent","is","name","parent","err","rethrowUnexpectedError","_addEventListener","event","callback","options","contexts","context","emitter","get","set","listenTo","_removeEventListener","values","stopListening","mixin","Object","forEach","key","prototype","eventPhase","currentTarget","_eventPhase","_currentTarget","stop","called","source","Map","range","startParent","start","endParent","end","startPath","getPath","endPath","length"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/bubblingemittermixin.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/observer/bubblingemittermixin\n */\nimport EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { Emitter } from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport BubblingEventInfo from './bubblingeventinfo';\nconst contextsSymbol = Symbol('bubbling contexts');\n/**\n * Bubbling emitter mixin for the view document as described in the\n * {@link ~BubblingEmitter} interface.\n *\n * @mixin BubblingEmitterMixin\n * @implements module:engine/view/observer/bubblingemittermixin~BubblingEmitter\n */\nexport default function BubblingEmitterMixin(base) {\n    class Mixin extends base {\n        fire(eventOrInfo, ...eventArgs) {\n            try {\n                const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);\n                const eventContexts = getBubblingContexts(this);\n                if (!eventContexts.size) {\n                    return;\n                }\n                updateEventInfo(eventInfo, 'capturing', this);\n                // The capture phase of the event.\n                if (fireListenerFor(eventContexts, '$capture', eventInfo, ...eventArgs)) {\n                    return eventInfo.return;\n                }\n                const startRange = eventInfo.startRange || this.selection.getFirstRange();\n                const selectedElement = startRange ? startRange.getContainedElement() : null;\n                const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;\n                let node = selectedElement || getDeeperRangeParent(startRange);\n                updateEventInfo(eventInfo, 'atTarget', node);\n                // For the not yet bubbling event trigger for $text node if selection can be there and it's not a custom context selected.\n                if (!isCustomContext) {\n                    if (fireListenerFor(eventContexts, '$text', eventInfo, ...eventArgs)) {\n                        return eventInfo.return;\n                    }\n                    updateEventInfo(eventInfo, 'bubbling', node);\n                }\n                while (node) {\n                    // Root node handling.\n                    if (node.is('rootElement')) {\n                        if (fireListenerFor(eventContexts, '$root', eventInfo, ...eventArgs)) {\n                            return eventInfo.return;\n                        }\n                    }\n                    // Element node handling.\n                    else if (node.is('element')) {\n                        if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {\n                            return eventInfo.return;\n                        }\n                    }\n                    // Check custom contexts (i.e., a widget).\n                    if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {\n                        return eventInfo.return;\n                    }\n                    node = node.parent;\n                    updateEventInfo(eventInfo, 'bubbling', node);\n                }\n                updateEventInfo(eventInfo, 'bubbling', this);\n                // Document context.\n                fireListenerFor(eventContexts, '$document', eventInfo, ...eventArgs);\n                return eventInfo.return;\n            }\n            catch (err) {\n                // @if CK_DEBUG // throw err;\n                /* istanbul ignore next */\n                CKEditorError.rethrowUnexpectedError(err, this);\n            }\n        }\n        _addEventListener(event, callback, options) {\n            const contexts = toArray(options.context || '$document');\n            const eventContexts = getBubblingContexts(this);\n            for (const context of contexts) {\n                let emitter = eventContexts.get(context);\n                if (!emitter) {\n                    emitter = new Emitter();\n                    eventContexts.set(context, emitter);\n                }\n                this.listenTo(emitter, event, callback, options);\n            }\n        }\n        _removeEventListener(event, callback) {\n            const eventContexts = getBubblingContexts(this);\n            for (const emitter of eventContexts.values()) {\n                this.stopListening(emitter, event, callback);\n            }\n        }\n    }\n    return Mixin;\n}\n// Backward compatibility with `mix`.\n{\n    const mixin = BubblingEmitterMixin(Object);\n    ['fire', '_addEventListener', '_removeEventListener'].forEach(key => {\n        BubblingEmitterMixin[key] = mixin.prototype[key];\n    });\n}\n// Update the event info bubbling fields.\n//\n// @param {module:utils/eventinfo~EventInfo} eventInfo The event info object to update.\n// @param {'none'|'capturing'|'atTarget'|'bubbling'} eventPhase The current event phase.\n// @param {module:engine/view/document~Document|module:engine/view/node~Node} currentTarget The current bubbling target.\nfunction updateEventInfo(eventInfo, eventPhase, currentTarget) {\n    if (eventInfo instanceof BubblingEventInfo) {\n        eventInfo._eventPhase = eventPhase;\n        eventInfo._currentTarget = currentTarget;\n    }\n}\n// Fires the listener for the specified context. Returns `true` if event was stopped.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {String|module:engine/view/node~Node} context\n// @param {module:utils/eventinfo~EventInfo} eventInfo The `EventInfo` object.\n// @param {...*} [eventArgs] Additional arguments to be passed to the callbacks.\n// @returns {Boolean} True if event stop was called.\nfunction fireListenerFor(eventContexts, context, eventInfo, ...eventArgs) {\n    const emitter = typeof context == 'string' ? eventContexts.get(context) : getCustomContext(eventContexts, context);\n    if (!emitter) {\n        return false;\n    }\n    emitter.fire(eventInfo, ...eventArgs);\n    return eventInfo.stop.called;\n}\n// Returns an emitter for a specified view node.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {module:engine/view/node~Node} node\n// @returns {module:utils/emittermixin~Emitter|null}\nfunction getCustomContext(eventContexts, node) {\n    for (const [context, emitter] of eventContexts) {\n        if (typeof context == 'function' && context(node)) {\n            return emitter;\n        }\n    }\n    return null;\n}\n// Returns bubbling contexts map for the source (emitter).\nfunction getBubblingContexts(source) {\n    if (!source[contextsSymbol]) {\n        source[contextsSymbol] = new Map();\n    }\n    return source[contextsSymbol];\n}\n// Returns the deeper parent element for the range.\nfunction getDeeperRangeParent(range) {\n    if (!range) {\n        return null;\n    }\n    const startParent = range.start.parent;\n    const endParent = range.end.parent;\n    const startPath = startParent.getPath();\n    const endPath = endParent.getPath();\n    return startPath.length > endPath.length ? startParent : endParent;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}