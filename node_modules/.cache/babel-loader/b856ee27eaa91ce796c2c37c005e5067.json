{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/viewconsumable\n */\nimport { isArray } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Class used for handling consumption of view {@link module:engine/view/element~Element elements},\n * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.\n * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name\n * does not consume its attributes, classes and styles.\n * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.\n * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.\n * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.\n * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.\n *\n *\t\tviewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.\n *\t\tviewConsumable.add( textNode ); // Adds text node for consumption.\n *\t\tviewConsumable.add( docFragment ); // Adds document fragment for consumption.\n *\t\tviewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.\n *\t\tviewConsumable.test( textNode ); // Tests if text node can be consumed.\n *\t\tviewConsumable.test( docFragment ); // Tests if document fragment can be consumed.\n *\t\tviewConsumable.consume( element, { name: true }  ); // Consume element's name.\n *\t\tviewConsumable.consume( textNode ); // Consume text node.\n *\t\tviewConsumable.consume( docFragment ); // Consume document fragment.\n *\t\tviewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.\n *\t\tviewConsumable.revert( textNode ); // Revert already consumed text node.\n *\t\tviewConsumable.revert( docFragment ); // Revert already consumed document fragment.\n */\nexport default class ViewConsumable {\n  /**\n   * Creates new ViewConsumable.\n   */\n  constructor() {\n    /**\n     * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,\n     * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.\n     * For {@link module:engine/view/text~Text text nodes} and\n     * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.\n     *\n     * @protected\n     * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}\n    */\n    this._consumables = new Map();\n  }\n  /**\n   * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.\n   *\n   *\t\tviewConsumable.add( p, { name: true } ); // Adds element's name to consume.\n   *\t\tviewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.\n   *\t\tviewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.\n   *\t\tviewConsumable.add( p, { styles: 'color' } ); // Adds element's style\n   *\t\tviewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.\n   *\t\tviewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.\n   *\t\tviewConsumable.add( textNode ); // Adds text node to consume.\n   *\t\tviewConsumable.add( docFragment ); // Adds document fragment to consume.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n   * attribute is provided - it should be handled separately by providing actual style/class.\n   *\n   *\t\tviewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.\n   *\t\tviewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   */\n  add(element, consumables) {\n    let elementConsumables;\n    // For text nodes and document fragments just mark them as consumable.\n    if (element.is('$text') || element.is('documentFragment')) {\n      this._consumables.set(element, true);\n      return;\n    }\n    // For elements create new ViewElementConsumables or update already existing one.\n    if (!this._consumables.has(element)) {\n      elementConsumables = new ViewElementConsumables(element);\n      this._consumables.set(element, elementConsumables);\n    } else {\n      elementConsumables = this._consumables.get(element);\n    }\n    elementConsumables.add(consumables);\n  }\n  /**\n   * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.\n   * It returns `true` when all items included in method's call can be consumed. Returns `false` when\n   * first already consumed item is found and `null` when first non-consumable item is found.\n   *\n   *\t\tviewConsumable.test( p, { name: true } ); // Tests element's name.\n   *\t\tviewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.\n   *\t\tviewConsumable.test( p, { classes: 'foobar' } ); // Tests class.\n   *\t\tviewConsumable.test( p, { styles: 'color' } ); // Tests style.\n   *\t\tviewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.\n   *\t\tviewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.\n   *\t\tviewConsumable.test( textNode ); // Tests text node.\n   *\t\tviewConsumable.test( docFragment ); // Tests document fragment.\n   *\n   * Testing classes and styles as attribute will test if all added classes/styles can be consumed.\n   *\n   *\t\tviewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.\n   *\t\tviewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`\n   * when first already consumed item is found and `null` when first non-consumable item is found.\n   */\n  test(element, consumables) {\n    const elementConsumables = this._consumables.get(element);\n    if (elementConsumables === undefined) {\n      return null;\n    }\n    // For text nodes and document fragments return stored boolean value.\n    if (element.is('$text') || element.is('documentFragment')) {\n      return elementConsumables;\n    }\n    // For elements test consumables object.\n    return elementConsumables.test(consumables);\n  }\n  /**\n   * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n   * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.\n   *\n   *\t\tviewConsumable.consume( p, { name: true } ); // Consumes element's name.\n   *\t\tviewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.\n   *\t\tviewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.\n   *\t\tviewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.\n   *\t\tviewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.\n   *\t\tviewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.\n   *\t\tviewConsumable.consume( textNode ); // Consumes text node.\n   *\t\tviewConsumable.consume( docFragment ); // Consumes document fragment.\n   *\n   * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.\n   *\n   *\t\tviewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.\n   *\t\tviewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,\n   * otherwise returns `false`.\n   */\n  consume(element, consumables) {\n    if (this.test(element, consumables)) {\n      if (element.is('$text') || element.is('documentFragment')) {\n        // For text nodes and document fragments set value to false.\n        this._consumables.set(element, false);\n      } else {\n        // For elements - consume consumables object.\n        this._consumables.get(element).consume(consumables);\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.\n   * Method does not revert items that were never previously added for consumption, even if they are included in\n   * method's call.\n   *\n   *\t\tviewConsumable.revert( p, { name: true } ); // Reverts element's name.\n   *\t\tviewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.\n   *\t\tviewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.\n   *\t\tviewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.\n   *\t\tviewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.\n   *\t\tviewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.\n   *\t\tviewConsumable.revert( textNode ); // Reverts text node.\n   *\t\tviewConsumable.revert( docFragment ); // Reverts document fragment.\n   *\n   * Reverting classes and styles as attribute will revert all classes/styles that were previously added for\n   * consumption.\n   *\n   *\t\tviewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.\n   *\t\tviewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   */\n  revert(element, consumables) {\n    const elementConsumables = this._consumables.get(element);\n    if (elementConsumables !== undefined) {\n      if (element.is('$text') || element.is('documentFragment')) {\n        // For text nodes and document fragments - set consumable to true.\n        this._consumables.set(element, true);\n      } else {\n        // For elements - revert items from consumables object.\n        elementConsumables.revert(consumables);\n      }\n    }\n  }\n  /**\n   * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include\n   * element's name and all its attributes, classes and styles.\n   *\n   * @static\n   * @param {module:engine/view/element~Element} element\n   * @returns {Object} consumables\n   */\n  static consumablesFromElement(element) {\n    const consumables = {\n      element,\n      name: true,\n      attributes: [],\n      classes: [],\n      styles: []\n    };\n    const attributes = element.getAttributeKeys();\n    for (const attribute of attributes) {\n      // Skip classes and styles - will be added separately.\n      if (attribute == 'style' || attribute == 'class') {\n        continue;\n      }\n      consumables.attributes.push(attribute);\n    }\n    const classes = element.getClassNames();\n    for (const className of classes) {\n      consumables.classes.push(className);\n    }\n    const styles = element.getStyleNames();\n    for (const style of styles) {\n      consumables.styles.push(style);\n    }\n    return consumables;\n  }\n  /**\n   * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from\n   * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n   * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.\n   *\n   * @static\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n   * from which `ViewConsumable` will be created.\n   * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used\n   * to add all consumables. It will be returned instead of a new instance.\n   */\n  static createFrom(from, instance) {\n    if (!instance) {\n      instance = new ViewConsumable();\n    }\n    if (from.is('$text')) {\n      instance.add(from);\n      return instance;\n    }\n    // Add `from` itself, if it is an element.\n    if (from.is('element')) {\n      instance.add(from, ViewConsumable.consumablesFromElement(from));\n    }\n    if (from.is('documentFragment')) {\n      instance.add(from);\n    }\n    for (const child of from.getChildren()) {\n      instance = ViewConsumable.createFrom(child, instance);\n    }\n    return instance;\n  }\n}\nconst CONSUMABLE_TYPES = ['attributes', 'classes', 'styles'];\n/**\n * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.\n * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.\n *\n * @private\n */\nclass ViewElementConsumables {\n  /**\n   * Creates ViewElementConsumables instance.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n   * from which `ViewElementConsumables` is being created.\n   */\n  constructor(from) {\n    /**\n     * @readonly\n     * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n     */\n    this.element = from;\n    /**\n     * Flag indicating if name of the element can be consumed.\n     *\n     * @private\n     * @member {Boolean}\n     */\n    this._canConsumeName = null;\n    /**\n     * Contains maps of element's consumables: attributes, classes and styles.\n     *\n     * @private\n     * @member {Object}\n     */\n    this._consumables = {\n      attributes: new Map(),\n      styles: new Map(),\n      classes: new Map()\n    };\n  }\n  /**\n   * Adds consumable parts of the {@link module:engine/view/element~Element view element}.\n   * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and\n   * styles still could be consumed):\n   *\n   *\t\tconsumables.add( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n   * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.\n   *\n   * @param {Object} consumables Object describing which parts of the element can be consumed.\n   * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.\n   */\n  add(consumables) {\n    if (consumables.name) {\n      this._canConsumeName = true;\n    }\n    for (const type of CONSUMABLE_TYPES) {\n      if (type in consumables) {\n        this._add(type, consumables[type]);\n      }\n    }\n  }\n  /**\n   * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.\n   *\n   * Element's name can be tested:\n   *\n   *\t\tconsumables.test( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * @param {Object} consumables Object describing which parts of the element should be tested.\n   * @param {Boolean} consumables.name If set to `true` element's name will be tested.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.\n   * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items\n   * was never marked for consumption and `false` when even one of the items was already consumed.\n   */\n  test(consumables) {\n    // Check if name can be consumed.\n    if (consumables.name && !this._canConsumeName) {\n      return this._canConsumeName;\n    }\n    for (const type of CONSUMABLE_TYPES) {\n      if (type in consumables) {\n        const value = this._test(type, consumables[type]);\n        if (value !== true) {\n          return value;\n        }\n      }\n    }\n    // Return true only if all can be consumed.\n    return true;\n  }\n  /**\n   * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item\n   * is already consumed - it consumes all consumable items provided.\n   * Element's name can be consumed:\n   *\n   *\t\tconsumables.consume( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * @param {Object} consumables Object describing which parts of the element should be consumed.\n   * @param {Boolean} consumables.name If set to `true` element's name will be consumed.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.\n   */\n  consume(consumables) {\n    if (consumables.name) {\n      this._canConsumeName = false;\n    }\n    for (const type of CONSUMABLE_TYPES) {\n      if (type in consumables) {\n        this._consume(type, consumables[type]);\n      }\n    }\n  }\n  /**\n   * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.\n   * Element's name can be reverted:\n   *\n   *\t\tconsumables.revert( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * @param {Object} consumables Object describing which parts of the element should be reverted.\n   * @param {Boolean} consumables.name If set to `true` element's name will be reverted.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.\n   */\n  revert(consumables) {\n    if (consumables.name) {\n      this._canConsumeName = true;\n    }\n    for (const type of CONSUMABLE_TYPES) {\n      if (type in consumables) {\n        this._revert(type, consumables[type]);\n      }\n    }\n  }\n  /**\n   * Helper method that adds consumables of a given type: attribute, class or style.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n   * type is provided - it should be handled separately by providing actual style/class type.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   */\n  _add(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        /**\n         * Class and style attributes should be handled separately in\n         * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.\n         *\n         * What you have done is trying to use:\n         *\n         *\t\tconsumables.add( { attributes: [ 'class', 'style' ] } );\n         *\n         * While each class and style should be registered separately:\n         *\n         *\t\tconsumables.add( { classes: 'some-class', styles: 'font-weight' } );\n         *\n         * @error viewconsumable-invalid-attribute\n         */\n        throw new CKEditorError('viewconsumable-invalid-attribute', this);\n      }\n      consumables.set(name, true);\n      if (type === 'styles') {\n        for (const alsoName of this.element.document.stylesProcessor.getRelatedStyles(name)) {\n          consumables.set(alsoName, true);\n        }\n      }\n    }\n  }\n  /**\n   * Helper method that tests consumables of a given type: attribute, class or style.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be\n   * consumed and `false` when one of the items is already consumed.\n   */\n  _test(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        const consumableName = name == 'class' ? 'classes' : 'styles';\n        // Check all classes/styles if class/style attribute is tested.\n        const value = this._test(consumableName, [...this._consumables[consumableName].keys()]);\n        if (value !== true) {\n          return value;\n        }\n      } else {\n        const value = consumables.get(name);\n        // Return null if attribute is not found.\n        if (value === undefined) {\n          return null;\n        }\n        if (!value) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Helper method that consumes items of a given type: attribute, class or style.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   */\n  _consume(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        const consumableName = name == 'class' ? 'classes' : 'styles';\n        // If class or style is provided for consumption - consume them all.\n        this._consume(consumableName, [...this._consumables[consumableName].keys()]);\n      } else {\n        consumables.set(name, false);\n        if (type == 'styles') {\n          for (const toConsume of this.element.document.stylesProcessor.getRelatedStyles(name)) {\n            consumables.set(toConsume, false);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Helper method that reverts items of a given type: attribute, class or style.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   */\n  _revert(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        const consumableName = name == 'class' ? 'classes' : 'styles';\n        // If class or style is provided for reverting - revert them all.\n        this._revert(consumableName, [...this._consumables[consumableName].keys()]);\n      } else {\n        const value = consumables.get(name);\n        if (value === false) {\n          consumables.set(name, true);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["isArray","CKEditorError","ViewConsumable","constructor","_consumables","Map","add","element","consumables","elementConsumables","is","set","has","ViewElementConsumables","get","test","undefined","consume","revert","consumablesFromElement","name","attributes","classes","styles","getAttributeKeys","attribute","push","getClassNames","className","getStyleNames","style","createFrom","from","instance","child","getChildren","CONSUMABLE_TYPES","_canConsumeName","type","_add","value","_test","_consume","_revert","item","items","alsoName","document","stylesProcessor","getRelatedStyles","consumableName","keys","toConsume"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/conversion/viewconsumable\n */\nimport { isArray } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Class used for handling consumption of view {@link module:engine/view/element~Element elements},\n * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.\n * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name\n * does not consume its attributes, classes and styles.\n * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.\n * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.\n * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.\n * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.\n *\n *\t\tviewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.\n *\t\tviewConsumable.add( textNode ); // Adds text node for consumption.\n *\t\tviewConsumable.add( docFragment ); // Adds document fragment for consumption.\n *\t\tviewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.\n *\t\tviewConsumable.test( textNode ); // Tests if text node can be consumed.\n *\t\tviewConsumable.test( docFragment ); // Tests if document fragment can be consumed.\n *\t\tviewConsumable.consume( element, { name: true }  ); // Consume element's name.\n *\t\tviewConsumable.consume( textNode ); // Consume text node.\n *\t\tviewConsumable.consume( docFragment ); // Consume document fragment.\n *\t\tviewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.\n *\t\tviewConsumable.revert( textNode ); // Revert already consumed text node.\n *\t\tviewConsumable.revert( docFragment ); // Revert already consumed document fragment.\n */\nexport default class ViewConsumable {\n    /**\n     * Creates new ViewConsumable.\n     */\n    constructor() {\n        /**\n         * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,\n         * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.\n         * For {@link module:engine/view/text~Text text nodes} and\n         * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.\n         *\n         * @protected\n         * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}\n        */\n        this._consumables = new Map();\n    }\n    /**\n     * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n     * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.\n     *\n     *\t\tviewConsumable.add( p, { name: true } ); // Adds element's name to consume.\n     *\t\tviewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.\n     *\t\tviewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.\n     *\t\tviewConsumable.add( p, { styles: 'color' } ); // Adds element's style\n     *\t\tviewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.\n     *\t\tviewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.\n     *\t\tviewConsumable.add( textNode ); // Adds text node to consume.\n     *\t\tviewConsumable.add( docFragment ); // Adds document fragment to consume.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n     * attribute is provided - it should be handled separately by providing actual style/class.\n     *\n     *\t\tviewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.\n     *\t\tviewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n     * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n     * @param {Boolean} consumables.name If set to true element's name will be included.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n     */\n    add(element, consumables) {\n        let elementConsumables;\n        // For text nodes and document fragments just mark them as consumable.\n        if (element.is('$text') || element.is('documentFragment')) {\n            this._consumables.set(element, true);\n            return;\n        }\n        // For elements create new ViewElementConsumables or update already existing one.\n        if (!this._consumables.has(element)) {\n            elementConsumables = new ViewElementConsumables(element);\n            this._consumables.set(element, elementConsumables);\n        }\n        else {\n            elementConsumables = this._consumables.get(element);\n        }\n        elementConsumables.add(consumables);\n    }\n    /**\n     * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n     * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.\n     * It returns `true` when all items included in method's call can be consumed. Returns `false` when\n     * first already consumed item is found and `null` when first non-consumable item is found.\n     *\n     *\t\tviewConsumable.test( p, { name: true } ); // Tests element's name.\n     *\t\tviewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.\n     *\t\tviewConsumable.test( p, { classes: 'foobar' } ); // Tests class.\n     *\t\tviewConsumable.test( p, { styles: 'color' } ); // Tests style.\n     *\t\tviewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.\n     *\t\tviewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.\n     *\t\tviewConsumable.test( textNode ); // Tests text node.\n     *\t\tviewConsumable.test( docFragment ); // Tests document fragment.\n     *\n     * Testing classes and styles as attribute will test if all added classes/styles can be consumed.\n     *\n     *\t\tviewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.\n     *\t\tviewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n     * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n     * @param {Boolean} consumables.name If set to true element's name will be included.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n     * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`\n     * when first already consumed item is found and `null` when first non-consumable item is found.\n     */\n    test(element, consumables) {\n        const elementConsumables = this._consumables.get(element);\n        if (elementConsumables === undefined) {\n            return null;\n        }\n        // For text nodes and document fragments return stored boolean value.\n        if (element.is('$text') || element.is('documentFragment')) {\n            return elementConsumables;\n        }\n        // For elements test consumables object.\n        return elementConsumables.test(consumables);\n    }\n    /**\n     * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n     * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n     * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.\n     *\n     *\t\tviewConsumable.consume( p, { name: true } ); // Consumes element's name.\n     *\t\tviewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.\n     *\t\tviewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.\n     *\t\tviewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.\n     *\t\tviewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.\n     *\t\tviewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.\n     *\t\tviewConsumable.consume( textNode ); // Consumes text node.\n     *\t\tviewConsumable.consume( docFragment ); // Consumes document fragment.\n     *\n     * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.\n     *\n     *\t\tviewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.\n     *\t\tviewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n     * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n     * @param {Boolean} consumables.name If set to true element's name will be included.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n     * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,\n     * otherwise returns `false`.\n     */\n    consume(element, consumables) {\n        if (this.test(element, consumables)) {\n            if (element.is('$text') || element.is('documentFragment')) {\n                // For text nodes and document fragments set value to false.\n                this._consumables.set(element, false);\n            }\n            else {\n                // For elements - consume consumables object.\n                this._consumables.get(element).consume(consumables);\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n     * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.\n     * Method does not revert items that were never previously added for consumption, even if they are included in\n     * method's call.\n     *\n     *\t\tviewConsumable.revert( p, { name: true } ); // Reverts element's name.\n     *\t\tviewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.\n     *\t\tviewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.\n     *\t\tviewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.\n     *\t\tviewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.\n     *\t\tviewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.\n     *\t\tviewConsumable.revert( textNode ); // Reverts text node.\n     *\t\tviewConsumable.revert( docFragment ); // Reverts document fragment.\n     *\n     * Reverting classes and styles as attribute will revert all classes/styles that were previously added for\n     * consumption.\n     *\n     *\t\tviewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.\n     *\t\tviewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n     * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n     * @param {Boolean} consumables.name If set to true element's name will be included.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n     */\n    revert(element, consumables) {\n        const elementConsumables = this._consumables.get(element);\n        if (elementConsumables !== undefined) {\n            if (element.is('$text') || element.is('documentFragment')) {\n                // For text nodes and document fragments - set consumable to true.\n                this._consumables.set(element, true);\n            }\n            else {\n                // For elements - revert items from consumables object.\n                elementConsumables.revert(consumables);\n            }\n        }\n    }\n    /**\n     * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include\n     * element's name and all its attributes, classes and styles.\n     *\n     * @static\n     * @param {module:engine/view/element~Element} element\n     * @returns {Object} consumables\n     */\n    static consumablesFromElement(element) {\n        const consumables = {\n            element,\n            name: true,\n            attributes: [],\n            classes: [],\n            styles: []\n        };\n        const attributes = element.getAttributeKeys();\n        for (const attribute of attributes) {\n            // Skip classes and styles - will be added separately.\n            if (attribute == 'style' || attribute == 'class') {\n                continue;\n            }\n            consumables.attributes.push(attribute);\n        }\n        const classes = element.getClassNames();\n        for (const className of classes) {\n            consumables.classes.push(className);\n        }\n        const styles = element.getStyleNames();\n        for (const style of styles) {\n            consumables.styles.push(style);\n        }\n        return consumables;\n    }\n    /**\n     * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from\n     * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n     * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.\n     *\n     * @static\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n     * from which `ViewConsumable` will be created.\n     * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used\n     * to add all consumables. It will be returned instead of a new instance.\n     */\n    static createFrom(from, instance) {\n        if (!instance) {\n            instance = new ViewConsumable();\n        }\n        if (from.is('$text')) {\n            instance.add(from);\n            return instance;\n        }\n        // Add `from` itself, if it is an element.\n        if (from.is('element')) {\n            instance.add(from, ViewConsumable.consumablesFromElement(from));\n        }\n        if (from.is('documentFragment')) {\n            instance.add(from);\n        }\n        for (const child of from.getChildren()) {\n            instance = ViewConsumable.createFrom(child, instance);\n        }\n        return instance;\n    }\n}\nconst CONSUMABLE_TYPES = ['attributes', 'classes', 'styles'];\n/**\n * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.\n * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.\n *\n * @private\n */\nclass ViewElementConsumables {\n    /**\n     * Creates ViewElementConsumables instance.\n     *\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n     * from which `ViewElementConsumables` is being created.\n     */\n    constructor(from) {\n        /**\n         * @readonly\n         * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n         */\n        this.element = from;\n        /**\n         * Flag indicating if name of the element can be consumed.\n         *\n         * @private\n         * @member {Boolean}\n         */\n        this._canConsumeName = null;\n        /**\n         * Contains maps of element's consumables: attributes, classes and styles.\n         *\n         * @private\n         * @member {Object}\n         */\n        this._consumables = {\n            attributes: new Map(),\n            styles: new Map(),\n            classes: new Map()\n        };\n    }\n    /**\n     * Adds consumable parts of the {@link module:engine/view/element~Element view element}.\n     * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and\n     * styles still could be consumed):\n     *\n     *\t\tconsumables.add( { name: true } );\n     *\n     * Attributes classes and styles:\n     *\n     *\t\tconsumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );\n     *\t\tconsumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n     * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.\n     *\n     * @param {Object} consumables Object describing which parts of the element can be consumed.\n     * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.\n     */\n    add(consumables) {\n        if (consumables.name) {\n            this._canConsumeName = true;\n        }\n        for (const type of CONSUMABLE_TYPES) {\n            if (type in consumables) {\n                this._add(type, consumables[type]);\n            }\n        }\n    }\n    /**\n     * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.\n     *\n     * Element's name can be tested:\n     *\n     *\t\tconsumables.test( { name: true } );\n     *\n     * Attributes classes and styles:\n     *\n     *\t\tconsumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );\n     *\t\tconsumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n     *\n     * @param {Object} consumables Object describing which parts of the element should be tested.\n     * @param {Boolean} consumables.name If set to `true` element's name will be tested.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.\n     * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items\n     * was never marked for consumption and `false` when even one of the items was already consumed.\n     */\n    test(consumables) {\n        // Check if name can be consumed.\n        if (consumables.name && !this._canConsumeName) {\n            return this._canConsumeName;\n        }\n        for (const type of CONSUMABLE_TYPES) {\n            if (type in consumables) {\n                const value = this._test(type, consumables[type]);\n                if (value !== true) {\n                    return value;\n                }\n            }\n        }\n        // Return true only if all can be consumed.\n        return true;\n    }\n    /**\n     * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item\n     * is already consumed - it consumes all consumable items provided.\n     * Element's name can be consumed:\n     *\n     *\t\tconsumables.consume( { name: true } );\n     *\n     * Attributes classes and styles:\n     *\n     *\t\tconsumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );\n     *\t\tconsumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n     *\n     * @param {Object} consumables Object describing which parts of the element should be consumed.\n     * @param {Boolean} consumables.name If set to `true` element's name will be consumed.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.\n     */\n    consume(consumables) {\n        if (consumables.name) {\n            this._canConsumeName = false;\n        }\n        for (const type of CONSUMABLE_TYPES) {\n            if (type in consumables) {\n                this._consume(type, consumables[type]);\n            }\n        }\n    }\n    /**\n     * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.\n     * Element's name can be reverted:\n     *\n     *\t\tconsumables.revert( { name: true } );\n     *\n     * Attributes classes and styles:\n     *\n     *\t\tconsumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );\n     *\t\tconsumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n     *\n     * @param {Object} consumables Object describing which parts of the element should be reverted.\n     * @param {Boolean} consumables.name If set to `true` element's name will be reverted.\n     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.\n     * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.\n     * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.\n     */\n    revert(consumables) {\n        if (consumables.name) {\n            this._canConsumeName = true;\n        }\n        for (const type of CONSUMABLE_TYPES) {\n            if (type in consumables) {\n                this._revert(type, consumables[type]);\n            }\n        }\n    }\n    /**\n     * Helper method that adds consumables of a given type: attribute, class or style.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n     * type is provided - it should be handled separately by providing actual style/class type.\n     *\n     * @private\n     * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n     * @param {String|Array.<String>} item Consumable item or array of items.\n     */\n    _add(type, item) {\n        const items = isArray(item) ? item : [item];\n        const consumables = this._consumables[type];\n        for (const name of items) {\n            if (type === 'attributes' && (name === 'class' || name === 'style')) {\n                /**\n                 * Class and style attributes should be handled separately in\n                 * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.\n                 *\n                 * What you have done is trying to use:\n                 *\n                 *\t\tconsumables.add( { attributes: [ 'class', 'style' ] } );\n                 *\n                 * While each class and style should be registered separately:\n                 *\n                 *\t\tconsumables.add( { classes: 'some-class', styles: 'font-weight' } );\n                 *\n                 * @error viewconsumable-invalid-attribute\n                 */\n                throw new CKEditorError('viewconsumable-invalid-attribute', this);\n            }\n            consumables.set(name, true);\n            if (type === 'styles') {\n                for (const alsoName of this.element.document.stylesProcessor.getRelatedStyles(name)) {\n                    consumables.set(alsoName, true);\n                }\n            }\n        }\n    }\n    /**\n     * Helper method that tests consumables of a given type: attribute, class or style.\n     *\n     * @private\n     * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n     * @param {String|Array.<String>} item Consumable item or array of items.\n     * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be\n     * consumed and `false` when one of the items is already consumed.\n     */\n    _test(type, item) {\n        const items = isArray(item) ? item : [item];\n        const consumables = this._consumables[type];\n        for (const name of items) {\n            if (type === 'attributes' && (name === 'class' || name === 'style')) {\n                const consumableName = name == 'class' ? 'classes' : 'styles';\n                // Check all classes/styles if class/style attribute is tested.\n                const value = this._test(consumableName, [...this._consumables[consumableName].keys()]);\n                if (value !== true) {\n                    return value;\n                }\n            }\n            else {\n                const value = consumables.get(name);\n                // Return null if attribute is not found.\n                if (value === undefined) {\n                    return null;\n                }\n                if (!value) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Helper method that consumes items of a given type: attribute, class or style.\n     *\n     * @private\n     * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n     * @param {String|Array.<String>} item Consumable item or array of items.\n     */\n    _consume(type, item) {\n        const items = isArray(item) ? item : [item];\n        const consumables = this._consumables[type];\n        for (const name of items) {\n            if (type === 'attributes' && (name === 'class' || name === 'style')) {\n                const consumableName = name == 'class' ? 'classes' : 'styles';\n                // If class or style is provided for consumption - consume them all.\n                this._consume(consumableName, [...this._consumables[consumableName].keys()]);\n            }\n            else {\n                consumables.set(name, false);\n                if (type == 'styles') {\n                    for (const toConsume of this.element.document.stylesProcessor.getRelatedStyles(name)) {\n                        consumables.set(toConsume, false);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Helper method that reverts items of a given type: attribute, class or style.\n     *\n     * @private\n     * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.\n     * @param {String|Array.<String>} item Consumable item or array of items.\n     */\n    _revert(type, item) {\n        const items = isArray(item) ? item : [item];\n        const consumables = this._consumables[type];\n        for (const name of items) {\n            if (type === 'attributes' && (name === 'class' || name === 'style')) {\n                const consumableName = name == 'class' ? 'classes' : 'styles';\n                // If class or style is provided for reverting - revert them all.\n                this._revert(consumableName, [...this._consumables[consumableName].keys()]);\n            }\n            else {\n                const value = consumables.get(name);\n                if (value === false) {\n                    consumables.set(name, true);\n                }\n            }\n        }\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,WAAW;AACnC,OAAOC,aAAa,MAAM,6CAA6C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,cAAc,CAAC;EAChC;AACJ;AACA;EACIC,WAAW,GAAG;IACV;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,IAAIC,GAAG,EAAE;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,GAAG,CAACC,OAAO,EAAEC,WAAW,EAAE;IACtB,IAAIC,kBAAkB;IACtB;IACA,IAAIF,OAAO,CAACG,EAAE,CAAC,OAAO,CAAC,IAAIH,OAAO,CAACG,EAAE,CAAC,kBAAkB,CAAC,EAAE;MACvD,IAAI,CAACN,YAAY,CAACO,GAAG,CAACJ,OAAO,EAAE,IAAI,CAAC;MACpC;IACJ;IACA;IACA,IAAI,CAAC,IAAI,CAACH,YAAY,CAACQ,GAAG,CAACL,OAAO,CAAC,EAAE;MACjCE,kBAAkB,GAAG,IAAII,sBAAsB,CAACN,OAAO,CAAC;MACxD,IAAI,CAACH,YAAY,CAACO,GAAG,CAACJ,OAAO,EAAEE,kBAAkB,CAAC;IACtD,CAAC,MACI;MACDA,kBAAkB,GAAG,IAAI,CAACL,YAAY,CAACU,GAAG,CAACP,OAAO,CAAC;IACvD;IACAE,kBAAkB,CAACH,GAAG,CAACE,WAAW,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,IAAI,CAACR,OAAO,EAAEC,WAAW,EAAE;IACv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"},"metadata":{},"sourceType":"module"}