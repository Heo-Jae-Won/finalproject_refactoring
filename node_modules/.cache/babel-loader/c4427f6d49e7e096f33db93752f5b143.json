{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widget\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport WidgetTypeAround from './widgettypearound/widgettypearound';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { getLocalizedArrowKeyCodeDirection } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport verticalNavigationHandler from './verticalnavigation';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils';\nimport '../theme/widget.css';\n\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Widget extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'Widget';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [WidgetTypeAround, Delete];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  init() {\n    var _this = this;\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document;\n\n    /**\n     * Holds previously selected widgets.\n     *\n     * @private\n     * @type {Set.<module:engine/view/element~Element>}\n     */\n    this._previouslySelected = new Set();\n\n    // Model to view selection converter.\n    // Converts selection placed over widget element to fake selection.\n    //\n    // By default, the selection is downcasted by the engine to surround the attribute element, even though its only\n    // child is an inline widget. A similar thing also happens when a collapsed marker is rendered as a UI element\n    // next to an inline widget: the view selection contains both the widget and the marker.\n    //\n    // This prevents creating a correct fake selection when this inline widget is selected. Normalize the selection\n    // in these cases based on the model:\n    //\n    //\t\t[<attributeElement><inlineWidget /></attributeElement>] -> <attributeElement>[<inlineWidget />]</attributeElement>\n    //\t\t[<uiElement></uiElement><inlineWidget />] -> <uiElement></uiElement>[<inlineWidget />]\n    //\n    // Thanks to this:\n    //\n    // * fake selection can be set correctly,\n    // * any logic depending on (View)Selection#getSelectedElement() also works OK.\n    //\n    // See https://github.com/ckeditor/ckeditor5/issues/9524.\n    this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n      const viewWriter = conversionApi.writer;\n      const modelSelection = data.selection;\n\n      // The collapsed selection can't contain any widget.\n      if (modelSelection.isCollapsed) {\n        return;\n      }\n      const selectedModelElement = modelSelection.getSelectedElement();\n      if (!selectedModelElement) {\n        return;\n      }\n      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n      if (!isWidget(selectedViewElement)) {\n        return;\n      }\n      if (!conversionApi.consumable.consume(modelSelection, 'selection')) {\n        return;\n      }\n      viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {\n        fake: true,\n        label: getLabel(selectedViewElement)\n      });\n    });\n\n    // Mark all widgets inside the selection with the css class.\n    // This handler is registered at the 'low' priority so it's triggered after the real selection conversion.\n    this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n      // Remove selected class from previously selected widgets.\n      this._clearPreviouslySelectedWidgets(conversionApi.writer);\n      const viewWriter = conversionApi.writer;\n      const viewSelection = viewWriter.document.selection;\n      let lastMarked = null;\n      for (const range of viewSelection.getRanges()) {\n        // Note: There could be multiple selected widgets in a range but no fake selection.\n        // All of them must be marked as selected, for instance [<widget></widget><widget></widget>]\n        for (const value of range) {\n          const node = value.item;\n          // Do not mark nested widgets in selected one. See: #4594\n          if (isWidget(node) && !isChild(node, lastMarked)) {\n            viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);\n            this._previouslySelected.add(node);\n            lastMarked = node;\n          }\n        }\n      }\n    }, {\n      priority: 'low'\n    });\n\n    // If mouse down is pressed on widget - create selection over whole widget.\n    view.addObserver(MouseObserver);\n    this.listenTo(viewDocument, 'mousedown', function () {\n      return _this._onMousedown(...arguments);\n    });\n\n    // There are two keydown listeners working on different priorities. This allows other\n    // features such as WidgetTypeAround or TableKeyboard to attach their listeners in between\n    // and customize the behavior even further in different content/selection scenarios.\n    //\n    // * The first listener handles changing the selection on arrow key press\n    // if the widget is selected or if the selection is next to a widget and the widget\n    // should become selected upon the arrow key press.\n    //\n    // * The second (late) listener makes sure the default browser action on arrow key press is\n    // prevented when a widget is selected. This prevents the selection from being moved\n    // from a fake selection container.\n    this.listenTo(viewDocument, 'arrowKey', function () {\n      _this._handleSelectionChangeOnArrowKeyPress(...arguments);\n    }, {\n      context: [isWidget, '$text']\n    });\n    this.listenTo(viewDocument, 'arrowKey', function () {\n      _this._preventDefaultOnArrowKeyPress(...arguments);\n    }, {\n      context: '$root'\n    });\n    this.listenTo(viewDocument, 'arrowKey', verticalNavigationHandler(this.editor.editing), {\n      context: '$text'\n    });\n\n    // Handle custom delete behaviour.\n    this.listenTo(viewDocument, 'delete', (evt, data) => {\n      if (this._handleDelete(data.direction == 'forward')) {\n        data.preventDefault();\n        evt.stop();\n      }\n    }, {\n      context: '$root'\n    });\n  }\n\n  /**\n   * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n  _onMousedown(eventInfo, domEventData) {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document;\n    let element = domEventData.target;\n\n    // Do nothing for single or double click inside nested editable.\n    if (isInsideNestedEditable(element)) {\n      // But at least triple click inside nested editable causes broken selection in Safari.\n      // For such event, we select the entire nested editable element.\n      // See: https://github.com/ckeditor/ckeditor5/issues/1463.\n      if ((env.isSafari || env.isGecko) && domEventData.domEvent.detail >= 3) {\n        const mapper = editor.editing.mapper;\n        const viewElement = element.is('attributeElement') ? element.findAncestor(element => !element.is('attributeElement')) : element;\n        const modelElement = mapper.toModelElement(viewElement);\n        domEventData.preventDefault();\n        this.editor.model.change(writer => {\n          writer.setSelection(modelElement, 'in');\n        });\n      }\n      return;\n    }\n\n    // If target is not a widget element - check if one of the ancestors is.\n    if (!isWidget(element)) {\n      element = element.findAncestor(isWidget);\n      if (!element) {\n        return;\n      }\n    }\n\n    // On Android selection would jump to the first table cell, on other devices\n    // we can't block it (and don't need to) because of drag and drop support.\n    if (env.isAndroid) {\n      domEventData.preventDefault();\n    }\n\n    // Focus editor if is not focused already.\n    if (!viewDocument.isFocused) {\n      view.focus();\n    }\n\n    // Create model selection over widget.\n    const modelElement = editor.editing.mapper.toModelElement(element);\n    this._setSelectionOverElement(modelElement);\n  }\n\n  /**\n   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes\n   * the model selection when:\n   *\n   * * arrow key is pressed when the widget is selected,\n   * * the selection is next to a widget and the widget should become selected upon the arrow key press.\n   *\n   * See {@link #_preventDefaultOnArrowKeyPress}.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n  _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {\n    const keyCode = domEventData.keyCode;\n    const model = this.editor.model;\n    const schema = model.schema;\n    const modelSelection = model.document.selection;\n    const objectElement = modelSelection.getSelectedElement();\n    const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);\n    const isForward = direction == 'down' || direction == 'right';\n    const isVerticalNavigation = direction == 'up' || direction == 'down';\n\n    // If object element is selected.\n    if (objectElement && schema.isObject(objectElement)) {\n      const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n      const newRange = schema.getNearestSelectionRange(position, isForward ? 'forward' : 'backward');\n      if (newRange) {\n        model.change(writer => {\n          writer.setSelection(newRange);\n        });\n        domEventData.preventDefault();\n        eventInfo.stop();\n      }\n      return;\n    }\n\n    // Handle collapsing of the selection when there is any widget on the edge of selection.\n    // This is needed because browsers have problems with collapsing such selection.\n    if (!modelSelection.isCollapsed && !domEventData.shiftKey) {\n      const firstPosition = modelSelection.getFirstPosition();\n      const lastPosition = modelSelection.getLastPosition();\n      const firstSelectedNode = firstPosition.nodeAfter;\n      const lastSelectedNode = lastPosition.nodeBefore;\n      if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {\n        model.change(writer => {\n          writer.setSelection(isForward ? lastPosition : firstPosition);\n        });\n        domEventData.preventDefault();\n        eventInfo.stop();\n      }\n      return;\n    }\n\n    // Return if not collapsed.\n    if (!modelSelection.isCollapsed) {\n      return;\n    }\n\n    // If selection is next to object element.\n\n    const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);\n    if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {\n      // Do not select an inline widget while handling up/down arrow.\n      if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {\n        return;\n      }\n      this._setSelectionOverElement(objectElementNextToSelection);\n      domEventData.preventDefault();\n      eventInfo.stop();\n    }\n  }\n\n  /**\n   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents\n   * the default browser behavior to make sure the fake selection is not being moved from a fake selection\n   * container.\n   *\n   * See {@link #_handleSelectionChangeOnArrowKeyPress}.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n  _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {\n    const model = this.editor.model;\n    const schema = model.schema;\n    const objectElement = model.document.selection.getSelectedElement();\n\n    // If object element is selected.\n    if (objectElement && schema.isObject(objectElement)) {\n      domEventData.preventDefault();\n      eventInfo.stop();\n    }\n  }\n\n  /**\n   * Handles delete keys: backspace and delete.\n   *\n   * @private\n   * @param {Boolean} isForward Set to true if delete was performed in forward direction.\n   * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n   */\n  _handleDelete(isForward) {\n    // Do nothing when the read only mode is enabled.\n    if (this.editor.isReadOnly) {\n      return;\n    }\n    const modelDocument = this.editor.model.document;\n    const modelSelection = modelDocument.selection;\n\n    // Do nothing on non-collapsed selection.\n    if (!modelSelection.isCollapsed) {\n      return;\n    }\n    const objectElement = this._getObjectElementNextToSelection(isForward);\n    if (objectElement) {\n      this.editor.model.change(writer => {\n        let previousNode = modelSelection.anchor.parent;\n\n        // Remove previous element if empty.\n        while (previousNode.isEmpty) {\n          const nodeToRemove = previousNode;\n          previousNode = nodeToRemove.parent;\n          writer.remove(nodeToRemove);\n        }\n        this._setSelectionOverElement(objectElement);\n      });\n      return true;\n    }\n  }\n\n  /**\n   * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} element\n   */\n  _setSelectionOverElement(element) {\n    this.editor.model.change(writer => {\n      writer.setSelection(writer.createRangeOn(element));\n    });\n  }\n\n  /**\n   * Checks if {@link module:engine/model/element~Element element} placed next to the current\n   * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n   * {@link module:engine/model/schema~Schema schema} as `object`.\n   *\n   * @protected\n   * @param {Boolean} forward Direction of checking.\n   * @returns {module:engine/model/element~Element|null}\n   */\n  _getObjectElementNextToSelection(forward) {\n    const model = this.editor.model;\n    const schema = model.schema;\n    const modelSelection = model.document.selection;\n\n    // Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n    // to its current state after undo.\n    const probe = model.createSelection(modelSelection);\n    model.modifySelection(probe, {\n      direction: forward ? 'forward' : 'backward'\n    });\n\n    // The selection didn't change so there is nothing there.\n    if (probe.isEqual(modelSelection)) {\n      return null;\n    }\n    const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n    if (!!objectElement && schema.isObject(objectElement)) {\n      return objectElement;\n    }\n    return null;\n  }\n\n  /**\n   * Removes CSS class from previously selected widgets.\n   *\n   * @private\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n   */\n  _clearPreviouslySelectedWidgets(writer) {\n    for (const widget of this._previouslySelected) {\n      writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);\n    }\n    this._previouslySelected.clear();\n  }\n}\n\n// Returns `true` when element is a nested editable or is placed inside one.\n//\n// @param {module:engine/view/element~Element}\n// @returns {Boolean}\nfunction isInsideNestedEditable(element) {\n  while (element) {\n    if (element.is('editableElement') && !element.is('rootElement')) {\n      return true;\n    }\n\n    // Click on nested widget should select it.\n    if (isWidget(element)) {\n      return false;\n    }\n    element = element.parent;\n  }\n  return false;\n}\n\n// Checks whether the specified `element` is a child of the `parent` element.\n//\n// @param {module:engine/view/element~Element} element An element to check.\n// @param {module:engine/view/element~Element|null} parent A parent for the element.\n// @returns {Boolean}\nfunction isChild(element, parent) {\n  if (!parent) {\n    return false;\n  }\n  return Array.from(element.getAncestors()).includes(parent);\n}","map":{"version":3,"names":["Plugin","MouseObserver","WidgetTypeAround","Delete","env","getLocalizedArrowKeyCodeDirection","verticalNavigationHandler","getLabel","isWidget","WIDGET_SELECTED_CLASS_NAME","Widget","pluginName","requires","init","editor","view","editing","viewDocument","document","_previouslySelected","Set","downcastDispatcher","on","evt","data","conversionApi","viewWriter","writer","modelSelection","selection","isCollapsed","selectedModelElement","getSelectedElement","selectedViewElement","mapper","toViewElement","consumable","consume","setSelection","createRangeOn","fake","label","_clearPreviouslySelectedWidgets","viewSelection","lastMarked","range","getRanges","value","node","item","isChild","addClass","add","priority","addObserver","listenTo","_onMousedown","_handleSelectionChangeOnArrowKeyPress","context","_preventDefaultOnArrowKeyPress","_handleDelete","direction","preventDefault","stop","eventInfo","domEventData","element","target","isInsideNestedEditable","isSafari","isGecko","domEvent","detail","viewElement","is","findAncestor","modelElement","toModelElement","model","change","isAndroid","isFocused","focus","_setSelectionOverElement","keyCode","schema","objectElement","locale","contentLanguageDirection","isForward","isVerticalNavigation","isObject","position","getLastPosition","getFirstPosition","newRange","getNearestSelectionRange","shiftKey","firstPosition","lastPosition","firstSelectedNode","nodeAfter","lastSelectedNode","nodeBefore","objectElementNextToSelection","_getObjectElementNextToSelection","isInline","isReadOnly","modelDocument","previousNode","anchor","parent","isEmpty","nodeToRemove","remove","forward","probe","createSelection","modifySelection","isEqual","widget","removeClass","clear","Array","from","getAncestors","includes"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-widget/src/widget.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widget\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport WidgetTypeAround from './widgettypearound/widgettypearound';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { getLocalizedArrowKeyCodeDirection } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\nimport verticalNavigationHandler from './verticalnavigation';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils';\n\nimport '../theme/widget.css';\n\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Widget extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Widget';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ WidgetTypeAround, Delete ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t/**\n\t\t * Holds previously selected widgets.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<module:engine/view/element~Element>}\n\t\t */\n\t\tthis._previouslySelected = new Set();\n\n\t\t// Model to view selection converter.\n\t\t// Converts selection placed over widget element to fake selection.\n\t\t//\n\t\t// By default, the selection is downcasted by the engine to surround the attribute element, even though its only\n\t\t// child is an inline widget. A similar thing also happens when a collapsed marker is rendered as a UI element\n\t\t// next to an inline widget: the view selection contains both the widget and the marker.\n\t\t//\n\t\t// This prevents creating a correct fake selection when this inline widget is selected. Normalize the selection\n\t\t// in these cases based on the model:\n\t\t//\n\t\t//\t\t[<attributeElement><inlineWidget /></attributeElement>] -> <attributeElement>[<inlineWidget />]</attributeElement>\n\t\t//\t\t[<uiElement></uiElement><inlineWidget />] -> <uiElement></uiElement>[<inlineWidget />]\n\t\t//\n\t\t// Thanks to this:\n\t\t//\n\t\t// * fake selection can be set correctly,\n\t\t// * any logic depending on (View)Selection#getSelectedElement() also works OK.\n\t\t//\n\t\t// See https://github.com/ckeditor/ckeditor5/issues/9524.\n\t\tthis.editor.editing.downcastDispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\tconst viewWriter = conversionApi.writer;\n\t\t\tconst modelSelection = data.selection;\n\n\t\t\t// The collapsed selection can't contain any widget.\n\t\t\tif ( modelSelection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\t\tif ( !selectedModelElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedViewElement = editor.editing.mapper.toViewElement( selectedModelElement );\n\n\t\t\tif ( !isWidget( selectedViewElement ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !conversionApi.consumable.consume( modelSelection, 'selection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tviewWriter.setSelection( viewWriter.createRangeOn( selectedViewElement ), {\n\t\t\t\tfake: true,\n\t\t\t\tlabel: getLabel( selectedViewElement )\n\t\t\t} );\n\t\t} );\n\n\t\t// Mark all widgets inside the selection with the css class.\n\t\t// This handler is registered at the 'low' priority so it's triggered after the real selection conversion.\n\t\tthis.editor.editing.downcastDispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\t// Remove selected class from previously selected widgets.\n\t\t\tthis._clearPreviouslySelectedWidgets( conversionApi.writer );\n\n\t\t\tconst viewWriter = conversionApi.writer;\n\t\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\t\tlet lastMarked = null;\n\n\t\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t\t// Note: There could be multiple selected widgets in a range but no fake selection.\n\t\t\t\t// All of them must be marked as selected, for instance [<widget></widget><widget></widget>]\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tconst node = value.item;\n\t\t\t\t\t// Do not mark nested widgets in selected one. See: #4594\n\t\t\t\t\tif ( isWidget( node ) && !isChild( node, lastMarked ) ) {\n\t\t\t\t\t\tviewWriter.addClass( WIDGET_SELECTED_CLASS_NAME, node );\n\t\t\t\t\t\tthis._previouslySelected.add( node );\n\t\t\t\t\t\tlastMarked = node;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// If mouse down is pressed on widget - create selection over whole widget.\n\t\tview.addObserver( MouseObserver );\n\t\tthis.listenTo( viewDocument, 'mousedown', ( ...args ) => this._onMousedown( ...args ) );\n\n\t\t// There are two keydown listeners working on different priorities. This allows other\n\t\t// features such as WidgetTypeAround or TableKeyboard to attach their listeners in between\n\t\t// and customize the behavior even further in different content/selection scenarios.\n\t\t//\n\t\t// * The first listener handles changing the selection on arrow key press\n\t\t// if the widget is selected or if the selection is next to a widget and the widget\n\t\t// should become selected upon the arrow key press.\n\t\t//\n\t\t// * The second (late) listener makes sure the default browser action on arrow key press is\n\t\t// prevented when a widget is selected. This prevents the selection from being moved\n\t\t// from a fake selection container.\n\t\tthis.listenTo( viewDocument, 'arrowKey', ( ...args ) => {\n\t\t\tthis._handleSelectionChangeOnArrowKeyPress( ...args );\n\t\t}, { context: [ isWidget, '$text' ] } );\n\n\t\tthis.listenTo( viewDocument, 'arrowKey', ( ...args ) => {\n\t\t\tthis._preventDefaultOnArrowKeyPress( ...args );\n\t\t}, { context: '$root' } );\n\n\t\tthis.listenTo( viewDocument, 'arrowKey', verticalNavigationHandler( this.editor.editing ), { context: '$text' } );\n\n\t\t// Handle custom delete behaviour.\n\t\tthis.listenTo( viewDocument, 'delete', ( evt, data ) => {\n\t\t\tif ( this._handleDelete( data.direction == 'forward' ) ) {\n\t\t\t\tdata.preventDefault();\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { context: '$root' } );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_onMousedown( eventInfo, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\t\tlet element = domEventData.target;\n\n\t\t// Do nothing for single or double click inside nested editable.\n\t\tif ( isInsideNestedEditable( element ) ) {\n\t\t\t// But at least triple click inside nested editable causes broken selection in Safari.\n\t\t\t// For such event, we select the entire nested editable element.\n\t\t\t// See: https://github.com/ckeditor/ckeditor5/issues/1463.\n\t\t\tif ( ( env.isSafari || env.isGecko ) && domEventData.domEvent.detail >= 3 ) {\n\t\t\t\tconst mapper = editor.editing.mapper;\n\t\t\t\tconst viewElement = element.is( 'attributeElement' ) ?\n\t\t\t\t\telement.findAncestor( element => !element.is( 'attributeElement' ) ) : element;\n\t\t\t\tconst modelElement = mapper.toModelElement( viewElement );\n\n\t\t\t\tdomEventData.preventDefault();\n\n\t\t\t\tthis.editor.model.change( writer => {\n\t\t\t\t\twriter.setSelection( modelElement, 'in' );\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// If target is not a widget element - check if one of the ancestors is.\n\t\tif ( !isWidget( element ) ) {\n\t\t\telement = element.findAncestor( isWidget );\n\n\t\t\tif ( !element ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// On Android selection would jump to the first table cell, on other devices\n\t\t// we can't block it (and don't need to) because of drag and drop support.\n\t\tif ( env.isAndroid ) {\n\t\t\tdomEventData.preventDefault();\n\t\t}\n\n\t\t// Focus editor if is not focused already.\n\t\tif ( !viewDocument.isFocused ) {\n\t\t\tview.focus();\n\t\t}\n\n\t\t// Create model selection over widget.\n\t\tconst modelElement = editor.editing.mapper.toModelElement( element );\n\n\t\tthis._setSelectionOverElement( modelElement );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes\n\t * the model selection when:\n\t *\n\t * * arrow key is pressed when the widget is selected,\n\t * * the selection is next to a widget and the widget should become selected upon the arrow key press.\n\t *\n\t * See {@link #_preventDefaultOnArrowKeyPress}.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_handleSelectionChangeOnArrowKeyPress( eventInfo, domEventData ) {\n\t\tconst keyCode = domEventData.keyCode;\n\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst objectElement = modelSelection.getSelectedElement();\n\t\tconst direction = getLocalizedArrowKeyCodeDirection( keyCode, this.editor.locale.contentLanguageDirection );\n\t\tconst isForward = direction == 'down' || direction == 'right';\n\t\tconst isVerticalNavigation = direction == 'up' || direction == 'down';\n\n\t\t// If object element is selected.\n\t\tif ( objectElement && schema.isObject( objectElement ) ) {\n\t\t\tconst position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n\t\t\tconst newRange = schema.getNearestSelectionRange( position, isForward ? 'forward' : 'backward' );\n\n\t\t\tif ( newRange ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelection( newRange );\n\t\t\t\t} );\n\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t\teventInfo.stop();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Handle collapsing of the selection when there is any widget on the edge of selection.\n\t\t// This is needed because browsers have problems with collapsing such selection.\n\t\tif ( !modelSelection.isCollapsed && !domEventData.shiftKey ) {\n\t\t\tconst firstPosition = modelSelection.getFirstPosition();\n\t\t\tconst lastPosition = modelSelection.getLastPosition();\n\n\t\t\tconst firstSelectedNode = firstPosition.nodeAfter;\n\t\t\tconst lastSelectedNode = lastPosition.nodeBefore;\n\n\t\t\tif ( firstSelectedNode && schema.isObject( firstSelectedNode ) || lastSelectedNode && schema.isObject( lastSelectedNode ) ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelection( isForward ? lastPosition : firstPosition );\n\t\t\t\t} );\n\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t\teventInfo.stop();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Return if not collapsed.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If selection is next to object element.\n\n\t\tconst objectElementNextToSelection = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( objectElementNextToSelection && schema.isObject( objectElementNextToSelection ) ) {\n\t\t\t// Do not select an inline widget while handling up/down arrow.\n\t\t\tif ( schema.isInline( objectElementNextToSelection ) && isVerticalNavigation ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._setSelectionOverElement( objectElementNextToSelection );\n\n\t\t\tdomEventData.preventDefault();\n\t\t\teventInfo.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents\n\t * the default browser behavior to make sure the fake selection is not being moved from a fake selection\n\t * container.\n\t *\n\t * See {@link #_handleSelectionChangeOnArrowKeyPress}.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_preventDefaultOnArrowKeyPress( eventInfo, domEventData ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst objectElement = model.document.selection.getSelectedElement();\n\n\t\t// If object element is selected.\n\t\tif ( objectElement && schema.isObject( objectElement ) ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\teventInfo.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles delete keys: backspace and delete.\n\t *\n\t * @private\n\t * @param {Boolean} isForward Set to true if delete was performed in forward direction.\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleDelete( isForward ) {\n\t\t// Do nothing when the read only mode is enabled.\n\t\tif ( this.editor.isReadOnly ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelDocument = this.editor.model.document;\n\t\tconst modelSelection = modelDocument.selection;\n\n\t\t// Do nothing on non-collapsed selection.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst objectElement = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( objectElement ) {\n\t\t\tthis.editor.model.change( writer => {\n\t\t\t\tlet previousNode = modelSelection.anchor.parent;\n\n\t\t\t\t// Remove previous element if empty.\n\t\t\t\twhile ( previousNode.isEmpty ) {\n\t\t\t\t\tconst nodeToRemove = previousNode;\n\t\t\t\t\tpreviousNode = nodeToRemove.parent;\n\n\t\t\t\t\twriter.remove( nodeToRemove );\n\t\t\t\t}\n\n\t\t\t\tthis._setSelectionOverElement( objectElement );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_setSelectionOverElement( element ) {\n\t\tthis.editor.model.change( writer => {\n\t\t\twriter.setSelection( writer.createRangeOn( element ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Checks if {@link module:engine/model/element~Element element} placed next to the current\n\t * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n\t * {@link module:engine/model/schema~Schema schema} as `object`.\n\t *\n\t * @protected\n\t * @param {Boolean} forward Direction of checking.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getObjectElementNextToSelection( forward ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelSelection = model.document.selection;\n\n\t\t// Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n\t\t// to its current state after undo.\n\t\tconst probe = model.createSelection( modelSelection );\n\t\tmodel.modifySelection( probe, { direction: forward ? 'forward' : 'backward' } );\n\n\t\t// The selection didn't change so there is nothing there.\n\t\tif ( probe.isEqual( modelSelection ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n\n\t\tif ( !!objectElement && schema.isObject( objectElement ) ) {\n\t\t\treturn objectElement;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes CSS class from previously selected widgets.\n\t *\n\t * @private\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\t */\n\t_clearPreviouslySelectedWidgets( writer ) {\n\t\tfor ( const widget of this._previouslySelected ) {\n\t\t\twriter.removeClass( WIDGET_SELECTED_CLASS_NAME, widget );\n\t\t}\n\n\t\tthis._previouslySelected.clear();\n\t}\n}\n\n// Returns `true` when element is a nested editable or is placed inside one.\n//\n// @param {module:engine/view/element~Element}\n// @returns {Boolean}\nfunction isInsideNestedEditable( element ) {\n\twhile ( element ) {\n\t\tif ( element.is( 'editableElement' ) && !element.is( 'rootElement' ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Click on nested widget should select it.\n\t\tif ( isWidget( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\telement = element.parent;\n\t}\n\n\treturn false;\n}\n\n// Checks whether the specified `element` is a child of the `parent` element.\n//\n// @param {module:engine/view/element~Element} element An element to check.\n// @param {module:engine/view/element~Element|null} parent A parent for the element.\n// @returns {Boolean}\nfunction isChild( element, parent ) {\n\tif ( !parent ) {\n\t\treturn false;\n\t}\n\n\treturn Array.from( element.getAncestors() ).includes( parent );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}