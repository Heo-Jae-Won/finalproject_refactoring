{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module module:engine/view/downcastwriter\n */\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport RawElement from './rawelement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\nexport default class DowncastWriter {\n  /**\n   * @param {module:engine/view/document~Document} document The view document instance.\n   */\n  constructor(document) {\n    /**\n     * The view document instance in which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n     *\n     * @private\n     * @type {Map.<String,Set>}\n     */\n    this._cloneGroups = new Map();\n    /**\n     * The slot factory used by the `elementToStructure` downcast helper.\n     *\n     * @private\n     * @type {Function|null}\n     */\n    this._slotFactory = null;\n  }\n  /**\n   * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n   * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n   *\n   * Usage:\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets backward selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\twriter.setSelection( otherSelection );\n   *\n   * \t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\twriter.setSelection( position );\n   *\n   * \t\t// Sets collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'p' );\n   *\t\twriter.setSelection( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * \t\twriter.setSelection( paragraph, 'in' );\n   *\n   * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\twriter.setSelection( paragraph, 'on' );\n   *\n   * \t\t// Removes all ranges.\n   *\t\twriter.setSelection( null );\n   *\n   * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\twriter.setSelection( range, { backward: true } );\n   *\n   *\t\t// Sets selection as fake.\n   *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * \t\t// represented in other way, for example by applying proper CSS class.\n   *\t\twriter.setSelection( range, { fake: true } );\n   *\n   * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * \t\t// (and be  properly handled by screen readers).\n   *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n  setSelection() {\n    this.document.selection._setTo(...arguments);\n  }\n  /**\n   * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n   *\n   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n   * parameters.\n   *\n   * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n  setSelectionFocus() {\n    this.document.selection._setFocus(...arguments);\n  }\n  /**\n   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.\n   *\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into the created document fragment.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.\n   */\n  createDocumentFragment(children) {\n    return new DocumentFragment(this.document, children);\n  }\n  /**\n   * Creates a new {@link module:engine/view/text~Text text node}.\n   *\n   *\t\twriter.createText( 'foo' );\n   *\n   * @param {String} data The text's data.\n   * @returns {module:engine/view/text~Text} The created text node.\n   */\n  createText(data) {\n    return new Text(this.document, data);\n  }\n  /**\n   * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.\n   *\n   *\t\twriter.createAttributeElement( 'strong' );\n   *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n   *\n   *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n   *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n   *\n   *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n   *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Element's attributes.\n   * @param {Object} [options] Element's options.\n   * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n   * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n   * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n   */\n  createAttributeElement(name, attributes) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const attributeElement = new AttributeElement(this.document, name, attributes);\n    if (typeof options.priority === 'number') {\n      attributeElement._priority = options.priority;\n    }\n    if (options.id) {\n      attributeElement._id = options.id;\n    }\n    if (options.renderUnsafeAttributes) {\n      attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n    }\n    return attributeElement;\n  }\n  createContainerElement(name, attributes) {\n    let childrenOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let children = null;\n    if (isPlainObject(childrenOrOptions)) {\n      options = childrenOrOptions;\n    } else {\n      children = childrenOrOptions;\n    }\n    const containerElement = new ContainerElement(this.document, name, attributes, children);\n    if (options.renderUnsafeAttributes) {\n      containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n    }\n    return containerElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/editableelement~EditableElement}.\n   *\n   *\t\twriter.createEditableElement( 'div' );\n   *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n   *\n   * Note: The editable element is to be used in the editing pipeline. Usually, together with\n   * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {Object} [options] Element's options.\n   * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n   * @returns {module:engine/view/editableelement~EditableElement} Created element.\n   */\n  createEditableElement(name, attributes) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const editableElement = new EditableElement(this.document, name, attributes);\n    if (options.renderUnsafeAttributes) {\n      editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n    }\n    return editableElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.\n   *\n   *\t\twriter.createEmptyElement( 'img' );\n   *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {Object} [options] Element's options.\n   * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n   * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n   */\n  createEmptyElement(name, attributes) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const emptyElement = new EmptyElement(this.document, name, attributes);\n    if (options.renderUnsafeAttributes) {\n      emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n    }\n    return emptyElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/uielement~UIElement}.\n   *\n   *\t\twriter.createUIElement( 'span' );\n   *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n   *\n   * A custom render function can be provided as the third parameter:\n   *\n   *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n   *\t\t\tconst domElement = this.toDomElement( domDocument );\n   *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n   *\n   *\t\t\treturn domElement;\n   *\t\t} );\n   *\n   * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,\n   * they are ignored by the editor selection system.\n   *\n   * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.\n   *\n   * @param {String} name The name of the element.\n   * @param {Object} [attributes] Element attributes.\n   * @param {Function} [renderFunction] A custom render function.\n   * @returns {module:engine/view/uielement~UIElement} The created element.\n   */\n  createUIElement(name, attributes, renderFunction) {\n    const uiElement = new UIElement(this.document, name, attributes);\n    if (renderFunction) {\n      uiElement.render = renderFunction;\n    }\n    return uiElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/rawelement~RawElement}.\n   *\n   *\t\twriter.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {\n   *\t\t\tdomElement.innerHTML = '<b>This is the raw content of the raw element.</b>';\n   *\t\t} );\n   *\n   * Raw elements work as data containers (\"wrappers\", \"sandboxes\") but their children are not managed or\n   * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures\n   * in the editor content without, for instance, worrying about compatibility with other editor features.\n   * Raw elements are a perfect tool for integration with external frameworks and data sources.\n   *\n   * Unlike {@link #createUIElement UI elements}, raw elements act like \"real\" editor content (similar to\n   * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),\n   * and they are considered by the editor selection.\n   *\n   * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}\n   * instead.\n   *\n   * @param {String} name The name of the element.\n   * @param {Object} [attributes] Element attributes.\n   * @param {Function} [renderFunction] A custom render function.\n   * @param {Object} [options] Element's options.\n   * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n   * @returns {module:engine/view/rawelement~RawElement} The created element.\n   */\n  createRawElement(name, attributes, renderFunction) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const rawElement = new RawElement(this.document, name, attributes);\n    if (renderFunction) {\n      rawElement.render = renderFunction;\n    }\n    if (options.renderUnsafeAttributes) {\n      rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n    }\n    return rawElement;\n  }\n  /**\n   * Adds or overwrites the element's attribute with a specified key and value.\n   *\n   *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n   *\n   * @param {String} key The attribute key.\n   * @param {String} value The attribute value.\n   * @param {module:engine/view/element~Element} element\n   */\n  setAttribute(key, value, element) {\n    element._setAttribute(key, value);\n  }\n  /**\n   * Removes attribute from the element.\n   *\n   *\t\twriter.removeAttribute( 'href', linkElement );\n   *\n   * @param {String} key Attribute key.\n   * @param {module:engine/view/element~Element} element\n   */\n  removeAttribute(key, element) {\n    element._removeAttribute(key);\n  }\n  /**\n   * Adds specified class to the element.\n   *\n   *\t\twriter.addClass( 'foo', linkElement );\n   *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n   *\n   * @param {Array.<String>|String} className\n   * @param {module:engine/view/element~Element} element\n   */\n  addClass(className, element) {\n    element._addClass(className);\n  }\n  /**\n   * Removes specified class from the element.\n   *\n   *\t\twriter.removeClass( 'foo', linkElement );\n   *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n   *\n   * @param {Array.<String>|String} className\n   * @param {module:engine/view/element~Element} element\n   */\n  removeClass(className, element) {\n    element._removeClass(className);\n  }\n  setStyle(property, value, element) {\n    if (isPlainObject(property) && element === undefined) {\n      value._setStyle(property);\n    } else {\n      element._setStyle(property, value);\n    }\n  }\n  /**\n   * Removes specified style from the element.\n   *\n   *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n   *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n   *\n   * @param {Array.<String>|String} property\n   * @param {module:engine/view/element~Element} element\n   */\n  removeStyle(property, element) {\n    element._removeStyle(property);\n  }\n  /**\n   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n   * so they can be used to add special data to elements.\n   *\n   * @param {String|Symbol} key\n   * @param {*} value\n   * @param {module:engine/view/element~Element} element\n   */\n  setCustomProperty(key, value, element) {\n    element._setCustomProperty(key, value);\n  }\n  /**\n   * Removes a custom property stored under the given key.\n   *\n   * @param {String|Symbol} key\n   * @param {module:engine/view/element~Element} element\n   * @returns {Boolean} Returns true if property was removed.\n   */\n  removeCustomProperty(key, element) {\n    return element._removeCustomProperty(key);\n  }\n  /**\n   * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements\n   * up to their first ancestor that is a container element.\n   *\n   * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:\n   *\n   *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n   *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n   *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n   *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n   *\n   * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n   *\n   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n   * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.\n   *\n   * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * when the {@link module:engine/view/range~Range#start start}\n   * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n   *\n   * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n   *\n   * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n   * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange The position where\n   * to break attribute elements.\n   * @returns {module:engine/view/position~Position|module:engine/view/range~Range} The new position or range, after breaking the\n   * attribute elements.\n   */\n  breakAttributes(positionOrRange) {\n    if (positionOrRange instanceof Position) {\n      return this._breakAttributes(positionOrRange);\n    } else {\n      return this._breakAttributesRange(positionOrRange);\n    }\n  }\n  /**\n   * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.\n   * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element\n   * if the position is at the beginning or at the end of its parent element.\n   *\n   *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n   *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n   *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n   *\t\t<p>foobar^</p> -> <p>foobar</p>^\n   *\n   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n   * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n   * @param {module:engine/view/position~Position} position The position where to break the element.\n   * @returns {module:engine/view/position~Position} The position between broken elements. If an element has not been broken,\n   * the returned position is placed either before or after it.\n   */\n  breakContainer(position) {\n    const element = position.parent;\n    if (!element.is('containerElement')) {\n      /**\n       * Trying to break an element which is not a container element.\n       *\n       * @error view-writer-break-non-container-element\n       */\n      throw new CKEditorError('view-writer-break-non-container-element', this.document);\n    }\n    if (!element.parent) {\n      /**\n       * Trying to break root element.\n       *\n       * @error view-writer-break-root\n       */\n      throw new CKEditorError('view-writer-break-root', this.document);\n    }\n    if (position.isAtStart) {\n      return Position._createBefore(element);\n    } else if (!position.isAtEnd) {\n      const newElement = element._clone(false);\n      this.insert(Position._createAfter(element), newElement);\n      const sourceRange = new Range(position, Position._createAt(element, 'end'));\n      const targetPosition = new Position(newElement, 0);\n      this.move(sourceRange, targetPosition);\n    }\n    return Position._createAfter(element);\n  }\n  /**\n   * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n   * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n   *\n   * In following examples `<p>` is a container and `<b>` is an attribute element:\n   *\n   *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n   *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n   *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n   *\n   * It will also take care about empty attributes when merging:\n   *\n   *\t\t<p><b>[]</b></p> -> <p>[]</p>\n   *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n   * @param {module:engine/view/position~Position} position Merge position.\n   * @returns {module:engine/view/position~Position} Position after merge.\n   */\n  mergeAttributes(position) {\n    const positionOffset = position.offset;\n    const positionParent = position.parent;\n    // When inside text node - nothing to merge.\n    if (positionParent.is('$text')) {\n      return position;\n    }\n    // When inside empty attribute - remove it.\n    if (positionParent.is('attributeElement') && positionParent.childCount === 0) {\n      const parent = positionParent.parent;\n      const offset = positionParent.index;\n      positionParent._remove();\n      this._removeFromClonedElementsGroup(positionParent);\n      return this.mergeAttributes(new Position(parent, offset));\n    }\n    const nodeBefore = positionParent.getChild(positionOffset - 1);\n    const nodeAfter = positionParent.getChild(positionOffset);\n    // Position should be placed between two nodes.\n    if (!nodeBefore || !nodeAfter) {\n      return position;\n    }\n    // When position is between two text nodes.\n    if (nodeBefore.is('$text') && nodeAfter.is('$text')) {\n      return mergeTextNodes(nodeBefore, nodeAfter);\n    }\n    // When position is between two same attribute elements.\n    else if (nodeBefore.is('attributeElement') && nodeAfter.is('attributeElement') && nodeBefore.isSimilar(nodeAfter)) {\n      // Move all children nodes from node placed after selection and remove that node.\n      const count = nodeBefore.childCount;\n      nodeBefore._appendChild(nodeAfter.getChildren());\n      nodeAfter._remove();\n      this._removeFromClonedElementsGroup(nodeAfter);\n      // New position is located inside the first node, before new nodes.\n      // Call this method recursively to merge again if needed.\n      return this.mergeAttributes(new Position(nodeBefore, count));\n    }\n    return position;\n  }\n  /**\n   * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n   * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n   *\n   *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n   *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n   * @param {module:engine/view/position~Position} position Merge position.\n   * @returns {module:engine/view/position~Position} Position after merge.\n   */\n  mergeContainers(position) {\n    const prev = position.nodeBefore;\n    const next = position.nodeAfter;\n    if (!prev || !next || !prev.is('containerElement') || !next.is('containerElement')) {\n      /**\n       * Element before and after given position cannot be merged.\n       *\n       * @error view-writer-merge-containers-invalid-position\n       */\n      throw new CKEditorError('view-writer-merge-containers-invalid-position', this.document);\n    }\n    const lastChild = prev.getChild(prev.childCount - 1);\n    const newPosition = lastChild instanceof Text ? Position._createAt(lastChild, 'end') : Position._createAt(prev, 'end');\n    this.move(Range._createIn(next), Position._createAt(prev, 'end'));\n    this.remove(Range._createOn(next));\n    return newPosition;\n  }\n  /**\n   * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion\n   * and merging them afterwards.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n   * contains instances that are not {@link module:engine/view/text~Text Texts},\n   * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n   * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n   * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n   * {@link module:engine/view/rawelement~RawElement RawElements} or\n   * {@link module:engine/view/uielement~UIElement UIElements}.\n   *\n   * @param {module:engine/view/position~Position} position Insertion position.\n   * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n   * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n   * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n   * Iterable.<module:engine/view/text~Text|\n   * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n   * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n   * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n   * @returns {module:engine/view/range~Range} Range around inserted nodes.\n   */\n  insert(position, nodes) {\n    nodes = isIterable(nodes) ? [...nodes] : [nodes];\n    // Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n    validateNodesToInsert(nodes, this.document);\n    // Group nodes in batches of nodes that require or do not require breaking an AttributeElements.\n    const nodeGroups = nodes.reduce((groups, node) => {\n      const lastGroup = groups[groups.length - 1];\n      // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n      // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n      const breakAttributes = !node.is('uiElement');\n      if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {\n        groups.push({\n          breakAttributes,\n          nodes: [node]\n        });\n      } else {\n        lastGroup.nodes.push(node);\n      }\n      return groups;\n    }, []);\n    // Insert nodes in batches.\n    let start = null;\n    let end = position;\n    for (const {\n      nodes,\n      breakAttributes\n    } of nodeGroups) {\n      const range = this._insertNodes(end, nodes, breakAttributes);\n      if (!start) {\n        start = range.start;\n      }\n      end = range.end;\n    }\n    // When no nodes were inserted - return collapsed range.\n    if (!start) {\n      return new Range(position);\n    }\n    return new Range(start, end);\n  }\n  /**\n   * Removes provided range from the container.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n   * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n   * to a collapsed range showing the new position.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n   */\n  remove(rangeOrItem) {\n    const range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn(rangeOrItem);\n    validateRangeContainer(range, this.document);\n    // If range is collapsed - nothing to remove.\n    if (range.isCollapsed) {\n      return new DocumentFragment(this.document);\n    }\n    // Break attributes at range start and end.\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n    const parentContainer = breakStart.parent;\n    const count = breakEnd.offset - breakStart.offset;\n    // Remove nodes in range.\n    const removed = parentContainer._removeChildren(breakStart.offset, count);\n    for (const node of removed) {\n      this._removeFromClonedElementsGroup(node);\n    }\n    // Merge after removing.\n    const mergePosition = this.mergeAttributes(breakStart);\n    range.start = mergePosition;\n    range.end = mergePosition.clone();\n    // Return removed nodes.\n    return new DocumentFragment(this.document, removed);\n  }\n  /**\n   * Removes matching elements from given range.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} range Range to clear.\n   * @param {module:engine/view/element~Element} element Element to remove.\n   */\n  clear(range, element) {\n    validateRangeContainer(range, this.document);\n    // Create walker on given range.\n    // We walk backward because when we remove element during walk it modifies range end position.\n    const walker = range.getWalker({\n      direction: 'backward',\n      ignoreElementEnd: true\n    });\n    // Let's walk.\n    for (const current of walker) {\n      const item = current.item;\n      let rangeToRemove;\n      // When current item matches to the given element.\n      if (item.is('element') && element.isSimilar(item)) {\n        // Create range on this element.\n        rangeToRemove = Range._createOn(item);\n        // When range starts inside Text or TextProxy element.\n      } else if (!current.nextPosition.isAfter(range.start) && item.is('$textProxy')) {\n        // We need to check if parent of this text matches to given element.\n        const parentElement = item.getAncestors().find(ancestor => {\n          return ancestor.is('element') && element.isSimilar(ancestor);\n        });\n        // If it is then create range inside this element.\n        if (parentElement) {\n          rangeToRemove = Range._createIn(parentElement);\n        }\n      }\n      // If we have found element to remove.\n      if (rangeToRemove) {\n        // We need to check if element range stick out of the given range and truncate if it is.\n        if (rangeToRemove.end.isAfter(range.end)) {\n          rangeToRemove.end = range.end;\n        }\n        if (rangeToRemove.start.isBefore(range.start)) {\n          rangeToRemove.start = range.start;\n        }\n        // At the end we remove range with found element.\n        this.remove(rangeToRemove);\n      }\n    }\n  }\n  /**\n   * Moves nodes from provided range to target position.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n   * @param {module:engine/view/position~Position} targetPosition Position to insert.\n   * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n   */\n  move(sourceRange, targetPosition) {\n    let nodes;\n    if (targetPosition.isAfter(sourceRange.end)) {\n      targetPosition = this._breakAttributes(targetPosition, true);\n      const parent = targetPosition.parent;\n      const countBefore = parent.childCount;\n      sourceRange = this._breakAttributesRange(sourceRange, true);\n      nodes = this.remove(sourceRange);\n      targetPosition.offset += parent.childCount - countBefore;\n    } else {\n      nodes = this.remove(sourceRange);\n    }\n    return this.insert(targetPosition, nodes);\n  }\n  /**\n   * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n   *\n   * If a collapsed range was passed and is same as selection, the selection\n   * will be moved to the inside of the wrapped attribute element.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n   * when {@link module:engine/view/range~Range#start}\n   * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n   * is collapsed and different than view selection.\n   *\n   * @param {module:engine/view/range~Range} range Range to wrap.\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n   * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n   */\n  wrap(range, attribute) {\n    if (!(attribute instanceof AttributeElement)) {\n      throw new CKEditorError('view-writer-wrap-invalid-attribute', this.document);\n    }\n    validateRangeContainer(range, this.document);\n    if (!range.isCollapsed) {\n      // Non-collapsed range. Wrap it with the attribute element.\n      return this._wrapRange(range, attribute);\n    } else {\n      // Collapsed range. Wrap position.\n      let position = range.start;\n      if (position.parent.is('element') && !_hasNonUiChildren(position.parent)) {\n        position = position.getLastMatchingPosition(value => value.item.is('uiElement'));\n      }\n      position = this._wrapPosition(position, attribute);\n      const viewSelection = this.document.selection;\n      // If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n      if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {\n        this.setSelection(position);\n      }\n      return new Range(position);\n    }\n  }\n  /**\n   * Unwraps nodes within provided range from attribute element.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} range\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   */\n  unwrap(range, attribute) {\n    if (!(attribute instanceof AttributeElement)) {\n      /**\n       * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#unwrap `DowncastWriter#unwrap()`}\n       * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n       *\n       * @error view-writer-unwrap-invalid-attribute\n       */\n      throw new CKEditorError('view-writer-unwrap-invalid-attribute', this.document);\n    }\n    validateRangeContainer(range, this.document);\n    // If range is collapsed - nothing to unwrap.\n    if (range.isCollapsed) {\n      return range;\n    }\n    // Break attributes at range start and end.\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n    const parentContainer = breakStart.parent;\n    // Unwrap children located between break points.\n    const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);\n    // Merge attributes at the both ends and return a new range.\n    const start = this.mergeAttributes(newRange.start);\n    // If start position was merged - move end position back.\n    if (!start.isEqual(newRange.start)) {\n      newRange.end.offset--;\n    }\n    const end = this.mergeAttributes(newRange.end);\n    return new Range(start, end);\n  }\n  /**\n   * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n   * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n   * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n   *\n   * New element has to be created because `Element#tagName` property in DOM is readonly.\n   *\n   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n   *\n   * @param {String} newName New name for element.\n   * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n   * @returns {module:engine/view/containerelement~ContainerElement} Element created due to rename.\n   */\n  rename(newName, viewElement) {\n    const newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());\n    this.insert(Position._createAfter(viewElement), newElement);\n    this.move(Range._createIn(viewElement), Position._createAt(newElement, 0));\n    this.remove(Range._createOn(viewElement));\n    return newElement;\n  }\n  /**\n   * Cleans up memory by removing obsolete cloned elements group from the writer.\n   *\n   * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n   * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n   * the group will no longer be needed.\n   *\n   * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n   * were removed from the view.\n   *\n   * Keep in mind that group names are equal to the `id` property of the attribute element.\n   *\n   * @param {String} groupName Name of the group to clear.\n   */\n  clearClonedElementsGroup(groupName) {\n    this._cloneGroups.delete(groupName);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/view/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n   *\n   * This method is a shortcut to other constructors such as:\n   *\n   * * {@link #createPositionBefore},\n   * * {@link #createPositionAfter},\n   *\n   * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   * @returns {module:engine/view/position~Position}\n   */\n  createPositionAt(itemOrPosition, offset) {\n    return Position._createAt(itemOrPosition, offset);\n  }\n  /**\n   * Creates a new position after given view item.\n   *\n   * @param {module:engine/view/item~Item} item View item after which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n  createPositionAfter(item) {\n    return Position._createAfter(item);\n  }\n  /**\n   * Creates a new position before given view item.\n   *\n   * @param {module:engine/view/item~Item} item View item before which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n  createPositionBefore(item) {\n    return Position._createBefore(item);\n  }\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n   *\n   * @param {module:engine/view/position~Position} start Start position.\n   * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n   * @returns {module:engine/view/range~Range}\n   */\n  createRange() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new Range(...args);\n  }\n  /**\n   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n   *\n   * @param {module:engine/view/item~Item} item\n   * @returns {module:engine/view/range~Range}\n   */\n  createRangeOn(item) {\n    return Range._createOn(item);\n  }\n  /**\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/view/range~Range}\n   */\n  createRangeIn(element) {\n    return Range._createIn(element);\n  }\n  /**\n   * Creates new {@link module:engine/view/selection~Selection} instance.\n   *\n   * \t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the document selection.\n   *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n   *\n   * \t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'p' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} [selectable=null]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   * @returns {module:engine/view/selection~Selection}\n   */\n  createSelection() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return new Selection(...args);\n  }\n  /**\n   * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n   * `elementToStructure()`} conversion helper.\n   *\n   *\t\tconst viewSlot = conversionApi.writer.createSlot();\n   *\t\tconst viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );\n   *\n   *\t\tconversionApi.writer.insert( viewPosition, viewSlot );\n   *\n   * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):\n   *\n   *\t\tconst viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );\n   *\t\tconst viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );\n   *\n   *\t\tconversionApi.writer.insert( viewPosition, viewSlot );\n   *\n   * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into\n   * multiple slots.\n   *\n   * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.\n   *\n   * @param {'children'|module:engine/conversion/downcasthelpers~SlotFilter} [modeOrFilter='children'] The filter for child nodes.\n   * @returns {module:engine/view/element~Element} The slot element to be placed in to the view structure while processing\n   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.\n   */\n  createSlot(modeOrFilter) {\n    if (!this._slotFactory) {\n      /**\n       * The `createSlot()` method is only allowed inside the `elementToStructure` downcast helper callback.\n       *\n       * @error view-writer-invalid-create-slot-context\n       */\n      throw new CKEditorError('view-writer-invalid-create-slot-context', this.document);\n    }\n    return this._slotFactory(this, modeOrFilter);\n  }\n  /**\n   * Registers a slot factory.\n   *\n   * @protected\n   * @param {Function} slotFactory The slot factory.\n   */\n  _registerSlotFactory(slotFactory) {\n    this._slotFactory = slotFactory;\n  }\n  /**\n   * Clears the registered slot factory.\n   *\n   * @protected\n   */\n  _clearSlotFactory() {\n    this._slotFactory = null;\n  }\n  /**\n   * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion\n   * and merging them afterwards if requested by the breakAttributes param.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position Insertion position.\n   * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n   * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n   * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n   * Iterable.<module:engine/view/text~Text|\n   * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n   * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n   * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n   * @param {Boolean} breakAttributes Whether attributes should be broken.\n   * @returns {module:engine/view/range~Range} Range around inserted nodes.\n   */\n  _insertNodes(position, nodes, breakAttributes) {\n    let parentElement;\n    // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n    // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n    if (breakAttributes) {\n      parentElement = getParentContainer(position);\n    } else {\n      parentElement = position.parent.is('$text') ? position.parent.parent : position.parent;\n    }\n    if (!parentElement) {\n      /**\n       * Position's parent container cannot be found.\n       *\n       * @error view-writer-invalid-position-container\n       */\n      throw new CKEditorError('view-writer-invalid-position-container', this.document);\n    }\n    let insertionPosition;\n    if (breakAttributes) {\n      insertionPosition = this._breakAttributes(position, true);\n    } else {\n      insertionPosition = position.parent.is('$text') ? breakTextNode(position) : position;\n    }\n    const length = parentElement._insertChild(insertionPosition.offset, nodes);\n    for (const node of nodes) {\n      this._addToClonedElementsGroup(node);\n    }\n    const endPosition = insertionPosition.getShiftedBy(length);\n    const start = this.mergeAttributes(insertionPosition);\n    // If start position was merged - move end position.\n    if (!start.isEqual(insertionPosition)) {\n      endPosition.offset--;\n    }\n    const end = this.mergeAttributes(endPosition);\n    return new Range(start, end);\n  }\n  /**\n   * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n   * `startOffset` and `endOffset` will be wrapped.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} parent\n   * @param {Number} startOffset\n   * @param {Number} endOffset\n   * @param {module:engine/view/element~Element} wrapElement\n   */\n  _wrapChildren(parent, startOffset, endOffset, wrapElement) {\n    let i = startOffset;\n    const wrapPositions = [];\n    while (i < endOffset) {\n      const child = parent.getChild(i);\n      const isText = child.is('$text');\n      const isAttribute = child.is('attributeElement');\n      //\n      // (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n      //\n      // Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n      // If possible, join elements.\n      //\n      // <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n      //\n      if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {\n        wrapPositions.push(new Position(parent, i));\n      }\n      //\n      // Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n      // `wrapElement` (due to priority).\n      //\n      // <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n      // <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n      else if (isText || !isAttribute || shouldABeOutsideB(wrapElement, child)) {\n        // Clone attribute.\n        const newAttribute = wrapElement._clone();\n        // Wrap current node with new attribute.\n        child._remove();\n        newAttribute._appendChild(child);\n        parent._insertChild(i, newAttribute);\n        this._addToClonedElementsGroup(newAttribute);\n        wrapPositions.push(new Position(parent, i));\n      }\n      //\n      // If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n      //\n      // <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n      //\n      else /* if ( isAttribute ) */{\n          this._wrapChildren(child, 0, child.childCount, wrapElement);\n        }\n      i++;\n    }\n    // Merge at each wrap.\n    let offsetChange = 0;\n    for (const position of wrapPositions) {\n      position.offset -= offsetChange;\n      // Do not merge with elements outside selected children.\n      if (position.offset == startOffset) {\n        continue;\n      }\n      const newPosition = this.mergeAttributes(position);\n      // If nodes were merged - other merge offsets will change.\n      if (!newPosition.isEqual(position)) {\n        offsetChange++;\n        endOffset--;\n      }\n    }\n    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n  }\n  /**\n   * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n   * `startOffset` and `endOffset` will be unwrapped.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} parent\n   * @param {Number} startOffset\n   * @param {Number} endOffset\n   * @param {module:engine/view/element~Element} unwrapElement\n   */\n  _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {\n    let i = startOffset;\n    const unwrapPositions = [];\n    // Iterate over each element between provided offsets inside parent.\n    // We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n    // so it could get messy. It is safer to it manually in this case.\n    while (i < endOffset) {\n      const child = parent.getChild(i);\n      // Skip all text nodes. There should be no container element's here either.\n      if (!child.is('attributeElement')) {\n        i++;\n        continue;\n      }\n      //\n      // (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n      //\n      // If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n      //\n      // <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n      //\n      if (child.isSimilar(unwrapElement)) {\n        const unwrapped = child.getChildren();\n        const count = child.childCount;\n        // Replace wrapper element with its children\n        child._remove();\n        parent._insertChild(i, unwrapped);\n        this._removeFromClonedElementsGroup(child);\n        // Save start and end position of moved items.\n        unwrapPositions.push(new Position(parent, i), new Position(parent, i + count));\n        // Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n        i += count;\n        endOffset += count - 1;\n        continue;\n      }\n      //\n      // If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n      // Partial unwrapping will happen only if the elements have the same name.\n      //\n      // <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n      // <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n      //\n      if (this._unwrapAttributeElement(unwrapElement, child)) {\n        unwrapPositions.push(new Position(parent, i), new Position(parent, i + 1));\n        i++;\n        continue;\n      }\n      //\n      // If other nested attribute is found, look through it's children for elements to unwrap.\n      //\n      // <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n      //\n      this._unwrapChildren(child, 0, child.childCount, unwrapElement);\n      i++;\n    }\n    // Merge at each unwrap.\n    let offsetChange = 0;\n    for (const position of unwrapPositions) {\n      position.offset -= offsetChange;\n      // Do not merge with elements outside selected children.\n      if (position.offset == startOffset || position.offset == endOffset) {\n        continue;\n      }\n      const newPosition = this.mergeAttributes(position);\n      // If nodes were merged - other merge offsets will change.\n      if (!newPosition.isEqual(position)) {\n        offsetChange++;\n        endOffset--;\n      }\n    }\n    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n  }\n  /**\n   * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n   * This method will also merge newly added attribute element with its siblings whenever possible.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n   */\n  _wrapRange(range, attribute) {\n    // Break attributes at range start and end.\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n    const parentContainer = breakStart.parent;\n    // Wrap all children with attribute.\n    const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);\n    // Merge attributes at the both ends and return a new range.\n    const start = this.mergeAttributes(newRange.start);\n    // If start position was merged - move end position back.\n    if (!start.isEqual(newRange.start)) {\n      newRange.end.offset--;\n    }\n    const end = this.mergeAttributes(newRange.end);\n    return new Range(start, end);\n  }\n  /**\n   * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n   * This method will also merge newly added attribute element with its siblings whenever possible.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   * @returns {module:engine/view/position~Position} New position after wrapping.\n   */\n  _wrapPosition(position, attribute) {\n    // Return same position when trying to wrap with attribute similar to position parent.\n    if (attribute.isSimilar(position.parent)) {\n      return movePositionToTextNode(position.clone());\n    }\n    // When position is inside text node - break it and place new position between two text nodes.\n    if (position.parent.is('$text')) {\n      position = breakTextNode(position);\n    }\n    // Create fake element that will represent position, and will not be merged with other attributes.\n    const fakeElement = this.createAttributeElement('_wrapPosition-fake-element');\n    fakeElement._priority = Number.POSITIVE_INFINITY;\n    fakeElement.isSimilar = () => false;\n    // Insert fake element in position location.\n    position.parent._insertChild(position.offset, fakeElement);\n    // Range around inserted fake attribute element.\n    const wrapRange = new Range(position, position.getShiftedBy(1));\n    // Wrap fake element with attribute (it will also merge if possible).\n    this.wrap(wrapRange, attribute);\n    // Remove fake element and place new position there.\n    const newPosition = new Position(fakeElement.parent, fakeElement.index);\n    fakeElement._remove();\n    // If position is placed between text nodes - merge them and return position inside.\n    const nodeBefore = newPosition.nodeBefore;\n    const nodeAfter = newPosition.nodeAfter;\n    if (nodeBefore instanceof Text && nodeAfter instanceof Text) {\n      return mergeTextNodes(nodeBefore, nodeAfter);\n    }\n    // If position is next to text node - move position inside.\n    return movePositionToTextNode(newPosition);\n  }\n  /**\n   * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n   * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n   * \telement to element being wrapped.\n   *\n   * \t@private\n   * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n   * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n   * \t@returns {Boolean} Returns `true` if elements are merged.\n   */\n  _wrapAttributeElement(wrapper, toWrap) {\n    if (!canBeJoined(wrapper, toWrap)) {\n      return false;\n    }\n    // Can't merge if name or priority differs.\n    if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {\n      return false;\n    }\n    // Check if attributes can be merged.\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      }\n      // If some attributes are different we cannot wrap.\n      if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n        return false;\n      }\n    }\n    // Check if styles can be merged.\n    for (const key of wrapper.getStyleNames()) {\n      if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {\n        return false;\n      }\n    }\n    // Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      }\n      // Move only these attributes that are not present - other are similar.\n      if (!toWrap.hasAttribute(key)) {\n        this.setAttribute(key, wrapper.getAttribute(key), toWrap);\n      }\n    }\n    for (const key of wrapper.getStyleNames()) {\n      if (!toWrap.hasStyle(key)) {\n        this.setStyle(key, wrapper.getStyle(key), toWrap);\n      }\n    }\n    for (const key of wrapper.getClassNames()) {\n      if (!toWrap.hasClass(key)) {\n        this.addClass(key, toWrap);\n      }\n    }\n    return true;\n  }\n  /**\n   * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n   * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n   * inside element being unwrapped.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n   * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n   * @returns {Boolean} Returns `true` if elements are unwrapped.\n   **/\n  _unwrapAttributeElement(wrapper, toUnwrap) {\n    if (!canBeJoined(wrapper, toUnwrap)) {\n      return false;\n    }\n    // Can't unwrap if name or priority differs.\n    if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {\n      return false;\n    }\n    // Check if AttributeElement has all wrapper attributes.\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      }\n      // If some attributes are missing or different we cannot unwrap.\n      if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n        return false;\n      }\n    }\n    // Check if AttributeElement has all wrapper classes.\n    if (!toUnwrap.hasClass(...wrapper.getClassNames())) {\n      return false;\n    }\n    // Check if AttributeElement has all wrapper styles.\n    for (const key of wrapper.getStyleNames()) {\n      // If some styles are missing or different we cannot unwrap.\n      if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {\n        return false;\n      }\n    }\n    // Remove all wrapper's attributes from unwrapped element.\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      }\n      this.removeAttribute(key, toUnwrap);\n    }\n    // Remove all wrapper's classes from unwrapped element.\n    this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap);\n    // Remove all wrapper's styles from unwrapped element.\n    this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);\n    return true;\n  }\n  /**\n   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n   * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n   * @returns {module:engine/view/range~Range} New range with located at break positions.\n   */\n  _breakAttributesRange(range) {\n    let forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const rangeStart = range.start;\n    const rangeEnd = range.end;\n    validateRangeContainer(range, this.document);\n    // Break at the collapsed position. Return new collapsed range.\n    if (range.isCollapsed) {\n      const position = this._breakAttributes(range.start, forceSplitText);\n      return new Range(position, position);\n    }\n    const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);\n    const count = breakEnd.parent.childCount;\n    const breakStart = this._breakAttributes(rangeStart, forceSplitText);\n    // Calculate new break end offset.\n    breakEnd.offset += breakEnd.parent.childCount - count;\n    return new Range(breakStart, breakEnd);\n  }\n  /**\n   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n   * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n   * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position Position where to break attributes.\n   * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n   * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n   */\n  _breakAttributes(position) {\n    let forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const positionOffset = position.offset;\n    const positionParent = position.parent;\n    // If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n    if (position.parent.is('emptyElement')) {\n      /**\n       * Cannot break an `EmptyElement` instance.\n       *\n       * This error is thrown if\n       * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n       * was executed in an incorrect position.\n       *\n       * @error view-writer-cannot-break-empty-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-empty-element', this.document);\n    }\n    // If position is placed inside UIElement - throw an exception as we cannot break inside.\n    if (position.parent.is('uiElement')) {\n      /**\n       * Cannot break a `UIElement` instance.\n       *\n       * This error is thrown if\n       * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n       * was executed in an incorrect position.\n       *\n       * @error view-writer-cannot-break-ui-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-ui-element', this.document);\n    }\n    // If position is placed inside RawElement - throw an exception as we cannot break inside.\n    if (position.parent.is('rawElement')) {\n      /**\n       * Cannot break a `RawElement` instance.\n       *\n       * This error is thrown if\n       * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n       * was executed in an incorrect position.\n       *\n       * @error view-writer-cannot-break-raw-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-raw-element', this.document);\n    }\n    // There are no attributes to break and text nodes breaking is not forced.\n    if (!forceSplitText && positionParent.is('$text') && isContainerOrFragment(positionParent.parent)) {\n      return position.clone();\n    }\n    // Position's parent is container, so no attributes to break.\n    if (isContainerOrFragment(positionParent)) {\n      return position.clone();\n    }\n    // Break text and start again in new position.\n    if (positionParent.is('$text')) {\n      return this._breakAttributes(breakTextNode(position), forceSplitText);\n    }\n    const length = positionParent.childCount;\n    // <p>foo<b><u>bar{}</u></b></p>\n    // <p>foo<b><u>bar</u>[]</b></p>\n    // <p>foo<b><u>bar</u></b>[]</p>\n    if (positionOffset == length) {\n      const newPosition = new Position(positionParent.parent, positionParent.index + 1);\n      return this._breakAttributes(newPosition, forceSplitText);\n    } else {\n      // <p>foo<b><u>{}bar</u></b></p>\n      // <p>foo<b>[]<u>bar</u></b></p>\n      // <p>foo{}<b><u>bar</u></b></p>\n      if (positionOffset === 0) {\n        const newPosition = new Position(positionParent.parent, positionParent.index);\n        return this._breakAttributes(newPosition, forceSplitText);\n      }\n      // <p>foo<b><u>b{}ar</u></b></p>\n      // <p>foo<b><u>b[]ar</u></b></p>\n      // <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n      // <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n      else {\n        const offsetAfter = positionParent.index + 1;\n        // Break element.\n        const clonedNode = positionParent._clone();\n        // Insert cloned node to position's parent node.\n        positionParent.parent._insertChild(offsetAfter, clonedNode);\n        this._addToClonedElementsGroup(clonedNode);\n        // Get nodes to move.\n        const count = positionParent.childCount - positionOffset;\n        const nodesToMove = positionParent._removeChildren(positionOffset, count);\n        // Move nodes to cloned node.\n        clonedNode._appendChild(nodesToMove);\n        // Create new position to work on.\n        const newPosition = new Position(positionParent.parent, offsetAfter);\n        return this._breakAttributes(newPosition, forceSplitText);\n      }\n    }\n  }\n  /**\n   * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n   * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n   * from the group now keep a reference to the given attribute element.\n   *\n   * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n   *\n   * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n   */\n  _addToClonedElementsGroup(element) {\n    // Add only if the element is in document tree.\n    if (!element.root.is('rootElement')) {\n      return;\n    }\n    // Traverse the element's children recursively to find other attribute elements that also might got inserted.\n    // The loop is at the beginning so we can make fast returns later in the code.\n    if (element.is('element')) {\n      for (const child of element.getChildren()) {\n        this._addToClonedElementsGroup(child);\n      }\n    }\n    const id = element.id;\n    if (!id) {\n      return;\n    }\n    let group = this._cloneGroups.get(id);\n    if (!group) {\n      group = new Set();\n      this._cloneGroups.set(id, group);\n    }\n    group.add(element);\n    element._clonesGroup = group;\n  }\n  /**\n   * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n   * from its clones group.\n   *\n   * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n   * This allows to reference the whole group even if the element was already removed from the tree.\n   *\n   * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n   */\n  _removeFromClonedElementsGroup(element) {\n    // Traverse the element's children recursively to find other attribute elements that also got removed.\n    // The loop is at the beginning so we can make fast returns later in the code.\n    if (element.is('element')) {\n      for (const child of element.getChildren()) {\n        this._removeFromClonedElementsGroup(child);\n      }\n    }\n    const id = element.id;\n    if (!id) {\n      return;\n    }\n    const group = this._cloneGroups.get(id);\n    if (!group) {\n      return;\n    }\n    group.delete(element);\n    // Not removing group from element on purpose!\n    // If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n  }\n}\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren(parent) {\n  return Array.from(parent.getChildren()).some(child => !child.is('uiElement'));\n}\n/**\n * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`}\n * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer(position) {\n  let parent = position.parent;\n  while (!isContainerOrFragment(parent)) {\n    if (!parent) {\n      return undefined;\n    }\n    parent = parent.parent;\n  }\n  return parent;\n}\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped outside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB(a, b) {\n  if (a.priority < b.priority) {\n    return true;\n  } else if (a.priority > b.priority) {\n    return false;\n  }\n  // When priorities are equal and names are different - use identities.\n  return a.getIdentity() < b.getIdentity();\n}\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode(position) {\n  const nodeBefore = position.nodeBefore;\n  if (nodeBefore && nodeBefore.is('$text')) {\n    return new Position(nodeBefore, nodeBefore.data.length);\n  }\n  const nodeAfter = position.nodeAfter;\n  if (nodeAfter && nodeAfter.is('$text')) {\n    return new Position(nodeAfter, 0);\n  }\n  return position;\n}\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode(position) {\n  if (position.offset == position.parent.data.length) {\n    return new Position(position.parent.parent, position.parent.index + 1);\n  }\n  if (position.offset === 0) {\n    return new Position(position.parent.parent, position.parent.index);\n  }\n  // Get part of the text that need to be moved.\n  const textToMove = position.parent.data.slice(position.offset);\n  // Leave rest of the text in position's parent.\n  position.parent._data = position.parent.data.slice(0, position.offset);\n  // Insert new text node after position's parent text node.\n  position.parent.parent._insertChild(position.parent.index + 1, new Text(position.root.document, textToMove));\n  // Return new position between two newly created text nodes.\n  return new Position(position.parent.parent, position.parent.index + 1);\n}\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes(t1, t2) {\n  // Merge text data into first text node and remove second one.\n  const nodeBeforeLength = t1.data.length;\n  t1._data += t2.data;\n  t2._remove();\n  return new Position(t1, nodeBeforeLength);\n}\nconst validNodesToInsert = [Text, AttributeElement, ContainerElement, EmptyElement, RawElement, UIElement];\n// Checks if provided nodes are valid to insert.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not supported ones (see error description for valid ones.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/element~Element> nodes\n// @param {Object} errorContext\nfunction validateNodesToInsert(nodes, errorContext) {\n  for (const node of nodes) {\n    if (!validNodesToInsert.some(validNode => node instanceof validNode)) {\n      // eslint-disable-line no-use-before-define\n      /**\n       * One of the nodes to be inserted is of an invalid type.\n       *\n       * Nodes to be inserted with {@link module:engine/view/downcastwriter~DowncastWriter#insert `DowncastWriter#insert()`} should be\n       * of the following types:\n       *\n       * * {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n       * * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n       * * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n       * * {@link module:engine/view/uielement~UIElement UIElement},\n       * * {@link module:engine/view/rawelement~RawElement RawElement},\n       * * {@link module:engine/view/text~Text Text}.\n       *\n       * @error view-writer-insert-invalid-node-type\n       */\n      throw new CKEditorError('view-writer-insert-invalid-node-type', errorContext);\n    }\n    if (!node.is('$text')) {\n      validateNodesToInsert(node.getChildren(), errorContext);\n    }\n  }\n}\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment(node) {\n  return node && (node.is('containerElement') || node.is('documentFragment'));\n}\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\nfunction validateRangeContainer(range, errorContext) {\n  const startContainer = getParentContainer(range.start);\n  const endContainer = getParentContainer(range.end);\n  if (!startContainer || !endContainer || startContainer !== endContainer) {\n    /**\n     * The container of the given range is invalid.\n     *\n     * This may happen if {@link module:engine/view/range~Range#start range start} and\n     * {@link module:engine/view/range~Range#end range end} positions are not placed inside the same container element or\n     * a parent container for these positions cannot be found.\n     *\n     * Methods like {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#remove()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#clean()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#unwrap()`} need to be called\n     * on a range that has its start and end positions located in the same container element. Both positions can be\n     * nested within other elements (e.g. an attribute element) but the closest container ancestor must be the same.\n     *\n     * @error view-writer-invalid-range-container\n     */\n    throw new CKEditorError('view-writer-invalid-range-container', errorContext);\n  }\n}\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined(a, b) {\n  return a.id === null && b.id === null;\n}","map":{"version":3,"names":["Position","Range","Selection","ContainerElement","AttributeElement","EmptyElement","UIElement","RawElement","CKEditorError","DocumentFragment","isIterable","Text","EditableElement","isPlainObject","DowncastWriter","constructor","document","_cloneGroups","Map","_slotFactory","setSelection","selection","_setTo","setSelectionFocus","_setFocus","createDocumentFragment","children","createText","data","createAttributeElement","name","attributes","options","attributeElement","priority","_priority","id","_id","renderUnsafeAttributes","_unsafeAttributesToRender","push","createContainerElement","childrenOrOptions","containerElement","createEditableElement","editableElement","createEmptyElement","emptyElement","createUIElement","renderFunction","uiElement","render","createRawElement","rawElement","setAttribute","key","value","element","_setAttribute","removeAttribute","_removeAttribute","addClass","className","_addClass","removeClass","_removeClass","setStyle","property","undefined","_setStyle","removeStyle","_removeStyle","setCustomProperty","_setCustomProperty","removeCustomProperty","_removeCustomProperty","breakAttributes","positionOrRange","_breakAttributes","_breakAttributesRange","breakContainer","position","parent","is","isAtStart","_createBefore","isAtEnd","newElement","_clone","insert","_createAfter","sourceRange","_createAt","targetPosition","move","mergeAttributes","positionOffset","offset","positionParent","childCount","index","_remove","_removeFromClonedElementsGroup","nodeBefore","getChild","nodeAfter","mergeTextNodes","isSimilar","count","_appendChild","getChildren","mergeContainers","prev","next","lastChild","newPosition","_createIn","remove","_createOn","nodes","validateNodesToInsert","nodeGroups","reduce","groups","node","lastGroup","length","start","end","range","_insertNodes","rangeOrItem","validateRangeContainer","isCollapsed","breakStart","breakEnd","parentContainer","removed","_removeChildren","mergePosition","clone","clear","walker","getWalker","direction","ignoreElementEnd","current","item","rangeToRemove","nextPosition","isAfter","parentElement","getAncestors","find","ancestor","isBefore","countBefore","wrap","attribute","_wrapRange","_hasNonUiChildren","getLastMatchingPosition","_wrapPosition","viewSelection","getFirstPosition","isEqual","unwrap","newRange","_unwrapChildren","rename","newName","viewElement","getAttributes","clearClonedElementsGroup","groupName","delete","createPositionAt","itemOrPosition","createPositionAfter","createPositionBefore","createRange","args","createRangeOn","createRangeIn","createSelection","createSlot","modeOrFilter","_registerSlotFactory","slotFactory","_clearSlotFactory","getParentContainer","insertionPosition","breakTextNode","_insertChild","_addToClonedElementsGroup","endPosition","getShiftedBy","_wrapChildren","startOffset","endOffset","wrapElement","i","wrapPositions","child","isText","isAttribute","_wrapAttributeElement","shouldABeOutsideB","newAttribute","offsetChange","_createFromParentsAndOffsets","unwrapElement","unwrapPositions","unwrapped","_unwrapAttributeElement","movePositionToTextNode","fakeElement","Number","POSITIVE_INFINITY","wrapRange","wrapper","toWrap","canBeJoined","getAttributeKeys","hasAttribute","getAttribute","getStyleNames","hasStyle","getStyle","getClassNames","hasClass","toUnwrap","Array","from","forceSplitText","rangeStart","rangeEnd","isContainerOrFragment","offsetAfter","clonedNode","nodesToMove","root","group","get","Set","set","add","_clonesGroup","some","a","b","getIdentity","textToMove","slice","_data","t1","t2","nodeBeforeLength","validNodesToInsert","errorContext","validNode","startContainer","endContainer"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module module:engine/view/downcastwriter\n */\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport RawElement from './rawelement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\nexport default class DowncastWriter {\n    /**\n     * @param {module:engine/view/document~Document} document The view document instance.\n     */\n    constructor(document) {\n        /**\n         * The view document instance in which this writer operates.\n         *\n         * @readonly\n         * @type {module:engine/view/document~Document}\n         */\n        this.document = document;\n        /**\n         * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n         * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n         *\n         * @private\n         * @type {Map.<String,Set>}\n         */\n        this._cloneGroups = new Map();\n        /**\n         * The slot factory used by the `elementToStructure` downcast helper.\n         *\n         * @private\n         * @type {Function|null}\n         */\n        this._slotFactory = null;\n    }\n    /**\n     * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n     * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n     *\n     * Usage:\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\twriter.setSelection( range );\n     *\n     *\t\t// Sets backward selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\twriter.setSelection( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n     *\t\twriter.setSelection( range );\n     *\n     *\t\t// Sets selection to the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\twriter.setSelection( otherSelection );\n     *\n     * \t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\twriter.setSelection( position );\n     *\n     * \t\t// Sets collapsed selection at the position of given item and offset.\n     *\t\tconst paragraph = writer.createContainerElement( 'p' );\n     *\t\twriter.setSelection( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * \t\twriter.setSelection( paragraph, 'in' );\n     *\n     * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\twriter.setSelection( paragraph, 'on' );\n     *\n     * \t\t// Removes all ranges.\n     *\t\twriter.setSelection( null );\n     *\n     * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Sets selection as backward.\n     *\t\twriter.setSelection( range, { backward: true } );\n     *\n     *\t\t// Sets selection as fake.\n     *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * \t\t// represented in other way, for example by applying proper CSS class.\n     *\t\twriter.setSelection( range, { fake: true } );\n     *\n     * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * \t\t// (and be  properly handled by screen readers).\n     *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n     *\n     * @param {module:engine/view/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     */\n    setSelection(...args) {\n        this.document.selection._setTo(...args);\n    }\n    /**\n     * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n     *\n     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n     * parameters.\n     *\n     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n    setSelectionFocus(...args) {\n        this.document.selection._setFocus(...args);\n    }\n    /**\n     * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.\n     *\n     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n     * A list of nodes to be inserted into the created document fragment.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.\n     */\n    createDocumentFragment(children) {\n        return new DocumentFragment(this.document, children);\n    }\n    /**\n     * Creates a new {@link module:engine/view/text~Text text node}.\n     *\n     *\t\twriter.createText( 'foo' );\n     *\n     * @param {String} data The text's data.\n     * @returns {module:engine/view/text~Text} The created text node.\n     */\n    createText(data) {\n        return new Text(this.document, data);\n    }\n    /**\n     * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.\n     *\n     *\t\twriter.createAttributeElement( 'strong' );\n     *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n     *\n     *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n     *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n     *\n     *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n     *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Element's attributes.\n     * @param {Object} [options] Element's options.\n     * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n     * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n     */\n    createAttributeElement(name, attributes, options = {}) {\n        const attributeElement = new AttributeElement(this.document, name, attributes);\n        if (typeof options.priority === 'number') {\n            attributeElement._priority = options.priority;\n        }\n        if (options.id) {\n            attributeElement._id = options.id;\n        }\n        if (options.renderUnsafeAttributes) {\n            attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n        }\n        return attributeElement;\n    }\n    createContainerElement(name, attributes, childrenOrOptions = {}, options = {}) {\n        let children = null;\n        if (isPlainObject(childrenOrOptions)) {\n            options = childrenOrOptions;\n        }\n        else {\n            children = childrenOrOptions;\n        }\n        const containerElement = new ContainerElement(this.document, name, attributes, children);\n        if (options.renderUnsafeAttributes) {\n            containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n        }\n        return containerElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/editableelement~EditableElement}.\n     *\n     *\t\twriter.createEditableElement( 'div' );\n     *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n     *\n     * Note: The editable element is to be used in the editing pipeline. Usually, together with\n     * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {Object} [options] Element's options.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/editableelement~EditableElement} Created element.\n     */\n    createEditableElement(name, attributes, options = {}) {\n        const editableElement = new EditableElement(this.document, name, attributes);\n        if (options.renderUnsafeAttributes) {\n            editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n        }\n        return editableElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.\n     *\n     *\t\twriter.createEmptyElement( 'img' );\n     *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {Object} [options] Element's options.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n     */\n    createEmptyElement(name, attributes, options = {}) {\n        const emptyElement = new EmptyElement(this.document, name, attributes);\n        if (options.renderUnsafeAttributes) {\n            emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n        }\n        return emptyElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/uielement~UIElement}.\n     *\n     *\t\twriter.createUIElement( 'span' );\n     *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n     *\n     * A custom render function can be provided as the third parameter:\n     *\n     *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n     *\t\t\tconst domElement = this.toDomElement( domDocument );\n     *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n     *\n     *\t\t\treturn domElement;\n     *\t\t} );\n     *\n     * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,\n     * they are ignored by the editor selection system.\n     *\n     * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.\n     *\n     * @param {String} name The name of the element.\n     * @param {Object} [attributes] Element attributes.\n     * @param {Function} [renderFunction] A custom render function.\n     * @returns {module:engine/view/uielement~UIElement} The created element.\n     */\n    createUIElement(name, attributes, renderFunction) {\n        const uiElement = new UIElement(this.document, name, attributes);\n        if (renderFunction) {\n            uiElement.render = renderFunction;\n        }\n        return uiElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/rawelement~RawElement}.\n     *\n     *\t\twriter.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {\n     *\t\t\tdomElement.innerHTML = '<b>This is the raw content of the raw element.</b>';\n     *\t\t} );\n     *\n     * Raw elements work as data containers (\"wrappers\", \"sandboxes\") but their children are not managed or\n     * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures\n     * in the editor content without, for instance, worrying about compatibility with other editor features.\n     * Raw elements are a perfect tool for integration with external frameworks and data sources.\n     *\n     * Unlike {@link #createUIElement UI elements}, raw elements act like \"real\" editor content (similar to\n     * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),\n     * and they are considered by the editor selection.\n     *\n     * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}\n     * instead.\n     *\n     * @param {String} name The name of the element.\n     * @param {Object} [attributes] Element attributes.\n     * @param {Function} [renderFunction] A custom render function.\n     * @param {Object} [options] Element's options.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/rawelement~RawElement} The created element.\n     */\n    createRawElement(name, attributes, renderFunction, options = {}) {\n        const rawElement = new RawElement(this.document, name, attributes);\n        if (renderFunction) {\n            rawElement.render = renderFunction;\n        }\n        if (options.renderUnsafeAttributes) {\n            rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);\n        }\n        return rawElement;\n    }\n    /**\n     * Adds or overwrites the element's attribute with a specified key and value.\n     *\n     *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n     *\n     * @param {String} key The attribute key.\n     * @param {String} value The attribute value.\n     * @param {module:engine/view/element~Element} element\n     */\n    setAttribute(key, value, element) {\n        element._setAttribute(key, value);\n    }\n    /**\n     * Removes attribute from the element.\n     *\n     *\t\twriter.removeAttribute( 'href', linkElement );\n     *\n     * @param {String} key Attribute key.\n     * @param {module:engine/view/element~Element} element\n     */\n    removeAttribute(key, element) {\n        element._removeAttribute(key);\n    }\n    /**\n     * Adds specified class to the element.\n     *\n     *\t\twriter.addClass( 'foo', linkElement );\n     *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n     *\n     * @param {Array.<String>|String} className\n     * @param {module:engine/view/element~Element} element\n     */\n    addClass(className, element) {\n        element._addClass(className);\n    }\n    /**\n     * Removes specified class from the element.\n     *\n     *\t\twriter.removeClass( 'foo', linkElement );\n     *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n     *\n     * @param {Array.<String>|String} className\n     * @param {module:engine/view/element~Element} element\n     */\n    removeClass(className, element) {\n        element._removeClass(className);\n    }\n    setStyle(property, value, element) {\n        if (isPlainObject(property) && element === undefined) {\n            value._setStyle(property);\n        }\n        else {\n            element._setStyle(property, value);\n        }\n    }\n    /**\n     * Removes specified style from the element.\n     *\n     *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n     *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n     *\n     * **Note**: This method can work with normalized style names if\n     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n     *\n     * @param {Array.<String>|String} property\n     * @param {module:engine/view/element~Element} element\n     */\n    removeStyle(property, element) {\n        element._removeStyle(property);\n    }\n    /**\n     * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n     * so they can be used to add special data to elements.\n     *\n     * @param {String|Symbol} key\n     * @param {*} value\n     * @param {module:engine/view/element~Element} element\n     */\n    setCustomProperty(key, value, element) {\n        element._setCustomProperty(key, value);\n    }\n    /**\n     * Removes a custom property stored under the given key.\n     *\n     * @param {String|Symbol} key\n     * @param {module:engine/view/element~Element} element\n     * @returns {Boolean} Returns true if property was removed.\n     */\n    removeCustomProperty(key, element) {\n        return element._removeCustomProperty(key);\n    }\n    /**\n     * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements\n     * up to their first ancestor that is a container element.\n     *\n     * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:\n     *\n     *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n     *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n     *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n     *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n     *\n     * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n     *\n     * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n     * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.\n     *\n     * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * when the {@link module:engine/view/range~Range#start start}\n     * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n     *\n     * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n     *\n     * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n     * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange The position where\n     * to break attribute elements.\n     * @returns {module:engine/view/position~Position|module:engine/view/range~Range} The new position or range, after breaking the\n     * attribute elements.\n     */\n    breakAttributes(positionOrRange) {\n        if (positionOrRange instanceof Position) {\n            return this._breakAttributes(positionOrRange);\n        }\n        else {\n            return this._breakAttributesRange(positionOrRange);\n        }\n    }\n    /**\n     * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.\n     * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element\n     * if the position is at the beginning or at the end of its parent element.\n     *\n     *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n     *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n     *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n     *\t\t<p>foobar^</p> -> <p>foobar</p>^\n     *\n     * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n     * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n     * @param {module:engine/view/position~Position} position The position where to break the element.\n     * @returns {module:engine/view/position~Position} The position between broken elements. If an element has not been broken,\n     * the returned position is placed either before or after it.\n     */\n    breakContainer(position) {\n        const element = position.parent;\n        if (!(element.is('containerElement'))) {\n            /**\n             * Trying to break an element which is not a container element.\n             *\n             * @error view-writer-break-non-container-element\n             */\n            throw new CKEditorError('view-writer-break-non-container-element', this.document);\n        }\n        if (!element.parent) {\n            /**\n             * Trying to break root element.\n             *\n             * @error view-writer-break-root\n             */\n            throw new CKEditorError('view-writer-break-root', this.document);\n        }\n        if (position.isAtStart) {\n            return Position._createBefore(element);\n        }\n        else if (!position.isAtEnd) {\n            const newElement = element._clone(false);\n            this.insert(Position._createAfter(element), newElement);\n            const sourceRange = new Range(position, Position._createAt(element, 'end'));\n            const targetPosition = new Position(newElement, 0);\n            this.move(sourceRange, targetPosition);\n        }\n        return Position._createAfter(element);\n    }\n    /**\n     * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n     * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n     *\n     * In following examples `<p>` is a container and `<b>` is an attribute element:\n     *\n     *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n     *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n     *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n     *\n     * It will also take care about empty attributes when merging:\n     *\n     *\t\t<p><b>[]</b></p> -> <p>[]</p>\n     *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n     *\n     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n     * @param {module:engine/view/position~Position} position Merge position.\n     * @returns {module:engine/view/position~Position} Position after merge.\n     */\n    mergeAttributes(position) {\n        const positionOffset = position.offset;\n        const positionParent = position.parent;\n        // When inside text node - nothing to merge.\n        if (positionParent.is('$text')) {\n            return position;\n        }\n        // When inside empty attribute - remove it.\n        if (positionParent.is('attributeElement') && positionParent.childCount === 0) {\n            const parent = positionParent.parent;\n            const offset = positionParent.index;\n            positionParent._remove();\n            this._removeFromClonedElementsGroup(positionParent);\n            return this.mergeAttributes(new Position(parent, offset));\n        }\n        const nodeBefore = positionParent.getChild(positionOffset - 1);\n        const nodeAfter = positionParent.getChild(positionOffset);\n        // Position should be placed between two nodes.\n        if (!nodeBefore || !nodeAfter) {\n            return position;\n        }\n        // When position is between two text nodes.\n        if (nodeBefore.is('$text') && nodeAfter.is('$text')) {\n            return mergeTextNodes(nodeBefore, nodeAfter);\n        }\n        // When position is between two same attribute elements.\n        else if (nodeBefore.is('attributeElement') && nodeAfter.is('attributeElement') && nodeBefore.isSimilar(nodeAfter)) {\n            // Move all children nodes from node placed after selection and remove that node.\n            const count = nodeBefore.childCount;\n            nodeBefore._appendChild(nodeAfter.getChildren());\n            nodeAfter._remove();\n            this._removeFromClonedElementsGroup(nodeAfter);\n            // New position is located inside the first node, before new nodes.\n            // Call this method recursively to merge again if needed.\n            return this.mergeAttributes(new Position(nodeBefore, count));\n        }\n        return position;\n    }\n    /**\n     * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n     * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n     *\n     *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n     *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n     *\n     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n     * @param {module:engine/view/position~Position} position Merge position.\n     * @returns {module:engine/view/position~Position} Position after merge.\n     */\n    mergeContainers(position) {\n        const prev = position.nodeBefore;\n        const next = position.nodeAfter;\n        if (!prev || !next || !prev.is('containerElement') || !next.is('containerElement')) {\n            /**\n             * Element before and after given position cannot be merged.\n             *\n             * @error view-writer-merge-containers-invalid-position\n             */\n            throw new CKEditorError('view-writer-merge-containers-invalid-position', this.document);\n        }\n        const lastChild = prev.getChild(prev.childCount - 1);\n        const newPosition = lastChild instanceof Text ? Position._createAt(lastChild, 'end') : Position._createAt(prev, 'end');\n        this.move(Range._createIn(next), Position._createAt(prev, 'end'));\n        this.remove(Range._createOn(next));\n        return newPosition;\n    }\n    /**\n     * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion\n     * and merging them afterwards.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n     * contains instances that are not {@link module:engine/view/text~Text Texts},\n     * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n     * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n     * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n     * {@link module:engine/view/rawelement~RawElement RawElements} or\n     * {@link module:engine/view/uielement~UIElement UIElements}.\n     *\n     * @param {module:engine/view/position~Position} position Insertion position.\n     * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n     * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n     * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n     * Iterable.<module:engine/view/text~Text|\n     * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n     * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n     * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n     * @returns {module:engine/view/range~Range} Range around inserted nodes.\n     */\n    insert(position, nodes) {\n        nodes = isIterable(nodes) ? [...nodes] : [nodes];\n        // Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n        validateNodesToInsert(nodes, this.document);\n        // Group nodes in batches of nodes that require or do not require breaking an AttributeElements.\n        const nodeGroups = nodes.reduce((groups, node) => {\n            const lastGroup = groups[groups.length - 1];\n            // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n            // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n            const breakAttributes = !node.is('uiElement');\n            if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {\n                groups.push({\n                    breakAttributes,\n                    nodes: [node]\n                });\n            }\n            else {\n                lastGroup.nodes.push(node);\n            }\n            return groups;\n        }, []);\n        // Insert nodes in batches.\n        let start = null;\n        let end = position;\n        for (const { nodes, breakAttributes } of nodeGroups) {\n            const range = this._insertNodes(end, nodes, breakAttributes);\n            if (!start) {\n                start = range.start;\n            }\n            end = range.end;\n        }\n        // When no nodes were inserted - return collapsed range.\n        if (!start) {\n            return new Range(position);\n        }\n        return new Range(start, end);\n    }\n    /**\n     * Removes provided range from the container.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n     * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n     * to a collapsed range showing the new position.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n     */\n    remove(rangeOrItem) {\n        const range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn(rangeOrItem);\n        validateRangeContainer(range, this.document);\n        // If range is collapsed - nothing to remove.\n        if (range.isCollapsed) {\n            return new DocumentFragment(this.document);\n        }\n        // Break attributes at range start and end.\n        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);\n        const parentContainer = breakStart.parent;\n        const count = breakEnd.offset - breakStart.offset;\n        // Remove nodes in range.\n        const removed = parentContainer._removeChildren(breakStart.offset, count);\n        for (const node of removed) {\n            this._removeFromClonedElementsGroup(node);\n        }\n        // Merge after removing.\n        const mergePosition = this.mergeAttributes(breakStart);\n        range.start = mergePosition;\n        range.end = mergePosition.clone();\n        // Return removed nodes.\n        return new DocumentFragment(this.document, removed);\n    }\n    /**\n     * Removes matching elements from given range.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range} range Range to clear.\n     * @param {module:engine/view/element~Element} element Element to remove.\n     */\n    clear(range, element) {\n        validateRangeContainer(range, this.document);\n        // Create walker on given range.\n        // We walk backward because when we remove element during walk it modifies range end position.\n        const walker = range.getWalker({\n            direction: 'backward',\n            ignoreElementEnd: true\n        });\n        // Let's walk.\n        for (const current of walker) {\n            const item = current.item;\n            let rangeToRemove;\n            // When current item matches to the given element.\n            if (item.is('element') && element.isSimilar(item)) {\n                // Create range on this element.\n                rangeToRemove = Range._createOn(item);\n                // When range starts inside Text or TextProxy element.\n            }\n            else if (!current.nextPosition.isAfter(range.start) && item.is('$textProxy')) {\n                // We need to check if parent of this text matches to given element.\n                const parentElement = item.getAncestors().find(ancestor => {\n                    return ancestor.is('element') && element.isSimilar(ancestor);\n                });\n                // If it is then create range inside this element.\n                if (parentElement) {\n                    rangeToRemove = Range._createIn(parentElement);\n                }\n            }\n            // If we have found element to remove.\n            if (rangeToRemove) {\n                // We need to check if element range stick out of the given range and truncate if it is.\n                if (rangeToRemove.end.isAfter(range.end)) {\n                    rangeToRemove.end = range.end;\n                }\n                if (rangeToRemove.start.isBefore(range.start)) {\n                    rangeToRemove.start = range.start;\n                }\n                // At the end we remove range with found element.\n                this.remove(rangeToRemove);\n            }\n        }\n    }\n    /**\n     * Moves nodes from provided range to target position.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n     * @param {module:engine/view/position~Position} targetPosition Position to insert.\n     * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n     */\n    move(sourceRange, targetPosition) {\n        let nodes;\n        if (targetPosition.isAfter(sourceRange.end)) {\n            targetPosition = this._breakAttributes(targetPosition, true);\n            const parent = targetPosition.parent;\n            const countBefore = parent.childCount;\n            sourceRange = this._breakAttributesRange(sourceRange, true);\n            nodes = this.remove(sourceRange);\n            targetPosition.offset += (parent.childCount - countBefore);\n        }\n        else {\n            nodes = this.remove(sourceRange);\n        }\n        return this.insert(targetPosition, nodes);\n    }\n    /**\n     * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n     *\n     * If a collapsed range was passed and is same as selection, the selection\n     * will be moved to the inside of the wrapped attribute element.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n     * when {@link module:engine/view/range~Range#start}\n     * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n     * is collapsed and different than view selection.\n     *\n     * @param {module:engine/view/range~Range} range Range to wrap.\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n     * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n     */\n    wrap(range, attribute) {\n        if (!(attribute instanceof AttributeElement)) {\n            throw new CKEditorError('view-writer-wrap-invalid-attribute', this.document);\n        }\n        validateRangeContainer(range, this.document);\n        if (!range.isCollapsed) {\n            // Non-collapsed range. Wrap it with the attribute element.\n            return this._wrapRange(range, attribute);\n        }\n        else {\n            // Collapsed range. Wrap position.\n            let position = range.start;\n            if (position.parent.is('element') && !_hasNonUiChildren(position.parent)) {\n                position = position.getLastMatchingPosition(value => value.item.is('uiElement'));\n            }\n            position = this._wrapPosition(position, attribute);\n            const viewSelection = this.document.selection;\n            // If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n            if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {\n                this.setSelection(position);\n            }\n            return new Range(position);\n        }\n    }\n    /**\n     * Unwraps nodes within provided range from attribute element.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range} range\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute\n     */\n    unwrap(range, attribute) {\n        if (!(attribute instanceof AttributeElement)) {\n            /**\n             * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#unwrap `DowncastWriter#unwrap()`}\n             * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n             *\n             * @error view-writer-unwrap-invalid-attribute\n             */\n            throw new CKEditorError('view-writer-unwrap-invalid-attribute', this.document);\n        }\n        validateRangeContainer(range, this.document);\n        // If range is collapsed - nothing to unwrap.\n        if (range.isCollapsed) {\n            return range;\n        }\n        // Break attributes at range start and end.\n        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);\n        const parentContainer = breakStart.parent;\n        // Unwrap children located between break points.\n        const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);\n        // Merge attributes at the both ends and return a new range.\n        const start = this.mergeAttributes(newRange.start);\n        // If start position was merged - move end position back.\n        if (!start.isEqual(newRange.start)) {\n            newRange.end.offset--;\n        }\n        const end = this.mergeAttributes(newRange.end);\n        return new Range(start, end);\n    }\n    /**\n     * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n     * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n     * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n     *\n     * New element has to be created because `Element#tagName` property in DOM is readonly.\n     *\n     * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n     *\n     * @param {String} newName New name for element.\n     * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n     * @returns {module:engine/view/containerelement~ContainerElement} Element created due to rename.\n     */\n    rename(newName, viewElement) {\n        const newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());\n        this.insert(Position._createAfter(viewElement), newElement);\n        this.move(Range._createIn(viewElement), Position._createAt(newElement, 0));\n        this.remove(Range._createOn(viewElement));\n        return newElement;\n    }\n    /**\n     * Cleans up memory by removing obsolete cloned elements group from the writer.\n     *\n     * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n     * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n     * the group will no longer be needed.\n     *\n     * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n     * were removed from the view.\n     *\n     * Keep in mind that group names are equal to the `id` property of the attribute element.\n     *\n     * @param {String} groupName Name of the group to clear.\n     */\n    clearClonedElementsGroup(groupName) {\n        this._cloneGroups.delete(groupName);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/view/position~Position position},\n     * * parent element and offset (offset defaults to `0`),\n     * * parent element and `'end'` (sets position at the end of that element),\n     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n     *\n     * This method is a shortcut to other constructors such as:\n     *\n     * * {@link #createPositionBefore},\n     * * {@link #createPositionAfter},\n     *\n     * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     * @returns {module:engine/view/position~Position}\n     */\n    createPositionAt(itemOrPosition, offset) {\n        return Position._createAt(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new position after given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item after which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n    createPositionAfter(item) {\n        return Position._createAfter(item);\n    }\n    /**\n     * Creates a new position before given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item before which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n    createPositionBefore(item) {\n        return Position._createBefore(item);\n    }\n    /**\n     * Creates a range spanning from `start` position to `end` position.\n     *\n     * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n     *\n     * @param {module:engine/view/position~Position} start Start position.\n     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n     * @returns {module:engine/view/range~Range}\n     */\n    createRange(...args) {\n        return new Range(...args);\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n     *\n     * @param {module:engine/view/item~Item} item\n     * @returns {module:engine/view/range~Range}\n     */\n    createRangeOn(item) {\n        return Range._createOn(item);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/view/range~Range}\n     */\n    createRangeIn(element) {\n        return Range._createIn(element);\n    }\n    /**\n     * Creates new {@link module:engine/view/selection~Selection} instance.\n     *\n     * \t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the document selection.\n     *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n     *\n     * \t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates collapsed selection at the position of given item and offset.\n     *\t\tconst paragraph = writer.createContainerElement( 'p' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n     *\n     * @param {module:engine/view/selection~Selectable} [selectable=null]\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     * @returns {module:engine/view/selection~Selection}\n     */\n    createSelection(...args) {\n        return new Selection(...args);\n    }\n    /**\n     * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n     * `elementToStructure()`} conversion helper.\n     *\n     *\t\tconst viewSlot = conversionApi.writer.createSlot();\n     *\t\tconst viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );\n     *\n     *\t\tconversionApi.writer.insert( viewPosition, viewSlot );\n     *\n     * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):\n     *\n     *\t\tconst viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );\n     *\t\tconst viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );\n     *\n     *\t\tconversionApi.writer.insert( viewPosition, viewSlot );\n     *\n     * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into\n     * multiple slots.\n     *\n     * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.\n     *\n     * @param {'children'|module:engine/conversion/downcasthelpers~SlotFilter} [modeOrFilter='children'] The filter for child nodes.\n     * @returns {module:engine/view/element~Element} The slot element to be placed in to the view structure while processing\n     * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.\n     */\n    createSlot(modeOrFilter) {\n        if (!this._slotFactory) {\n            /**\n             * The `createSlot()` method is only allowed inside the `elementToStructure` downcast helper callback.\n             *\n             * @error view-writer-invalid-create-slot-context\n             */\n            throw new CKEditorError('view-writer-invalid-create-slot-context', this.document);\n        }\n        return this._slotFactory(this, modeOrFilter);\n    }\n    /**\n     * Registers a slot factory.\n     *\n     * @protected\n     * @param {Function} slotFactory The slot factory.\n     */\n    _registerSlotFactory(slotFactory) {\n        this._slotFactory = slotFactory;\n    }\n    /**\n     * Clears the registered slot factory.\n     *\n     * @protected\n     */\n    _clearSlotFactory() {\n        this._slotFactory = null;\n    }\n    /**\n     * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion\n     * and merging them afterwards if requested by the breakAttributes param.\n     *\n     * @private\n     * @param {module:engine/view/position~Position} position Insertion position.\n     * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n     * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n     * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n     * Iterable.<module:engine/view/text~Text|\n     * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n     * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n     * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n     * @param {Boolean} breakAttributes Whether attributes should be broken.\n     * @returns {module:engine/view/range~Range} Range around inserted nodes.\n     */\n    _insertNodes(position, nodes, breakAttributes) {\n        let parentElement;\n        // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n        // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n        if (breakAttributes) {\n            parentElement = getParentContainer(position);\n        }\n        else {\n            parentElement = position.parent.is('$text') ? position.parent.parent : position.parent;\n        }\n        if (!parentElement) {\n            /**\n             * Position's parent container cannot be found.\n             *\n             * @error view-writer-invalid-position-container\n             */\n            throw new CKEditorError('view-writer-invalid-position-container', this.document);\n        }\n        let insertionPosition;\n        if (breakAttributes) {\n            insertionPosition = this._breakAttributes(position, true);\n        }\n        else {\n            insertionPosition = position.parent.is('$text') ? breakTextNode(position) : position;\n        }\n        const length = parentElement._insertChild(insertionPosition.offset, nodes);\n        for (const node of nodes) {\n            this._addToClonedElementsGroup(node);\n        }\n        const endPosition = insertionPosition.getShiftedBy(length);\n        const start = this.mergeAttributes(insertionPosition);\n        // If start position was merged - move end position.\n        if (!start.isEqual(insertionPosition)) {\n            endPosition.offset--;\n        }\n        const end = this.mergeAttributes(endPosition);\n        return new Range(start, end);\n    }\n    /**\n     * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n     * `startOffset` and `endOffset` will be wrapped.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} parent\n     * @param {Number} startOffset\n     * @param {Number} endOffset\n     * @param {module:engine/view/element~Element} wrapElement\n     */\n    _wrapChildren(parent, startOffset, endOffset, wrapElement) {\n        let i = startOffset;\n        const wrapPositions = [];\n        while (i < endOffset) {\n            const child = parent.getChild(i);\n            const isText = child.is('$text');\n            const isAttribute = child.is('attributeElement');\n            //\n            // (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n            //\n            // Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n            // If possible, join elements.\n            //\n            // <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n            //\n            if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {\n                wrapPositions.push(new Position(parent, i));\n            }\n            //\n            // Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n            // `wrapElement` (due to priority).\n            //\n            // <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n            // <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n            else if (isText || !isAttribute || shouldABeOutsideB(wrapElement, child)) {\n                // Clone attribute.\n                const newAttribute = wrapElement._clone();\n                // Wrap current node with new attribute.\n                child._remove();\n                newAttribute._appendChild(child);\n                parent._insertChild(i, newAttribute);\n                this._addToClonedElementsGroup(newAttribute);\n                wrapPositions.push(new Position(parent, i));\n            }\n            //\n            // If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n            //\n            // <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n            //\n            else /* if ( isAttribute ) */ {\n                this._wrapChildren(child, 0, child.childCount, wrapElement);\n            }\n            i++;\n        }\n        // Merge at each wrap.\n        let offsetChange = 0;\n        for (const position of wrapPositions) {\n            position.offset -= offsetChange;\n            // Do not merge with elements outside selected children.\n            if (position.offset == startOffset) {\n                continue;\n            }\n            const newPosition = this.mergeAttributes(position);\n            // If nodes were merged - other merge offsets will change.\n            if (!newPosition.isEqual(position)) {\n                offsetChange++;\n                endOffset--;\n            }\n        }\n        return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n    }\n    /**\n     * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n     * `startOffset` and `endOffset` will be unwrapped.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} parent\n     * @param {Number} startOffset\n     * @param {Number} endOffset\n     * @param {module:engine/view/element~Element} unwrapElement\n     */\n    _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {\n        let i = startOffset;\n        const unwrapPositions = [];\n        // Iterate over each element between provided offsets inside parent.\n        // We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n        // so it could get messy. It is safer to it manually in this case.\n        while (i < endOffset) {\n            const child = parent.getChild(i);\n            // Skip all text nodes. There should be no container element's here either.\n            if (!child.is('attributeElement')) {\n                i++;\n                continue;\n            }\n            //\n            // (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n            //\n            // If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n            //\n            // <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n            //\n            if (child.isSimilar(unwrapElement)) {\n                const unwrapped = child.getChildren();\n                const count = child.childCount;\n                // Replace wrapper element with its children\n                child._remove();\n                parent._insertChild(i, unwrapped);\n                this._removeFromClonedElementsGroup(child);\n                // Save start and end position of moved items.\n                unwrapPositions.push(new Position(parent, i), new Position(parent, i + count));\n                // Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n                i += count;\n                endOffset += count - 1;\n                continue;\n            }\n            //\n            // If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n            // Partial unwrapping will happen only if the elements have the same name.\n            //\n            // <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n            // <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n            //\n            if (this._unwrapAttributeElement(unwrapElement, child)) {\n                unwrapPositions.push(new Position(parent, i), new Position(parent, i + 1));\n                i++;\n                continue;\n            }\n            //\n            // If other nested attribute is found, look through it's children for elements to unwrap.\n            //\n            // <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n            //\n            this._unwrapChildren(child, 0, child.childCount, unwrapElement);\n            i++;\n        }\n        // Merge at each unwrap.\n        let offsetChange = 0;\n        for (const position of unwrapPositions) {\n            position.offset -= offsetChange;\n            // Do not merge with elements outside selected children.\n            if (position.offset == startOffset || position.offset == endOffset) {\n                continue;\n            }\n            const newPosition = this.mergeAttributes(position);\n            // If nodes were merged - other merge offsets will change.\n            if (!newPosition.isEqual(position)) {\n                offsetChange++;\n                endOffset--;\n            }\n        }\n        return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n    }\n    /**\n     * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n     * This method will also merge newly added attribute element with its siblings whenever possible.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     *\n     * @private\n     * @param {module:engine/view/range~Range} range\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute\n     * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n     */\n    _wrapRange(range, attribute) {\n        // Break attributes at range start and end.\n        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);\n        const parentContainer = breakStart.parent;\n        // Wrap all children with attribute.\n        const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);\n        // Merge attributes at the both ends and return a new range.\n        const start = this.mergeAttributes(newRange.start);\n        // If start position was merged - move end position back.\n        if (!start.isEqual(newRange.start)) {\n            newRange.end.offset--;\n        }\n        const end = this.mergeAttributes(newRange.end);\n        return new Range(start, end);\n    }\n    /**\n     * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n     * This method will also merge newly added attribute element with its siblings whenever possible.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     *\n     * @private\n     * @param {module:engine/view/position~Position} position\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute\n     * @returns {module:engine/view/position~Position} New position after wrapping.\n     */\n    _wrapPosition(position, attribute) {\n        // Return same position when trying to wrap with attribute similar to position parent.\n        if (attribute.isSimilar(position.parent)) {\n            return movePositionToTextNode(position.clone());\n        }\n        // When position is inside text node - break it and place new position between two text nodes.\n        if (position.parent.is('$text')) {\n            position = breakTextNode(position);\n        }\n        // Create fake element that will represent position, and will not be merged with other attributes.\n        const fakeElement = this.createAttributeElement('_wrapPosition-fake-element');\n        fakeElement._priority = Number.POSITIVE_INFINITY;\n        fakeElement.isSimilar = () => false;\n        // Insert fake element in position location.\n        position.parent._insertChild(position.offset, fakeElement);\n        // Range around inserted fake attribute element.\n        const wrapRange = new Range(position, position.getShiftedBy(1));\n        // Wrap fake element with attribute (it will also merge if possible).\n        this.wrap(wrapRange, attribute);\n        // Remove fake element and place new position there.\n        const newPosition = new Position(fakeElement.parent, fakeElement.index);\n        fakeElement._remove();\n        // If position is placed between text nodes - merge them and return position inside.\n        const nodeBefore = newPosition.nodeBefore;\n        const nodeAfter = newPosition.nodeAfter;\n        if (nodeBefore instanceof Text && nodeAfter instanceof Text) {\n            return mergeTextNodes(nodeBefore, nodeAfter);\n        }\n        // If position is next to text node - move position inside.\n        return movePositionToTextNode(newPosition);\n    }\n    /**\n     * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n     * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n     * \telement to element being wrapped.\n     *\n     * \t@private\n     * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n     * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n     * \t@returns {Boolean} Returns `true` if elements are merged.\n     */\n    _wrapAttributeElement(wrapper, toWrap) {\n        if (!canBeJoined(wrapper, toWrap)) {\n            return false;\n        }\n        // Can't merge if name or priority differs.\n        if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {\n            return false;\n        }\n        // Check if attributes can be merged.\n        for (const key of wrapper.getAttributeKeys()) {\n            // Classes and styles should be checked separately.\n            if (key === 'class' || key === 'style') {\n                continue;\n            }\n            // If some attributes are different we cannot wrap.\n            if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n                return false;\n            }\n        }\n        // Check if styles can be merged.\n        for (const key of wrapper.getStyleNames()) {\n            if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {\n                return false;\n            }\n        }\n        // Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n        for (const key of wrapper.getAttributeKeys()) {\n            // Classes and styles should be checked separately.\n            if (key === 'class' || key === 'style') {\n                continue;\n            }\n            // Move only these attributes that are not present - other are similar.\n            if (!toWrap.hasAttribute(key)) {\n                this.setAttribute(key, wrapper.getAttribute(key), toWrap);\n            }\n        }\n        for (const key of wrapper.getStyleNames()) {\n            if (!toWrap.hasStyle(key)) {\n                this.setStyle(key, wrapper.getStyle(key), toWrap);\n            }\n        }\n        for (const key of wrapper.getClassNames()) {\n            if (!toWrap.hasClass(key)) {\n                this.addClass(key, toWrap);\n            }\n        }\n        return true;\n    }\n    /**\n     * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n     * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n     * inside element being unwrapped.\n     *\n     * @private\n     * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n     * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n     * @returns {Boolean} Returns `true` if elements are unwrapped.\n     **/\n    _unwrapAttributeElement(wrapper, toUnwrap) {\n        if (!canBeJoined(wrapper, toUnwrap)) {\n            return false;\n        }\n        // Can't unwrap if name or priority differs.\n        if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {\n            return false;\n        }\n        // Check if AttributeElement has all wrapper attributes.\n        for (const key of wrapper.getAttributeKeys()) {\n            // Classes and styles should be checked separately.\n            if (key === 'class' || key === 'style') {\n                continue;\n            }\n            // If some attributes are missing or different we cannot unwrap.\n            if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n                return false;\n            }\n        }\n        // Check if AttributeElement has all wrapper classes.\n        if (!toUnwrap.hasClass(...wrapper.getClassNames())) {\n            return false;\n        }\n        // Check if AttributeElement has all wrapper styles.\n        for (const key of wrapper.getStyleNames()) {\n            // If some styles are missing or different we cannot unwrap.\n            if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {\n                return false;\n            }\n        }\n        // Remove all wrapper's attributes from unwrapped element.\n        for (const key of wrapper.getAttributeKeys()) {\n            // Classes and styles should be checked separately.\n            if (key === 'class' || key === 'style') {\n                continue;\n            }\n            this.removeAttribute(key, toUnwrap);\n        }\n        // Remove all wrapper's classes from unwrapped element.\n        this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap);\n        // Remove all wrapper's styles from unwrapped element.\n        this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);\n        return true;\n    }\n    /**\n     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n     *\n     * @private\n     * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n     * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n     * @returns {module:engine/view/range~Range} New range with located at break positions.\n     */\n    _breakAttributesRange(range, forceSplitText = false) {\n        const rangeStart = range.start;\n        const rangeEnd = range.end;\n        validateRangeContainer(range, this.document);\n        // Break at the collapsed position. Return new collapsed range.\n        if (range.isCollapsed) {\n            const position = this._breakAttributes(range.start, forceSplitText);\n            return new Range(position, position);\n        }\n        const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);\n        const count = breakEnd.parent.childCount;\n        const breakStart = this._breakAttributes(rangeStart, forceSplitText);\n        // Calculate new break end offset.\n        breakEnd.offset += breakEnd.parent.childCount - count;\n        return new Range(breakStart, breakEnd);\n    }\n    /**\n     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n     * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n     * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n     *\n     * @private\n     * @param {module:engine/view/position~Position} position Position where to break attributes.\n     * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n     * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n     */\n    _breakAttributes(position, forceSplitText = false) {\n        const positionOffset = position.offset;\n        const positionParent = position.parent;\n        // If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n        if (position.parent.is('emptyElement')) {\n            /**\n             * Cannot break an `EmptyElement` instance.\n             *\n             * This error is thrown if\n             * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n             * was executed in an incorrect position.\n             *\n             * @error view-writer-cannot-break-empty-element\n             */\n            throw new CKEditorError('view-writer-cannot-break-empty-element', this.document);\n        }\n        // If position is placed inside UIElement - throw an exception as we cannot break inside.\n        if (position.parent.is('uiElement')) {\n            /**\n             * Cannot break a `UIElement` instance.\n             *\n             * This error is thrown if\n             * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n             * was executed in an incorrect position.\n             *\n             * @error view-writer-cannot-break-ui-element\n             */\n            throw new CKEditorError('view-writer-cannot-break-ui-element', this.document);\n        }\n        // If position is placed inside RawElement - throw an exception as we cannot break inside.\n        if (position.parent.is('rawElement')) {\n            /**\n             * Cannot break a `RawElement` instance.\n             *\n             * This error is thrown if\n             * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n             * was executed in an incorrect position.\n             *\n             * @error view-writer-cannot-break-raw-element\n             */\n            throw new CKEditorError('view-writer-cannot-break-raw-element', this.document);\n        }\n        // There are no attributes to break and text nodes breaking is not forced.\n        if (!forceSplitText && positionParent.is('$text') && isContainerOrFragment(positionParent.parent)) {\n            return position.clone();\n        }\n        // Position's parent is container, so no attributes to break.\n        if (isContainerOrFragment(positionParent)) {\n            return position.clone();\n        }\n        // Break text and start again in new position.\n        if (positionParent.is('$text')) {\n            return this._breakAttributes(breakTextNode(position), forceSplitText);\n        }\n        const length = positionParent.childCount;\n        // <p>foo<b><u>bar{}</u></b></p>\n        // <p>foo<b><u>bar</u>[]</b></p>\n        // <p>foo<b><u>bar</u></b>[]</p>\n        if (positionOffset == length) {\n            const newPosition = new Position(positionParent.parent, positionParent.index + 1);\n            return this._breakAttributes(newPosition, forceSplitText);\n        }\n        else {\n            // <p>foo<b><u>{}bar</u></b></p>\n            // <p>foo<b>[]<u>bar</u></b></p>\n            // <p>foo{}<b><u>bar</u></b></p>\n            if (positionOffset === 0) {\n                const newPosition = new Position(positionParent.parent, positionParent.index);\n                return this._breakAttributes(newPosition, forceSplitText);\n            }\n            // <p>foo<b><u>b{}ar</u></b></p>\n            // <p>foo<b><u>b[]ar</u></b></p>\n            // <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n            // <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n            else {\n                const offsetAfter = positionParent.index + 1;\n                // Break element.\n                const clonedNode = positionParent._clone();\n                // Insert cloned node to position's parent node.\n                positionParent.parent._insertChild(offsetAfter, clonedNode);\n                this._addToClonedElementsGroup(clonedNode);\n                // Get nodes to move.\n                const count = positionParent.childCount - positionOffset;\n                const nodesToMove = positionParent._removeChildren(positionOffset, count);\n                // Move nodes to cloned node.\n                clonedNode._appendChild(nodesToMove);\n                // Create new position to work on.\n                const newPosition = new Position(positionParent.parent, offsetAfter);\n                return this._breakAttributes(newPosition, forceSplitText);\n            }\n        }\n    }\n    /**\n     * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n     * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n     * from the group now keep a reference to the given attribute element.\n     *\n     * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n     *\n     * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     *\n     * @private\n     * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n     */\n    _addToClonedElementsGroup(element) {\n        // Add only if the element is in document tree.\n        if (!element.root.is('rootElement')) {\n            return;\n        }\n        // Traverse the element's children recursively to find other attribute elements that also might got inserted.\n        // The loop is at the beginning so we can make fast returns later in the code.\n        if (element.is('element')) {\n            for (const child of element.getChildren()) {\n                this._addToClonedElementsGroup(child);\n            }\n        }\n        const id = element.id;\n        if (!id) {\n            return;\n        }\n        let group = this._cloneGroups.get(id);\n        if (!group) {\n            group = new Set();\n            this._cloneGroups.set(id, group);\n        }\n        group.add(element);\n        element._clonesGroup = group;\n    }\n    /**\n     * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n     * from its clones group.\n     *\n     * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n     * This allows to reference the whole group even if the element was already removed from the tree.\n     *\n     * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     *\n     * @private\n     * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n     */\n    _removeFromClonedElementsGroup(element) {\n        // Traverse the element's children recursively to find other attribute elements that also got removed.\n        // The loop is at the beginning so we can make fast returns later in the code.\n        if (element.is('element')) {\n            for (const child of element.getChildren()) {\n                this._removeFromClonedElementsGroup(child);\n            }\n        }\n        const id = element.id;\n        if (!id) {\n            return;\n        }\n        const group = this._cloneGroups.get(id);\n        if (!group) {\n            return;\n        }\n        group.delete(element);\n        // Not removing group from element on purpose!\n        // If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n    }\n}\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren(parent) {\n    return Array.from(parent.getChildren()).some(child => !child.is('uiElement'));\n}\n/**\n * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`}\n * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer(position) {\n    let parent = position.parent;\n    while (!isContainerOrFragment(parent)) {\n        if (!parent) {\n            return undefined;\n        }\n        parent = parent.parent;\n    }\n    return parent;\n}\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped outside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB(a, b) {\n    if (a.priority < b.priority) {\n        return true;\n    }\n    else if (a.priority > b.priority) {\n        return false;\n    }\n    // When priorities are equal and names are different - use identities.\n    return a.getIdentity() < b.getIdentity();\n}\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode(position) {\n    const nodeBefore = position.nodeBefore;\n    if (nodeBefore && nodeBefore.is('$text')) {\n        return new Position(nodeBefore, nodeBefore.data.length);\n    }\n    const nodeAfter = position.nodeAfter;\n    if (nodeAfter && nodeAfter.is('$text')) {\n        return new Position(nodeAfter, 0);\n    }\n    return position;\n}\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode(position) {\n    if (position.offset == position.parent.data.length) {\n        return new Position(position.parent.parent, position.parent.index + 1);\n    }\n    if (position.offset === 0) {\n        return new Position(position.parent.parent, position.parent.index);\n    }\n    // Get part of the text that need to be moved.\n    const textToMove = position.parent.data.slice(position.offset);\n    // Leave rest of the text in position's parent.\n    position.parent._data = position.parent.data.slice(0, position.offset);\n    // Insert new text node after position's parent text node.\n    position.parent.parent._insertChild(position.parent.index + 1, new Text(position.root.document, textToMove));\n    // Return new position between two newly created text nodes.\n    return new Position(position.parent.parent, position.parent.index + 1);\n}\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes(t1, t2) {\n    // Merge text data into first text node and remove second one.\n    const nodeBeforeLength = t1.data.length;\n    t1._data += t2.data;\n    t2._remove();\n    return new Position(t1, nodeBeforeLength);\n}\nconst validNodesToInsert = [Text, AttributeElement, ContainerElement, EmptyElement, RawElement, UIElement];\n// Checks if provided nodes are valid to insert.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not supported ones (see error description for valid ones.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/element~Element> nodes\n// @param {Object} errorContext\nfunction validateNodesToInsert(nodes, errorContext) {\n    for (const node of nodes) {\n        if (!validNodesToInsert.some((validNode => node instanceof validNode))) { // eslint-disable-line no-use-before-define\n            /**\n             * One of the nodes to be inserted is of an invalid type.\n             *\n             * Nodes to be inserted with {@link module:engine/view/downcastwriter~DowncastWriter#insert `DowncastWriter#insert()`} should be\n             * of the following types:\n             *\n             * * {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n             * * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n             * * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n             * * {@link module:engine/view/uielement~UIElement UIElement},\n             * * {@link module:engine/view/rawelement~RawElement RawElement},\n             * * {@link module:engine/view/text~Text Text}.\n             *\n             * @error view-writer-insert-invalid-node-type\n             */\n            throw new CKEditorError('view-writer-insert-invalid-node-type', errorContext);\n        }\n        if (!node.is('$text')) {\n            validateNodesToInsert(node.getChildren(), errorContext);\n        }\n    }\n}\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment(node) {\n    return node && (node.is('containerElement') || node.is('documentFragment'));\n}\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\nfunction validateRangeContainer(range, errorContext) {\n    const startContainer = getParentContainer(range.start);\n    const endContainer = getParentContainer(range.end);\n    if (!startContainer || !endContainer || startContainer !== endContainer) {\n        /**\n         * The container of the given range is invalid.\n         *\n         * This may happen if {@link module:engine/view/range~Range#start range start} and\n         * {@link module:engine/view/range~Range#end range end} positions are not placed inside the same container element or\n         * a parent container for these positions cannot be found.\n         *\n         * Methods like {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#remove()`},\n         * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#clean()`},\n         * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`},\n         * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#unwrap()`} need to be called\n         * on a range that has its start and end positions located in the same container element. Both positions can be\n         * nested within other elements (e.g. an attribute element) but the closest container ancestor must be the same.\n         *\n         * @error view-writer-invalid-range-container\n         */\n        throw new CKEditorError('view-writer-invalid-range-container', errorContext);\n    }\n}\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined(a, b) {\n    return a.id === null && b.id === null;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,YAAY;AACjC,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,YAAY,MAAM,gBAAgB;AACzC,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,aAAa,MAAM,6CAA6C;AACvE,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,UAAU,MAAM,0CAA0C;AACjE,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,SAASC,aAAa,QAAQ,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,cAAc,CAAC;EAChC;AACJ;AACA;EACIC,WAAW,CAACC,QAAQ,EAAE;IAClB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IACxB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,IAAIC,GAAG,EAAE;IAC7B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,IAAI;EAC5B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,GAAU;IAClB,IAAI,CAACJ,QAAQ,CAACK,SAAS,CAACC,MAAM,CAAC,YAAO,CAAC;EAC3C;EACA;AACJ;AAC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/B,IAAI5C,aAAa,CAACsD,QAAQ,CAAC,IAAIV,OAAO,KAAKW,SAAS,EAAE;MAClDZ,KAAK,CAACa,SAAS,CAACF,QAAQ,CAAC;IAC7B,CAAC,MACI;MACDV,OAAO,CAACY,SAAS,CAACF,QAAQ,EAAEX,KAAK,CAAC;IACtC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIc,WAAW,CAACH,QAAQ,EAAEV,OAAO,EAAE;IAC3BA,OAAO,CAACc,YAAY,CAACJ,QAAQ,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,iBAAiB,CAACjB,GAAG,EAAEC,KAAK,EAAEC,OAAO,EAAE;IACnCA,OAAO,CAACgB,kBAAkB,CAAClB,GAAG,EAAEC,KAAK,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIkB,oBAAoB,CAACnB,GAAG,EAAEE,OAAO,EAAE;IAC/B,OAAOA,OAAO,CAACkB,qBAAqB,CAACpB,GAAG,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIqB,eAAe,CAACC,eAAe,EAAE;IAC7B,IAAIA,eAAe,YAAY7E,QAAQ,EAAE;MACrC,OAAO,IAAI,CAAC8E,gBAAgB,CAACD,eAAe,CAAC;IACjD,CAAC,MACI;MACD,OAAO,IAAI,CAACE,qBAAqB,CAACF,eAAe,CAAC;IACtD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,cAAc,CAACC,QAAQ,EAAE;IACrB,MAAMxB,OAAO,GAAGwB,QAAQ,CAACC,MAAM;IAC/B,IAAI,CAAEzB,OAAO,CAAC0B,EAAE,CAAC,kBAAkB,C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,CAAC8J,MAAM,CAACD,SAAS,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,gBAAgB,CAACC,cAAc,EAAEhF,MAAM,EAAE;IACrC,OAAOjG,QAAQ,CAAC4F,SAAS,CAACqF,cAAc,EAAEhF,MAAM,CAAC;EACrD;EACA;AACJ;AACA;AACA;AACA;AACA;EACIiF,mBAAmB,CAAC/B,IAAI,EAAE;IACtB,OAAOnJ,QAAQ,CAAC0F,YAAY,CAACyD,IAAI,CAAC;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIgC,oBAAoB,CAAChC,IAAI,EAAE;IACvB,OAAOnJ,QAAQ,CAACqF,aAAa,CAAC8D,IAAI,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIiC,WAAW,GAAU;IAAA,kCAANC,IAAI;MAAJA,IAAI;IAAA;IACf,OAAO,IAAIpL,KAAK,CAAC,GAAGoL,IAAI,CAAC;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,aAAa,CAACnC,IAAI,EAAE;IAChB,OAAOlJ,KAAK,CAACqH,SAAS,CAAC6B,IAAI,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIoC,aAAa,CAAC9H,OAAO,EAAE;IACnB,OAAOxD,KAAK,CAACmH,SAAS,CAAC3D,OAAO,CAAC;EACnC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+H,eAAe,GAAU;IAAA,mCAANH,IAAI;MAAJA,IAAI;IAAA;IACnB,OAAO,IAAInL,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"},"metadata":{},"sourceType":"module"}