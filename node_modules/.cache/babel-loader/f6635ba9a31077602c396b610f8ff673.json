{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/editor/editorui\n */\n\n/* globals console */\n\nimport ComponentFactory from '@ckeditor/ckeditor5-ui/src/componentfactory';\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport TooltipManager from '@ckeditor/ckeditor5-ui/src/tooltipmanager';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isVisible from '@ckeditor/ckeditor5-utils/src/dom/isvisible';\n\n/**\n * A class providing the minimal interface that is required to successfully bootstrap any editor UI.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class EditorUI {\n  /**\n   * Creates an instance of the editor UI class.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   */\n  constructor(editor) {\n    /**\n     * The editor that the UI belongs to.\n     *\n     * @readonly\n     * @member {module:core/editor/editor~Editor} #editor\n     */\n    this.editor = editor;\n\n    /**\n     * An instance of the {@link module:ui/componentfactory~ComponentFactory}, a registry used by plugins\n     * to register factories of specific UI components.\n     *\n     * @readonly\n     * @member {module:ui/componentfactory~ComponentFactory} #componentFactory\n     */\n    this.componentFactory = new ComponentFactory(editor);\n\n    /**\n     * Stores the information about the editor UI focus and propagates it so various plugins and components\n     * are unified as a focus group.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker} #focusTracker\n     */\n    this.focusTracker = new FocusTracker();\n\n    /**\n     * Manages the tooltips displayed on mouseover and focus across the UI.\n     *\n     * @readonly\n     * @member {module:ui/tooltipmanager~TooltipManager}\n     */\n    this.tooltipManager = new TooltipManager(editor);\n\n    /**\n     * Stores viewport offsets from every direction.\n     *\n     * Viewport offset can be used to constrain balloons or other UI elements into an element smaller than the viewport.\n     * This can be useful if there are any other absolutely positioned elements that may interfere with editor UI.\n     *\n     * Example `editor.ui.viewportOffset` returns:\n     *\n     * ```js\n     * {\n     * \ttop: 50,\n     * \tright: 50,\n     * \tbottom: 50,\n     * \tleft: 50\n     * }\n     * ```\n     *\n     * This property can be overriden after editor already being initialized:\n     *\n     * ```js\n     * editor.ui.viewportOffset = {\n     * \ttop: 100,\n     * \tright: 0,\n     * \tbottom: 0,\n     * \tleft: 0\n     * };\n     * ```\n     *\n     * @observable\n     * @member {Object} #viewportOffset\n     */\n    this.set('viewportOffset', this._readViewportOffsetFromConfig());\n\n    /**\n     * Indicates the UI is ready. Set `true` after {@link #event:ready} event is fired.\n     *\n     * @readonly\n     * @default false\n     * @member {Boolean} #isReady\n     */\n    this.isReady = false;\n    this.once('ready', () => {\n      this.isReady = true;\n    });\n\n    /**\n     * Stores all editable elements used by the editor instance.\n     *\n     * @private\n     * @member {Map.<String,HTMLElement>}\n     */\n    this._editableElementsMap = new Map();\n\n    /**\n     * All available & focusable toolbars.\n     *\n     * @private\n     * @type {Array.<module:core/editor/editorui~FocusableToolbarDefinition>}\n     */\n    this._focusableToolbarDefinitions = [];\n\n    // Informs UI components that should be refreshed after layout change.\n    this.listenTo(editor.editing.view.document, 'layoutChanged', () => this.update());\n    this._initFocusTracking();\n  }\n\n  /**\n   * The main (outermost) DOM element of the editor UI.\n   *\n   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which\n   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}\n   * it is the editable element itself (as there is no other wrapper). However, in\n   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not\n   * come with a single \"main\" HTML element (its editable element and toolbar are separate).\n   *\n   * This property can be understood as a shorthand for retrieving the element that a specific editor integration\n   * considers to be its main DOM element.\n   *\n   * @readonly\n   * @member {HTMLElement|null} #element\n   */\n  get element() {\n    return null;\n  }\n\n  /**\n   * Fires the {@link module:core/editor/editorui~EditorUI#event:update `update`} event.\n   *\n   * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to\n   * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).\n   */\n  update() {\n    this.fire('update');\n  }\n\n  /**\n   * Destroys the UI.\n   */\n  destroy() {\n    this.stopListening();\n    this.focusTracker.destroy();\n    this.tooltipManager.destroy(this.editor);\n\n    // Clean–up the references to the CKEditor instance stored in the native editable DOM elements.\n    for (const domElement of this._editableElementsMap.values()) {\n      domElement.ckeditorInstance = null;\n    }\n    this._editableElementsMap = new Map();\n    this._focusableToolbarDefinitions = [];\n  }\n\n  /**\n   * Stores the native DOM editable element used by the editor under a unique name.\n   *\n   * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable\n   * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.\n   *\n   * @param {String} rootName The unique name of the editable element.\n   * @param {HTMLElement} domElement The native DOM editable element.\n   */\n  setEditableElement(rootName, domElement) {\n    this._editableElementsMap.set(rootName, domElement);\n\n    // Put a reference to the CKEditor instance in the editable native DOM element.\n    // It helps 3rd–party software (browser extensions, other libraries) access and recognize\n    // CKEditor 5 instances (editing roots) and use their API (there is no global editor\n    // instance registry).\n    if (!domElement.ckeditorInstance) {\n      domElement.ckeditorInstance = this.editor;\n    }\n\n    // Register the element so it becomes available for Alt+F10 and Esc navigation.\n    this.focusTracker.add(domElement);\n    const setUpKeystrokeHandler = () => {\n      // The editing view of the editor is already listening to keystrokes from DOM roots (see: KeyObserver).\n      // Do not duplicate listeners.\n      if (this.editor.editing.view.getDomRoot(rootName)) {\n        return;\n      }\n      this.editor.keystrokes.listenTo(domElement);\n    };\n\n    // For editable elements set by features after EditorUI is ready (e.g. source editing).\n    if (this.isReady) {\n      setUpKeystrokeHandler();\n    }\n    // For editable elements set while the editor is being created (e.g. DOM roots).\n    else {\n      this.once('ready', setUpKeystrokeHandler);\n    }\n  }\n\n  /**\n   * Returns the editable editor element with the given name or null if editable does not exist.\n   *\n   * @param {String} [rootName=main] The editable name.\n   * @returns {HTMLElement|undefined}\n   */\n  getEditableElement() {\n    let rootName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n    return this._editableElementsMap.get(rootName);\n  }\n\n  /**\n   * Returns array of names of all editor editable elements.\n   *\n   * @returns {Iterable.<String>}\n   */\n  getEditableElementsNames() {\n    return this._editableElementsMap.keys();\n  }\n\n  /**\n   * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.\n   *\n   * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.\n   * Successive keystroke presses navigate over available toolbars.\n   *\n   * @param {module:ui/toolbar/toolbarview~ToolbarView} toolbarView A instance of the toolbar to be registered.\n   * @param {Object} [options]\n   * @param {Boolean} [options.isContextual] Set `true` if the toolbar is attached to the content of the editor. Such toolbar takes\n   * a precedence over other toolbars when a user pressed <kbd>Alt</kbd> + <kbd>F10</kbd>.\n   * @param {Function} [options.beforeFocus] Specify a callback executed before the toolbar instance DOM element gains focus\n   * upon the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.\n   * @param {Function} [options.afterBlur] Specify a callback executed after the toolbar instance DOM element loses focus upon\n   * <kbd>Esc</kbd> keystroke but before the focus goes back to the {@link #setEditableElement editable element}.\n   */\n  addToolbar(toolbarView) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (toolbarView.isRendered) {\n      this.focusTracker.add(toolbarView.element);\n      this.editor.keystrokes.listenTo(toolbarView.element);\n    } else {\n      toolbarView.once('render', () => {\n        this.focusTracker.add(toolbarView.element);\n        this.editor.keystrokes.listenTo(toolbarView.element);\n      });\n    }\n    this._focusableToolbarDefinitions.push({\n      toolbarView,\n      options\n    });\n  }\n\n  /**\n   * Stores all editable elements used by the editor instance.\n   *\n   * @protected\n   * @deprecated\n   * @member {Map.<String,HTMLElement>}\n   */\n  get _editableElements() {\n    /**\n     * The {@link module:core/editor/editorui~EditorUI#_editableElements `EditorUI#_editableElements`} property has been\n     * deprecated and will be removed in the near future. Please use {@link #setEditableElement `setEditableElement()`} and\n     * {@link #getEditableElement `getEditableElement()`} methods instead.\n     *\n     * @error editor-ui-deprecated-editable-elements\n     * @param {module:core/editor/editorui~EditorUI} editorUI Editor UI instance the deprecated property belongs to.\n     */\n    console.warn('editor-ui-deprecated-editable-elements: ' + 'The EditorUI#_editableElements property has been deprecated and will be removed in the near future.', {\n      editorUI: this\n    });\n    return this._editableElementsMap;\n  }\n\n  /**\n   * Returns viewport offsets object:\n   *\n   * ```js\n   * {\n   * \ttop: Number,\n   * \tright: Number,\n   * \tbottom: Number,\n   * \tleft: Number\n   * }\n   * ```\n   *\n   * Only top property is currently supported.\n   *\n   * @private\n   * @return {Object}\n   */\n  _readViewportOffsetFromConfig() {\n    const editor = this.editor;\n    const viewportOffsetConfig = editor.config.get('ui.viewportOffset');\n    if (viewportOffsetConfig) {\n      return viewportOffsetConfig;\n    }\n    const legacyOffsetConfig = editor.config.get('toolbar.viewportTopOffset');\n\n    // Fall back to deprecated toolbar config.\n    if (legacyOffsetConfig) {\n      /**\n       * The {@link module:core/editor/editorconfig~EditorConfig#toolbar `EditorConfig#toolbar.viewportTopOffset`}\n       * property has been deprecated and will be removed in the near future. Please use\n       * {@link module:core/editor/editorconfig~EditorConfig#ui `EditorConfig#ui.viewportOffset`} instead.\n       *\n       * @error editor-ui-deprecated-viewport-offset-config\n       */\n      console.warn('editor-ui-deprecated-viewport-offset-config: ' + 'The `toolbar.vieportTopOffset` configuration option is deprecated. ' + 'It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.');\n      return {\n        top: legacyOffsetConfig\n      };\n    }\n\n    // More keys to come in the future.\n    return {\n      top: 0\n    };\n  }\n\n  /**\n   * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable\n   * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}\n   * to allow users navigate across the UI.\n   *\n   * @private\n   */\n  _initFocusTracking() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    let lastFocusedForeignElement;\n    let candidateDefinitions;\n\n    // Focus the next focusable toolbar on <kbd>Alt</kbd> + <kbd>F10</kbd>.\n    editor.keystrokes.set('Alt+F10', (data, cancel) => {\n      const focusedElement = this.focusTracker.focusedElement;\n\n      // Focus moved out of a DOM element that\n      // * is not a toolbar,\n      // * does not belong to the editing view (e.g. source editing).\n      if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(editingView.domRoots.values()).includes(focusedElement)) {\n        lastFocusedForeignElement = focusedElement;\n      }\n      const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();\n\n      // * When focusing a toolbar for the first time, set the array of definitions for successive presses of Alt+F10.\n      // This ensures, the navigation works always the same and no pair of toolbars takes over\n      // (e.g. image and table toolbars when a selected image is inside a cell).\n      // * It could be that the focus went to the toolbar by clicking a toolbar item (e.g. a dropdown). In this case,\n      // there were no candidates so they must be obtained (#12339).\n      if (!currentFocusedToolbarDefinition || !candidateDefinitions) {\n        candidateDefinitions = this._getFocusableCandidateToolbarDefinitions(currentFocusedToolbarDefinition);\n      }\n\n      // In a single Alt+F10 press, check all candidates but if none were focused, don't go any further.\n      // This prevents an infinite loop.\n      for (let i = 0; i < candidateDefinitions.length; i++) {\n        const candidateDefinition = candidateDefinitions.shift();\n\n        // Put the first definition to the back of the array. This allows circular navigation over all toolbars\n        // on successive presses of Alt+F10.\n        candidateDefinitions.push(candidateDefinition);\n\n        // Don't focus the same toolbar again. If you did, this would move focus from the nth focused toolbar item back to the\n        // first item as per ToolbarView#focus() if the user navigated inside the toolbar.\n        if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {\n          // Clean up after a current visible toolbar when switching to the next one.\n          if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {\n            currentFocusedToolbarDefinition.options.afterBlur();\n          }\n          break;\n        }\n      }\n      cancel();\n    });\n\n    // Blur the focused toolbar on <kbd>Esc</kbd> and bring the focus back to its origin.\n    editor.keystrokes.set('Esc', (data, cancel) => {\n      const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();\n      if (!focusedToolbarDef) {\n        return;\n      }\n\n      // Bring focus back to where it came from before focusing the toolbar:\n      // 1. If it came from outside the engine view (e.g. source editing), move it there.\n      if (lastFocusedForeignElement) {\n        lastFocusedForeignElement.focus();\n        lastFocusedForeignElement = null;\n      }\n      // 2. There are two possibilities left:\n      //   2.1. It could be that the focus went from an editable element in the view (root or nested).\n      //   2.2. It could be the focus went straight to the toolbar before even focusing the editing area.\n      // In either case, just focus the view editing. The focus will land where it belongs.\n      else {\n        editor.editing.view.focus();\n      }\n\n      // Clean up after the toolbar if there is anything to do there.\n      if (focusedToolbarDef.options.afterBlur) {\n        focusedToolbarDef.options.afterBlur();\n      }\n      cancel();\n    });\n  }\n\n  /**\n   * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.\n   *\n   * Focusable toolbars candidates are either:\n   * * already visible,\n   * * have `beforeFocus()` set in their {@link module:core/editor/editorui~FocusableToolbarDefinition definition} that suggests that\n   * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible\n   * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).\n   *\n   * **Note**: Contextual toolbars take precedence over regular toolbars.\n   *\n   * @private\n   * @returns {Array.<module:core/editor/editorui~FocusableToolbarDefinition>}\n   */\n  _getFocusableCandidateToolbarDefinitions() {\n    const definitions = [];\n    for (const toolbarDef of this._focusableToolbarDefinitions) {\n      const {\n        toolbarView,\n        options\n      } = toolbarDef;\n      if (isVisible(toolbarView.element) || options.beforeFocus) {\n        definitions.push(toolbarDef);\n      }\n    }\n\n    // Contextual and already visible toolbars have higher priority. If both are true, the toolbar will always focus first.\n    // For instance, a selected widget toolbar vs inline editor toolbar: both are visible but the widget toolbar is contextual.\n    definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));\n    return definitions;\n  }\n\n  /**\n   * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).\n   *\n   * `null` is returned when no toolbar is currently focused.\n   *\n   * @private\n   * @returns {module:core/editor/editorui~FocusableToolbarDefinition|null}\n   */\n  _getCurrentFocusedToolbarDefinition() {\n    for (const definition of this._focusableToolbarDefinitions) {\n      if (definition.toolbarView.element && definition.toolbarView.element.contains(this.focusTracker.focusedElement)) {\n        return definition;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Focuses a focusable toolbar candidate using its definition.\n   *\n   * @private\n   * @param {module:core/editor/editorui~FocusableToolbarDefinition} candidateToolbarDefinition A definition of the toolbar to focus.\n   * @returns {Boolean} `true` when the toolbar candidate was focused. `false` otherwise.\n   */\n  _focusFocusableCandidateToolbar(candidateToolbarDefinition) {\n    const {\n      toolbarView,\n      options: {\n        beforeFocus\n      }\n    } = candidateToolbarDefinition;\n    if (beforeFocus) {\n      beforeFocus();\n    }\n\n    // If it didn't show up after beforeFocus(), it's not focusable at all.\n    if (!isVisible(toolbarView.element)) {\n      return false;\n    }\n    toolbarView.focus();\n    return true;\n  }\n\n  /**\n   * Fired when the editor UI is ready.\n   *\n   * Fired before {@link module:engine/controller/datacontroller~DataController#event:ready}.\n   *\n   * @event ready\n   */\n\n  /**\n   * Fired whenever the UI (all related components) should be refreshed.\n   *\n   * **Note:**: The event is fired after each {@link module:engine/view/document~Document#event:layoutChanged}.\n   * It can also be fired manually via the {@link module:core/editor/editorui~EditorUI#update} method.\n   *\n   * @event update\n   */\n}\n\nmix(EditorUI, ObservableMixin);\n\n/**\n * A definition of a focusable toolbar. Used by {@link module:core/editor/editorui~EditorUI#addToolbar}.\n *\n * @private\n * @interface module:core/editor/editorui~FocusableToolbarDefinition\n */\n\n/**\n * An instance of a focusable toolbar view.\n *\n * @member {module:ui/toolbar/toolbarview~ToolbarView} #toolbarView\n */\n\n/**\n * Options of a focusable toolbar view:\n *\n * * `isContextual`: Marks the higher priority toolbar. For example when there are 2 visible toolbars,\n * it allows to distinguish which toolbar should be focused first after the `alt+f10` keystroke\n * * `beforeFocus`: A callback executed before the `ToolbarView` gains focus upon the `Alt+F10` keystroke.\n * * `afterBlur`: A callback executed after `ToolbarView` loses focus upon `Esc` keystroke but before the focus goes back to the `origin`.\n *\n * @member {Object} #options\n */\n\n// Returns a number (weight) for a toolbar definition. Visible toolbars have a higher priority and so do\n// contextual toolbars (displayed in the context of a content, for instance, an image toolbar).\n//\n// A standard invisible toolbar is the heaviest. A visible contextual toolbar is the lightest.\n//\n// @private\n// @param {module:core/editor/editorui~FocusableToolbarDefinition} toolbarDef A toolbar definition to be weighted.\n// @returns {Number}\nfunction getToolbarDefinitionWeight(toolbarDef) {\n  const {\n    toolbarView,\n    options\n  } = toolbarDef;\n  let weight = 10;\n\n  // Prioritize already visible toolbars. They should get focused first.\n  if (isVisible(toolbarView.element)) {\n    weight--;\n  }\n\n  // Prioritize contextual toolbars. They are displayed at the selection.\n  if (options.isContextual) {\n    weight--;\n  }\n  return weight;\n}","map":{"version":3,"names":["ComponentFactory","FocusTracker","TooltipManager","ObservableMixin","mix","isVisible","EditorUI","constructor","editor","componentFactory","focusTracker","tooltipManager","set","_readViewportOffsetFromConfig","isReady","once","_editableElementsMap","Map","_focusableToolbarDefinitions","listenTo","editing","view","document","update","_initFocusTracking","element","fire","destroy","stopListening","domElement","values","ckeditorInstance","setEditableElement","rootName","add","setUpKeystrokeHandler","getDomRoot","keystrokes","getEditableElement","get","getEditableElementsNames","keys","addToolbar","toolbarView","options","isRendered","push","_editableElements","console","warn","editorUI","viewportOffsetConfig","config","legacyOffsetConfig","top","editingView","lastFocusedForeignElement","candidateDefinitions","data","cancel","focusedElement","Array","from","includes","domRoots","currentFocusedToolbarDefinition","_getCurrentFocusedToolbarDefinition","_getFocusableCandidateToolbarDefinitions","i","length","candidateDefinition","shift","_focusFocusableCandidateToolbar","afterBlur","focusedToolbarDef","focus","definitions","toolbarDef","beforeFocus","sort","defA","defB","getToolbarDefinitionWeight","definition","contains","candidateToolbarDefinition","weight","isContextual"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-core/src/editor/editorui.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/editor/editorui\n */\n\n/* globals console */\n\nimport ComponentFactory from '@ckeditor/ckeditor5-ui/src/componentfactory';\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport TooltipManager from '@ckeditor/ckeditor5-ui/src/tooltipmanager';\n\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isVisible from '@ckeditor/ckeditor5-utils/src/dom/isvisible';\n\n/**\n * A class providing the minimal interface that is required to successfully bootstrap any editor UI.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class EditorUI {\n\t/**\n\t * Creates an instance of the editor UI class.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t */\n\tconstructor( editor ) {\n\t\t/**\n\t\t * The editor that the UI belongs to.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editor/editor~Editor} #editor\n\t\t */\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * An instance of the {@link module:ui/componentfactory~ComponentFactory}, a registry used by plugins\n\t\t * to register factories of specific UI components.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/componentfactory~ComponentFactory} #componentFactory\n\t\t */\n\t\tthis.componentFactory = new ComponentFactory( editor );\n\n\t\t/**\n\t\t * Stores the information about the editor UI focus and propagates it so various plugins and components\n\t\t * are unified as a focus group.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/focustracker~FocusTracker} #focusTracker\n\t\t */\n\t\tthis.focusTracker = new FocusTracker();\n\n\t\t/**\n\t\t * Manages the tooltips displayed on mouseover and focus across the UI.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/tooltipmanager~TooltipManager}\n\t\t */\n\t\tthis.tooltipManager = new TooltipManager( editor );\n\n\t\t/**\n\t\t * Stores viewport offsets from every direction.\n\t\t *\n\t\t * Viewport offset can be used to constrain balloons or other UI elements into an element smaller than the viewport.\n\t\t * This can be useful if there are any other absolutely positioned elements that may interfere with editor UI.\n\t\t *\n\t\t * Example `editor.ui.viewportOffset` returns:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t * \ttop: 50,\n\t\t * \tright: 50,\n\t\t * \tbottom: 50,\n\t\t * \tleft: 50\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * This property can be overriden after editor already being initialized:\n\t\t *\n\t\t * ```js\n\t\t * editor.ui.viewportOffset = {\n\t\t * \ttop: 100,\n\t\t * \tright: 0,\n\t\t * \tbottom: 0,\n\t\t * \tleft: 0\n\t\t * };\n\t\t * ```\n\t\t *\n\t\t * @observable\n\t\t * @member {Object} #viewportOffset\n\t\t */\n\t\tthis.set( 'viewportOffset', this._readViewportOffsetFromConfig() );\n\n\t\t/**\n\t\t * Indicates the UI is ready. Set `true` after {@link #event:ready} event is fired.\n\t\t *\n\t\t * @readonly\n\t\t * @default false\n\t\t * @member {Boolean} #isReady\n\t\t */\n\t\tthis.isReady = false;\n\t\tthis.once( 'ready', () => {\n\t\t\tthis.isReady = true;\n\t\t} );\n\n\t\t/**\n\t\t * Stores all editable elements used by the editor instance.\n\t\t *\n\t\t * @private\n\t\t * @member {Map.<String,HTMLElement>}\n\t\t */\n\t\tthis._editableElementsMap = new Map();\n\n\t\t/**\n\t\t * All available & focusable toolbars.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<module:core/editor/editorui~FocusableToolbarDefinition>}\n\t\t */\n\t\tthis._focusableToolbarDefinitions = [];\n\n\t\t// Informs UI components that should be refreshed after layout change.\n\t\tthis.listenTo( editor.editing.view.document, 'layoutChanged', () => this.update() );\n\n\t\tthis._initFocusTracking();\n\t}\n\n\t/**\n\t * The main (outermost) DOM element of the editor UI.\n\t *\n\t * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which\n\t * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}\n\t * it is the editable element itself (as there is no other wrapper). However, in\n\t * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not\n\t * come with a single \"main\" HTML element (its editable element and toolbar are separate).\n\t *\n\t * This property can be understood as a shorthand for retrieving the element that a specific editor integration\n\t * considers to be its main DOM element.\n\t *\n\t * @readonly\n\t * @member {HTMLElement|null} #element\n\t */\n\tget element() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Fires the {@link module:core/editor/editorui~EditorUI#event:update `update`} event.\n\t *\n\t * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to\n\t * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).\n\t */\n\tupdate() {\n\t\tthis.fire( 'update' );\n\t}\n\n\t/**\n\t * Destroys the UI.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\n\t\tthis.focusTracker.destroy();\n\t\tthis.tooltipManager.destroy( this.editor );\n\n\t\t// Clean–up the references to the CKEditor instance stored in the native editable DOM elements.\n\t\tfor ( const domElement of this._editableElementsMap.values() ) {\n\t\t\tdomElement.ckeditorInstance = null;\n\t\t}\n\n\t\tthis._editableElementsMap = new Map();\n\t\tthis._focusableToolbarDefinitions = [];\n\t}\n\n\t/**\n\t * Stores the native DOM editable element used by the editor under a unique name.\n\t *\n\t * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable\n\t * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.\n\t *\n\t * @param {String} rootName The unique name of the editable element.\n\t * @param {HTMLElement} domElement The native DOM editable element.\n\t */\n\tsetEditableElement( rootName, domElement ) {\n\t\tthis._editableElementsMap.set( rootName, domElement );\n\n\t\t// Put a reference to the CKEditor instance in the editable native DOM element.\n\t\t// It helps 3rd–party software (browser extensions, other libraries) access and recognize\n\t\t// CKEditor 5 instances (editing roots) and use their API (there is no global editor\n\t\t// instance registry).\n\t\tif ( !domElement.ckeditorInstance ) {\n\t\t\tdomElement.ckeditorInstance = this.editor;\n\t\t}\n\n\t\t// Register the element so it becomes available for Alt+F10 and Esc navigation.\n\t\tthis.focusTracker.add( domElement );\n\n\t\tconst setUpKeystrokeHandler = () => {\n\t\t\t// The editing view of the editor is already listening to keystrokes from DOM roots (see: KeyObserver).\n\t\t\t// Do not duplicate listeners.\n\t\t\tif ( this.editor.editing.view.getDomRoot( rootName ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.editor.keystrokes.listenTo( domElement );\n\t\t};\n\n\t\t// For editable elements set by features after EditorUI is ready (e.g. source editing).\n\t\tif ( this.isReady ) {\n\t\t\tsetUpKeystrokeHandler();\n\t\t}\n\t\t// For editable elements set while the editor is being created (e.g. DOM roots).\n\t\telse {\n\t\t\tthis.once( 'ready', setUpKeystrokeHandler );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the editable editor element with the given name or null if editable does not exist.\n\t *\n\t * @param {String} [rootName=main] The editable name.\n\t * @returns {HTMLElement|undefined}\n\t */\n\tgetEditableElement( rootName = 'main' ) {\n\t\treturn this._editableElementsMap.get( rootName );\n\t}\n\n\t/**\n\t * Returns array of names of all editor editable elements.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetEditableElementsNames() {\n\t\treturn this._editableElementsMap.keys();\n\t}\n\n\t/**\n\t * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.\n\t *\n\t * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.\n\t * Successive keystroke presses navigate over available toolbars.\n\t *\n\t * @param {module:ui/toolbar/toolbarview~ToolbarView} toolbarView A instance of the toolbar to be registered.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.isContextual] Set `true` if the toolbar is attached to the content of the editor. Such toolbar takes\n\t * a precedence over other toolbars when a user pressed <kbd>Alt</kbd> + <kbd>F10</kbd>.\n\t * @param {Function} [options.beforeFocus] Specify a callback executed before the toolbar instance DOM element gains focus\n\t * upon the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.\n\t * @param {Function} [options.afterBlur] Specify a callback executed after the toolbar instance DOM element loses focus upon\n\t * <kbd>Esc</kbd> keystroke but before the focus goes back to the {@link #setEditableElement editable element}.\n\t */\n\taddToolbar( toolbarView, options = {} ) {\n\t\tif ( toolbarView.isRendered ) {\n\t\t\tthis.focusTracker.add( toolbarView.element );\n\t\t\tthis.editor.keystrokes.listenTo( toolbarView.element );\n\t\t} else {\n\t\t\ttoolbarView.once( 'render', () => {\n\t\t\t\tthis.focusTracker.add( toolbarView.element );\n\t\t\t\tthis.editor.keystrokes.listenTo( toolbarView.element );\n\t\t\t} );\n\t\t}\n\n\t\tthis._focusableToolbarDefinitions.push( { toolbarView, options } );\n\t}\n\n\t/**\n\t * Stores all editable elements used by the editor instance.\n\t *\n\t * @protected\n\t * @deprecated\n\t * @member {Map.<String,HTMLElement>}\n\t */\n\tget _editableElements() {\n\t\t/**\n\t\t * The {@link module:core/editor/editorui~EditorUI#_editableElements `EditorUI#_editableElements`} property has been\n\t\t * deprecated and will be removed in the near future. Please use {@link #setEditableElement `setEditableElement()`} and\n\t\t * {@link #getEditableElement `getEditableElement()`} methods instead.\n\t\t *\n\t\t * @error editor-ui-deprecated-editable-elements\n\t\t * @param {module:core/editor/editorui~EditorUI} editorUI Editor UI instance the deprecated property belongs to.\n\t\t */\n\t\tconsole.warn(\n\t\t\t'editor-ui-deprecated-editable-elements: ' +\n\t\t\t'The EditorUI#_editableElements property has been deprecated and will be removed in the near future.',\n\t\t\t{ editorUI: this } );\n\n\t\treturn this._editableElementsMap;\n\t}\n\n\t/**\n\t * Returns viewport offsets object:\n\t *\n\t * ```js\n\t * {\n\t * \ttop: Number,\n\t * \tright: Number,\n\t * \tbottom: Number,\n\t * \tleft: Number\n\t * }\n\t * ```\n\t *\n\t * Only top property is currently supported.\n\t *\n\t * @private\n\t * @return {Object}\n\t */\n\t_readViewportOffsetFromConfig() {\n\t\tconst editor = this.editor;\n\t\tconst viewportOffsetConfig = editor.config.get( 'ui.viewportOffset' );\n\n\t\tif ( viewportOffsetConfig ) {\n\t\t\treturn viewportOffsetConfig;\n\t\t}\n\n\t\tconst legacyOffsetConfig = editor.config.get( 'toolbar.viewportTopOffset' );\n\n\t\t// Fall back to deprecated toolbar config.\n\t\tif ( legacyOffsetConfig ) {\n\t\t\t/**\n\t\t\t * The {@link module:core/editor/editorconfig~EditorConfig#toolbar `EditorConfig#toolbar.viewportTopOffset`}\n\t\t\t * property has been deprecated and will be removed in the near future. Please use\n\t\t\t * {@link module:core/editor/editorconfig~EditorConfig#ui `EditorConfig#ui.viewportOffset`} instead.\n\t\t\t *\n\t\t\t * @error editor-ui-deprecated-viewport-offset-config\n\t\t\t */\n\t\t\tconsole.warn(\n\t\t\t\t'editor-ui-deprecated-viewport-offset-config: ' +\n\t\t\t\t'The `toolbar.vieportTopOffset` configuration option is deprecated. ' +\n\t\t\t\t'It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.'\n\t\t\t);\n\n\t\t\treturn { top: legacyOffsetConfig };\n\t\t}\n\n\t\t// More keys to come in the future.\n\t\treturn { top: 0 };\n\t}\n\n\t/**\n\t * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable\n\t * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}\n\t * to allow users navigate across the UI.\n\t *\n\t * @private\n\t */\n\t_initFocusTracking() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\tlet lastFocusedForeignElement;\n\t\tlet candidateDefinitions;\n\n\t\t// Focus the next focusable toolbar on <kbd>Alt</kbd> + <kbd>F10</kbd>.\n\t\teditor.keystrokes.set( 'Alt+F10', ( data, cancel ) => {\n\t\t\tconst focusedElement = this.focusTracker.focusedElement;\n\n\t\t\t// Focus moved out of a DOM element that\n\t\t\t// * is not a toolbar,\n\t\t\t// * does not belong to the editing view (e.g. source editing).\n\t\t\tif (\n\t\t\t\tArray.from( this._editableElementsMap.values() ).includes( focusedElement ) &&\n\t\t\t\t!Array.from( editingView.domRoots.values() ).includes( focusedElement )\n\t\t\t) {\n\t\t\t\tlastFocusedForeignElement = focusedElement;\n\t\t\t}\n\n\t\t\tconst currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();\n\n\t\t\t// * When focusing a toolbar for the first time, set the array of definitions for successive presses of Alt+F10.\n\t\t\t// This ensures, the navigation works always the same and no pair of toolbars takes over\n\t\t\t// (e.g. image and table toolbars when a selected image is inside a cell).\n\t\t\t// * It could be that the focus went to the toolbar by clicking a toolbar item (e.g. a dropdown). In this case,\n\t\t\t// there were no candidates so they must be obtained (#12339).\n\t\t\tif ( !currentFocusedToolbarDefinition || !candidateDefinitions ) {\n\t\t\t\tcandidateDefinitions = this._getFocusableCandidateToolbarDefinitions( currentFocusedToolbarDefinition );\n\t\t\t}\n\n\t\t\t// In a single Alt+F10 press, check all candidates but if none were focused, don't go any further.\n\t\t\t// This prevents an infinite loop.\n\t\t\tfor ( let i = 0; i < candidateDefinitions.length; i++ ) {\n\t\t\t\tconst candidateDefinition = candidateDefinitions.shift();\n\n\t\t\t\t// Put the first definition to the back of the array. This allows circular navigation over all toolbars\n\t\t\t\t// on successive presses of Alt+F10.\n\t\t\t\tcandidateDefinitions.push( candidateDefinition );\n\n\t\t\t\t// Don't focus the same toolbar again. If you did, this would move focus from the nth focused toolbar item back to the\n\t\t\t\t// first item as per ToolbarView#focus() if the user navigated inside the toolbar.\n\t\t\t\tif (\n\t\t\t\t\tcandidateDefinition !== currentFocusedToolbarDefinition &&\n\t\t\t\t\tthis._focusFocusableCandidateToolbar( candidateDefinition )\n\t\t\t\t) {\n\t\t\t\t\t// Clean up after a current visible toolbar when switching to the next one.\n\t\t\t\t\tif ( currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur ) {\n\t\t\t\t\t\tcurrentFocusedToolbarDefinition.options.afterBlur();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcancel();\n\t\t} );\n\n\t\t// Blur the focused toolbar on <kbd>Esc</kbd> and bring the focus back to its origin.\n\t\teditor.keystrokes.set( 'Esc', ( data, cancel ) => {\n\t\t\tconst focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();\n\n\t\t\tif ( !focusedToolbarDef ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Bring focus back to where it came from before focusing the toolbar:\n\t\t\t// 1. If it came from outside the engine view (e.g. source editing), move it there.\n\t\t\tif ( lastFocusedForeignElement ) {\n\t\t\t\tlastFocusedForeignElement.focus();\n\t\t\t\tlastFocusedForeignElement = null;\n\t\t\t}\n\t\t\t// 2. There are two possibilities left:\n\t\t\t//   2.1. It could be that the focus went from an editable element in the view (root or nested).\n\t\t\t//   2.2. It could be the focus went straight to the toolbar before even focusing the editing area.\n\t\t\t// In either case, just focus the view editing. The focus will land where it belongs.\n\t\t\telse {\n\t\t\t\teditor.editing.view.focus();\n\t\t\t}\n\n\t\t\t// Clean up after the toolbar if there is anything to do there.\n\t\t\tif ( focusedToolbarDef.options.afterBlur ) {\n\t\t\t\tfocusedToolbarDef.options.afterBlur();\n\t\t\t}\n\n\t\t\tcancel();\n\t\t} );\n\t}\n\n\t/**\n\t * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.\n\t *\n\t * Focusable toolbars candidates are either:\n\t * * already visible,\n\t * * have `beforeFocus()` set in their {@link module:core/editor/editorui~FocusableToolbarDefinition definition} that suggests that\n\t * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible\n\t * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).\n\t *\n\t * **Note**: Contextual toolbars take precedence over regular toolbars.\n\t *\n\t * @private\n\t * @returns {Array.<module:core/editor/editorui~FocusableToolbarDefinition>}\n\t */\n\t_getFocusableCandidateToolbarDefinitions() {\n\t\tconst definitions = [];\n\n\t\tfor ( const toolbarDef of this._focusableToolbarDefinitions ) {\n\t\t\tconst { toolbarView, options } = toolbarDef;\n\n\t\t\tif ( isVisible( toolbarView.element ) || options.beforeFocus ) {\n\t\t\t\tdefinitions.push( toolbarDef );\n\t\t\t}\n\t\t}\n\n\t\t// Contextual and already visible toolbars have higher priority. If both are true, the toolbar will always focus first.\n\t\t// For instance, a selected widget toolbar vs inline editor toolbar: both are visible but the widget toolbar is contextual.\n\t\tdefinitions.sort( ( defA, defB ) => getToolbarDefinitionWeight( defA ) - getToolbarDefinitionWeight( defB ) );\n\n\t\treturn definitions;\n\t}\n\n\t/**\n\t * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).\n\t *\n\t * `null` is returned when no toolbar is currently focused.\n\t *\n\t * @private\n\t * @returns {module:core/editor/editorui~FocusableToolbarDefinition|null}\n\t */\n\t_getCurrentFocusedToolbarDefinition() {\n\t\tfor ( const definition of this._focusableToolbarDefinitions ) {\n\t\t\tif ( definition.toolbarView.element && definition.toolbarView.element.contains( this.focusTracker.focusedElement ) ) {\n\t\t\t\treturn definition;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses a focusable toolbar candidate using its definition.\n\t *\n\t * @private\n\t * @param {module:core/editor/editorui~FocusableToolbarDefinition} candidateToolbarDefinition A definition of the toolbar to focus.\n\t * @returns {Boolean} `true` when the toolbar candidate was focused. `false` otherwise.\n\t */\n\t_focusFocusableCandidateToolbar( candidateToolbarDefinition ) {\n\t\tconst { toolbarView, options: { beforeFocus } } = candidateToolbarDefinition;\n\n\t\tif ( beforeFocus ) {\n\t\t\tbeforeFocus();\n\t\t}\n\n\t\t// If it didn't show up after beforeFocus(), it's not focusable at all.\n\t\tif ( !isVisible( toolbarView.element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttoolbarView.focus();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Fired when the editor UI is ready.\n\t *\n\t * Fired before {@link module:engine/controller/datacontroller~DataController#event:ready}.\n\t *\n\t * @event ready\n\t */\n\n\t/**\n\t * Fired whenever the UI (all related components) should be refreshed.\n\t *\n\t * **Note:**: The event is fired after each {@link module:engine/view/document~Document#event:layoutChanged}.\n\t * It can also be fired manually via the {@link module:core/editor/editorui~EditorUI#update} method.\n\t *\n\t * @event update\n\t */\n}\n\nmix( EditorUI, ObservableMixin );\n\n/**\n * A definition of a focusable toolbar. Used by {@link module:core/editor/editorui~EditorUI#addToolbar}.\n *\n * @private\n * @interface module:core/editor/editorui~FocusableToolbarDefinition\n */\n\n/**\n * An instance of a focusable toolbar view.\n *\n * @member {module:ui/toolbar/toolbarview~ToolbarView} #toolbarView\n */\n\n/**\n * Options of a focusable toolbar view:\n *\n * * `isContextual`: Marks the higher priority toolbar. For example when there are 2 visible toolbars,\n * it allows to distinguish which toolbar should be focused first after the `alt+f10` keystroke\n * * `beforeFocus`: A callback executed before the `ToolbarView` gains focus upon the `Alt+F10` keystroke.\n * * `afterBlur`: A callback executed after `ToolbarView` loses focus upon `Esc` keystroke but before the focus goes back to the `origin`.\n *\n * @member {Object} #options\n */\n\n// Returns a number (weight) for a toolbar definition. Visible toolbars have a higher priority and so do\n// contextual toolbars (displayed in the context of a content, for instance, an image toolbar).\n//\n// A standard invisible toolbar is the heaviest. A visible contextual toolbar is the lightest.\n//\n// @private\n// @param {module:core/editor/editorui~FocusableToolbarDefinition} toolbarDef A toolbar definition to be weighted.\n// @returns {Number}\nfunction getToolbarDefinitionWeight( toolbarDef ) {\n\tconst { toolbarView, options } = toolbarDef;\n\tlet weight = 10;\n\n\t// Prioritize already visible toolbars. They should get focused first.\n\tif ( isVisible( toolbarView.element ) ) {\n\t\tweight--;\n\t}\n\n\t// Prioritize contextual toolbars. They are displayed at the selection.\n\tif ( options.isContextual ) {\n\t\tweight--;\n\t}\n\n\treturn weight;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAOA,gBAAgB,MAAM,6CAA6C;AAC1E,OAAOC,YAAY,MAAM,4CAA4C;AACrE,OAAOC,cAAc,MAAM,2CAA2C;AAEtE,OAAOC,eAAe,MAAM,+CAA+C;AAC3E,OAAOC,GAAG,MAAM,mCAAmC;AACnD,OAAOC,SAAS,MAAM,6CAA6C;;AAEnE;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,QAAQ,CAAC;EAC7B;AACD;AACA;AACA;AACA;EACCC,WAAW,CAAEC,MAAM,EAAG;IACrB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,MAAM,GAAGA,MAAM;;IAEpB;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,gBAAgB,GAAG,IAAIT,gBAAgB,CAAEQ,MAAM,CAAE;;IAEtD;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACE,YAAY,GAAG,IAAIT,YAAY,EAAE;;IAEtC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACU,cAAc,GAAG,IAAIT,cAAc,CAAEM,MAAM,CAAE;;IAElD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACI,GAAG,CAAE,gBAAgB,EAAE,IAAI,CAACC,6BAA6B,EAAE,CAAE;;IAElE;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,IAAI,CAAE,OAAO,EAAE,MAAM;MACzB,IAAI,CAACD,OAAO,GAAG,IAAI;IACpB,CAAC,CAAE;;IAEH;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACE,oBAAoB,GAAG,IAAIC,GAAG,EAAE;;IAErC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,4BAA4B,GAAG,EAAE;;IAEtC;IACA,IAAI,CAACC,QAAQ,CAAEX,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"},"metadata":{},"sourceType":"module"}