{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Finds positions of the first and last change in the given string/array and generates a set of changes:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ { index: 2, type: 'insert', values: [ 'x', 'y', 'z' ] } ]\n *\n *\t\tfastDiff( '12a', '12aa' );\n *\t\t// [ { index: 3, type: 'insert', values: [ 'a' ] } ]\n *\n *\t\tfastDiff( '12xyza', '12a' );\n *\t\t// [ { index: 2, type: 'delete', howMany: 3 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'a' ], [ '1', '2', 'a' ] );\n *\t\t// [ { index: 3, type: 'delete', howMany: 1 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'b', 'c', '3' ], [ '2', 'a', 'b' ] );\n *\t\t// [ { index: 0, type: 'insert', values: [ '2', 'a', 'b' ] }, { index: 3, type: 'delete', howMany: 6 } ]\n *\n * Passed arrays can contain any type of data, however to compare them correctly custom comparator function\n * should be passed as a third parameter:\n *\n *\t\tfastDiff( [ { value: 1 }, { value: 2 } ], [ { value: 1 }, { value: 3 } ], ( a, b ) => {\n *\t\t\treturn a.value === b.value;\n *\t\t} );\n *\t\t// [ { index: 1, type: 'insert', values: [ { value: 3 } ] }, { index: 2, type: 'delete', howMany: 1 } ]\n *\n * The resulted set of changes can be applied to the input in order to transform it into the output, for example:\n *\n *\t\tlet input = '12abc3';\n *\t\tconst output = '2ab';\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + change.values.join( '' ) + input.substring( change.index );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + input.substring( change.index + change.howMany );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * or in case of arrays:\n *\n *\t\tlet input = [ '1', '2', 'a', 'b', 'c', '3' ];\n *\t\tconst output = [ '2', 'a', 'b' ];\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( change.values, input.slice( change.index ) );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( input.slice( change.index + change.howMany ) );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * By passing `true` as the fourth parameter (`atomicChanges`) the output of this function will become compatible with\n * the {@link module:utils/diff~diff `diff()`} function:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ 'equal', 'equal', 'insert', 'insert', 'insert', 'equal' ]\n *\n * The default output format of this function is compatible with the output format of\n * {@link module:utils/difftochanges~diffToChanges `diffToChanges()`}. The `diffToChanges()` input format is, in turn,\n * compatible with the output of {@link module:utils/diff~diff `diff()`}:\n *\n *\t\tconst a = '1234';\n *\t\tconst b = '12xyz34';\n *\n *\t\t// Both calls will return the same results (grouped changes format).\n *\t\tfastDiff( a, b );\n *\t\tdiffToChanges( diff( a, b ) );\n *\n *\t\t// Again, both calls will return the same results (atomic changes format).\n *\t\tfastDiff( a, b, null, true );\n *\t\tdiff( a, b );\n *\n *\n * @param {Array|String} a Input array or string.\n * @param {Array|String} b Input array or string.\n * @param {Function} [cmp] Optional function used to compare array values, by default `===` (strict equal operator) is used.\n * @param {Boolean} [atomicChanges=false] Whether an array of `inset|delete|equal` operations should\n * be returned instead of changes set. This makes this function compatible with {@link module:utils/diff~diff `diff()`}.\n * @returns {Array} Array of changes.\n */\nexport default function fastDiff(a, b, cmp) {\n  let atomicChanges = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Set the comparator function.\n  cmp = cmp || function (a, b) {\n    return a === b;\n  };\n  // Convert the string (or any array-like object - eg. NodeList) to an array by using the slice() method because,\n  // unlike Array.from(), it returns array of UTF-16 code units instead of the code points of a string.\n  // One code point might be a surrogate pair of two code units. All text offsets are expected to be in code units.\n  // See ckeditor/ckeditor5#3147.\n  //\n  // We need to make sure here that fastDiff() works identical to diff().\n  const arrayA = Array.isArray(a) ? a : Array.prototype.slice.call(a);\n  const arrayB = Array.isArray(b) ? b : Array.prototype.slice.call(b);\n  // Find first and last change.\n  const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);\n  // Transform into changes array.\n  return atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);\n}\n// Finds position of the first and last change in the given arrays. For example:\n//\n//\t\tconst indexes = findChangeBoundaryIndexes( [ '1', '2', '3', '4' ], [ '1', '3', '4', '2', '4' ] );\n//\t\tconsole.log( indexes ); // { firstIndex: 1, lastIndexOld: 3, lastIndexNew: 4 }\n//\n// The above indexes means that in the first array the modified part is `1[23]4` and in the second array it is `1[342]4`.\n// Based on such indexes, array with `insert`/`delete` operations which allows transforming first value into the second one\n// can be generated.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Object}\n// @returns {Number} return.firstIndex Index of the first change in both values (always the same for both).\n// @returns {Number} result.lastIndexOld Index of the last common value in `arr1`.\n// @returns {Number} result.lastIndexNew Index of the last common value in `arr2`.\nfunction findChangeBoundaryIndexes(arr1, arr2, cmp) {\n  // Find the first difference between passed values.\n  const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);\n  // If arrays are equal return -1 indexes object.\n  if (firstIndex === -1) {\n    return {\n      firstIndex: -1,\n      lastIndexOld: -1,\n      lastIndexNew: -1\n    };\n  }\n  // Remove the common part of each value and reverse them to make it simpler to find the last difference between them.\n  const oldArrayReversed = cutAndReverse(arr1, firstIndex);\n  const newArrayReversed = cutAndReverse(arr2, firstIndex);\n  // Find the first difference between reversed values.\n  // It should be treated as \"how many elements from the end the last difference occurred\".\n  //\n  // For example:\n  //\n  // \t\t\t\tinitial\t->\tafter cut\t-> reversed:\n  // oldValue:\t'321ba'\t->\t'21ba'\t\t-> 'ab12'\n  // newValue:\t'31xba'\t->\t'1xba'\t\t-> 'abx1'\n  // lastIndex:\t\t\t\t\t\t\t-> 2\n  //\n  // So the last change occurred two characters from the end of the arrays.\n  const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);\n  // Use `lastIndex` to calculate proper offset, starting from the beginning (`lastIndex` kind of starts from the end).\n  const lastIndexOld = arr1.length - lastIndex;\n  const lastIndexNew = arr2.length - lastIndex;\n  return {\n    firstIndex,\n    lastIndexOld,\n    lastIndexNew\n  };\n}\n// Returns a first index on which given arrays differ. If both arrays are the same, -1 is returned.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Number}\nfunction findFirstDifferenceIndex(arr1, arr2, cmp) {\n  for (let i = 0; i < Math.max(arr1.length, arr2.length); i++) {\n    if (arr1[i] === undefined || arr2[i] === undefined || !cmp(arr1[i], arr2[i])) {\n      return i;\n    }\n  }\n  return -1; // Return -1 if arrays are equal.\n}\n// Returns a copy of the given array with `howMany` elements removed starting from the beginning and in reversed order.\n//\n// @param {Array} arr Array to be processed.\n// @param {Number} howMany How many elements from array beginning to remove.\n// @returns {Array} Shortened and reversed array.\nfunction cutAndReverse(arr, howMany) {\n  return arr.slice(howMany).reverse();\n}\n// Generates changes array based on change indexes from `findChangeBoundaryIndexes` function. This function will\n// generate array with 0 (no changes), 1 (deletion or insertion) or 2 records (insertion and deletion).\n//\n// @param {Array} newArray New array for which change indexes were calculated.\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @returns {Array.<module:utils/difftochanges~Change>} Array of changes compatible with\n// {@link module:utils/difftochanges~diffToChanges} format.\nfunction changeIndexesToChanges(newArray, changeIndexes) {\n  const result = [];\n  const {\n    firstIndex,\n    lastIndexOld,\n    lastIndexNew\n  } = changeIndexes;\n  // Order operations as 'insert', 'delete' array to keep compatibility with {@link module:utils/difftochanges~diffToChanges}\n  // in most cases. However, 'diffToChanges' does not stick to any order so in some cases\n  // (for example replacing '12345' with 'abcd') it will generate 'delete', 'insert' order.\n  if (lastIndexNew - firstIndex > 0) {\n    result.push({\n      index: firstIndex,\n      type: 'insert',\n      values: newArray.slice(firstIndex, lastIndexNew)\n    });\n  }\n  if (lastIndexOld - firstIndex > 0) {\n    result.push({\n      index: firstIndex + (lastIndexNew - firstIndex),\n      type: 'delete',\n      howMany: lastIndexOld - firstIndex\n    });\n  }\n  return result;\n}\n// Generates array with set `equal|insert|delete` operations based on change indexes from `findChangeBoundaryIndexes` function.\n//\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @param {Number} newLength Length of the new array on which `findChangeBoundaryIndexes` calculated change indexes.\n// @returns {Array.<module:utils/diff~DiffResult>} Array of changes compatible with {@link module:utils/diff~diff} format.\nfunction changeIndexesToAtomicChanges(changeIndexes, newLength) {\n  const {\n    firstIndex,\n    lastIndexOld,\n    lastIndexNew\n  } = changeIndexes;\n  // No changes.\n  if (firstIndex === -1) {\n    return Array(newLength).fill('equal');\n  }\n  let result = [];\n  if (firstIndex > 0) {\n    result = result.concat(Array(firstIndex).fill('equal'));\n  }\n  if (lastIndexNew - firstIndex > 0) {\n    result = result.concat(Array(lastIndexNew - firstIndex).fill('insert'));\n  }\n  if (lastIndexOld - firstIndex > 0) {\n    result = result.concat(Array(lastIndexOld - firstIndex).fill('delete'));\n  }\n  if (lastIndexNew < newLength) {\n    result = result.concat(Array(newLength - lastIndexNew).fill('equal'));\n  }\n  return result;\n}","map":{"version":3,"names":["fastDiff","a","b","cmp","atomicChanges","arrayA","Array","isArray","prototype","slice","call","arrayB","changeIndexes","findChangeBoundaryIndexes","changeIndexesToAtomicChanges","length","changeIndexesToChanges","arr1","arr2","firstIndex","findFirstDifferenceIndex","lastIndexOld","lastIndexNew","oldArrayReversed","cutAndReverse","newArrayReversed","lastIndex","i","Math","max","undefined","arr","howMany","reverse","newArray","result","push","index","type","values","newLength","fill","concat"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Finds positions of the first and last change in the given string/array and generates a set of changes:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ { index: 2, type: 'insert', values: [ 'x', 'y', 'z' ] } ]\n *\n *\t\tfastDiff( '12a', '12aa' );\n *\t\t// [ { index: 3, type: 'insert', values: [ 'a' ] } ]\n *\n *\t\tfastDiff( '12xyza', '12a' );\n *\t\t// [ { index: 2, type: 'delete', howMany: 3 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'a' ], [ '1', '2', 'a' ] );\n *\t\t// [ { index: 3, type: 'delete', howMany: 1 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'b', 'c', '3' ], [ '2', 'a', 'b' ] );\n *\t\t// [ { index: 0, type: 'insert', values: [ '2', 'a', 'b' ] }, { index: 3, type: 'delete', howMany: 6 } ]\n *\n * Passed arrays can contain any type of data, however to compare them correctly custom comparator function\n * should be passed as a third parameter:\n *\n *\t\tfastDiff( [ { value: 1 }, { value: 2 } ], [ { value: 1 }, { value: 3 } ], ( a, b ) => {\n *\t\t\treturn a.value === b.value;\n *\t\t} );\n *\t\t// [ { index: 1, type: 'insert', values: [ { value: 3 } ] }, { index: 2, type: 'delete', howMany: 1 } ]\n *\n * The resulted set of changes can be applied to the input in order to transform it into the output, for example:\n *\n *\t\tlet input = '12abc3';\n *\t\tconst output = '2ab';\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + change.values.join( '' ) + input.substring( change.index );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + input.substring( change.index + change.howMany );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * or in case of arrays:\n *\n *\t\tlet input = [ '1', '2', 'a', 'b', 'c', '3' ];\n *\t\tconst output = [ '2', 'a', 'b' ];\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( change.values, input.slice( change.index ) );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( input.slice( change.index + change.howMany ) );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * By passing `true` as the fourth parameter (`atomicChanges`) the output of this function will become compatible with\n * the {@link module:utils/diff~diff `diff()`} function:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ 'equal', 'equal', 'insert', 'insert', 'insert', 'equal' ]\n *\n * The default output format of this function is compatible with the output format of\n * {@link module:utils/difftochanges~diffToChanges `diffToChanges()`}. The `diffToChanges()` input format is, in turn,\n * compatible with the output of {@link module:utils/diff~diff `diff()`}:\n *\n *\t\tconst a = '1234';\n *\t\tconst b = '12xyz34';\n *\n *\t\t// Both calls will return the same results (grouped changes format).\n *\t\tfastDiff( a, b );\n *\t\tdiffToChanges( diff( a, b ) );\n *\n *\t\t// Again, both calls will return the same results (atomic changes format).\n *\t\tfastDiff( a, b, null, true );\n *\t\tdiff( a, b );\n *\n *\n * @param {Array|String} a Input array or string.\n * @param {Array|String} b Input array or string.\n * @param {Function} [cmp] Optional function used to compare array values, by default `===` (strict equal operator) is used.\n * @param {Boolean} [atomicChanges=false] Whether an array of `inset|delete|equal` operations should\n * be returned instead of changes set. This makes this function compatible with {@link module:utils/diff~diff `diff()`}.\n * @returns {Array} Array of changes.\n */\nexport default function fastDiff(a, b, cmp, atomicChanges = false) {\n    // Set the comparator function.\n    cmp = cmp || function (a, b) {\n        return a === b;\n    };\n    // Convert the string (or any array-like object - eg. NodeList) to an array by using the slice() method because,\n    // unlike Array.from(), it returns array of UTF-16 code units instead of the code points of a string.\n    // One code point might be a surrogate pair of two code units. All text offsets are expected to be in code units.\n    // See ckeditor/ckeditor5#3147.\n    //\n    // We need to make sure here that fastDiff() works identical to diff().\n    const arrayA = Array.isArray(a) ? a : Array.prototype.slice.call(a);\n    const arrayB = Array.isArray(b) ? b : Array.prototype.slice.call(b);\n    // Find first and last change.\n    const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);\n    // Transform into changes array.\n    return atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);\n}\n// Finds position of the first and last change in the given arrays. For example:\n//\n//\t\tconst indexes = findChangeBoundaryIndexes( [ '1', '2', '3', '4' ], [ '1', '3', '4', '2', '4' ] );\n//\t\tconsole.log( indexes ); // { firstIndex: 1, lastIndexOld: 3, lastIndexNew: 4 }\n//\n// The above indexes means that in the first array the modified part is `1[23]4` and in the second array it is `1[342]4`.\n// Based on such indexes, array with `insert`/`delete` operations which allows transforming first value into the second one\n// can be generated.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Object}\n// @returns {Number} return.firstIndex Index of the first change in both values (always the same for both).\n// @returns {Number} result.lastIndexOld Index of the last common value in `arr1`.\n// @returns {Number} result.lastIndexNew Index of the last common value in `arr2`.\nfunction findChangeBoundaryIndexes(arr1, arr2, cmp) {\n    // Find the first difference between passed values.\n    const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);\n    // If arrays are equal return -1 indexes object.\n    if (firstIndex === -1) {\n        return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };\n    }\n    // Remove the common part of each value and reverse them to make it simpler to find the last difference between them.\n    const oldArrayReversed = cutAndReverse(arr1, firstIndex);\n    const newArrayReversed = cutAndReverse(arr2, firstIndex);\n    // Find the first difference between reversed values.\n    // It should be treated as \"how many elements from the end the last difference occurred\".\n    //\n    // For example:\n    //\n    // \t\t\t\tinitial\t->\tafter cut\t-> reversed:\n    // oldValue:\t'321ba'\t->\t'21ba'\t\t-> 'ab12'\n    // newValue:\t'31xba'\t->\t'1xba'\t\t-> 'abx1'\n    // lastIndex:\t\t\t\t\t\t\t-> 2\n    //\n    // So the last change occurred two characters from the end of the arrays.\n    const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);\n    // Use `lastIndex` to calculate proper offset, starting from the beginning (`lastIndex` kind of starts from the end).\n    const lastIndexOld = arr1.length - lastIndex;\n    const lastIndexNew = arr2.length - lastIndex;\n    return { firstIndex, lastIndexOld, lastIndexNew };\n}\n// Returns a first index on which given arrays differ. If both arrays are the same, -1 is returned.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Number}\nfunction findFirstDifferenceIndex(arr1, arr2, cmp) {\n    for (let i = 0; i < Math.max(arr1.length, arr2.length); i++) {\n        if (arr1[i] === undefined || arr2[i] === undefined || !cmp(arr1[i], arr2[i])) {\n            return i;\n        }\n    }\n    return -1; // Return -1 if arrays are equal.\n}\n// Returns a copy of the given array with `howMany` elements removed starting from the beginning and in reversed order.\n//\n// @param {Array} arr Array to be processed.\n// @param {Number} howMany How many elements from array beginning to remove.\n// @returns {Array} Shortened and reversed array.\nfunction cutAndReverse(arr, howMany) {\n    return arr.slice(howMany).reverse();\n}\n// Generates changes array based on change indexes from `findChangeBoundaryIndexes` function. This function will\n// generate array with 0 (no changes), 1 (deletion or insertion) or 2 records (insertion and deletion).\n//\n// @param {Array} newArray New array for which change indexes were calculated.\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @returns {Array.<module:utils/difftochanges~Change>} Array of changes compatible with\n// {@link module:utils/difftochanges~diffToChanges} format.\nfunction changeIndexesToChanges(newArray, changeIndexes) {\n    const result = [];\n    const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;\n    // Order operations as 'insert', 'delete' array to keep compatibility with {@link module:utils/difftochanges~diffToChanges}\n    // in most cases. However, 'diffToChanges' does not stick to any order so in some cases\n    // (for example replacing '12345' with 'abcd') it will generate 'delete', 'insert' order.\n    if (lastIndexNew - firstIndex > 0) {\n        result.push({\n            index: firstIndex,\n            type: 'insert',\n            values: newArray.slice(firstIndex, lastIndexNew)\n        });\n    }\n    if (lastIndexOld - firstIndex > 0) {\n        result.push({\n            index: firstIndex + (lastIndexNew - firstIndex),\n            type: 'delete',\n            howMany: lastIndexOld - firstIndex\n        });\n    }\n    return result;\n}\n// Generates array with set `equal|insert|delete` operations based on change indexes from `findChangeBoundaryIndexes` function.\n//\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @param {Number} newLength Length of the new array on which `findChangeBoundaryIndexes` calculated change indexes.\n// @returns {Array.<module:utils/diff~DiffResult>} Array of changes compatible with {@link module:utils/diff~diff} format.\nfunction changeIndexesToAtomicChanges(changeIndexes, newLength) {\n    const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;\n    // No changes.\n    if (firstIndex === -1) {\n        return Array(newLength).fill('equal');\n    }\n    let result = [];\n    if (firstIndex > 0) {\n        result = result.concat(Array(firstIndex).fill('equal'));\n    }\n    if (lastIndexNew - firstIndex > 0) {\n        result = result.concat(Array(lastIndexNew - firstIndex).fill('insert'));\n    }\n    if (lastIndexOld - firstIndex > 0) {\n        result = result.concat(Array(lastIndexOld - firstIndex).fill('delete'));\n    }\n    if (lastIndexNew < newLength) {\n        result = result.concat(Array(newLength - lastIndexNew).fill('equal'));\n    }\n    return result;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,QAAQ,CAACC,CAAC,EAAEC,CAAC,EAAEC,GAAG,EAAyB;EAAA,IAAvBC,aAAa,uEAAG,KAAK;EAC7D;EACAD,GAAG,GAAGA,GAAG,IAAI,UAAUF,CAAC,EAAEC,CAAC,EAAE;IACzB,OAAOD,CAAC,KAAKC,CAAC;EAClB,CAAC;EACD;EACA;EACA;EACA;EACA;EACA;EACA,MAAMG,MAAM,GAAGC,KAAK,CAACC,OAAO,CAACN,CAAC,CAAC,GAAGA,CAAC,GAAGK,KAAK,CAACE,SAAS,CAACC,KAAK,CAACC,IAAI,CAACT,CAAC,CAAC;EACnE,MAAMU,MAAM,GAAGL,KAAK,CAACC,OAAO,CAACL,CAAC,CAAC,GAAGA,CAAC,GAAGI,KAAK,CAACE,SAAS,CAACC,KAAK,CAACC,IAAI,CAACR,CAAC,CAAC;EACnE;EACA,MAAMU,aAAa,GAAGC,yBAAyB,CAACR,MAAM,EAAEM,MAAM,EAAER,GAAG,CAAC;EACpE;EACA,OAAOC,aAAa,GAAGU,4BAA4B,CAACF,aAAa,EAAED,MAAM,CAACI,MAAM,CAAC,GAAGC,sBAAsB,CAACL,MAAM,EAAEC,aAAa,CAAC;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,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"},"metadata":{},"sourceType":"module"}