{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/deletecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport ChangeBuffer from './utils/changebuffer';\n\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\nexport default class DeleteCommand extends Command {\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n   * should consume the content when the selection is collapsed.\n   */\n  constructor(editor, direction) {\n    super(editor);\n\n    /**\n     * The directionality of the delete describing in what direction it should\n     * consume the content when the selection is collapsed.\n     *\n     * @readonly\n     * @member {'forward'|'backward'} #direction\n     */\n    this.direction = direction;\n\n    /**\n     * Delete's change buffer used to group subsequent changes into batches.\n     *\n     * @readonly\n     * @private\n     * @type {module:typing/utils/changebuffer~ChangeBuffer}\n     */\n    this._buffer = new ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));\n  }\n\n  /**\n   * The current change buffer.\n   *\n   * @type {module:typing/utils/changebuffer~ChangeBuffer}\n   */\n  get buffer() {\n    return this._buffer;\n  }\n\n  /**\n   * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n   * or a piece of content in the {@link #direction defined direction}.\n   *\n   * @fires execute\n   * @param {Object} [options] The command options.\n   * @param {'character'|'codePoint'|'word'} [options.unit='character']\n   * See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n   * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n   * See the {@link module:engine/view/document~Document#event:delete} event data.\n   * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection\n   * will be used.\n   */\n  execute() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const model = this.editor.model;\n    const doc = model.document;\n    model.enqueueChange(this._buffer.batch, writer => {\n      this._buffer.lock();\n      const selection = writer.createSelection(options.selection || doc.selection);\n      const sequence = options.sequence || 1;\n\n      // Do not replace the whole selected content if selection was collapsed.\n      // This prevents such situation:\n      //\n      // <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n      // starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n      const doNotResetEntireContent = selection.isCollapsed;\n\n      // Try to extend the selection in the specified direction.\n      if (selection.isCollapsed) {\n        model.modifySelection(selection, {\n          direction: this.direction,\n          unit: options.unit,\n          treatEmojiAsSingleUnit: true\n        });\n      }\n\n      // Check if deleting in an empty editor. See #61.\n      if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {\n        this._replaceEntireContentWithParagraph(writer);\n        return;\n      }\n\n      // Check if deleting in the first empty block.\n      // See https://github.com/ckeditor/ckeditor5/issues/8137.\n      if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {\n        this.editor.execute('paragraph', {\n          selection\n        });\n        return;\n      }\n\n      // If selection is still collapsed, then there's nothing to delete.\n      if (selection.isCollapsed) {\n        return;\n      }\n      let changeCount = 0;\n      selection.getFirstRange().getMinimalFlatRanges().forEach(range => {\n        changeCount += count(range.getWalker({\n          singleCharacters: true,\n          ignoreElementEnd: true,\n          shallow: true\n        }));\n      });\n      model.deleteContent(selection, {\n        doNotResetEntireContent,\n        direction: this.direction\n      });\n      this._buffer.input(changeCount);\n      writer.setSelection(selection);\n      this._buffer.unlock();\n    });\n  }\n\n  /**\n   * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n   * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n   * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n   *\n   * But, if the user pressed the key in an empty editable for the first time,\n   * we want to replace the entire content with a paragraph if:\n   *\n   * * the current limit element is empty,\n   * * the paragraph is allowed in the limit element,\n   * * the limit doesn't already have a paragraph inside.\n   *\n   * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n   *\n   * @private\n   * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n   * @returns {Boolean}\n   */\n  _shouldEntireContentBeReplacedWithParagraph(sequence) {\n    // Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n    if (sequence > 1) {\n      return false;\n    }\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const limitElement = model.schema.getLimitElement(selection);\n\n    // If a collapsed selection contains the whole content it means that the content is empty\n    // (from the user perspective).\n    const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);\n    if (!limitElementIsEmpty) {\n      return false;\n    }\n    if (!model.schema.checkChild(limitElement, 'paragraph')) {\n      return false;\n    }\n    const limitElementFirstChild = limitElement.getChild(0);\n\n    // Does nothing if the limit element already contains only a paragraph.\n    // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n    // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n    if (limitElementFirstChild && limitElementFirstChild.name === 'paragraph') {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n   *\n   * @private\n   * @param {module:engine/model/writer~Writer} writer The model writer.\n   */\n  _replaceEntireContentWithParagraph(writer) {\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const limitElement = model.schema.getLimitElement(selection);\n    const paragraph = writer.createElement('paragraph');\n    writer.remove(writer.createRangeIn(limitElement));\n    writer.insert(paragraph, limitElement);\n    writer.setSelection(paragraph, 0);\n  }\n\n  /**\n   * Checks if the selection is inside an empty element that is the first child of the limit element\n   * and should be replaced with a paragraph.\n   *\n   * @private\n   * @param {module:engine/model/selection~Selection} selection The selection.\n   * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n   * @returns {Boolean}\n   */\n  _shouldReplaceFirstBlockWithParagraph(selection, sequence) {\n    const model = this.editor.model;\n\n    // Does nothing if user pressed and held the \"Backspace\" key or it was a \"Delete\" button.\n    if (sequence > 1 || this.direction != 'backward') {\n      return false;\n    }\n    if (!selection.isCollapsed) {\n      return false;\n    }\n    const position = selection.getFirstPosition();\n    const limitElement = model.schema.getLimitElement(position);\n    const limitElementFirstChild = limitElement.getChild(0);\n\n    // Only elements that are direct children of the limit element can be replaced.\n    // Unwrapping from a block quote should be handled in a dedicated feature.\n    if (position.parent != limitElementFirstChild) {\n      return false;\n    }\n\n    // A block should be replaced only if it was empty.\n    if (!selection.containsEntireContent(limitElementFirstChild)) {\n      return false;\n    }\n\n    // Replace with a paragraph only if it's allowed there.\n    if (!model.schema.checkChild(limitElement, 'paragraph')) {\n      return false;\n    }\n\n    // Does nothing if the limit element already contains only a paragraph.\n    if (limitElementFirstChild.name == 'paragraph') {\n      return false;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["Command","count","ChangeBuffer","DeleteCommand","constructor","editor","direction","_buffer","model","config","get","buffer","execute","options","doc","document","enqueueChange","batch","writer","lock","selection","createSelection","sequence","doNotResetEntireContent","isCollapsed","modifySelection","unit","treatEmojiAsSingleUnit","_shouldEntireContentBeReplacedWithParagraph","_replaceEntireContentWithParagraph","_shouldReplaceFirstBlockWithParagraph","changeCount","getFirstRange","getMinimalFlatRanges","forEach","range","getWalker","singleCharacters","ignoreElementEnd","shallow","deleteContent","input","setSelection","unlock","limitElement","schema","getLimitElement","limitElementIsEmpty","containsEntireContent","checkChild","limitElementFirstChild","getChild","name","paragraph","createElement","remove","createRangeIn","insert","position","getFirstPosition","parent"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-typing/src/deletecommand.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/deletecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\n\nimport ChangeBuffer from './utils/changebuffer';\n\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\nexport default class DeleteCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n\t * should consume the content when the selection is collapsed.\n\t */\n\tconstructor( editor, direction ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The directionality of the delete describing in what direction it should\n\t\t * consume the content when the selection is collapsed.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'forward'|'backward'} #direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Delete's change buffer used to group subsequent changes into batches.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @type {module:typing/utils/changebuffer~ChangeBuffer}\n\t\t */\n\t\tthis._buffer = new ChangeBuffer( editor.model, editor.config.get( 'typing.undoStep' ) );\n\t}\n\n\t/**\n\t * The current change buffer.\n\t *\n\t * @type {module:typing/utils/changebuffer~ChangeBuffer}\n\t */\n\tget buffer() {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n\t * or a piece of content in the {@link #direction defined direction}.\n\t *\n\t * @fires execute\n\t * @param {Object} [options] The command options.\n\t * @param {'character'|'codePoint'|'word'} [options.unit='character']\n\t * See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n\t * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n\t * See the {@link module:engine/view/document~Document#event:delete} event data.\n\t * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection\n\t * will be used.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\n\t\tmodel.enqueueChange( this._buffer.batch, writer => {\n\t\t\tthis._buffer.lock();\n\n\t\t\tconst selection = writer.createSelection( options.selection || doc.selection );\n\t\t\tconst sequence = options.sequence || 1;\n\n\t\t\t// Do not replace the whole selected content if selection was collapsed.\n\t\t\t// This prevents such situation:\n\t\t\t//\n\t\t\t// <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n\t\t\t// starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n\t\t\tconst doNotResetEntireContent = selection.isCollapsed;\n\n\t\t\t// Try to extend the selection in the specified direction.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\tmodel.modifySelection( selection, {\n\t\t\t\t\tdirection: this.direction,\n\t\t\t\t\tunit: options.unit,\n\t\t\t\t\ttreatEmojiAsSingleUnit: true\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Check if deleting in an empty editor. See #61.\n\t\t\tif ( this._shouldEntireContentBeReplacedWithParagraph( sequence ) ) {\n\t\t\t\tthis._replaceEntireContentWithParagraph( writer );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if deleting in the first empty block.\n\t\t\t// See https://github.com/ckeditor/ckeditor5/issues/8137.\n\t\t\tif ( this._shouldReplaceFirstBlockWithParagraph( selection, sequence ) ) {\n\t\t\t\tthis.editor.execute( 'paragraph', { selection } );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If selection is still collapsed, then there's nothing to delete.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet changeCount = 0;\n\n\t\t\tselection.getFirstRange().getMinimalFlatRanges().forEach( range => {\n\t\t\t\tchangeCount += count(\n\t\t\t\t\trange.getWalker( { singleCharacters: true, ignoreElementEnd: true, shallow: true } )\n\t\t\t\t);\n\t\t\t} );\n\n\t\t\tmodel.deleteContent( selection, {\n\t\t\t\tdoNotResetEntireContent,\n\t\t\t\tdirection: this.direction\n\t\t\t} );\n\n\t\t\tthis._buffer.input( changeCount );\n\n\t\t\twriter.setSelection( selection );\n\n\t\t\tthis._buffer.unlock();\n\t\t} );\n\t}\n\n\t/**\n\t * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n\t * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n\t * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n\t *\n\t * But, if the user pressed the key in an empty editable for the first time,\n\t * we want to replace the entire content with a paragraph if:\n\t *\n\t * * the current limit element is empty,\n\t * * the paragraph is allowed in the limit element,\n\t * * the limit doesn't already have a paragraph inside.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n\t *\n\t * @private\n\t * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n\t * @returns {Boolean}\n\t */\n\t_shouldEntireContentBeReplacedWithParagraph( sequence ) {\n\t\t// Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n\t\tif ( sequence > 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\n\t\t// If a collapsed selection contains the whole content it means that the content is empty\n\t\t// (from the user perspective).\n\t\tconst limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent( limitElement );\n\n\t\tif ( !limitElementIsEmpty ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !model.schema.checkChild( limitElement, 'paragraph' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst limitElementFirstChild = limitElement.getChild( 0 );\n\n\t\t// Does nothing if the limit element already contains only a paragraph.\n\t\t// We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n\t\t// because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n\t\tif ( limitElementFirstChild && limitElementFirstChild.name === 'paragraph' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer The model writer.\n\t */\n\t_replaceEntireContentWithParagraph( writer ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\t\tconst paragraph = writer.createElement( 'paragraph' );\n\n\t\twriter.remove( writer.createRangeIn( limitElement ) );\n\t\twriter.insert( paragraph, limitElement );\n\n\t\twriter.setSelection( paragraph, 0 );\n\t}\n\n\t/**\n\t * Checks if the selection is inside an empty element that is the first child of the limit element\n\t * and should be replaced with a paragraph.\n\t *\n\t * @private\n\t * @param {module:engine/model/selection~Selection} selection The selection.\n\t * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n\t * @returns {Boolean}\n\t */\n\t_shouldReplaceFirstBlockWithParagraph( selection, sequence ) {\n\t\tconst model = this.editor.model;\n\n\t\t// Does nothing if user pressed and held the \"Backspace\" key or it was a \"Delete\" button.\n\t\tif ( sequence > 1 || this.direction != 'backward' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst position = selection.getFirstPosition();\n\t\tconst limitElement = model.schema.getLimitElement( position );\n\t\tconst limitElementFirstChild = limitElement.getChild( 0 );\n\n\t\t// Only elements that are direct children of the limit element can be replaced.\n\t\t// Unwrapping from a block quote should be handled in a dedicated feature.\n\t\tif ( position.parent != limitElementFirstChild ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// A block should be replaced only if it was empty.\n\t\tif ( !selection.containsEntireContent( limitElementFirstChild ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Replace with a paragraph only if it's allowed there.\n\t\tif ( !model.schema.checkChild( limitElement, 'paragraph' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Does nothing if the limit element already contains only a paragraph.\n\t\tif ( limitElementFirstChild.name == 'paragraph' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}