{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/dom/position\n */\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es';\n// @if CK_DEBUG_POSITION // import { RectDrawer } from '@ckeditor/ckeditor5-minimap/src/utils';\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options The input data and configuration of the helper.\n * @returns {module:utils/dom/position~Position}\n */\nexport function getOptimalPosition(_ref) {\n  let {\n    element,\n    target,\n    positions,\n    limiter,\n    fitInViewport,\n    viewportOffsetConfig\n  } = _ref;\n  // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-utils/issues/157\n  if (isFunction(target)) {\n    target = target();\n  }\n  // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-ui/issues/260\n  if (isFunction(limiter)) {\n    limiter = limiter();\n  }\n  const positionedElementAncestor = getPositionedAncestor(element);\n  const elementRect = new Rect(element);\n  const targetRect = new Rect(target);\n  let bestPosition;\n  // @if CK_DEBUG_POSITION // RectDrawer.clear();\n  // @if CK_DEBUG_POSITION // RectDrawer.draw( targetRect, { outlineWidth: '5px' }, 'Target' );\n  const viewportRect = fitInViewport && getConstrainedViewportRect(viewportOffsetConfig) || null;\n  const positionOptions = {\n    targetRect,\n    elementRect,\n    positionedElementAncestor,\n    viewportRect\n  };\n  // If there are no limits, just grab the very first position and be done with that drama.\n  if (!limiter && !fitInViewport) {\n    bestPosition = new PositionObject(positions[0], positionOptions);\n  } else {\n    const limiterRect = limiter && new Rect(limiter).getVisible();\n    // @if CK_DEBUG_POSITION // if ( viewportRect ) {\n    // @if CK_DEBUG_POSITION //\t\tRectDrawer.draw( viewportRect, { outlineWidth: '5px' }, 'Viewport' );\n    // @if CK_DEBUG_POSITION // }\n    // @if CK_DEBUG_POSITION // if ( limiter ) {\n    // @if CK_DEBUG_POSITION // \tRectDrawer.draw( limiterRect, { outlineWidth: '5px', outlineColor: 'green' }, 'Visible limiter' );\n    // @if CK_DEBUG_POSITION // }\n    Object.assign(positionOptions, {\n      limiterRect,\n      viewportRect\n    });\n    // If there's no best position found, i.e. when all intersections have no area because\n    // rects have no width or height, then just use the first available position.\n    bestPosition = getBestPosition(positions, positionOptions) || new PositionObject(positions[0], positionOptions);\n  }\n  return bestPosition;\n}\n// Returns a viewport `Rect` shrunk by the viewport offset config from all sides.\n//\n// @private\n// @param {Object} An object containing viewportOffset config.\n// @returns {module:utils/dom/rect~Rect} A shrunken rect of the viewport.\nfunction getConstrainedViewportRect(viewportOffsetConfig) {\n  viewportOffsetConfig = Object.assign({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  }, viewportOffsetConfig);\n  const viewportRect = new Rect(global.window);\n  viewportRect.top += viewportOffsetConfig.top;\n  viewportRect.height -= viewportOffsetConfig.top;\n  viewportRect.bottom -= viewportOffsetConfig.bottom;\n  viewportRect.height -= viewportOffsetConfig.bottom;\n  return viewportRect;\n}\n// For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n//\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position}to be checked, in the order of preference.\n// @param {Object} options\n// @param {module:utils/dom/rect~Rect} options.elementRect The positioned element rect.\n// @param {module:utils/dom/rect~Rect} options.targetRect The target element rect.\n// @param {module:utils/dom/rect~Rect} options.viewportRect The viewport rect.\n// @param {module:utils/dom/rect~Rect} [options.limiterRect] The limiter rect.\n// @param {HTMLElement|null} [options.positionedElementAncestor] Nearest element ancestor element which CSS position is not \"static\".\n//\n// @returns {module:utils/dom/position~Position|null} An array containing the name of the position and it's rect.\nfunction getBestPosition(positions, options) {\n  const {\n    elementRect\n  } = options;\n  // This is when element is fully visible.\n  const elementRectArea = elementRect.getArea();\n  const positionInstances = positions.map(positioningFunction => new PositionObject(positioningFunction, options))\n  // Some positioning functions may return `null` if they don't want to participate.\n  .filter(position => !!position.name);\n  let maxFitFactor = 0;\n  let bestPosition = null;\n  for (const position of positionInstances) {\n    const {\n      limiterIntersectionArea,\n      viewportIntersectionArea\n    } = position;\n    // If a such position is found that element is fully contained by the limiter then, obviously,\n    // there will be no better one, so finishing.\n    if (limiterIntersectionArea === elementRectArea) {\n      return position;\n    }\n    // To maximize both viewport and limiter intersection areas we use distance on _viewportIntersectionArea\n    // and _limiterIntersectionArea plane (without sqrt because we are looking for max value).\n    const fitFactor = viewportIntersectionArea ** 2 + limiterIntersectionArea ** 2;\n    if (fitFactor > maxFitFactor) {\n      maxFitFactor = fitFactor;\n      bestPosition = position;\n    }\n  }\n  return bestPosition;\n}\n// For a given absolute Rect coordinates object and a positioned element ancestor, it updates its\n// coordinates that make up for the position and the scroll of the ancestor.\n//\n// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates\n// are used in realâ€“life to position elements with `position: absolute`, which are scoped by any positioned\n// (and scrollable) ancestors.\n//\n// @private\n//\n// @param {module:utils/dom/rect~Rect} rect A rect with absolute rect coordinates.\n// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.\nfunction shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {\n  const ancestorPosition = getRectForAbsolutePositioning(new Rect(positionedElementAncestor));\n  const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);\n  let moveX = 0;\n  let moveY = 0;\n  // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n  // If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n  // consideration. `Rect` is always relative to the viewport while `position: absolute` works\n  // with respect to that positioned ancestor.\n  moveX -= ancestorPosition.left;\n  moveY -= ancestorPosition.top;\n  // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, not only its position must be taken into\n  // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n  // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n  // must compensate that scrolling.\n  moveX += positionedElementAncestor.scrollLeft;\n  moveY += positionedElementAncestor.scrollTop;\n  // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n  // while `position: absolute` positioning does not consider it.\n  // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n  // not upper-left corner of its border.\n  moveX -= ancestorBorderWidths.left;\n  moveY -= ancestorBorderWidths.top;\n  rect.moveBy(moveX, moveY);\n}\n// DOMRect (also Rect) works in a scrollâ€“independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {module:utils/dom/rect~Rect} Object containing `left` and `top` properties, in absolute coordinates.\nfunction getRectForAbsolutePositioning(rect) {\n  const {\n    scrollX,\n    scrollY\n  } = global.window;\n  return rect.clone().moveBy(scrollX, scrollY);\n}\n// A position class which instances are created and used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n//\n// {@link module:utils/dom/position~Position#top} and {@link module:utils/dom/position~Position#left} properties of the position instance\n// translate directly to the `top` and `left` properties in CSS \"`position: absolute` coordinate system\". If set on the positioned element\n// in DOM, they will make it display it in the right place in the viewport.\n// @private\n// @implements {Position}\nclass PositionObject {\n  // Creates an instance of the {@link module:utils/dom/position~PositionObject} class.\n  //\n  // @param {module:utils/dom/position~PositioningFunction} positioningFunction function The function that defines the expected\n  // coordinates the positioned element should move to.\n  // @param {Object} [options] options object.\n  // @param {module:utils/dom/rect~Rect} options.elementRect The positioned element rect.\n  // @param {module:utils/dom/rect~Rect} options.targetRect The target element rect.\n  // @param {module:utils/dom/rect~Rect|null} options.viewportRect The viewport rect.\n  // @param {module:utils/dom/rect~Rect} [options.limiterRect] The limiter rect.\n  // @param {HTMLElement|null} [options.positionedElementAncestor] Nearest element ancestor element which CSS position is not \"static\".\n  constructor(positioningFunction, options) {\n    const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect);\n    // Nameless position for a function that didn't participate.\n    if (!positioningFunctionOutput) {\n      return;\n    }\n    const {\n      left,\n      top,\n      name,\n      config\n    } = positioningFunctionOutput;\n    this.name = name;\n    this.config = config;\n    this._positioningFunctionCorrdinates = {\n      left,\n      top\n    };\n    this._options = options;\n  }\n  // The left value in pixels in the CSS `position: absolute` coordinate system.\n  // Set it on the positioned element in DOM to move it to the position.\n  //\n  // @readonly\n  // @type {Number}\n  get left() {\n    return this._absoluteRect.left;\n  }\n  // The top value in pixels in the CSS `position: absolute` coordinate system.\n  // Set it on the positioned element in DOM to move it to the position.\n  //\n  // @readonly\n  // @type {Number}\n  get top() {\n    return this._absoluteRect.top;\n  }\n  // An intersection area between positioned element and limiter within viewport constraints.\n  //\n  // @readonly\n  // @type {Number}\n  get limiterIntersectionArea() {\n    const limiterRect = this._options.limiterRect;\n    if (limiterRect) {\n      const viewportRect = this._options.viewportRect;\n      if (viewportRect) {\n        // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n        const limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);\n        if (limiterViewportIntersectRect) {\n          // If the limiter is within the viewport, then check the intersection between that part of the\n          // limiter and actual position.\n          return limiterViewportIntersectRect.getIntersectionArea(this._rect);\n        }\n      } else {\n        return limiterRect.getIntersectionArea(this._rect);\n      }\n    }\n    return 0;\n  }\n  // An intersection area between positioned element and viewport.\n  //\n  // @readonly\n  // @type {Number}\n  get viewportIntersectionArea() {\n    const viewportRect = this._options.viewportRect;\n    if (viewportRect) {\n      return viewportRect.getIntersectionArea(this._rect);\n    }\n    return 0;\n  }\n  // An already positioned element rect. A clone of the element rect passed to the constructor\n  // but placed in the viewport according to the positioning function.\n  //\n  // @private\n  // @readonly\n  // @type {module:utils/dom/rect~Rect}\n  get _rect() {\n    if (this._cachedRect) {\n      return this._cachedRect;\n    }\n    this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top);\n    return this._cachedRect;\n  }\n  // An already absolutely positioned element rect. See ({@link #_rect}).\n  //\n  // @private\n  // @readonly\n  // @type {module:utils/dom/rect~Rect}\n  get _absoluteRect() {\n    if (this._cachedAbsoluteRect) {\n      return this._cachedAbsoluteRect;\n    }\n    this._cachedAbsoluteRect = getRectForAbsolutePositioning(this._rect);\n    if (this._options.positionedElementAncestor) {\n      shiftRectToCompensatePositionedAncestor(this._cachedAbsoluteRect, this._options.positionedElementAncestor);\n    }\n    return this._cachedAbsoluteRect;\n  }\n}","map":{"version":3,"names":["global","Rect","getPositionedAncestor","getBorderWidths","isFunction","getOptimalPosition","element","target","positions","limiter","fitInViewport","viewportOffsetConfig","positionedElementAncestor","elementRect","targetRect","bestPosition","viewportRect","getConstrainedViewportRect","positionOptions","PositionObject","limiterRect","getVisible","Object","assign","getBestPosition","top","bottom","left","right","window","height","options","elementRectArea","getArea","positionInstances","map","positioningFunction","filter","position","name","maxFitFactor","limiterIntersectionArea","viewportIntersectionArea","fitFactor","shiftRectToCompensatePositionedAncestor","rect","ancestorPosition","getRectForAbsolutePositioning","ancestorBorderWidths","moveX","moveY","scrollLeft","scrollTop","moveBy","scrollX","scrollY","clone","constructor","positioningFunctionOutput","config","_positioningFunctionCorrdinates","_options","_absoluteRect","limiterViewportIntersectRect","getIntersection","getIntersectionArea","_rect","_cachedRect","moveTo","_cachedAbsoluteRect"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/dom/position\n */\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es';\n// @if CK_DEBUG_POSITION // import { RectDrawer } from '@ckeditor/ckeditor5-minimap/src/utils';\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options The input data and configuration of the helper.\n * @returns {module:utils/dom/position~Position}\n */\nexport function getOptimalPosition({ element, target, positions, limiter, fitInViewport, viewportOffsetConfig }) {\n    // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n    // https://github.com/ckeditor/ckeditor5-utils/issues/157\n    if (isFunction(target)) {\n        target = target();\n    }\n    // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n    // https://github.com/ckeditor/ckeditor5-ui/issues/260\n    if (isFunction(limiter)) {\n        limiter = limiter();\n    }\n    const positionedElementAncestor = getPositionedAncestor(element);\n    const elementRect = new Rect(element);\n    const targetRect = new Rect(target);\n    let bestPosition;\n    // @if CK_DEBUG_POSITION // RectDrawer.clear();\n    // @if CK_DEBUG_POSITION // RectDrawer.draw( targetRect, { outlineWidth: '5px' }, 'Target' );\n    const viewportRect = fitInViewport && getConstrainedViewportRect(viewportOffsetConfig) || null;\n    const positionOptions = { targetRect, elementRect, positionedElementAncestor, viewportRect };\n    // If there are no limits, just grab the very first position and be done with that drama.\n    if (!limiter && !fitInViewport) {\n        bestPosition = new PositionObject(positions[0], positionOptions);\n    }\n    else {\n        const limiterRect = limiter && new Rect(limiter).getVisible();\n        // @if CK_DEBUG_POSITION // if ( viewportRect ) {\n        // @if CK_DEBUG_POSITION //\t\tRectDrawer.draw( viewportRect, { outlineWidth: '5px' }, 'Viewport' );\n        // @if CK_DEBUG_POSITION // }\n        // @if CK_DEBUG_POSITION // if ( limiter ) {\n        // @if CK_DEBUG_POSITION // \tRectDrawer.draw( limiterRect, { outlineWidth: '5px', outlineColor: 'green' }, 'Visible limiter' );\n        // @if CK_DEBUG_POSITION // }\n        Object.assign(positionOptions, { limiterRect, viewportRect });\n        // If there's no best position found, i.e. when all intersections have no area because\n        // rects have no width or height, then just use the first available position.\n        bestPosition = getBestPosition(positions, positionOptions) || new PositionObject(positions[0], positionOptions);\n    }\n    return bestPosition;\n}\n// Returns a viewport `Rect` shrunk by the viewport offset config from all sides.\n//\n// @private\n// @param {Object} An object containing viewportOffset config.\n// @returns {module:utils/dom/rect~Rect} A shrunken rect of the viewport.\nfunction getConstrainedViewportRect(viewportOffsetConfig) {\n    viewportOffsetConfig = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, viewportOffsetConfig);\n    const viewportRect = new Rect(global.window);\n    viewportRect.top += viewportOffsetConfig.top;\n    viewportRect.height -= viewportOffsetConfig.top;\n    viewportRect.bottom -= viewportOffsetConfig.bottom;\n    viewportRect.height -= viewportOffsetConfig.bottom;\n    return viewportRect;\n}\n// For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n//\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position}to be checked, in the order of preference.\n// @param {Object} options\n// @param {module:utils/dom/rect~Rect} options.elementRect The positioned element rect.\n// @param {module:utils/dom/rect~Rect} options.targetRect The target element rect.\n// @param {module:utils/dom/rect~Rect} options.viewportRect The viewport rect.\n// @param {module:utils/dom/rect~Rect} [options.limiterRect] The limiter rect.\n// @param {HTMLElement|null} [options.positionedElementAncestor] Nearest element ancestor element which CSS position is not \"static\".\n//\n// @returns {module:utils/dom/position~Position|null} An array containing the name of the position and it's rect.\nfunction getBestPosition(positions, options) {\n    const { elementRect } = options;\n    // This is when element is fully visible.\n    const elementRectArea = elementRect.getArea();\n    const positionInstances = positions\n        .map(positioningFunction => new PositionObject(positioningFunction, options))\n        // Some positioning functions may return `null` if they don't want to participate.\n        .filter(position => !!position.name);\n    let maxFitFactor = 0;\n    let bestPosition = null;\n    for (const position of positionInstances) {\n        const { limiterIntersectionArea, viewportIntersectionArea } = position;\n        // If a such position is found that element is fully contained by the limiter then, obviously,\n        // there will be no better one, so finishing.\n        if (limiterIntersectionArea === elementRectArea) {\n            return position;\n        }\n        // To maximize both viewport and limiter intersection areas we use distance on _viewportIntersectionArea\n        // and _limiterIntersectionArea plane (without sqrt because we are looking for max value).\n        const fitFactor = viewportIntersectionArea ** 2 + limiterIntersectionArea ** 2;\n        if (fitFactor > maxFitFactor) {\n            maxFitFactor = fitFactor;\n            bestPosition = position;\n        }\n    }\n    return bestPosition;\n}\n// For a given absolute Rect coordinates object and a positioned element ancestor, it updates its\n// coordinates that make up for the position and the scroll of the ancestor.\n//\n// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates\n// are used in realâ€“life to position elements with `position: absolute`, which are scoped by any positioned\n// (and scrollable) ancestors.\n//\n// @private\n//\n// @param {module:utils/dom/rect~Rect} rect A rect with absolute rect coordinates.\n// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.\nfunction shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {\n    const ancestorPosition = getRectForAbsolutePositioning(new Rect(positionedElementAncestor));\n    const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);\n    let moveX = 0;\n    let moveY = 0;\n    // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n    // If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n    // consideration. `Rect` is always relative to the viewport while `position: absolute` works\n    // with respect to that positioned ancestor.\n    moveX -= ancestorPosition.left;\n    moveY -= ancestorPosition.top;\n    // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n    // If there's some positioned ancestor of the panel, not only its position must be taken into\n    // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n    // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n    // must compensate that scrolling.\n    moveX += positionedElementAncestor.scrollLeft;\n    moveY += positionedElementAncestor.scrollTop;\n    // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n    // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n    // while `position: absolute` positioning does not consider it.\n    // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n    // not upper-left corner of its border.\n    moveX -= ancestorBorderWidths.left;\n    moveY -= ancestorBorderWidths.top;\n    rect.moveBy(moveX, moveY);\n}\n// DOMRect (also Rect) works in a scrollâ€“independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {module:utils/dom/rect~Rect} Object containing `left` and `top` properties, in absolute coordinates.\nfunction getRectForAbsolutePositioning(rect) {\n    const { scrollX, scrollY } = global.window;\n    return rect.clone().moveBy(scrollX, scrollY);\n}\n// A position class which instances are created and used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n//\n// {@link module:utils/dom/position~Position#top} and {@link module:utils/dom/position~Position#left} properties of the position instance\n// translate directly to the `top` and `left` properties in CSS \"`position: absolute` coordinate system\". If set on the positioned element\n// in DOM, they will make it display it in the right place in the viewport.\n// @private\n// @implements {Position}\nclass PositionObject {\n    // Creates an instance of the {@link module:utils/dom/position~PositionObject} class.\n    //\n    // @param {module:utils/dom/position~PositioningFunction} positioningFunction function The function that defines the expected\n    // coordinates the positioned element should move to.\n    // @param {Object} [options] options object.\n    // @param {module:utils/dom/rect~Rect} options.elementRect The positioned element rect.\n    // @param {module:utils/dom/rect~Rect} options.targetRect The target element rect.\n    // @param {module:utils/dom/rect~Rect|null} options.viewportRect The viewport rect.\n    // @param {module:utils/dom/rect~Rect} [options.limiterRect] The limiter rect.\n    // @param {HTMLElement|null} [options.positionedElementAncestor] Nearest element ancestor element which CSS position is not \"static\".\n    constructor(positioningFunction, options) {\n        const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect);\n        // Nameless position for a function that didn't participate.\n        if (!positioningFunctionOutput) {\n            return;\n        }\n        const { left, top, name, config } = positioningFunctionOutput;\n        this.name = name;\n        this.config = config;\n        this._positioningFunctionCorrdinates = { left, top };\n        this._options = options;\n    }\n    // The left value in pixels in the CSS `position: absolute` coordinate system.\n    // Set it on the positioned element in DOM to move it to the position.\n    //\n    // @readonly\n    // @type {Number}\n    get left() {\n        return this._absoluteRect.left;\n    }\n    // The top value in pixels in the CSS `position: absolute` coordinate system.\n    // Set it on the positioned element in DOM to move it to the position.\n    //\n    // @readonly\n    // @type {Number}\n    get top() {\n        return this._absoluteRect.top;\n    }\n    // An intersection area between positioned element and limiter within viewport constraints.\n    //\n    // @readonly\n    // @type {Number}\n    get limiterIntersectionArea() {\n        const limiterRect = this._options.limiterRect;\n        if (limiterRect) {\n            const viewportRect = this._options.viewportRect;\n            if (viewportRect) {\n                // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n                const limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);\n                if (limiterViewportIntersectRect) {\n                    // If the limiter is within the viewport, then check the intersection between that part of the\n                    // limiter and actual position.\n                    return limiterViewportIntersectRect.getIntersectionArea(this._rect);\n                }\n            }\n            else {\n                return limiterRect.getIntersectionArea(this._rect);\n            }\n        }\n        return 0;\n    }\n    // An intersection area between positioned element and viewport.\n    //\n    // @readonly\n    // @type {Number}\n    get viewportIntersectionArea() {\n        const viewportRect = this._options.viewportRect;\n        if (viewportRect) {\n            return viewportRect.getIntersectionArea(this._rect);\n        }\n        return 0;\n    }\n    // An already positioned element rect. A clone of the element rect passed to the constructor\n    // but placed in the viewport according to the positioning function.\n    //\n    // @private\n    // @readonly\n    // @type {module:utils/dom/rect~Rect}\n    get _rect() {\n        if (this._cachedRect) {\n            return this._cachedRect;\n        }\n        this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top);\n        return this._cachedRect;\n    }\n    // An already absolutely positioned element rect. See ({@link #_rect}).\n    //\n    // @private\n    // @readonly\n    // @type {module:utils/dom/rect~Rect}\n    get _absoluteRect() {\n        if (this._cachedAbsoluteRect) {\n            return this._cachedAbsoluteRect;\n        }\n        this._cachedAbsoluteRect = getRectForAbsolutePositioning(this._rect);\n        if (this._options.positionedElementAncestor) {\n            shiftRectToCompensatePositionedAncestor(this._cachedAbsoluteRect, this._options.positionedElementAncestor);\n        }\n        return this._cachedAbsoluteRect;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}