{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/view/document\n */\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport BubblingEmitterMixin from './observer/bubblingemittermixin';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n/**\n * Document class creates an abstract layer over the content editable area, contains a tree of view elements and\n * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.\n *\n * @mixes module:engine/view/observer/bubblingemittermixin~BubblingEmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Document extends BubblingEmitterMixin(Observable) {\n  /**\n   * Creates a Document instance.\n   *\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  constructor(stylesProcessor) {\n    super();\n    /**\n     * Selection done on this document.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection\n     */\n    this.selection = new DocumentSelection();\n    /**\n     * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.\n     *\n     * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and\n     * {@link module:engine/model/document~Document#roots} and this is handled by\n     * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create\n     * model root using {@link module:engine/model/document~Document#createRoot}.\n     *\n     * @readonly\n     * @member {module:utils/collection~Collection} module:engine/view/document~Document#roots\n     */\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The styles processor instance used by this document when normalizing styles.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Defines whether document is in read-only mode.\n     *\n     * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.\n     *\n     * @observable\n     * @member {Boolean} #isReadOnly\n     */\n    this.set('isReadOnly', false);\n    /**\n     * True if document is focused.\n     *\n     * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.\n     * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isFocused\n     */\n    this.set('isFocused', false);\n    /**\n     * `true` while the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n     * When they stop selecting, the property goes back to `false`.\n     *\n     * This property is updated by the {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isSelecting\n     */\n    this.set('isSelecting', false);\n    /**\n     * True if composition is in progress inside the document.\n     *\n     * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n     * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isComposing\n     */\n    this.set('isComposing', false);\n    /**\n     * Post-fixer callbacks registered to the view document.\n     *\n     * @private\n     * @member {Set}\n     */\n    this._postFixers = new Set();\n  }\n  /**\n   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not\n   * specific \"main\" root is returned.\n   *\n   * @param {String} [name='main'] Name of the root.\n   * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name\n   * or null when there is no root of given name.\n   */\n  getRoot() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n    return this.roots.get(name);\n  }\n  /**\n   * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered\n   * to the DOM.\n   *\n   * Post-fixers are executed right after all changes from the outermost change block were applied but\n   * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made\n   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n   * not be fixed in the new document tree state.\n   *\n   * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that\n   * changes executed in a view post-fixer should not break model-view mapping.\n   *\n   * The types of changes which should be safe:\n   *\n   * * adding or removing attribute from elements,\n   * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},\n   * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be\n   * re-converted}.\n   *\n   * Try to avoid changes which touch view structure:\n   *\n   * * you should not add or remove nor wrap or unwrap any view elements,\n   * * you should not change the editor data model in a view post-fixer.\n   *\n   * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.\n   *\n   * Typically, a post-fixer will look like this:\n   *\n   *\t\teditor.editing.view.document.registerPostFixer( writer => {\n   *\t\t\tif ( checkSomeCondition() ) {\n   *\t\t\t\twriter.doSomething();\n   *\n   *\t\t\t\t// Let other post-fixers know that something changed.\n   *\t\t\t\treturn true;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).\n   * That is because adding a post-fixer does not execute it.\n   * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.\n   * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling\n   * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.\n   *\n   * If you need to register a callback which is executed when DOM elements are already updated,\n   * use {@link module:engine/view/view~View#event:render render event}.\n   *\n   * @param {Function} postFixer\n   */\n  registerPostFixer(postFixer) {\n    this._postFixers.add(postFixer);\n  }\n  /**\n   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n   */\n  destroy() {\n    this.roots.map(root => root.destroy());\n    this.stopListening();\n  }\n  /**\n   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n   *\n   * @protected\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n   */\n  _callPostFixers(writer) {\n    let wasFixed = false;\n    do {\n      for (const callback of this._postFixers) {\n        wasFixed = callback(writer);\n        if (wasFixed) {\n          break;\n        }\n      }\n    } while (wasFixed);\n  }\n}","map":{"version":3,"names":["DocumentSelection","Collection","BubblingEmitterMixin","Observable","Document","constructor","stylesProcessor","selection","roots","idProperty","set","_postFixers","Set","getRoot","name","get","registerPostFixer","postFixer","add","destroy","map","root","stopListening","_callPostFixers","writer","wasFixed","callback"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/document.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/view/document\n */\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport BubblingEmitterMixin from './observer/bubblingemittermixin';\nimport { Observable } from '@ckeditor/ckeditor5-utils/src/observablemixin';\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n/**\n * Document class creates an abstract layer over the content editable area, contains a tree of view elements and\n * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.\n *\n * @mixes module:engine/view/observer/bubblingemittermixin~BubblingEmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Document extends BubblingEmitterMixin(Observable) {\n    /**\n     * Creates a Document instance.\n     *\n     * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n     */\n    constructor(stylesProcessor) {\n        super();\n        /**\n         * Selection done on this document.\n         *\n         * @readonly\n         * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection\n         */\n        this.selection = new DocumentSelection();\n        /**\n         * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.\n         *\n         * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and\n         * {@link module:engine/model/document~Document#roots} and this is handled by\n         * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create\n         * model root using {@link module:engine/model/document~Document#createRoot}.\n         *\n         * @readonly\n         * @member {module:utils/collection~Collection} module:engine/view/document~Document#roots\n         */\n        this.roots = new Collection({ idProperty: 'rootName' });\n        /**\n         * The styles processor instance used by this document when normalizing styles.\n         *\n         * @readonly\n         * @member {module:engine/view/stylesmap~StylesProcessor}\n         */\n        this.stylesProcessor = stylesProcessor;\n        /**\n         * Defines whether document is in read-only mode.\n         *\n         * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.\n         *\n         * @observable\n         * @member {Boolean} #isReadOnly\n         */\n        this.set('isReadOnly', false);\n        /**\n         * True if document is focused.\n         *\n         * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.\n         * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.\n         *\n         * @readonly\n         * @observable\n         * @member {Boolean} module:engine/view/document~Document#isFocused\n         */\n        this.set('isFocused', false);\n        /**\n         * `true` while the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n         * When they stop selecting, the property goes back to `false`.\n         *\n         * This property is updated by the {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n         *\n         * @readonly\n         * @observable\n         * @member {Boolean} module:engine/view/document~Document#isSelecting\n         */\n        this.set('isSelecting', false);\n        /**\n         * True if composition is in progress inside the document.\n         *\n         * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n         * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.\n         *\n         * @readonly\n         * @observable\n         * @member {Boolean} module:engine/view/document~Document#isComposing\n         */\n        this.set('isComposing', false);\n        /**\n         * Post-fixer callbacks registered to the view document.\n         *\n         * @private\n         * @member {Set}\n         */\n        this._postFixers = new Set();\n    }\n    /**\n     * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not\n     * specific \"main\" root is returned.\n     *\n     * @param {String} [name='main'] Name of the root.\n     * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name\n     * or null when there is no root of given name.\n     */\n    getRoot(name = 'main') {\n        return this.roots.get(name);\n    }\n    /**\n     * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered\n     * to the DOM.\n     *\n     * Post-fixers are executed right after all changes from the outermost change block were applied but\n     * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made\n     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n     * not be fixed in the new document tree state.\n     *\n     * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that\n     * changes executed in a view post-fixer should not break model-view mapping.\n     *\n     * The types of changes which should be safe:\n     *\n     * * adding or removing attribute from elements,\n     * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},\n     * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be\n     * re-converted}.\n     *\n     * Try to avoid changes which touch view structure:\n     *\n     * * you should not add or remove nor wrap or unwrap any view elements,\n     * * you should not change the editor data model in a view post-fixer.\n     *\n     * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.\n     *\n     * Typically, a post-fixer will look like this:\n     *\n     *\t\teditor.editing.view.document.registerPostFixer( writer => {\n     *\t\t\tif ( checkSomeCondition() ) {\n     *\t\t\t\twriter.doSomething();\n     *\n     *\t\t\t\t// Let other post-fixers know that something changed.\n     *\t\t\t\treturn true;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).\n     * That is because adding a post-fixer does not execute it.\n     * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.\n     * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling\n     * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.\n     *\n     * If you need to register a callback which is executed when DOM elements are already updated,\n     * use {@link module:engine/view/view~View#event:render render event}.\n     *\n     * @param {Function} postFixer\n     */\n    registerPostFixer(postFixer) {\n        this._postFixers.add(postFixer);\n    }\n    /**\n     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n     */\n    destroy() {\n        this.roots.map(root => root.destroy());\n        this.stopListening();\n    }\n    /**\n     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n     *\n     * @protected\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n     */\n    _callPostFixers(writer) {\n        let wasFixed = false;\n        do {\n            for (const callback of this._postFixers) {\n                wasFixed = callback(writer);\n                if (wasFixed) {\n                    break;\n                }\n            }\n        } while (wasFixed);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,iBAAiB,MAAM,qBAAqB;AACnD,OAAOC,UAAU,MAAM,0CAA0C;AACjE,OAAOC,oBAAoB,MAAM,iCAAiC;AAClE,SAASC,UAAU,QAAQ,+CAA+C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,QAAQ,SAASF,oBAAoB,CAACC,UAAU,CAAC,CAAC;EACnE;AACJ;AACA;AACA;AACA;EACIE,WAAW,CAACC,eAAe,EAAE;IACzB,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,IAAIP,iBAAiB,EAAE;IACxC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACQ,KAAK,GAAG,IAAIP,UAAU,CAAC;MAAEQ,UAAU,EAAE;IAAW,CAAC,CAAC;IACvD;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACH,eAAe,GAAGA,eAAe;IACtC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACI,GAAG,CAAC,YAAY,EAAE,KAAK,CAAC;IAC7B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACA,GAAG,CAAC,WAAW,EAAE,KAAK,CAAC;IAC5B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACA,GAAG,CAAC,aAAa,EAAE,KAAK,CAAC;IAC9B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACA,GAAG,CAAC,aAAa,EAAE,KAAK,CAAC;IAC9B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,IAAIC,GAAG,EAAE;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,OAAO,GAAgB;IAAA,IAAfC,IAAI,uEAAG,MAAM;IACjB,OAAO,IAAI,CAACN,KAAK,CAACO,GAAG,CAACD,IAAI,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,iBAAiB,CAACC,SAAS,EAAE;IACzB,IAAI,CAACN,WAAW,CAACO,GAAG,CAACD,SAAS,CAAC;EACnC;EACA;AACJ;AACA;EACIE,OAAO,GAAG;IACN,IAAI,CAACX,KAAK,CAACY,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACF,OAAO,EAAE,CAAC;IACtC,IAAI,CAACG,aAAa,EAAE;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,eAAe,CAACC,MAAM,EAAE;IACpB,IAAIC,QAAQ,GAAG,KAAK;IACpB,GAAG;MACC,KAAK,MAAMC,QAAQ,IAAI,IAAI,CAACf,WAAW,EAAE;QACrCc,QAAQ,GAAGC,QAAQ,CAACF,MAAM,CAAC;QAC3B,IAAIC,QAAQ,EAAE;UACV;QACJ;MACJ;IACJ,CAAC,QAAQA,QAAQ;EACrB;AACJ"},"metadata":{},"sourceType":"module"}