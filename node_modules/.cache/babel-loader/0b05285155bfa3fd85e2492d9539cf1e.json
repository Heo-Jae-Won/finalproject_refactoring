{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable @typescript-eslint/unified-signatures, new-cap */\n/**\n * @module utils/observablemixin\n */\nimport { Emitter } from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport { isObject } from 'lodash-es';\nconst observablePropertiesSymbol = Symbol('observableProperties');\nconst boundObservablesSymbol = Symbol('boundObservables');\nconst boundPropertiesSymbol = Symbol('boundProperties');\nconst decoratedMethods = Symbol('decoratedMethods');\nconst decoratedOriginal = Symbol('decoratedOriginal');\n/**\n * A mixin that injects the \"observable properties\" and data binding functionality described in the\n * {@link ~Observable} interface.\n *\n * Read more about the concept of observables in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide,\n * * {@glink framework/guides/deep-dive/observables Observables deep dive} guide.\n *\n * @mixin ObservableMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/observablemixin~Observable\n */\nexport default function ObservableMixin(base) {\n  class Mixin extends base {\n    set(name, value) {\n      // If the first parameter is an Object, iterate over its properties.\n      if (isObject(name)) {\n        Object.keys(name).forEach(property => {\n          this.set(property, name[property]);\n        }, this);\n        return;\n      }\n      initObservable(this);\n      const properties = this[observablePropertiesSymbol];\n      if (name in this && !properties.has(name)) {\n        /**\n         * Cannot override an existing property.\n         *\n         * This error is thrown when trying to {@link ~Observable#set set} a property with\n         * a name of an already existing property. For example:\n         *\n         *\t\tlet observable = new Model();\n         *\t\tobservable.property = 1;\n         *\t\tobservable.set( 'property', 2 );\t\t\t// throws\n         *\n         *\t\tobservable.set( 'property', 1 );\n         *\t\tobservable.set( 'property', 2 );\t\t\t// ok, because this is an existing property.\n         *\n         * @error observable-set-cannot-override\n         */\n        throw new CKEditorError('observable-set-cannot-override', this);\n      }\n      Object.defineProperty(this, name, {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return properties.get(name);\n        },\n        set(value) {\n          const oldValue = properties.get(name);\n          // Fire `set` event before the new value will be set to make it possible\n          // to override observable property without affecting `change` event.\n          // See https://github.com/ckeditor/ckeditor5-utils/issues/171.\n          let newValue = this.fire(`set:${name}`, name, value, oldValue);\n          if (newValue === undefined) {\n            newValue = value;\n          }\n          // Allow undefined as an initial value like A.define( 'x', undefined ) (#132).\n          // Note: When properties map has no such own property, then its value is undefined.\n          if (oldValue !== newValue || !properties.has(name)) {\n            properties.set(name, newValue);\n            this.fire(`change:${name}`, name, newValue, oldValue);\n          }\n        }\n      });\n      this[name] = value;\n    }\n    bind() {\n      for (var _len = arguments.length, bindProperties = new Array(_len), _key = 0; _key < _len; _key++) {\n        bindProperties[_key] = arguments[_key];\n      }\n      if (!bindProperties.length || !isStringArray(bindProperties)) {\n        /**\n         * All properties must be strings.\n         *\n         * @error observable-bind-wrong-properties\n         */\n        throw new CKEditorError('observable-bind-wrong-properties', this);\n      }\n      if (new Set(bindProperties).size !== bindProperties.length) {\n        /**\n         * Properties must be unique.\n         *\n         * @error observable-bind-duplicate-properties\n         */\n        throw new CKEditorError('observable-bind-duplicate-properties', this);\n      }\n      initObservable(this);\n      const boundProperties = this[boundPropertiesSymbol];\n      bindProperties.forEach(propertyName => {\n        if (boundProperties.has(propertyName)) {\n          /**\n           * Cannot bind the same property more than once.\n           *\n           * @error observable-bind-rebind\n           */\n          throw new CKEditorError('observable-bind-rebind', this);\n        }\n      });\n      const bindings = new Map();\n      // @typedef {Object} Binding\n      // @property {Array} property Property which is bound.\n      // @property {Array} to Array of observable–property components of the binding (`{ observable: ..., property: .. }`).\n      // @property {Array} callback A function which processes `to` components.\n      bindProperties.forEach(a => {\n        const binding = {\n          property: a,\n          to: []\n        };\n        boundProperties.set(a, binding);\n        bindings.set(a, binding);\n      });\n      // @typedef {Object} BindChain\n      // @property {Function} to See {@link ~ObservableMixin#_bindTo}.\n      // @property {Function} toMany See {@link ~ObservableMixin#_bindToMany}.\n      // @property {module:utils/observablemixin~Observable} _observable The observable which initializes the binding.\n      // @property {Array} _bindProperties Array of `_observable` properties to be bound.\n      // @property {Array} _to Array of `to()` observable–properties (`{ observable: toObservable, properties: ...toProperties }`).\n      // @property {Map} _bindings Stores bindings to be kept in\n      // {@link ~ObservableMixin#_boundProperties}/{@link ~ObservableMixin#_boundObservables}\n      // initiated in this binding chain.\n      return {\n        to: bindTo,\n        toMany: bindToMany,\n        _observable: this,\n        _bindProperties: bindProperties,\n        _to: [],\n        _bindings: bindings\n      };\n    }\n    unbind() {\n      // Nothing to do here if not inited yet.\n      if (!this[observablePropertiesSymbol]) {\n        return;\n      }\n      const boundProperties = this[boundPropertiesSymbol];\n      const boundObservables = this[boundObservablesSymbol];\n      for (var _len2 = arguments.length, unbindProperties = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        unbindProperties[_key2] = arguments[_key2];\n      }\n      if (unbindProperties.length) {\n        if (!isStringArray(unbindProperties)) {\n          /**\n           * Properties must be strings.\n           *\n           * @error observable-unbind-wrong-properties\n           */\n          throw new CKEditorError('observable-unbind-wrong-properties', this);\n        }\n        unbindProperties.forEach(propertyName => {\n          const binding = boundProperties.get(propertyName);\n          // Nothing to do if the binding is not defined\n          if (!binding) {\n            return;\n          }\n          binding.to.forEach(_ref => {\n            let [toObservable, toProperty] = _ref;\n            const toProperties = boundObservables.get(toObservable);\n            const toPropertyBindings = toProperties[toProperty];\n            toPropertyBindings.delete(binding);\n            if (!toPropertyBindings.size) {\n              delete toProperties[toProperty];\n            }\n            if (!Object.keys(toProperties).length) {\n              boundObservables.delete(toObservable);\n              this.stopListening(toObservable, 'change');\n            }\n          });\n          boundProperties.delete(propertyName);\n        });\n      } else {\n        boundObservables.forEach((bindings, boundObservable) => {\n          this.stopListening(boundObservable, 'change');\n        });\n        boundObservables.clear();\n        boundProperties.clear();\n      }\n    }\n    decorate(methodName) {\n      initObservable(this);\n      const originalMethod = this[methodName];\n      if (!originalMethod) {\n        /**\n         * Cannot decorate an undefined method.\n         *\n         * @error observablemixin-cannot-decorate-undefined\n         * @param {Object} object The object which method should be decorated.\n         * @param {String} methodName Name of the method which does not exist.\n         */\n        throw new CKEditorError('observablemixin-cannot-decorate-undefined', this, {\n          object: this,\n          methodName\n        });\n      }\n      this.on(methodName, (evt, args) => {\n        evt.return = originalMethod.apply(this, args);\n      });\n      this[methodName] = function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return this.fire(methodName, args);\n      };\n      this[methodName][decoratedOriginal] = originalMethod;\n      if (!this[decoratedMethods]) {\n        this[decoratedMethods] = [];\n      }\n      this[decoratedMethods].push(methodName);\n    }\n    // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.\n    // This is needed in case of:\n    //  1. Have x.foo() decorated.\n    //  2. Call x.stopListening()\n    //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)\n    stopListening(emitter, event, callback) {\n      // Removing all listeners so let's clean the decorated methods to the original state.\n      if (!emitter && this[decoratedMethods]) {\n        for (const methodName of this[decoratedMethods]) {\n          this[methodName] = this[methodName][decoratedOriginal];\n        }\n        delete this[decoratedMethods];\n      }\n      Emitter.prototype.stopListening.call(this, emitter, event, callback);\n    }\n  }\n  return Mixin;\n}\nexport const Observable = ObservableMixin(Emitter);\n// Backward compatibility with `mix`\n['set', 'bind', 'unbind', 'decorate', 'on', 'once', 'off', 'listenTo', 'stopListening', 'fire', 'delegate', 'stopDelegating', '_addEventListener', '_removeEventListener'].forEach(key => {\n  ObservableMixin[key] = Observable.prototype[key];\n});\n// Init symbol properties needed for the observable mechanism to work.\n//\n// @private\n// @param {module:utils/observablemixin~ObservableMixin} observable\nfunction initObservable(observable) {\n  // Do nothing if already inited.\n  if (observable[observablePropertiesSymbol]) {\n    return;\n  }\n  // The internal hash containing the observable's state.\n  //\n  // @private\n  // @type {Map}\n  Object.defineProperty(observable, observablePropertiesSymbol, {\n    value: new Map()\n  });\n  // Map containing bindings to external observables. It shares the binding objects\n  // (`{ observable: A, property: 'a', to: ... }`) with {@link module:utils/observablemixin~ObservableMixin#_boundProperties} and\n  // it is used to observe external observables to update own properties accordingly.\n  // See {@link module:utils/observablemixin~ObservableMixin#bind}.\n  //\n  //\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n  //\t\tconsole.log( A._boundObservables );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\tB: {\n  //\t\t\t\t\tx: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n  //\t\t\t\t\t] ),\n  //\t\t\t\t\ty: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\t\t] )\n  //\t\t\t\t}\n  //\t\t\t} )\n  //\n  //\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n  //\t\tconsole.log( A._boundObservables );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\tB: {\n  //\t\t\t\t\tx: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n  //\t\t\t\t\t] ),\n  //\t\t\t\t\ty: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\t\t] ),\n  //\t\t\t\t\tz: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n  //\t\t\t\t\t] )\n  //\t\t\t\t},\n  //\t\t\t\tC: {\n  //\t\t\t\t\tw: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n  //\t\t\t\t\t] )\n  //\t\t\t\t}\n  //\t\t\t} )\n  //\n  // @private\n  // @type {Map}\n  Object.defineProperty(observable, boundObservablesSymbol, {\n    value: new Map()\n  });\n  // Object that stores which properties of this observable are bound and how. It shares\n  // the binding objects (`{ observable: A, property: 'a', to: ... }`) with\n  // {@link module:utils/observablemixin~ObservableMixin#_boundObservables}. This data structure is\n  // a reverse of {@link module:utils/observablemixin~ObservableMixin#_boundObservables} and it is helpful for\n  // {@link module:utils/observablemixin~ObservableMixin#unbind}.\n  //\n  // See {@link module:utils/observablemixin~ObservableMixin#bind}.\n  //\n  //\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n  //\t\tconsole.log( A._boundProperties );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n  //\t\t\t} )\n  //\n  //\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n  //\t\tconsole.log( A._boundProperties );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] },\n  //\t\t\t\td: { observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n  //\t\t\t} )\n  //\n  // @private\n  // @type {Map}\n  Object.defineProperty(observable, boundPropertiesSymbol, {\n    value: new Map()\n  });\n}\n// A chaining for {@link module:utils/observablemixin~ObservableMixin#bind} providing `.to()` interface.\n//\n// @private\n// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.\nfunction bindTo() {\n  const parsedArgs = parseBindToArgs(...arguments);\n  const bindingsKeys = Array.from(this._bindings.keys());\n  const numberOfBindings = bindingsKeys.length;\n  // Eliminate A.bind( 'x' ).to( B, C )\n  if (!parsedArgs.callback && parsedArgs.to.length > 1) {\n    /**\n     * Binding multiple observables only possible with callback.\n     *\n     * @error observable-bind-to-no-callback\n     */\n    throw new CKEditorError('observable-bind-to-no-callback', this);\n  }\n  // Eliminate A.bind( 'x', 'y' ).to( B, callback )\n  if (numberOfBindings > 1 && parsedArgs.callback) {\n    /**\n     * Cannot bind multiple properties and use a callback in one binding.\n     *\n     * @error observable-bind-to-extra-callback\n     */\n    throw new CKEditorError('observable-bind-to-extra-callback', this);\n  }\n  parsedArgs.to.forEach(to => {\n    // Eliminate A.bind( 'x', 'y' ).to( B, 'a' )\n    if (to.properties.length && to.properties.length !== numberOfBindings) {\n      /**\n       * The number of properties must match.\n       *\n       * @error observable-bind-to-properties-length\n       */\n      throw new CKEditorError('observable-bind-to-properties-length', this);\n    }\n    // When no to.properties specified, observing source properties instead i.e.\n    // A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y\n    if (!to.properties.length) {\n      to.properties = this._bindProperties;\n    }\n  });\n  this._to = parsedArgs.to;\n  // Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.\n  if (parsedArgs.callback) {\n    this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;\n  }\n  attachBindToListeners(this._observable, this._to);\n  // Update observable._boundProperties and observable._boundObservables.\n  updateBindToBound(this);\n  // Set initial values of bound properties.\n  this._bindProperties.forEach(propertyName => {\n    updateBoundObservableProperty(this._observable, propertyName);\n  });\n}\n// Binds to an attribute in a set of iterable observables.\n//\n// @private\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @param {Function} callback\nfunction bindToMany(observables, attribute, callback) {\n  if (this._bindings.size > 1) {\n    /**\n     * Binding one attribute to many observables only possible with one attribute.\n     *\n     * @error observable-bind-to-many-not-one-binding\n     */\n    throw new CKEditorError('observable-bind-to-many-not-one-binding', this);\n  }\n  this.to(\n  // Bind to #attribute of each observable...\n  ...getBindingTargets(observables, attribute),\n  // ...using given callback to parse attribute values.\n  callback);\n}\n// Returns an array of binding components for\n// {@link Observable#bind} from a set of iterable observables.\n//\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @returns {Array.<String|Observable>}\nfunction getBindingTargets(observables, attribute) {\n  const observableAndAttributePairs = observables.map(observable => [observable, attribute]);\n  // Merge pairs to one-dimension array of observables and attributes.\n  return Array.prototype.concat.apply([], observableAndAttributePairs);\n}\n// Check if all entries of the array are of `String` type.\n//\n// @private\n// @param {Array} arr An array to be checked.\n// @returns {Boolean}\nfunction isStringArray(arr) {\n  return arr.every(a => typeof a == 'string');\n}\n// Parses and validates {@link Observable#bind}`.to( args )` arguments and returns\n// an object with a parsed structure. For example\n//\n//\t\tA.bind( 'x' ).to( B, 'a', C, 'b', call );\n//\n// becomes\n//\n//\t\t{\n//\t\t\tto: [\n//\t\t\t\t{ observable: B, properties: [ 'a' ] },\n//\t\t\t\t{ observable: C, properties: [ 'b' ] },\n//\t\t\t],\n//\t\t\tcallback: call\n// \t\t}\n//\n// @private\n// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.\n// @returns {Object}\nfunction parseBindToArgs() {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n  // Eliminate A.bind( 'x' ).to()\n  if (!args.length) {\n    /**\n     * Invalid argument syntax in `to()`.\n     *\n     * @error observable-bind-to-parse-error\n     */\n    throw new CKEditorError('observable-bind-to-parse-error', null);\n  }\n  const parsed = {\n    to: []\n  };\n  let lastObservable;\n  if (typeof args[args.length - 1] == 'function') {\n    parsed.callback = args.pop();\n  }\n  args.forEach(a => {\n    if (typeof a == 'string') {\n      lastObservable.properties.push(a);\n    } else if (typeof a == 'object') {\n      lastObservable = {\n        observable: a,\n        properties: []\n      };\n      parsed.to.push(lastObservable);\n    } else {\n      throw new CKEditorError('observable-bind-to-parse-error', null);\n    }\n  });\n  return parsed;\n}\n// Synchronizes {@link module:utils/observablemixin#_boundObservables} with {@link Binding}.\n//\n// @private\n// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.\n// @param {Observable} toObservable A observable, which is a new component of `binding`.\n// @param {String} toPropertyName A name of `toObservable`'s property, a new component of the `binding`.\nfunction updateBoundObservables(observable, binding, toObservable, toPropertyName) {\n  const boundObservables = observable[boundObservablesSymbol];\n  const bindingsToObservable = boundObservables.get(toObservable);\n  const bindings = bindingsToObservable || {};\n  if (!bindings[toPropertyName]) {\n    bindings[toPropertyName] = new Set();\n  }\n  // Pass the binding to a corresponding Set in `observable._boundObservables`.\n  bindings[toPropertyName].add(binding);\n  if (!bindingsToObservable) {\n    boundObservables.set(toObservable, bindings);\n  }\n}\n// Synchronizes {@link Observable#_boundProperties} and {@link Observable#_boundObservables}\n// with {@link BindChain}.\n//\n// Assuming the following binding being created\n//\n// \t\tA.bind( 'a', 'b' ).to( B, 'x', 'y' );\n//\n// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [] },\n// \t\t\tb: { observable: A, property: 'b', to: [] },\n// \t\t}\n//\n// Iterate over all bindings in this chain and fill their `to` properties with\n// corresponding to( ... ) arguments (components of the binding), so\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [ B, 'x' ] },\n// \t\t\tb: { observable: A, property: 'b', to: [ B, 'y' ] },\n// \t\t}\n//\n// Then update the structure of {@link Observable#_boundObservables} with updated\n// binding, so it becomes:\n//\n// \t\tMap( {\n// \t\t\tB: {\n// \t\t\t\tx: Set( [\n// \t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] }\n// \t\t\t\t] ),\n// \t\t\t\ty: Set( [\n// \t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n// \t\t\t\t] )\n//\t\t\t}\n// \t\t} )\n//\n// @private\n// @param {BindChain} chain The binding initialized by {@link Observable#bind}.\nfunction updateBindToBound(chain) {\n  let toProperty;\n  chain._bindings.forEach((binding, propertyName) => {\n    // Note: For a binding without a callback, this will run only once\n    // like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )\n    // TODO: ES6 destructuring.\n    chain._to.forEach(to => {\n      toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];\n      binding.to.push([to.observable, toProperty]);\n      updateBoundObservables(chain._observable, binding, to.observable, toProperty);\n    });\n  });\n}\n// Updates an property of a {@link Observable} with a value\n// determined by an entry in {@link Observable#_boundProperties}.\n//\n// @private\n// @param {Observable} observable A observable which property is to be updated.\n// @param {String} propertyName An property to be updated.\nfunction updateBoundObservableProperty(observable, propertyName) {\n  const boundProperties = observable[boundPropertiesSymbol];\n  const binding = boundProperties.get(propertyName);\n  let propertyValue;\n  // When a binding with callback is created like\n  //\n  // \t\tA.bind( 'a' ).to( B, 'b', C, 'c', callback );\n  //\n  // collect B.b and C.c, then pass them to callback to set A.a.\n  if (binding.callback) {\n    propertyValue = binding.callback.apply(observable, binding.to.map(to => to[0][to[1]]));\n  } else {\n    propertyValue = binding.to[0];\n    propertyValue = propertyValue[0][propertyValue[1]];\n  }\n  if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {\n    observable[propertyName] = propertyValue;\n  } else {\n    observable.set(propertyName, propertyValue);\n  }\n}\n// Starts listening to changes in {@link BindChain._to} observables to update\n// {@link BindChain._observable} {@link BindChain._bindProperties}. Also sets the\n// initial state of {@link BindChain._observable}.\n//\n// @private\n// @param {Observable} observable\n// @param {BindChain} chain The chain initialized by {@link Observable#bind}.\nfunction attachBindToListeners(observable, toBindings) {\n  toBindings.forEach(to => {\n    const boundObservables = observable[boundObservablesSymbol];\n    let bindings;\n    // If there's already a chain between the observables (`observable` listens to\n    // `to.observable`), there's no need to create another `change` event listener.\n    if (!boundObservables.get(to.observable)) {\n      observable.listenTo(to.observable, 'change', (evt, propertyName) => {\n        bindings = boundObservables.get(to.observable)[propertyName];\n        // Note: to.observable will fire for any property change, react\n        // to changes of properties which are bound only.\n        if (bindings) {\n          bindings.forEach(binding => {\n            updateBoundObservableProperty(observable, binding.property);\n          });\n        }\n      });\n    }\n  });\n}","map":{"version":3,"names":["Emitter","CKEditorError","isObject","observablePropertiesSymbol","Symbol","boundObservablesSymbol","boundPropertiesSymbol","decoratedMethods","decoratedOriginal","ObservableMixin","base","Mixin","set","name","value","Object","keys","forEach","property","initObservable","properties","has","defineProperty","enumerable","configurable","get","oldValue","newValue","fire","undefined","bind","bindProperties","length","isStringArray","Set","size","boundProperties","propertyName","bindings","Map","a","binding","to","bindTo","toMany","bindToMany","_observable","_bindProperties","_to","_bindings","unbind","boundObservables","unbindProperties","toObservable","toProperty","toProperties","toPropertyBindings","delete","stopListening","boundObservable","clear","decorate","methodName","originalMethod","object","on","evt","args","return","apply","push","emitter","event","callback","prototype","call","Observable","key","observable","parsedArgs","parseBindToArgs","bindingsKeys","Array","from","numberOfBindings","attachBindToListeners","updateBindToBound","updateBoundObservableProperty","observables","attribute","getBindingTargets","observableAndAttributePairs","map","concat","arr","every","parsed","lastObservable","pop","updateBoundObservables","toPropertyName","bindingsToObservable","add","chain","indexOf","propertyValue","hasOwnProperty","toBindings","listenTo"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/observablemixin.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable @typescript-eslint/unified-signatures, new-cap */\n/**\n * @module utils/observablemixin\n */\nimport { Emitter } from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport { isObject } from 'lodash-es';\nconst observablePropertiesSymbol = Symbol('observableProperties');\nconst boundObservablesSymbol = Symbol('boundObservables');\nconst boundPropertiesSymbol = Symbol('boundProperties');\nconst decoratedMethods = Symbol('decoratedMethods');\nconst decoratedOriginal = Symbol('decoratedOriginal');\n/**\n * A mixin that injects the \"observable properties\" and data binding functionality described in the\n * {@link ~Observable} interface.\n *\n * Read more about the concept of observables in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide,\n * * {@glink framework/guides/deep-dive/observables Observables deep dive} guide.\n *\n * @mixin ObservableMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/observablemixin~Observable\n */\nexport default function ObservableMixin(base) {\n    class Mixin extends base {\n        set(name, value) {\n            // If the first parameter is an Object, iterate over its properties.\n            if (isObject(name)) {\n                Object.keys(name).forEach(property => {\n                    this.set(property, name[property]);\n                }, this);\n                return;\n            }\n            initObservable(this);\n            const properties = this[observablePropertiesSymbol];\n            if ((name in this) && !properties.has(name)) {\n                /**\n                 * Cannot override an existing property.\n                 *\n                 * This error is thrown when trying to {@link ~Observable#set set} a property with\n                 * a name of an already existing property. For example:\n                 *\n                 *\t\tlet observable = new Model();\n                 *\t\tobservable.property = 1;\n                 *\t\tobservable.set( 'property', 2 );\t\t\t// throws\n                 *\n                 *\t\tobservable.set( 'property', 1 );\n                 *\t\tobservable.set( 'property', 2 );\t\t\t// ok, because this is an existing property.\n                 *\n                 * @error observable-set-cannot-override\n                 */\n                throw new CKEditorError('observable-set-cannot-override', this);\n            }\n            Object.defineProperty(this, name, {\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return properties.get(name);\n                },\n                set(value) {\n                    const oldValue = properties.get(name);\n                    // Fire `set` event before the new value will be set to make it possible\n                    // to override observable property without affecting `change` event.\n                    // See https://github.com/ckeditor/ckeditor5-utils/issues/171.\n                    let newValue = this.fire(`set:${name}`, name, value, oldValue);\n                    if (newValue === undefined) {\n                        newValue = value;\n                    }\n                    // Allow undefined as an initial value like A.define( 'x', undefined ) (#132).\n                    // Note: When properties map has no such own property, then its value is undefined.\n                    if (oldValue !== newValue || !properties.has(name)) {\n                        properties.set(name, newValue);\n                        this.fire(`change:${name}`, name, newValue, oldValue);\n                    }\n                }\n            });\n            this[name] = value;\n        }\n        bind(...bindProperties) {\n            if (!bindProperties.length || !isStringArray(bindProperties)) {\n                /**\n                 * All properties must be strings.\n                 *\n                 * @error observable-bind-wrong-properties\n                 */\n                throw new CKEditorError('observable-bind-wrong-properties', this);\n            }\n            if ((new Set(bindProperties)).size !== bindProperties.length) {\n                /**\n                 * Properties must be unique.\n                 *\n                 * @error observable-bind-duplicate-properties\n                 */\n                throw new CKEditorError('observable-bind-duplicate-properties', this);\n            }\n            initObservable(this);\n            const boundProperties = this[boundPropertiesSymbol];\n            bindProperties.forEach(propertyName => {\n                if (boundProperties.has(propertyName)) {\n                    /**\n                     * Cannot bind the same property more than once.\n                     *\n                     * @error observable-bind-rebind\n                     */\n                    throw new CKEditorError('observable-bind-rebind', this);\n                }\n            });\n            const bindings = new Map();\n            // @typedef {Object} Binding\n            // @property {Array} property Property which is bound.\n            // @property {Array} to Array of observable–property components of the binding (`{ observable: ..., property: .. }`).\n            // @property {Array} callback A function which processes `to` components.\n            bindProperties.forEach(a => {\n                const binding = { property: a, to: [] };\n                boundProperties.set(a, binding);\n                bindings.set(a, binding);\n            });\n            // @typedef {Object} BindChain\n            // @property {Function} to See {@link ~ObservableMixin#_bindTo}.\n            // @property {Function} toMany See {@link ~ObservableMixin#_bindToMany}.\n            // @property {module:utils/observablemixin~Observable} _observable The observable which initializes the binding.\n            // @property {Array} _bindProperties Array of `_observable` properties to be bound.\n            // @property {Array} _to Array of `to()` observable–properties (`{ observable: toObservable, properties: ...toProperties }`).\n            // @property {Map} _bindings Stores bindings to be kept in\n            // {@link ~ObservableMixin#_boundProperties}/{@link ~ObservableMixin#_boundObservables}\n            // initiated in this binding chain.\n            return {\n                to: bindTo,\n                toMany: bindToMany,\n                _observable: this,\n                _bindProperties: bindProperties,\n                _to: [],\n                _bindings: bindings\n            };\n        }\n        unbind(...unbindProperties) {\n            // Nothing to do here if not inited yet.\n            if (!(this[observablePropertiesSymbol])) {\n                return;\n            }\n            const boundProperties = this[boundPropertiesSymbol];\n            const boundObservables = this[boundObservablesSymbol];\n            if (unbindProperties.length) {\n                if (!isStringArray(unbindProperties)) {\n                    /**\n                     * Properties must be strings.\n                     *\n                     * @error observable-unbind-wrong-properties\n                     */\n                    throw new CKEditorError('observable-unbind-wrong-properties', this);\n                }\n                unbindProperties.forEach(propertyName => {\n                    const binding = boundProperties.get(propertyName);\n                    // Nothing to do if the binding is not defined\n                    if (!binding) {\n                        return;\n                    }\n                    binding.to.forEach(([toObservable, toProperty]) => {\n                        const toProperties = boundObservables.get(toObservable);\n                        const toPropertyBindings = toProperties[toProperty];\n                        toPropertyBindings.delete(binding);\n                        if (!toPropertyBindings.size) {\n                            delete toProperties[toProperty];\n                        }\n                        if (!Object.keys(toProperties).length) {\n                            boundObservables.delete(toObservable);\n                            this.stopListening(toObservable, 'change');\n                        }\n                    });\n                    boundProperties.delete(propertyName);\n                });\n            }\n            else {\n                boundObservables.forEach((bindings, boundObservable) => {\n                    this.stopListening(boundObservable, 'change');\n                });\n                boundObservables.clear();\n                boundProperties.clear();\n            }\n        }\n        decorate(methodName) {\n            initObservable(this);\n            const originalMethod = this[methodName];\n            if (!originalMethod) {\n                /**\n                 * Cannot decorate an undefined method.\n                 *\n                 * @error observablemixin-cannot-decorate-undefined\n                 * @param {Object} object The object which method should be decorated.\n                 * @param {String} methodName Name of the method which does not exist.\n                 */\n                throw new CKEditorError('observablemixin-cannot-decorate-undefined', this, { object: this, methodName });\n            }\n            this.on(methodName, (evt, args) => {\n                evt.return = originalMethod.apply(this, args);\n            });\n            this[methodName] = function (...args) {\n                return this.fire(methodName, args);\n            };\n            this[methodName][decoratedOriginal] = originalMethod;\n            if (!this[decoratedMethods]) {\n                this[decoratedMethods] = [];\n            }\n            this[decoratedMethods].push(methodName);\n        }\n        // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.\n        // This is needed in case of:\n        //  1. Have x.foo() decorated.\n        //  2. Call x.stopListening()\n        //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)\n        stopListening(emitter, event, callback) {\n            // Removing all listeners so let's clean the decorated methods to the original state.\n            if (!emitter && this[decoratedMethods]) {\n                for (const methodName of this[decoratedMethods]) {\n                    this[methodName] = this[methodName][decoratedOriginal];\n                }\n                delete this[decoratedMethods];\n            }\n            Emitter.prototype.stopListening.call(this, emitter, event, callback);\n        }\n    }\n    return Mixin;\n}\nexport const Observable = ObservableMixin(Emitter);\n// Backward compatibility with `mix`\n([\n    'set', 'bind', 'unbind', 'decorate',\n    'on', 'once', 'off', 'listenTo',\n    'stopListening', 'fire', 'delegate', 'stopDelegating',\n    '_addEventListener', '_removeEventListener'\n]).forEach(key => {\n    ObservableMixin[key] = Observable.prototype[key];\n});\n// Init symbol properties needed for the observable mechanism to work.\n//\n// @private\n// @param {module:utils/observablemixin~ObservableMixin} observable\nfunction initObservable(observable) {\n    // Do nothing if already inited.\n    if (observable[observablePropertiesSymbol]) {\n        return;\n    }\n    // The internal hash containing the observable's state.\n    //\n    // @private\n    // @type {Map}\n    Object.defineProperty(observable, observablePropertiesSymbol, {\n        value: new Map()\n    });\n    // Map containing bindings to external observables. It shares the binding objects\n    // (`{ observable: A, property: 'a', to: ... }`) with {@link module:utils/observablemixin~ObservableMixin#_boundProperties} and\n    // it is used to observe external observables to update own properties accordingly.\n    // See {@link module:utils/observablemixin~ObservableMixin#bind}.\n    //\n    //\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n    //\t\tconsole.log( A._boundObservables );\n    //\n    //\t\t\tMap( {\n    //\t\t\t\tB: {\n    //\t\t\t\t\tx: Set( [\n    //\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n    //\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n    //\t\t\t\t\t] ),\n    //\t\t\t\t\ty: Set( [\n    //\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n    //\t\t\t\t\t] )\n    //\t\t\t\t}\n    //\t\t\t} )\n    //\n    //\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n    //\t\tconsole.log( A._boundObservables );\n    //\n    //\t\t\tMap( {\n    //\t\t\t\tB: {\n    //\t\t\t\t\tx: Set( [\n    //\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n    //\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n    //\t\t\t\t\t] ),\n    //\t\t\t\t\ty: Set( [\n    //\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n    //\t\t\t\t\t] ),\n    //\t\t\t\t\tz: Set( [\n    //\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n    //\t\t\t\t\t] )\n    //\t\t\t\t},\n    //\t\t\t\tC: {\n    //\t\t\t\t\tw: Set( [\n    //\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n    //\t\t\t\t\t] )\n    //\t\t\t\t}\n    //\t\t\t} )\n    //\n    // @private\n    // @type {Map}\n    Object.defineProperty(observable, boundObservablesSymbol, {\n        value: new Map()\n    });\n    // Object that stores which properties of this observable are bound and how. It shares\n    // the binding objects (`{ observable: A, property: 'a', to: ... }`) with\n    // {@link module:utils/observablemixin~ObservableMixin#_boundObservables}. This data structure is\n    // a reverse of {@link module:utils/observablemixin~ObservableMixin#_boundObservables} and it is helpful for\n    // {@link module:utils/observablemixin~ObservableMixin#unbind}.\n    //\n    // See {@link module:utils/observablemixin~ObservableMixin#bind}.\n    //\n    //\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n    //\t\tconsole.log( A._boundProperties );\n    //\n    //\t\t\tMap( {\n    //\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n    //\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n    //\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n    //\t\t\t} )\n    //\n    //\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n    //\t\tconsole.log( A._boundProperties );\n    //\n    //\t\t\tMap( {\n    //\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n    //\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n    //\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] },\n    //\t\t\t\td: { observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n    //\t\t\t} )\n    //\n    // @private\n    // @type {Map}\n    Object.defineProperty(observable, boundPropertiesSymbol, {\n        value: new Map()\n    });\n}\n// A chaining for {@link module:utils/observablemixin~ObservableMixin#bind} providing `.to()` interface.\n//\n// @private\n// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.\nfunction bindTo(...args) {\n    const parsedArgs = parseBindToArgs(...args);\n    const bindingsKeys = Array.from(this._bindings.keys());\n    const numberOfBindings = bindingsKeys.length;\n    // Eliminate A.bind( 'x' ).to( B, C )\n    if (!parsedArgs.callback && parsedArgs.to.length > 1) {\n        /**\n         * Binding multiple observables only possible with callback.\n         *\n         * @error observable-bind-to-no-callback\n         */\n        throw new CKEditorError('observable-bind-to-no-callback', this);\n    }\n    // Eliminate A.bind( 'x', 'y' ).to( B, callback )\n    if (numberOfBindings > 1 && parsedArgs.callback) {\n        /**\n         * Cannot bind multiple properties and use a callback in one binding.\n         *\n         * @error observable-bind-to-extra-callback\n         */\n        throw new CKEditorError('observable-bind-to-extra-callback', this);\n    }\n    parsedArgs.to.forEach(to => {\n        // Eliminate A.bind( 'x', 'y' ).to( B, 'a' )\n        if (to.properties.length && to.properties.length !== numberOfBindings) {\n            /**\n             * The number of properties must match.\n             *\n             * @error observable-bind-to-properties-length\n             */\n            throw new CKEditorError('observable-bind-to-properties-length', this);\n        }\n        // When no to.properties specified, observing source properties instead i.e.\n        // A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y\n        if (!to.properties.length) {\n            to.properties = this._bindProperties;\n        }\n    });\n    this._to = parsedArgs.to;\n    // Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.\n    if (parsedArgs.callback) {\n        this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;\n    }\n    attachBindToListeners(this._observable, this._to);\n    // Update observable._boundProperties and observable._boundObservables.\n    updateBindToBound(this);\n    // Set initial values of bound properties.\n    this._bindProperties.forEach(propertyName => {\n        updateBoundObservableProperty(this._observable, propertyName);\n    });\n}\n// Binds to an attribute in a set of iterable observables.\n//\n// @private\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @param {Function} callback\nfunction bindToMany(observables, attribute, callback) {\n    if (this._bindings.size > 1) {\n        /**\n         * Binding one attribute to many observables only possible with one attribute.\n         *\n         * @error observable-bind-to-many-not-one-binding\n         */\n        throw new CKEditorError('observable-bind-to-many-not-one-binding', this);\n    }\n    this.to(\n    // Bind to #attribute of each observable...\n    ...getBindingTargets(observables, attribute), \n    // ...using given callback to parse attribute values.\n    callback);\n}\n// Returns an array of binding components for\n// {@link Observable#bind} from a set of iterable observables.\n//\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @returns {Array.<String|Observable>}\nfunction getBindingTargets(observables, attribute) {\n    const observableAndAttributePairs = observables.map(observable => [observable, attribute]);\n    // Merge pairs to one-dimension array of observables and attributes.\n    return Array.prototype.concat.apply([], observableAndAttributePairs);\n}\n// Check if all entries of the array are of `String` type.\n//\n// @private\n// @param {Array} arr An array to be checked.\n// @returns {Boolean}\nfunction isStringArray(arr) {\n    return arr.every(a => typeof a == 'string');\n}\n// Parses and validates {@link Observable#bind}`.to( args )` arguments and returns\n// an object with a parsed structure. For example\n//\n//\t\tA.bind( 'x' ).to( B, 'a', C, 'b', call );\n//\n// becomes\n//\n//\t\t{\n//\t\t\tto: [\n//\t\t\t\t{ observable: B, properties: [ 'a' ] },\n//\t\t\t\t{ observable: C, properties: [ 'b' ] },\n//\t\t\t],\n//\t\t\tcallback: call\n// \t\t}\n//\n// @private\n// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.\n// @returns {Object}\nfunction parseBindToArgs(...args) {\n    // Eliminate A.bind( 'x' ).to()\n    if (!args.length) {\n        /**\n         * Invalid argument syntax in `to()`.\n         *\n         * @error observable-bind-to-parse-error\n         */\n        throw new CKEditorError('observable-bind-to-parse-error', null);\n    }\n    const parsed = { to: [] };\n    let lastObservable;\n    if (typeof args[args.length - 1] == 'function') {\n        parsed.callback = args.pop();\n    }\n    args.forEach(a => {\n        if (typeof a == 'string') {\n            lastObservable.properties.push(a);\n        }\n        else if (typeof a == 'object') {\n            lastObservable = { observable: a, properties: [] };\n            parsed.to.push(lastObservable);\n        }\n        else {\n            throw new CKEditorError('observable-bind-to-parse-error', null);\n        }\n    });\n    return parsed;\n}\n// Synchronizes {@link module:utils/observablemixin#_boundObservables} with {@link Binding}.\n//\n// @private\n// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.\n// @param {Observable} toObservable A observable, which is a new component of `binding`.\n// @param {String} toPropertyName A name of `toObservable`'s property, a new component of the `binding`.\nfunction updateBoundObservables(observable, binding, toObservable, toPropertyName) {\n    const boundObservables = observable[boundObservablesSymbol];\n    const bindingsToObservable = boundObservables.get(toObservable);\n    const bindings = bindingsToObservable || {};\n    if (!bindings[toPropertyName]) {\n        bindings[toPropertyName] = new Set();\n    }\n    // Pass the binding to a corresponding Set in `observable._boundObservables`.\n    bindings[toPropertyName].add(binding);\n    if (!bindingsToObservable) {\n        boundObservables.set(toObservable, bindings);\n    }\n}\n// Synchronizes {@link Observable#_boundProperties} and {@link Observable#_boundObservables}\n// with {@link BindChain}.\n//\n// Assuming the following binding being created\n//\n// \t\tA.bind( 'a', 'b' ).to( B, 'x', 'y' );\n//\n// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [] },\n// \t\t\tb: { observable: A, property: 'b', to: [] },\n// \t\t}\n//\n// Iterate over all bindings in this chain and fill their `to` properties with\n// corresponding to( ... ) arguments (components of the binding), so\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [ B, 'x' ] },\n// \t\t\tb: { observable: A, property: 'b', to: [ B, 'y' ] },\n// \t\t}\n//\n// Then update the structure of {@link Observable#_boundObservables} with updated\n// binding, so it becomes:\n//\n// \t\tMap( {\n// \t\t\tB: {\n// \t\t\t\tx: Set( [\n// \t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] }\n// \t\t\t\t] ),\n// \t\t\t\ty: Set( [\n// \t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n// \t\t\t\t] )\n//\t\t\t}\n// \t\t} )\n//\n// @private\n// @param {BindChain} chain The binding initialized by {@link Observable#bind}.\nfunction updateBindToBound(chain) {\n    let toProperty;\n    chain._bindings.forEach((binding, propertyName) => {\n        // Note: For a binding without a callback, this will run only once\n        // like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )\n        // TODO: ES6 destructuring.\n        chain._to.forEach(to => {\n            toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];\n            binding.to.push([to.observable, toProperty]);\n            updateBoundObservables(chain._observable, binding, to.observable, toProperty);\n        });\n    });\n}\n// Updates an property of a {@link Observable} with a value\n// determined by an entry in {@link Observable#_boundProperties}.\n//\n// @private\n// @param {Observable} observable A observable which property is to be updated.\n// @param {String} propertyName An property to be updated.\nfunction updateBoundObservableProperty(observable, propertyName) {\n    const boundProperties = observable[boundPropertiesSymbol];\n    const binding = boundProperties.get(propertyName);\n    let propertyValue;\n    // When a binding with callback is created like\n    //\n    // \t\tA.bind( 'a' ).to( B, 'b', C, 'c', callback );\n    //\n    // collect B.b and C.c, then pass them to callback to set A.a.\n    if (binding.callback) {\n        propertyValue = binding.callback.apply(observable, binding.to.map(to => to[0][to[1]]));\n    }\n    else {\n        propertyValue = binding.to[0];\n        propertyValue = propertyValue[0][propertyValue[1]];\n    }\n    if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {\n        observable[propertyName] = propertyValue;\n    }\n    else {\n        observable.set(propertyName, propertyValue);\n    }\n}\n// Starts listening to changes in {@link BindChain._to} observables to update\n// {@link BindChain._observable} {@link BindChain._bindProperties}. Also sets the\n// initial state of {@link BindChain._observable}.\n//\n// @private\n// @param {Observable} observable\n// @param {BindChain} chain The chain initialized by {@link Observable#bind}.\nfunction attachBindToListeners(observable, toBindings) {\n    toBindings.forEach(to => {\n        const boundObservables = observable[boundObservablesSymbol];\n        let bindings;\n        // If there's already a chain between the observables (`observable` listens to\n        // `to.observable`), there's no need to create another `change` event listener.\n        if (!boundObservables.get(to.observable)) {\n            observable.listenTo(to.observable, 'change', (evt, propertyName) => {\n                bindings = boundObservables.get(to.observable)[propertyName];\n                // Note: to.observable will fire for any property change, react\n                // to changes of properties which are bound only.\n                if (bindings) {\n                    bindings.forEach(binding => {\n                        updateBoundObservableProperty(observable, binding.property);\n                    });\n                }\n            });\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}