{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/config\n */\nimport { isPlainObject, isElement, cloneDeepWith } from 'lodash-es';\n/**\n * Handles a configuration dictionary.\n */\nexport default class Config {\n  /**\n   * Creates an instance of the {@link ~Config} class.\n   *\n   * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n   * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n   */\n  constructor(configurations, defaultConfigurations) {\n    /**\n     * Store for the whole configuration.\n     *\n     * @private\n     * @member {Object}\n     */\n    this._config = {};\n    // Set default configuration.\n    if (defaultConfigurations) {\n      // Clone the configuration to make sure that the properties will not be shared\n      // between editors and make the watchdog feature work correctly.\n      this.define(cloneConfig(defaultConfigurations));\n    }\n    // Set initial configuration.\n    if (configurations) {\n      this._setObjectToTarget(this._config, configurations);\n    }\n  }\n  /**\n   * Set configuration values.\n   *\n   * It accepts both a name/value pair or an object, which properties and values will be used to set\n   * configurations.\n   *\n   * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n   * the value for the `width` configuration in the `resize` subset.\n   *\n   *\t\tconfig.set( 'width', 500 );\n   *\t\tconfig.set( 'toolbar.collapsed', true );\n   *\n   *\t\t// Equivalent to:\n   *\t\tconfig.set( {\n   *\t\t\twidth: 500\n   *\t\t\ttoolbar: {\n   *\t\t\t\tcollapsed: true\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Passing an object as the value will amend the configuration, not replace it.\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcollapsed: true,\n   *\t\t} );\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcolor: 'red',\n   *\t\t} );\n   *\n   *\t\tconfig.get( 'toolbar.collapsed' ); // true\n   *\t\tconfig.get( 'toolbar.color' ); // 'red'\n   *\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   */\n  set(name, value) {\n    this._setToTarget(this._config, name, value);\n  }\n  /**\n   * Does exactly the same as {@link #set} with one exception – passed configuration extends\n   * existing one, but does not overwrite already defined values.\n   *\n   * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n   * rarely used for other needs.\n   *\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   */\n  define(name, value) {\n    const isDefine = true;\n    this._setToTarget(this._config, name, value, isDefine);\n  }\n  /**\n   * Gets the value for a configuration entry.\n   *\n   *\t\tconfig.get( 'name' );\n   *\n   * Deep configurations can be retrieved by separating each part with a dot.\n   *\n   *\t\tconfig.get( 'toolbar.collapsed' );\n   *\n   * @param {String} name The configuration name. Configuration names are case-sensitive.\n   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n   */\n  get(name) {\n    return this._getFromSource(this._config, name);\n  }\n  /**\n   * Iterates over all top level configuration names.\n   *\n   * @returns {Iterable.<String>}\n   */\n  *names() {\n    for (const name of Object.keys(this._config)) {\n      yield name;\n    }\n  }\n  /**\n   * Saves passed configuration to the specified target (nested object).\n   *\n   * @private\n   * @param {Object} target Nested config object.\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n   */\n  _setToTarget(target, name, value) {\n    let isDefine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    // In case of an object, iterate through it and call `_setToTarget` again for each property.\n    if (isPlainObject(name)) {\n      this._setObjectToTarget(target, name, isDefine);\n      return;\n    }\n    // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n    const parts = name.split('.');\n    // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n    name = parts.pop();\n    // Iterate over parts to check if currently stored configuration has proper structure.\n    for (const part of parts) {\n      // If there is no object for specified part then create one.\n      if (!isPlainObject(target[part])) {\n        target[part] = {};\n      }\n      // Nested object becomes a target.\n      target = target[part];\n    }\n    // In case of value is an object.\n    if (isPlainObject(value)) {\n      // We take care of proper config structure.\n      if (!isPlainObject(target[name])) {\n        target[name] = {};\n      }\n      target = target[name];\n      // And iterate through this object calling `_setToTarget` again for each property.\n      this._setObjectToTarget(target, value, isDefine);\n      return;\n    }\n    // Do nothing if we are defining configuration for non empty name.\n    if (isDefine && typeof target[name] != 'undefined') {\n      return;\n    }\n    target[name] = value;\n  }\n  /**\n   * Get specified configuration from specified source (nested object).\n   *\n   * @private\n   * @param {Object} source level of nested object.\n   * @param {String} name The configuration name. Configuration names are case-sensitive.\n   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n   */\n  _getFromSource(source, name) {\n    // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n    const parts = name.split('.');\n    // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n    name = parts.pop();\n    // Iterate over parts to check if currently stored configuration has proper structure.\n    for (const part of parts) {\n      if (!isPlainObject(source[part])) {\n        source = null;\n        break;\n      }\n      // Nested object becomes a source.\n      source = source[part];\n    }\n    // Always returns undefined for non existing configuration.\n    return source ? cloneConfig(source[name]) : undefined;\n  }\n  /**\n   * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n   *\n   * @private\n   * @param {Object} target Nested config object.\n   * @param {Object} configuration Configuration data set\n   * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n   */\n  _setObjectToTarget(target, configuration, isDefine) {\n    Object.keys(configuration).forEach(key => {\n      this._setToTarget(target, key, configuration[key], isDefine);\n    });\n  }\n}\n// Clones configuration object or value.\n// @param {*} source Source configuration\n// @returns {*} Cloned configuration value.\nfunction cloneConfig(source) {\n  return cloneDeepWith(source, leaveDOMReferences);\n}\n// A customized function for cloneDeepWith.\n// It will leave references to DOM Elements instead of cloning them.\n//\n// @param {*} value\n// @returns {Element|undefined}\nfunction leaveDOMReferences(value) {\n  return isElement(value) ? value : undefined;\n}","map":{"version":3,"names":["isPlainObject","isElement","cloneDeepWith","Config","constructor","configurations","defaultConfigurations","_config","define","cloneConfig","_setObjectToTarget","set","name","value","_setToTarget","isDefine","get","_getFromSource","names","Object","keys","target","parts","split","pop","part","source","undefined","configuration","forEach","key","leaveDOMReferences"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/config.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/config\n */\nimport { isPlainObject, isElement, cloneDeepWith } from 'lodash-es';\n/**\n * Handles a configuration dictionary.\n */\nexport default class Config {\n    /**\n     * Creates an instance of the {@link ~Config} class.\n     *\n     * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n     * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n     */\n    constructor(configurations, defaultConfigurations) {\n        /**\n         * Store for the whole configuration.\n         *\n         * @private\n         * @member {Object}\n         */\n        this._config = {};\n        // Set default configuration.\n        if (defaultConfigurations) {\n            // Clone the configuration to make sure that the properties will not be shared\n            // between editors and make the watchdog feature work correctly.\n            this.define(cloneConfig(defaultConfigurations));\n        }\n        // Set initial configuration.\n        if (configurations) {\n            this._setObjectToTarget(this._config, configurations);\n        }\n    }\n    /**\n     * Set configuration values.\n     *\n     * It accepts both a name/value pair or an object, which properties and values will be used to set\n     * configurations.\n     *\n     * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n     * the value for the `width` configuration in the `resize` subset.\n     *\n     *\t\tconfig.set( 'width', 500 );\n     *\t\tconfig.set( 'toolbar.collapsed', true );\n     *\n     *\t\t// Equivalent to:\n     *\t\tconfig.set( {\n     *\t\t\twidth: 500\n     *\t\t\ttoolbar: {\n     *\t\t\t\tcollapsed: true\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Passing an object as the value will amend the configuration, not replace it.\n     *\n     *\t\tconfig.set( 'toolbar', {\n     *\t\t\tcollapsed: true,\n     *\t\t} );\n     *\n     *\t\tconfig.set( 'toolbar', {\n     *\t\t\tcolor: 'red',\n     *\t\t} );\n     *\n     *\t\tconfig.get( 'toolbar.collapsed' ); // true\n     *\t\tconfig.get( 'toolbar.color' ); // 'red'\n     *\n     * @param {String|Object} name The configuration name or an object from which take properties as\n     * configuration entries. Configuration names are case-sensitive.\n     * @param {*} value The configuration value. Used if a name is passed.\n     */\n    set(name, value) {\n        this._setToTarget(this._config, name, value);\n    }\n    /**\n     * Does exactly the same as {@link #set} with one exception – passed configuration extends\n     * existing one, but does not overwrite already defined values.\n     *\n     * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n     * rarely used for other needs.\n     *\n     * @param {String|Object} name The configuration name or an object from which take properties as\n     * configuration entries. Configuration names are case-sensitive.\n     * @param {*} value The configuration value. Used if a name is passed.\n     */\n    define(name, value) {\n        const isDefine = true;\n        this._setToTarget(this._config, name, value, isDefine);\n    }\n    /**\n     * Gets the value for a configuration entry.\n     *\n     *\t\tconfig.get( 'name' );\n     *\n     * Deep configurations can be retrieved by separating each part with a dot.\n     *\n     *\t\tconfig.get( 'toolbar.collapsed' );\n     *\n     * @param {String} name The configuration name. Configuration names are case-sensitive.\n     * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n     */\n    get(name) {\n        return this._getFromSource(this._config, name);\n    }\n    /**\n     * Iterates over all top level configuration names.\n     *\n     * @returns {Iterable.<String>}\n     */\n    *names() {\n        for (const name of Object.keys(this._config)) {\n            yield name;\n        }\n    }\n    /**\n     * Saves passed configuration to the specified target (nested object).\n     *\n     * @private\n     * @param {Object} target Nested config object.\n     * @param {String|Object} name The configuration name or an object from which take properties as\n     * configuration entries. Configuration names are case-sensitive.\n     * @param {*} value The configuration value. Used if a name is passed.\n     * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n     */\n    _setToTarget(target, name, value, isDefine = false) {\n        // In case of an object, iterate through it and call `_setToTarget` again for each property.\n        if (isPlainObject(name)) {\n            this._setObjectToTarget(target, name, isDefine);\n            return;\n        }\n        // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n        const parts = name.split('.');\n        // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n        name = parts.pop();\n        // Iterate over parts to check if currently stored configuration has proper structure.\n        for (const part of parts) {\n            // If there is no object for specified part then create one.\n            if (!isPlainObject(target[part])) {\n                target[part] = {};\n            }\n            // Nested object becomes a target.\n            target = target[part];\n        }\n        // In case of value is an object.\n        if (isPlainObject(value)) {\n            // We take care of proper config structure.\n            if (!isPlainObject(target[name])) {\n                target[name] = {};\n            }\n            target = target[name];\n            // And iterate through this object calling `_setToTarget` again for each property.\n            this._setObjectToTarget(target, value, isDefine);\n            return;\n        }\n        // Do nothing if we are defining configuration for non empty name.\n        if (isDefine && typeof target[name] != 'undefined') {\n            return;\n        }\n        target[name] = value;\n    }\n    /**\n     * Get specified configuration from specified source (nested object).\n     *\n     * @private\n     * @param {Object} source level of nested object.\n     * @param {String} name The configuration name. Configuration names are case-sensitive.\n     * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n     */\n    _getFromSource(source, name) {\n        // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n        const parts = name.split('.');\n        // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n        name = parts.pop();\n        // Iterate over parts to check if currently stored configuration has proper structure.\n        for (const part of parts) {\n            if (!isPlainObject(source[part])) {\n                source = null;\n                break;\n            }\n            // Nested object becomes a source.\n            source = source[part];\n        }\n        // Always returns undefined for non existing configuration.\n        return source ? cloneConfig(source[name]) : undefined;\n    }\n    /**\n     * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n     *\n     * @private\n     * @param {Object} target Nested config object.\n     * @param {Object} configuration Configuration data set\n     * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n     */\n    _setObjectToTarget(target, configuration, isDefine) {\n        Object.keys(configuration).forEach(key => {\n            this._setToTarget(target, key, configuration[key], isDefine);\n        });\n    }\n}\n// Clones configuration object or value.\n// @param {*} source Source configuration\n// @returns {*} Cloned configuration value.\nfunction cloneConfig(source) {\n    return cloneDeepWith(source, leaveDOMReferences);\n}\n// A customized function for cloneDeepWith.\n// It will leave references to DOM Elements instead of cloning them.\n//\n// @param {*} value\n// @returns {Element|undefined}\nfunction leaveDOMReferences(value) {\n    return isElement(value) ? value : undefined;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,aAAa,EAAEC,SAAS,EAAEC,aAAa,QAAQ,WAAW;AACnE;AACA;AACA;AACA,eAAe,MAAMC,MAAM,CAAC;EACxB;AACJ;AACA;AACA;AACA;AACA;EACIC,WAAW,CAACC,cAAc,EAAEC,qBAAqB,EAAE;IAC/C;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB;IACA,IAAID,qBAAqB,EAAE;MACvB;MACA;MACA,IAAI,CAACE,MAAM,CAACC,WAAW,CAACH,qBAAqB,CAAC,CAAC;IACnD;IACA;IACA,IAAID,cAAc,EAAE;MAChB,IAAI,CAACK,kBAAkB,CAAC,IAAI,CAACH,OAAO,EAAEF,cAAc,CAAC;IACzD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAE;IACb,IAAI,CAACC,YAAY,CAAC,IAAI,CAACP,OAAO,EAAEK,IAAI,EAAEC,KAAK,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIL,MAAM,CAACI,IAAI,EAAEC,KAAK,EAAE;IAChB,MAAME,QAAQ,GAAG,IAAI;IACrB,IAAI,CAACD,YAAY,CAAC,IAAI,CAACP,OAAO,EAAEK,IAAI,EAAEC,KAAK,EAAEE,QAAQ,CAAC;EAC1D;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,GAAG,CAACJ,IAAI,EAAE;IACN,OAAO,IAAI,CAACK,cAAc,CAAC,IAAI,CAACV,OAAO,EAAEK,IAAI,CAAC;EAClD;EACA;AACJ;AACA;AACA;AACA;EACI,CAACM,KAAK,GAAG;IACL,KAAK,MAAMN,IAAI,IAAIO,MAAM,CAACC,IAAI,CAAC,IAAI,CAACb,OAAO,CAAC,EAAE;MAC1C,MAAMK,IAAI;IACd;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,YAAY,CAACO,MAAM,EAAET,IAAI,EAAEC,KAAK,EAAoB;IAAA,IAAlBE,QAAQ,uEAAG,KAAK;IAC9C;IACA,IAAIf,aAAa,CAACY,IAAI,CAAC,EAAE;MACrB,IAAI,CAACF,kBAAkB,CAACW,MAAM,EAAET,IAAI,EAAEG,QAAQ,CAAC;MAC/C;IACJ;IACA;IACA,MAAMO,KAAK,GAAGV,IAAI,CAACW,KAAK,CAAC,GAAG,CAAC;IAC7B;IACAX,IAAI,GAAGU,KAAK,CAACE,GAAG,EAAE;IAClB;IACA,KAAK,MAAMC,IAAI,IAAIH,KAAK,EAAE;MACtB;MACA,IAAI,CAACtB,aAAa,CAACqB,MAAM,CAACI,IAAI,CAAC,CAAC,EAAE;QAC9BJ,MAAM,CAACI,IAAI,CAAC,GAAG,CAAC,CAAC;MACrB;MACA;MACAJ,MAAM,GAAGA,MAAM,CAACI,IAAI,CAAC;IACzB;IACA;IACA,IAAIzB,aAAa,CAACa,KAAK,CAAC,EAAE;MACtB;MACA,IAAI,CAACb,aAAa,CAACqB,MAAM,CAACT,IAAI,CAAC,CAAC,EAAE;QAC9BS,MAAM,CAACT,IAAI,CAAC,GAAG,CAAC,CAAC;MACrB;MACAS,MAAM,GAAGA,MAAM,CAACT,IAAI,CAAC;MACrB;MACA,IAAI,CAACF,kBAAkB,CAACW,MAAM,EAAER,KAAK,EAAEE,QAAQ,CAAC;MAChD;IACJ;IACA;IACA,IAAIA,QAAQ,IAAI,OAAOM,MAAM,CAACT,IAAI,CAAC,IAAI,WAAW,EAAE;MAChD;IACJ;IACAS,MAAM,CAACT,IAAI,CAAC,GAAGC,KAAK;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACII,cAAc,CAACS,MAAM,EAAEd,IAAI,EAAE;IACzB;IACA,MAAMU,KAAK,GAAGV,IAAI,CAACW,KAAK,CAAC,GAAG,CAAC;IAC7B;IACAX,IAAI,GAAGU,KAAK,CAACE,GAAG,EAAE;IAClB;IACA,KAAK,MAAMC,IAAI,IAAIH,KAAK,EAAE;MACtB,IAAI,CAACtB,aAAa,CAAC0B,MAAM,CAACD,IAAI,CAAC,CAAC,EAAE;QAC9BC,MAAM,GAAG,IAAI;QACb;MACJ;MACA;MACAA,MAAM,GAAGA,MAAM,CAACD,IAAI,CAAC;IACzB;IACA;IACA,OAAOC,MAAM,GAAGjB,WAAW,CAACiB,MAAM,CAACd,IAAI,CAAC,CAAC,GAAGe,SAAS;EACzD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIjB,kBAAkB,CAACW,MAAM,EAAEO,aAAa,EAAEb,QAAQ,EAAE;IAChDI,MAAM,CAACC,IAAI,CAACQ,aAAa,CAAC,CAACC,OAAO,CAACC,GAAG,IAAI;MACtC,IAAI,CAAChB,YAAY,CAACO,MAAM,EAAES,GAAG,EAAEF,aAAa,CAACE,GAAG,CAAC,EAAEf,QAAQ,CAAC;IAChE,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA,SAASN,WAAW,CAACiB,MAAM,EAAE;EACzB,OAAOxB,aAAa,CAACwB,MAAM,EAAEK,kBAAkB,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,kBAAkB,CAAClB,KAAK,EAAE;EAC/B,OAAOZ,SAAS,CAACY,KAAK,CAAC,GAAGA,KAAK,GAAGc,SAAS;AAC/C"},"metadata":{},"sourceType":"module"}