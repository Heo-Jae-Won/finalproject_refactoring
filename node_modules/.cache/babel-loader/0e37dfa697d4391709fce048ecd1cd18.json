{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/view/node\n */\nimport TypeCheckable from './typecheckable';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport { clone } from 'lodash-es';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Abstract view node class.\n *\n * This is an abstract class. Its constructor should not be used directly.\n * Use the {@link module:engine/view/downcastwriter~DowncastWriter} or {@link module:engine/view/upcastwriter~UpcastWriter}\n * to create new instances of view nodes.\n *\n * @abstract\n */\nexport default class Node extends EmitterMixin(TypeCheckable) {\n  /**\n   * Creates a tree view node.\n   *\n   * @protected\n   * @param {module:engine/view/document~Document} document The document instance to which this node belongs.\n   */\n  constructor(document) {\n    super();\n    /**\n     * The document instance to which this node belongs.\n     *\n     * @readonly\n     * @member {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Parent element. Null by default. Set by {@link module:engine/view/element~Element#_insertChild}.\n     *\n     * @readonly\n     * @member {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n     */\n    this.parent = null;\n  }\n  /**\n   * Index of the node in the parent element or null if the node has no parent.\n   *\n   * Accessing this property throws an error if this node's parent element does not contain it.\n   * This means that view tree got broken.\n   *\n   * @readonly\n   * @type {Number|null}\n   */\n  get index() {\n    let pos;\n    if (!this.parent) {\n      return null;\n    }\n    // No parent or child doesn't exist in parent's children.\n    if ((pos = this.parent.getChildIndex(this)) == -1) {\n      /**\n       * The node's parent does not contain this node. It means that the document tree is corrupted.\n       *\n       * @error view-node-not-found-in-parent\n       */\n      throw new CKEditorError('view-node-not-found-in-parent', this);\n    }\n    return pos;\n  }\n  /**\n   * Node's next sibling, or `null` if it is the last child.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|null}\n   */\n  get nextSibling() {\n    const index = this.index;\n    return index !== null && this.parent.getChild(index + 1) || null;\n  }\n  /**\n   * Node's previous sibling, or `null` if it is the first child.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|null}\n   */\n  get previousSibling() {\n    const index = this.index;\n    return index !== null && this.parent.getChild(index - 1) || null;\n  }\n  /**\n   * Top-most ancestor of the node. If the node has no parent it is the root itself.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n   */\n  get root() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n    let root = this;\n    while (root.parent) {\n      root = root.parent;\n    }\n    return root;\n  }\n  /**\n   * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).\n   *\n   * @returns {Boolean}\n   */\n  isAttached() {\n    return this.root.is('rootElement');\n  }\n  /**\n   * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,\n   * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.\n   *\n   *\t\tconst abc = downcastWriter.createText( 'abc' );\n   *\t\tconst foo = downcastWriter.createText( 'foo' );\n   *\t\tconst h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );\n   *\t\tconst p = downcastWriter.createElement( 'p', null, [ abc, foo ] );\n   *\t\tconst div = downcastWriter.createElement( 'div', null, [ h1, p ] );\n   *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n   *\t\th1.getPath(); // Returns [ 0 ].\n   *\t\tdiv.getPath(); // Returns [].\n   *\n   * @returns {Array.<Number>} The path.\n   */\n  getPath() {\n    const path = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n    let node = this;\n    while (node.parent) {\n      path.unshift(node.index);\n      node = node.parent;\n    }\n    return path;\n  }\n  /**\n   * Returns ancestors array of this node.\n   *\n   * @param {Object} options Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n   * otherwise root element will be the first item in the array.\n   * @returns {Array} Array with ancestors.\n   */\n  getAncestors() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const ancestors = [];\n    let parent = options.includeSelf ? this : this.parent;\n    while (parent) {\n      ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n      parent = parent.parent;\n    }\n    return ancestors;\n  }\n  /**\n   * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}\n   * which is a common ancestor of both nodes.\n   *\n   * @param {module:engine/view/node~Node} node The second node.\n   * @param {Object} options Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n   * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n   * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n   */\n  getCommonAncestor(node) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const ancestorsA = this.getAncestors(options);\n    const ancestorsB = node.getAncestors(options);\n    let i = 0;\n    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n      i++;\n    }\n    return i === 0 ? null : ancestorsA[i - 1];\n  }\n  /**\n   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n   *\n   * @param {module:engine/view/node~Node} node Node to compare with.\n   * @returns {Boolean}\n   */\n  isBefore(node) {\n    // Given node is not before this node if they are same.\n    if (this == node) {\n      return false;\n    }\n    // Return `false` if it is impossible to compare nodes.\n    if (this.root !== node.root) {\n      return false;\n    }\n    const thisPath = this.getPath();\n    const nodePath = node.getPath();\n    const result = compareArrays(thisPath, nodePath);\n    switch (result) {\n      case 'prefix':\n        return true;\n      case 'extension':\n        return false;\n      default:\n        return thisPath[result] < nodePath[result];\n    }\n  }\n  /**\n   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n   *\n   * @param {module:engine/view/node~Node} node Node to compare with.\n   * @returns {Boolean}\n   */\n  isAfter(node) {\n    // Given node is not before this node if they are same.\n    if (this == node) {\n      return false;\n    }\n    // Return `false` if it is impossible to compare nodes.\n    if (this.root !== node.root) {\n      return false;\n    }\n    // In other cases, just check if the `node` is before, and return the opposite.\n    return !this.isBefore(node);\n  }\n  /**\n   * Removes node from parent.\n   *\n   * @internal\n   * @protected\n   */\n  _remove() {\n    this.parent._removeChildren(this.index);\n  }\n  /**\n   * @internal\n   * @protected\n   * @param {module:engine/view/document~ChangeType} type Type of the change.\n   * @param {module:engine/view/node~Node} node Changed node.\n   * @fires change\n   */\n  _fireChange(type, node) {\n    this.fire(`change:${type}`, node);\n    if (this.parent) {\n      this.parent._fireChange(type, node);\n    }\n  }\n  /**\n   * Custom toJSON method to solve child-parent circular dependencies.\n   *\n   * @returns {Object} Clone of this object with the parent property removed.\n   */\n  toJSON() {\n    const json = clone(this);\n    // Due to circular references we need to remove parent reference.\n    delete json.parent;\n    return json;\n  }\n}\n/**\n * Checks whether this object is of the given type.\n *\n * This method is useful when processing view objects that are of unknown type. For example, a function\n * may return a {@link module:engine/view/documentfragment~DocumentFragment} or a {@link module:engine/view/node~Node}\n * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n *\n *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n *\n * Since this method is also available on a range of model objects, you can prefix the type of the object with\n * `model:` or `view:` to check, for example, if this is the model's or view's element:\n *\n *\t\tviewElement.is( 'view:element' ); // -> true\n *\t\tviewElement.is( 'model:element' ); // -> false\n *\n * By using this method it is also possible to check a name of an element:\n *\n *\t\timgElement.is( 'element', 'img' ); // -> true\n *\t\timgElement.is( 'view:element', 'img' ); // -> same as above, but more precise\n *\n * The list of view objects which implement the `is()` method:\n *\n * * {@link module:engine/view/attributeelement~AttributeElement#is `AttributeElement#is()`}\n * * {@link module:engine/view/containerelement~ContainerElement#is `ContainerElement#is()`}\n * * {@link module:engine/view/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n * * {@link module:engine/view/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n * * {@link module:engine/view/editableelement~EditableElement#is `EditableElement#is()`}\n * * {@link module:engine/view/element~Element#is `Element#is()`}\n * * {@link module:engine/view/emptyelement~EmptyElement#is `EmptyElement#is()`}\n * * {@link module:engine/view/node~Node#is `Node#is()`}\n * * {@link module:engine/view/position~Position#is `Position#is()`}\n * * {@link module:engine/view/range~Range#is `Range#is()`}\n * * {@link module:engine/view/rooteditableelement~RootEditableElement#is `RootEditableElement#is()`}\n * * {@link module:engine/view/selection~Selection#is `Selection#is()`}\n * * {@link module:engine/view/text~Text#is `Text#is()`}\n * * {@link module:engine/view/textproxy~TextProxy#is `TextProxy#is()`}\n * * {@link module:engine/view/uielement~UIElement#is `UIElement#is()`}\n *\n * @method #is\n * @param {String} type Type to check.\n * @returns {Boolean}\n */\nNode.prototype.is = function (type) {\n  return type === 'node' || type === 'view:node';\n};","map":{"version":3,"names":["TypeCheckable","CKEditorError","EmitterMixin","compareArrays","clone","Node","constructor","document","parent","index","pos","getChildIndex","nextSibling","getChild","previousSibling","root","isAttached","is","getPath","path","node","unshift","getAncestors","options","ancestors","includeSelf","parentFirst","getCommonAncestor","ancestorsA","ancestorsB","i","isBefore","thisPath","nodePath","result","isAfter","_remove","_removeChildren","_fireChange","type","fire","toJSON","json","prototype"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/node.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* eslint-disable new-cap */\n/**\n * @module engine/view/node\n */\nimport TypeCheckable from './typecheckable';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport { clone } from 'lodash-es';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Abstract view node class.\n *\n * This is an abstract class. Its constructor should not be used directly.\n * Use the {@link module:engine/view/downcastwriter~DowncastWriter} or {@link module:engine/view/upcastwriter~UpcastWriter}\n * to create new instances of view nodes.\n *\n * @abstract\n */\nexport default class Node extends EmitterMixin(TypeCheckable) {\n    /**\n     * Creates a tree view node.\n     *\n     * @protected\n     * @param {module:engine/view/document~Document} document The document instance to which this node belongs.\n     */\n    constructor(document) {\n        super();\n        /**\n         * The document instance to which this node belongs.\n         *\n         * @readonly\n         * @member {module:engine/view/document~Document}\n         */\n        this.document = document;\n        /**\n         * Parent element. Null by default. Set by {@link module:engine/view/element~Element#_insertChild}.\n         *\n         * @readonly\n         * @member {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n         */\n        this.parent = null;\n    }\n    /**\n     * Index of the node in the parent element or null if the node has no parent.\n     *\n     * Accessing this property throws an error if this node's parent element does not contain it.\n     * This means that view tree got broken.\n     *\n     * @readonly\n     * @type {Number|null}\n     */\n    get index() {\n        let pos;\n        if (!this.parent) {\n            return null;\n        }\n        // No parent or child doesn't exist in parent's children.\n        if ((pos = this.parent.getChildIndex(this)) == -1) {\n            /**\n             * The node's parent does not contain this node. It means that the document tree is corrupted.\n             *\n             * @error view-node-not-found-in-parent\n             */\n            throw new CKEditorError('view-node-not-found-in-parent', this);\n        }\n        return pos;\n    }\n    /**\n     * Node's next sibling, or `null` if it is the last child.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|null}\n     */\n    get nextSibling() {\n        const index = this.index;\n        return (index !== null && this.parent.getChild(index + 1)) || null;\n    }\n    /**\n     * Node's previous sibling, or `null` if it is the first child.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|null}\n     */\n    get previousSibling() {\n        const index = this.index;\n        return (index !== null && this.parent.getChild(index - 1)) || null;\n    }\n    /**\n     * Top-most ancestor of the node. If the node has no parent it is the root itself.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n     */\n    get root() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let root = this;\n        while (root.parent) {\n            root = root.parent;\n        }\n        return root;\n    }\n    /**\n     * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).\n     *\n     * @returns {Boolean}\n     */\n    isAttached() {\n        return this.root.is('rootElement');\n    }\n    /**\n     * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,\n     * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.\n     *\n     *\t\tconst abc = downcastWriter.createText( 'abc' );\n     *\t\tconst foo = downcastWriter.createText( 'foo' );\n     *\t\tconst h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );\n     *\t\tconst p = downcastWriter.createElement( 'p', null, [ abc, foo ] );\n     *\t\tconst div = downcastWriter.createElement( 'div', null, [ h1, p ] );\n     *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n     *\t\th1.getPath(); // Returns [ 0 ].\n     *\t\tdiv.getPath(); // Returns [].\n     *\n     * @returns {Array.<Number>} The path.\n     */\n    getPath() {\n        const path = [];\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let node = this;\n        while (node.parent) {\n            path.unshift(node.index);\n            node = node.parent;\n        }\n        return path;\n    }\n    /**\n     * Returns ancestors array of this node.\n     *\n     * @param {Object} options Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n     * otherwise root element will be the first item in the array.\n     * @returns {Array} Array with ancestors.\n     */\n    getAncestors(options = {}) {\n        const ancestors = [];\n        let parent = options.includeSelf ? this : this.parent;\n        while (parent) {\n            ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n            parent = parent.parent;\n        }\n        return ancestors;\n    }\n    /**\n     * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}\n     * which is a common ancestor of both nodes.\n     *\n     * @param {module:engine/view/node~Node} node The second node.\n     * @param {Object} options Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n     * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n     * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n     */\n    getCommonAncestor(node, options = {}) {\n        const ancestorsA = this.getAncestors(options);\n        const ancestorsB = node.getAncestors(options);\n        let i = 0;\n        while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n            i++;\n        }\n        return i === 0 ? null : ancestorsA[i - 1];\n    }\n    /**\n     * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n     *\n     * @param {module:engine/view/node~Node} node Node to compare with.\n     * @returns {Boolean}\n     */\n    isBefore(node) {\n        // Given node is not before this node if they are same.\n        if (this == node) {\n            return false;\n        }\n        // Return `false` if it is impossible to compare nodes.\n        if (this.root !== node.root) {\n            return false;\n        }\n        const thisPath = this.getPath();\n        const nodePath = node.getPath();\n        const result = compareArrays(thisPath, nodePath);\n        switch (result) {\n            case 'prefix':\n                return true;\n            case 'extension':\n                return false;\n            default:\n                return thisPath[result] < nodePath[result];\n        }\n    }\n    /**\n     * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n     *\n     * @param {module:engine/view/node~Node} node Node to compare with.\n     * @returns {Boolean}\n     */\n    isAfter(node) {\n        // Given node is not before this node if they are same.\n        if (this == node) {\n            return false;\n        }\n        // Return `false` if it is impossible to compare nodes.\n        if (this.root !== node.root) {\n            return false;\n        }\n        // In other cases, just check if the `node` is before, and return the opposite.\n        return !this.isBefore(node);\n    }\n    /**\n     * Removes node from parent.\n     *\n     * @internal\n     * @protected\n     */\n    _remove() {\n        this.parent._removeChildren(this.index);\n    }\n    /**\n     * @internal\n     * @protected\n     * @param {module:engine/view/document~ChangeType} type Type of the change.\n     * @param {module:engine/view/node~Node} node Changed node.\n     * @fires change\n     */\n    _fireChange(type, node) {\n        this.fire(`change:${type}`, node);\n        if (this.parent) {\n            this.parent._fireChange(type, node);\n        }\n    }\n    /**\n     * Custom toJSON method to solve child-parent circular dependencies.\n     *\n     * @returns {Object} Clone of this object with the parent property removed.\n     */\n    toJSON() {\n        const json = clone(this);\n        // Due to circular references we need to remove parent reference.\n        delete json.parent;\n        return json;\n    }\n}\n/**\n * Checks whether this object is of the given type.\n *\n * This method is useful when processing view objects that are of unknown type. For example, a function\n * may return a {@link module:engine/view/documentfragment~DocumentFragment} or a {@link module:engine/view/node~Node}\n * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n *\n *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n *\n * Since this method is also available on a range of model objects, you can prefix the type of the object with\n * `model:` or `view:` to check, for example, if this is the model's or view's element:\n *\n *\t\tviewElement.is( 'view:element' ); // -> true\n *\t\tviewElement.is( 'model:element' ); // -> false\n *\n * By using this method it is also possible to check a name of an element:\n *\n *\t\timgElement.is( 'element', 'img' ); // -> true\n *\t\timgElement.is( 'view:element', 'img' ); // -> same as above, but more precise\n *\n * The list of view objects which implement the `is()` method:\n *\n * * {@link module:engine/view/attributeelement~AttributeElement#is `AttributeElement#is()`}\n * * {@link module:engine/view/containerelement~ContainerElement#is `ContainerElement#is()`}\n * * {@link module:engine/view/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n * * {@link module:engine/view/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n * * {@link module:engine/view/editableelement~EditableElement#is `EditableElement#is()`}\n * * {@link module:engine/view/element~Element#is `Element#is()`}\n * * {@link module:engine/view/emptyelement~EmptyElement#is `EmptyElement#is()`}\n * * {@link module:engine/view/node~Node#is `Node#is()`}\n * * {@link module:engine/view/position~Position#is `Position#is()`}\n * * {@link module:engine/view/range~Range#is `Range#is()`}\n * * {@link module:engine/view/rooteditableelement~RootEditableElement#is `RootEditableElement#is()`}\n * * {@link module:engine/view/selection~Selection#is `Selection#is()`}\n * * {@link module:engine/view/text~Text#is `Text#is()`}\n * * {@link module:engine/view/textproxy~TextProxy#is `TextProxy#is()`}\n * * {@link module:engine/view/uielement~UIElement#is `UIElement#is()`}\n *\n * @method #is\n * @param {String} type Type to check.\n * @returns {Boolean}\n */\nNode.prototype.is = function (type) {\n    return type === 'node' || type === 'view:node';\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}