{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/changebuffer\n */\n\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n *\t\tconst buffer = new ChangeBuffer( model, LIMIT );\n *\n *\t\t// Later on in your feature:\n *\t\tbuffer.batch.insert( pos, insertedCharacters );\n *\t\tbuffer.input( insertedCharacters.length );\n *\n */\nexport default class ChangeBuffer {\n  /**\n   * Creates a new instance of the change buffer.\n   *\n   * @param {module:engine/model/model~Model} model\n   * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.\n   */\n  constructor(model) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n    /**\n     * The model instance.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model} #model\n     */\n    this.model = model;\n\n    /**\n     * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n     * the {@link #batch batch} is set to a new one.\n     *\n     * @readonly\n     * @member {Number} #size\n     */\n    this.size = 0;\n\n    /**\n     * The maximum number of atomic changes which can be contained in one batch.\n     *\n     * @readonly\n     * @member {Number} #limit\n     */\n    this.limit = limit;\n\n    /**\n     * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n     *\n     * @readonly\n     * @member {Boolean} #isLocked\n     */\n    this.isLocked = false;\n\n    // The function to be called in order to notify the buffer about batches which appeared in the document.\n    // The callback will check whether it is a new batch and in that case the buffer will be flushed.\n    //\n    // The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n    // should be added to a new batch. For instance, when the user types, then inserts an image, and then types again,\n    // the characters typed after inserting the image should be added to a different batch than the characters typed before.\n    this._changeCallback = (evt, batch) => {\n      if (batch.isLocal && batch.isUndoable && batch !== this._batch) {\n        this._reset(true);\n      }\n    };\n    this._selectionChangeCallback = () => {\n      this._reset();\n    };\n    this.model.document.on('change', this._changeCallback);\n    this.model.document.selection.on('change:range', this._selectionChangeCallback);\n    this.model.document.selection.on('change:attribute', this._selectionChangeCallback);\n\n    /**\n     * The current batch instance.\n     *\n     * @private\n     * @member #_batch\n     */\n\n    /**\n     * The callback to document the change event which later needs to be removed.\n     *\n     * @private\n     * @member #_changeCallback\n     */\n\n    /**\n     * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.\n     *\n     * @private\n     * @member #_selectionChangeCallback\n     */\n  }\n\n  /**\n   * The current batch to which a feature should add its operations. Once the {@link #size}\n   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n   *\n   * @type {module:engine/model/batch~Batch}\n   */\n  get batch() {\n    if (!this._batch) {\n      this._batch = this.model.createBatch({\n        isTyping: true\n      });\n    }\n    return this._batch;\n  }\n\n  /**\n   * The input number of changes into the buffer. Once the {@link #size} is\n   * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n   *\n   * @param {Number} changeCount The number of atomic changes to input.\n   */\n  input(changeCount) {\n    this.size += changeCount;\n    if (this.size >= this.limit) {\n      this._reset(true);\n    }\n  }\n\n  /**\n   * Locks the buffer.\n   */\n  lock() {\n    this.isLocked = true;\n  }\n\n  /**\n   * Unlocks the buffer.\n   */\n  unlock() {\n    this.isLocked = false;\n  }\n\n  /**\n   * Destroys the buffer.\n   */\n  destroy() {\n    this.model.document.off('change', this._changeCallback);\n    this.model.document.selection.off('change:range', this._selectionChangeCallback);\n    this.model.document.selection.off('change:attribute', this._selectionChangeCallback);\n  }\n\n  /**\n   * Resets the change buffer.\n   *\n   * @private\n   * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.\n   */\n  _reset(ignoreLock) {\n    if (!this.isLocked || ignoreLock) {\n      this._batch = null;\n      this.size = 0;\n    }\n  }\n}","map":{"version":3,"names":["ChangeBuffer","constructor","model","limit","size","isLocked","_changeCallback","evt","batch","isLocal","isUndoable","_batch","_reset","_selectionChangeCallback","document","on","selection","createBatch","isTyping","input","changeCount","lock","unlock","destroy","off","ignoreLock"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-typing/src/utils/changebuffer.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/changebuffer\n */\n\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n *\t\tconst buffer = new ChangeBuffer( model, LIMIT );\n *\n *\t\t// Later on in your feature:\n *\t\tbuffer.batch.insert( pos, insertedCharacters );\n *\t\tbuffer.input( insertedCharacters.length );\n *\n */\nexport default class ChangeBuffer {\n\t/**\n\t * Creates a new instance of the change buffer.\n\t *\n\t * @param {module:engine/model/model~Model} model\n\t * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.\n\t */\n\tconstructor( model, limit = 20 ) {\n\t\t/**\n\t\t * The model instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model} #model\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n\t\t * the {@link #batch batch} is set to a new one.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #size\n\t\t */\n\t\tthis.size = 0;\n\n\t\t/**\n\t\t * The maximum number of atomic changes which can be contained in one batch.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #limit\n\t\t */\n\t\tthis.limit = limit;\n\n\t\t/**\n\t\t * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} #isLocked\n\t\t */\n\t\tthis.isLocked = false;\n\n\t\t// The function to be called in order to notify the buffer about batches which appeared in the document.\n\t\t// The callback will check whether it is a new batch and in that case the buffer will be flushed.\n\t\t//\n\t\t// The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n\t\t// should be added to a new batch. For instance, when the user types, then inserts an image, and then types again,\n\t\t// the characters typed after inserting the image should be added to a different batch than the characters typed before.\n\t\tthis._changeCallback = ( evt, batch ) => {\n\t\t\tif ( batch.isLocal && batch.isUndoable && batch !== this._batch ) {\n\t\t\t\tthis._reset( true );\n\t\t\t}\n\t\t};\n\n\t\tthis._selectionChangeCallback = () => {\n\t\t\tthis._reset();\n\t\t};\n\n\t\tthis.model.document.on( 'change', this._changeCallback );\n\n\t\tthis.model.document.selection.on( 'change:range', this._selectionChangeCallback );\n\t\tthis.model.document.selection.on( 'change:attribute', this._selectionChangeCallback );\n\n\t\t/**\n\t\t * The current batch instance.\n\t\t *\n\t\t * @private\n\t\t * @member #_batch\n\t\t */\n\n\t\t/**\n\t\t * The callback to document the change event which later needs to be removed.\n\t\t *\n\t\t * @private\n\t\t * @member #_changeCallback\n\t\t */\n\n\t\t/**\n\t\t * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.\n\t\t *\n\t\t * @private\n\t\t * @member #_selectionChangeCallback\n\t\t */\n\t}\n\n\t/**\n\t * The current batch to which a feature should add its operations. Once the {@link #size}\n\t * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n\t *\n\t * @type {module:engine/model/batch~Batch}\n\t */\n\tget batch() {\n\t\tif ( !this._batch ) {\n\t\t\tthis._batch = this.model.createBatch( { isTyping: true } );\n\t\t}\n\n\t\treturn this._batch;\n\t}\n\n\t/**\n\t * The input number of changes into the buffer. Once the {@link #size} is\n\t * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n\t *\n\t * @param {Number} changeCount The number of atomic changes to input.\n\t */\n\tinput( changeCount ) {\n\t\tthis.size += changeCount;\n\n\t\tif ( this.size >= this.limit ) {\n\t\t\tthis._reset( true );\n\t\t}\n\t}\n\n\t/**\n\t * Locks the buffer.\n\t */\n\tlock() {\n\t\tthis.isLocked = true;\n\t}\n\n\t/**\n\t * Unlocks the buffer.\n\t */\n\tunlock() {\n\t\tthis.isLocked = false;\n\t}\n\n\t/**\n\t * Destroys the buffer.\n\t */\n\tdestroy() {\n\t\tthis.model.document.off( 'change', this._changeCallback );\n\t\tthis.model.document.selection.off( 'change:range', this._selectionChangeCallback );\n\t\tthis.model.document.selection.off( 'change:attribute', this._selectionChangeCallback );\n\t}\n\n\t/**\n\t * Resets the change buffer.\n\t *\n\t * @private\n\t * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.\n\t */\n\t_reset( ignoreLock ) {\n\t\tif ( !this.isLocked || ignoreLock ) {\n\t\t\tthis._batch = null;\n\t\t\tthis.size = 0;\n\t\t}\n\t}\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMA,YAAY,CAAC;EACjC;AACD;AACA;AACA;AACA;AACA;EACCC,WAAW,CAAEC,KAAK,EAAe;IAAA,IAAbC,KAAK,uEAAG,EAAE;IAC7B;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACD,KAAK,GAAGA,KAAK;;IAElB;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACE,IAAI,GAAG,CAAC;;IAEb;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACD,KAAK,GAAGA,KAAK;;IAElB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACE,QAAQ,GAAG,KAAK;;IAErB;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,eAAe,GAAG,CAAEC,GAAG,EAAEC,KAAK,KAAM;MACxC,IAAKA,KAAK,CAACC,OAAO,IAAID,KAAK,CAACE,UAAU,IAAIF,KAAK,KAAK,IAAI,CAACG,MAAM,EAAG;QACjE,IAAI,CAACC,MAAM,CAAE,IAAI,CAAE;MACpB;IACD,CAAC;IAED,IAAI,CAACC,wBAAwB,GAAG,MAAM;MACrC,IAAI,CAACD,MAAM,EAAE;IACd,CAAC;IAED,IAAI,CAACV,KAAK,CAACY,QAAQ,CAACC,EAAE,CAAE,QAAQ,EAAE,IAAI,CAACT,eAAe,CAAE;IAExD,IAAI,CAACJ,KAAK,CAACY,QAAQ,CAACE,SAAS,CAACD,EAAE,CAAE,cAAc,EAAE,IAAI,CAACF,wBAAwB,CAAE;IACjF,IAAI,CAACX,KAAK,CAACY,QAAQ,CAACE,SAAS,CAACD,EAAE,CAAE,kBAAkB,EAAE,IAAI,CAACF,wBAAwB,CAAE;;IAErF;AACF;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;EACC;;EAEA;AACD;AACA;AACA;AACA;AACA;EACC,IAAIL,KAAK,GAAG;IACX,IAAK,CAAC,IAAI,CAACG,MAAM,EAAG;MACnB,IAAI,CAACA,MAAM,GAAG,IAAI,CAACT,KAAK,CAACe,WAAW,CAAE;QAAEC,QAAQ,EAAE;MAAK,CAAC,CAAE;IAC3D;IAEA,OAAO,IAAI,CAACP,MAAM;EACnB;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCQ,KAAK,CAAEC,WAAW,EAAG;IACpB,IAAI,CAAChB,IAAI,IAAIgB,WAAW;IAExB,IAAK,IAAI,CAAChB,IAAI,IAAI,IAAI,CAACD,KAAK,EAAG;MAC9B,IAAI,CAACS,MAAM,CAAE,IAAI,CAAE;IACpB;EACD;;EAEA;AACD;AACA;EACCS,IAAI,GAAG;IACN,IAAI,CAAChB,QAAQ,GAAG,IAAI;EACrB;;EAEA;AACD;AACA;EACCiB,MAAM,GAAG;IACR,IAAI,CAACjB,QAAQ,GAAG,KAAK;EACtB;;EAEA;AACD;AACA;EACCkB,OAAO,GAAG;IACT,IAAI,CAACrB,KAAK,CAACY,QAAQ,CAACU,GAAG,CAAE,QAAQ,EAAE,IAAI,CAAClB,eAAe,CAAE;IACzD,IAAI,CAACJ,KAAK,CAACY,QAAQ,CAACE,SAAS,CAACQ,GAAG,CAAE,cAAc,EAAE,IAAI,CAACX,wBAAwB,CAAE;IAClF,IAAI,CAACX,KAAK,CAACY,QAAQ,CAACE,SAAS,CAACQ,GAAG,CAAE,kBAAkB,EAAE,IAAI,CAACX,wBAAwB,CAAE;EACvF;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCD,MAAM,CAAEa,UAAU,EAAG;IACpB,IAAK,CAAC,IAAI,CAACpB,QAAQ,IAAIoB,UAAU,EAAG;MACnC,IAAI,CAACd,MAAM,GAAG,IAAI;MAClB,IAAI,CAACP,IAAI,GAAG,CAAC;IACd;EACD;AACD"},"metadata":{},"sourceType":"module"}