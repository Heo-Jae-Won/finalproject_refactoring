{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\n\n/**\n * @module widget/verticalnavigationhandler\n */\n\n/**\n * Returns 'keydown' handler for up/down arrow keys that modifies the caret movement if it's in a text line next to an object.\n *\n * @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n * @returns {Function}\n */\nexport default function verticalNavigationHandler(editing) {\n  const model = editing.model;\n  return (evt, data) => {\n    const arrowUpPressed = data.keyCode == keyCodes.arrowup;\n    const arrowDownPressed = data.keyCode == keyCodes.arrowdown;\n    const expandSelection = data.shiftKey;\n    const selection = model.document.selection;\n    if (!arrowUpPressed && !arrowDownPressed) {\n      return;\n    }\n    const isForward = arrowDownPressed;\n\n    // Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n    // Selection for sure will not approach any object.\n    if (expandSelection && selectionWillShrink(selection, isForward)) {\n      return;\n    }\n\n    // Find a range between selection and closest limit element.\n    const range = findTextRangeFromSelection(editing, selection, isForward);\n\n    // There is no selection position inside the limit element.\n    if (!range) {\n      return;\n    }\n\n    // If already at the edge of a limit element.\n    if (range.isCollapsed) {\n      // A collapsed selection at limit edge - nothing more to do.\n      if (selection.isCollapsed) {\n        return;\n      }\n\n      // A non collapsed selection is at the limit edge while expanding the selection - let others do their stuff.\n      else if (expandSelection) {\n        return;\n      }\n    }\n\n    // If the range is a single line (there is no word wrapping) then move the selection to the position closest to the limit element.\n    //\n    // We can't move the selection directly to the isObject element (eg. table cell) because of dual position at the end/beginning\n    // of wrapped line (it's at the same time at the end of one line and at the start of the next line).\n    if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {\n      model.change(writer => {\n        const newPosition = isForward ? range.end : range.start;\n        if (expandSelection) {\n          const newSelection = model.createSelection(selection.anchor);\n          newSelection.setFocus(newPosition);\n          writer.setSelection(newSelection);\n        } else {\n          writer.setSelection(newPosition);\n        }\n      });\n      evt.stop();\n      data.preventDefault();\n      data.stopPropagation();\n    }\n  };\n}\n\n// Finds the range between selection and closest limit element (in the direction of navigation).\n// The position next to limit element is adjusted to the closest allowed `$text` position.\n//\n// Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/selection~Selection} selection The current selection.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {module:engine/model/range~Range|null}\n//\nfunction findTextRangeFromSelection(editing, selection, isForward) {\n  const model = editing.model;\n  if (isForward) {\n    const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();\n    const endPosition = getNearestNonInlineLimit(model, startPosition, 'forward');\n\n    // There is no limit element, browser should handle this.\n    if (!endPosition) {\n      return null;\n    }\n    const range = model.createRange(startPosition, endPosition);\n    const lastRangePosition = getNearestTextPosition(model.schema, range, 'backward');\n    if (lastRangePosition) {\n      return model.createRange(startPosition, lastRangePosition);\n    }\n    return null;\n  } else {\n    const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();\n    const startPosition = getNearestNonInlineLimit(model, endPosition, 'backward');\n\n    // There is no limit element, browser should handle this.\n    if (!startPosition) {\n      return null;\n    }\n    const range = model.createRange(startPosition, endPosition);\n    const firstRangePosition = getNearestTextPosition(model.schema, range, 'forward');\n    if (firstRangePosition) {\n      return model.createRange(firstRangePosition, endPosition);\n    }\n    return null;\n  }\n}\n\n// Finds the limit element position that is closest to startPosition.\n//\n// @param {module:engine/model/model~Model} model\n// @param {<module:engine/model/position~Position>} startPosition\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {<module:engine/model/position~Position>|null}\n//\nfunction getNearestNonInlineLimit(model, startPosition, direction) {\n  const schema = model.schema;\n  const range = model.createRangeIn(startPosition.root);\n  const walkerValueType = direction == 'forward' ? 'elementStart' : 'elementEnd';\n  for (const {\n    previousPosition,\n    item,\n    type\n  } of range.getWalker({\n    startPosition,\n    direction\n  })) {\n    if (schema.isLimit(item) && !schema.isInline(item)) {\n      return previousPosition;\n    }\n\n    // Stop looking for isLimit element if the next element is a block element (it is for sure not single line).\n    if (type == walkerValueType && schema.isBlock(item)) {\n      return null;\n    }\n  }\n  return null;\n}\n\n// Basing on the provided range, finds the first or last (depending on `direction`) position inside the range\n// that can contain `$text` (according to schema).\n//\n// @param {module:engine/model/schema~Schema} schema The schema.\n// @param {module:engine/model/range~Range} range The range to find the position in.\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {module:engine/model/position~Position|null} The nearest selection position.\n//\nfunction getNearestTextPosition(schema, range, direction) {\n  const position = direction == 'backward' ? range.end : range.start;\n  if (schema.checkChild(position, '$text')) {\n    return position;\n  }\n  for (const {\n    nextPosition\n  } of range.getWalker({\n    direction\n  })) {\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  }\n  return null;\n}\n\n// Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects\n// (verifying if they visually wrap content to the next line).\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/range~Range} modelRange The current table cell content range.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {Boolean}\n//\nfunction isSingleLineRange(editing, modelRange, isForward) {\n  const model = editing.model;\n  const domConverter = editing.view.domConverter;\n\n  // Wrapped lines contain exactly the same position at the end of current line\n  // and at the beginning of next line. That position's client rect is at the end\n  // of current line. In case of caret at first position of the last line that 'dual'\n  // position would be detected as it's not the last line.\n  if (isForward) {\n    const probe = model.createSelection(modelRange.start);\n    model.modifySelection(probe);\n\n    // If the new position is at the end of the container then we can't use this position\n    // because it would provide incorrect result for eg caption of image and selection\n    // just before end of it. Also in this case there is no \"dual\" position.\n    if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {\n      modelRange = model.createRange(probe.focus, modelRange.end);\n    }\n  }\n  const viewRange = editing.mapper.toViewRange(modelRange);\n  const domRange = domConverter.viewRangeToDom(viewRange);\n  const rects = Rect.getDomRangeRects(domRange);\n  let boundaryVerticalPosition;\n  for (const rect of rects) {\n    if (boundaryVerticalPosition === undefined) {\n      boundaryVerticalPosition = Math.round(rect.bottom);\n      continue;\n    }\n\n    // Let's check if this rect is in new line.\n    if (Math.round(rect.top) >= boundaryVerticalPosition) {\n      return false;\n    }\n    boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));\n  }\n  return true;\n}\nfunction selectionWillShrink(selection, isForward) {\n  return !selection.isCollapsed && selection.isBackward == isForward;\n}","map":{"version":3,"names":["keyCodes","Rect","verticalNavigationHandler","editing","model","evt","data","arrowUpPressed","keyCode","arrowup","arrowDownPressed","arrowdown","expandSelection","shiftKey","selection","document","isForward","selectionWillShrink","range","findTextRangeFromSelection","isCollapsed","isSingleLineRange","change","writer","newPosition","end","start","newSelection","createSelection","anchor","setFocus","setSelection","stop","preventDefault","stopPropagation","startPosition","focus","getLastPosition","endPosition","getNearestNonInlineLimit","createRange","lastRangePosition","getNearestTextPosition","schema","getFirstPosition","firstRangePosition","direction","createRangeIn","root","walkerValueType","previousPosition","item","type","getWalker","isLimit","isInline","isBlock","position","checkChild","nextPosition","modelRange","domConverter","view","probe","modifySelection","isAtEnd","isEqual","viewRange","mapper","toViewRange","domRange","viewRangeToDom","rects","getDomRangeRects","boundaryVerticalPosition","rect","undefined","Math","round","bottom","top","max","isBackward"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-widget/src/verticalnavigation.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\n\n/**\n * @module widget/verticalnavigationhandler\n */\n\n/**\n * Returns 'keydown' handler for up/down arrow keys that modifies the caret movement if it's in a text line next to an object.\n *\n * @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n * @returns {Function}\n */\nexport default function verticalNavigationHandler( editing ) {\n\tconst model = editing.model;\n\n\treturn ( evt, data ) => {\n\t\tconst arrowUpPressed = data.keyCode == keyCodes.arrowup;\n\t\tconst arrowDownPressed = data.keyCode == keyCodes.arrowdown;\n\t\tconst expandSelection = data.shiftKey;\n\t\tconst selection = model.document.selection;\n\n\t\tif ( !arrowUpPressed && !arrowDownPressed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isForward = arrowDownPressed;\n\n\t\t// Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n\t\t// Selection for sure will not approach any object.\n\t\tif ( expandSelection && selectionWillShrink( selection, isForward ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find a range between selection and closest limit element.\n\t\tconst range = findTextRangeFromSelection( editing, selection, isForward );\n\n\t\t// There is no selection position inside the limit element.\n\t\tif ( !range ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If already at the edge of a limit element.\n\t\tif ( range.isCollapsed ) {\n\t\t\t// A collapsed selection at limit edge - nothing more to do.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// A non collapsed selection is at the limit edge while expanding the selection - let others do their stuff.\n\t\t\telse if ( expandSelection ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the range is a single line (there is no word wrapping) then move the selection to the position closest to the limit element.\n\t\t//\n\t\t// We can't move the selection directly to the isObject element (eg. table cell) because of dual position at the end/beginning\n\t\t// of wrapped line (it's at the same time at the end of one line and at the start of the next line).\n\t\tif ( range.isCollapsed || isSingleLineRange( editing, range, isForward ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\tconst newPosition = isForward ? range.end : range.start;\n\n\t\t\t\tif ( expandSelection ) {\n\t\t\t\t\tconst newSelection = model.createSelection( selection.anchor );\n\t\t\t\t\tnewSelection.setFocus( newPosition );\n\n\t\t\t\t\twriter.setSelection( newSelection );\n\t\t\t\t} else {\n\t\t\t\t\twriter.setSelection( newPosition );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tevt.stop();\n\t\t\tdata.preventDefault();\n\t\t\tdata.stopPropagation();\n\t\t}\n\t};\n}\n\n// Finds the range between selection and closest limit element (in the direction of navigation).\n// The position next to limit element is adjusted to the closest allowed `$text` position.\n//\n// Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/selection~Selection} selection The current selection.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {module:engine/model/range~Range|null}\n//\nfunction findTextRangeFromSelection( editing, selection, isForward ) {\n\tconst model = editing.model;\n\n\tif ( isForward ) {\n\t\tconst startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();\n\t\tconst endPosition = getNearestNonInlineLimit( model, startPosition, 'forward' );\n\n\t\t// There is no limit element, browser should handle this.\n\t\tif ( !endPosition ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst range = model.createRange( startPosition, endPosition );\n\t\tconst lastRangePosition = getNearestTextPosition( model.schema, range, 'backward' );\n\n\t\tif ( lastRangePosition ) {\n\t\t\treturn model.createRange( startPosition, lastRangePosition );\n\t\t}\n\n\t\treturn null;\n\t} else {\n\t\tconst endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();\n\t\tconst startPosition = getNearestNonInlineLimit( model, endPosition, 'backward' );\n\n\t\t// There is no limit element, browser should handle this.\n\t\tif ( !startPosition ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst range = model.createRange( startPosition, endPosition );\n\t\tconst firstRangePosition = getNearestTextPosition( model.schema, range, 'forward' );\n\n\t\tif ( firstRangePosition ) {\n\t\t\treturn model.createRange( firstRangePosition, endPosition );\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Finds the limit element position that is closest to startPosition.\n//\n// @param {module:engine/model/model~Model} model\n// @param {<module:engine/model/position~Position>} startPosition\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {<module:engine/model/position~Position>|null}\n//\nfunction getNearestNonInlineLimit( model, startPosition, direction ) {\n\tconst schema = model.schema;\n\tconst range = model.createRangeIn( startPosition.root );\n\n\tconst walkerValueType = direction == 'forward' ? 'elementStart' : 'elementEnd';\n\n\tfor ( const { previousPosition, item, type } of range.getWalker( { startPosition, direction } ) ) {\n\t\tif ( schema.isLimit( item ) && !schema.isInline( item ) ) {\n\t\t\treturn previousPosition;\n\t\t}\n\n\t\t// Stop looking for isLimit element if the next element is a block element (it is for sure not single line).\n\t\tif ( type == walkerValueType && schema.isBlock( item ) ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Basing on the provided range, finds the first or last (depending on `direction`) position inside the range\n// that can contain `$text` (according to schema).\n//\n// @param {module:engine/model/schema~Schema} schema The schema.\n// @param {module:engine/model/range~Range} range The range to find the position in.\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {module:engine/model/position~Position|null} The nearest selection position.\n//\nfunction getNearestTextPosition( schema, range, direction ) {\n\tconst position = direction == 'backward' ? range.end : range.start;\n\n\tif ( schema.checkChild( position, '$text' ) ) {\n\t\treturn position;\n\t}\n\n\tfor ( const { nextPosition } of range.getWalker( { direction } ) ) {\n\t\tif ( schema.checkChild( nextPosition, '$text' ) ) {\n\t\t\treturn nextPosition;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects\n// (verifying if they visually wrap content to the next line).\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/range~Range} modelRange The current table cell content range.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {Boolean}\n//\nfunction isSingleLineRange( editing, modelRange, isForward ) {\n\tconst model = editing.model;\n\tconst domConverter = editing.view.domConverter;\n\n\t// Wrapped lines contain exactly the same position at the end of current line\n\t// and at the beginning of next line. That position's client rect is at the end\n\t// of current line. In case of caret at first position of the last line that 'dual'\n\t// position would be detected as it's not the last line.\n\tif ( isForward ) {\n\t\tconst probe = model.createSelection( modelRange.start );\n\n\t\tmodel.modifySelection( probe );\n\n\t\t// If the new position is at the end of the container then we can't use this position\n\t\t// because it would provide incorrect result for eg caption of image and selection\n\t\t// just before end of it. Also in this case there is no \"dual\" position.\n\t\tif ( !probe.focus.isAtEnd && !modelRange.start.isEqual( probe.focus ) ) {\n\t\t\tmodelRange = model.createRange( probe.focus, modelRange.end );\n\t\t}\n\t}\n\n\tconst viewRange = editing.mapper.toViewRange( modelRange );\n\tconst domRange = domConverter.viewRangeToDom( viewRange );\n\tconst rects = Rect.getDomRangeRects( domRange );\n\n\tlet boundaryVerticalPosition;\n\n\tfor ( const rect of rects ) {\n\t\tif ( boundaryVerticalPosition === undefined ) {\n\t\t\tboundaryVerticalPosition = Math.round( rect.bottom );\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Let's check if this rect is in new line.\n\t\tif ( Math.round( rect.top ) >= boundaryVerticalPosition ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboundaryVerticalPosition = Math.max( boundaryVerticalPosition, Math.round( rect.bottom ) );\n\t}\n\n\treturn true;\n}\n\nfunction selectionWillShrink( selection, isForward ) {\n\treturn !selection.isCollapsed && selection.isBackward == isForward;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,SAASA,QAAQ,QAAQ,wCAAwC;AACjE,OAAOC,IAAI,MAAM,wCAAwC;;AAEzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,yBAAyB,CAAEC,OAAO,EAAG;EAC5D,MAAMC,KAAK,GAAGD,OAAO,CAACC,KAAK;EAE3B,OAAO,CAAEC,GAAG,EAAEC,IAAI,KAAM;IACvB,MAAMC,cAAc,GAAGD,IAAI,CAACE,OAAO,IAAIR,QAAQ,CAACS,OAAO;IACvD,MAAMC,gBAAgB,GAAGJ,IAAI,CAACE,OAAO,IAAIR,QAAQ,CAACW,SAAS;IAC3D,MAAMC,eAAe,GAAGN,IAAI,CAACO,QAAQ;IACrC,MAAMC,SAAS,GAAGV,KAAK,CAACW,QAAQ,CAACD,SAAS;IAE1C,IAAK,CAACP,cAAc,IAAI,CAACG,gBAAgB,EAAG;MAC3C;IACD;IAEA,MAAMM,SAAS,GAAGN,gBAAgB;;IAElC;IACA;IACA,IAAKE,eAAe,IAAIK,mBAAmB,CAAEH,SAAS,EAAEE,SAAS,CAAE,EAAG;MACrE;IACD;;IAEA;IACA,MAAME,KAAK,GAAGC,0BAA0B,CAAEhB,OAAO,EAAEW,SAAS,EAAEE,SAAS,CAAE;;IAEzE;IACA,IAAK,CAACE,KAAK,EAAG;MACb;IACD;;IAEA;IACA,IAAKA,KAAK,CAACE,WAAW,EAAG;MACxB;MACA,IAAKN,SAAS,CAACM,WAAW,EAAG;QAC5B;MACD;;MAEA;MAAA,KACK,IAAKR,eAAe,EAAG;QAC3B;MACD;IACD;;IAEA;IACA;IACA;IACA;IACA,IAAKM,KAAK,CAACE,WAAW,IAAIC,iBAAiB,CAAElB,OAAO,EAAEe,KAAK,EAAEF,SAAS,CAAE,EAAG;MAC1EZ,KAAK,CAACkB,MAAM,CAAEC,MAAM,IAAI;QACvB,MAAMC,WAAW,GAAGR,SAAS,GAAGE,KAAK,CAACO,GAAG,GAAGP,KAAK,CAACQ,KAAK;QAEvD,IAAKd,eAAe,EAAG;UACtB,MAAMe,YAAY,GAAGvB,KAAK,CAACwB,eAAe,CAAEd,SAAS,CAACe,MAAM,CAAE;UAC9DF,YAAY,CAACG,QAAQ,CAAEN,WAAW,CAAE;UAEpCD,MAAM,CAACQ,YAAY,CAAEJ,YAAY,CAAE;QACpC,CAAC,MAAM;UACNJ,MAAM,CAACQ,YAAY,CAAEP,WAAW,CAAE;QACnC;MACD,CAAC,CAAE;MAEHnB,GAAG,CAAC2B,IAAI,EAAE;MACV1B,IAAI,CAAC2B,cAAc,EAAE;MACrB3B,IAAI,CAAC4B,eAAe,EAAE;IACvB;EACD,CAAC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASf,0BAA0B,CAAEhB,OAAO,EAAEW,SAAS,EAAEE,SAAS,EAAG;EACpE,MAAMZ,KAAK,GAAGD,OAAO,CAACC,KAAK;EAE3B,IAAKY,SAAS,EAAG;IAChB,MAAMmB,aAAa,GAAGrB,SAAS,CAACM,WAAW,GAAGN,SAAS,CAACsB,KAAK,GAAGtB,SAAS,CAACuB,eAAe,EAAE;IAC3F,MAAMC,WAAW,GAAGC,wBAAwB,CAAEnC,KAAK,EAAE+B,aAAa,EAAE,SAAS,CAAE;;IAE/E;IACA,IAAK,CAACG,WAAW,EAAG;MACnB,OAAO,IAAI;IACZ;IAEA,MAAMpB,KAAK,GAAGd,KAAK,CAACoC,WAAW,CAAEL,aAAa,EAAEG,WAAW,CAAE;IAC7D,MAAMG,iBAAiB,GAAGC,sBAAsB,CAAEtC,KAAK,CAACuC,MAAM,EAAEzB,KAAK,EAAE,UAAU,CAAE;IAEnF,IAAKuB,iBAAiB,EAAG;MACxB,OAAOrC,KAAK,CAACoC,WAAW,CAAEL,aAAa,EAAEM,iBAAiB,CAAE;IAC7D;IAEA,OAAO,IAAI;EACZ,CAAC,MAAM;IACN,MAAMH,WAAW,GAAGxB,SAAS,CAACM,WAAW,GAAGN,SAAS,CAACsB,KAAK,GAAGtB,SAAS,CAAC8B,gBAAgB,EAAE;IAC1F,MAAMT,aAAa,GAAGI,wBAAwB,CAAEnC,KAAK,EAAEkC,WAAW,EAAE,UAAU,CAAE;;IAEhF;IACA,IAAK,CAACH,aAAa,EAAG;MACrB,OAAO,IAAI;IACZ;IAEA,MAAMjB,KAAK,GAAGd,KAAK,CAACoC,WAAW,CAAEL,aAAa,EAAEG,WAAW,CAAE;IAC7D,MAAMO,kBAAkB,GAAGH,sBAAsB,CAAEtC,KAAK,CAACuC,MAAM,EAAEzB,KAAK,EAAE,SAAS,CAAE;IAEnF,IAAK2B,kBAAkB,EAAG;MACzB,OAAOzC,KAAK,CAACoC,WAAW,CAAEK,kBAAkB,EAAEP,WAAW,CAAE;IAC5D;IAEA,OAAO,IAAI;EACZ;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,wBAAwB,CAAEnC,KAAK,EAAE+B,aAAa,EAAEW,SAAS,EAAG;EACpE,MAAMH,MAAM,GAAGvC,KAAK,CAACuC,MAAM;EAC3B,MAAMzB,KAAK,GAAGd,KAAK,CAAC2C,aAAa,CAAEZ,aAAa,CAACa,IAAI,CAAE;EAEvD,MAAMC,eAAe,GAAGH,SAAS,IAAI,SAAS,GAAG,cAAc,GAAG,YAAY;EAE9E,KAAM,MAAM;IAAEI,gBAAgB;IAAEC,IAAI;IAAEC;EAAK,CAAC,IAAIlC,KAAK,CAACmC,SAAS,CAAE;IAAElB,aAAa;IAAEW;EAAU,CAAC,CAAE,EAAG;IACjG,IAAKH,MAAM,CAACW,OAAO,CAAEH,IAAI,CAAE,IAAI,CAACR,MAAM,CAACY,QAAQ,CAAEJ,IAAI,CAAE,EAAG;MACzD,OAAOD,gBAAgB;IACxB;;IAEA;IACA,IAAKE,IAAI,IAAIH,eAAe,IAAIN,MAAM,CAACa,OAAO,CAAEL,IAAI,CAAE,EAAG;MACxD,OAAO,IAAI;IACZ;EACD;EAEA,OAAO,IAAI;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAST,sBAAsB,CAAEC,MAAM,EAAEzB,KAAK,EAAE4B,SAAS,EAAG;EAC3D,MAAMW,QAAQ,GAAGX,SAAS,IAAI,UAAU,GAAG5B,KAAK,CAACO,GAAG,GAAGP,KAAK,CAACQ,KAAK;EAElE,IAAKiB,MAAM,CAACe,UAAU,CAAED,QAAQ,EAAE,OAAO,CAAE,EAAG;IAC7C,OAAOA,QAAQ;EAChB;EAEA,KAAM,MAAM;IAAEE;EAAa,CAAC,IAAIzC,KAAK,CAACmC,SAAS,CAAE;IAAEP;EAAU,CAAC,CAAE,EAAG;IAClE,IAAKH,MAAM,CAACe,UAAU,CAAEC,YAAY,EAAE,OAAO,CAAE,EAAG;MACjD,OAAOA,YAAY;IACpB;EACD;EAEA,OAAO,IAAI;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStC,iBAAiB,CAAElB,OAAO,EAAEyD,UAAU,EAAE5C,SAAS,EAAG;EAC5D,MAAMZ,KAAK,GAAGD,OAAO,CAACC,KAAK;EAC3B,MAAMyD,YAAY,GAAG1D,OAAO,CAAC2D,IAAI,CAACD,YAAY;;EAE9C;EACA;EACA;EACA;EACA,IAAK7C,SAAS,EAAG;IAChB,MAAM+C,KAAK,GAAG3D,KAAK,CAACwB,eAAe,CAAEgC,UAAU,CAAClC,KAAK,CAAE;IAEvDtB,KAAK,CAAC4D,eAAe,CAAED,KAAK,CAAE;;IAE9B;IACA;IACA;IACA,IAAK,CAACA,KAAK,CAAC3B,KAAK,CAAC6B,OAAO,IAAI,CAACL,UAAU,CAAClC,KAAK,CAACwC,OAAO,CAAEH,KAAK,CAAC3B,KAAK,CAAE,EAAG;MACvEwB,UAAU,GAAGxD,KAAK,CAACoC,WAAW,CAAEuB,KAAK,CAAC3B,KAAK,EAAEwB,UAAU,CAACnC,GAAG,CAAE;IAC9D;EACD;EAEA,MAAM0C,SAAS,GAAGhE,OAAO,CAACiE,MAAM,CAACC,WAAW,CAAET,UAAU,CAAE;EAC1D,MAAMU,QAAQ,GAAGT,YAAY,CAACU,cAAc,CAAEJ,SAAS,CAAE;EACzD,MAAMK,KAAK,GAAGvE,IAAI,CAACwE,gBAAgB,CAAEH,QAAQ,CAAE;EAE/C,IAAII,wBAAwB;EAE5B,KAAM,MAAMC,IAAI,IAAIH,KAAK,EAAG;IAC3B,IAAKE,wBAAwB,KAAKE,SAAS,EAAG;MAC7CF,wBAAwB,GAAGG,IAAI,CAACC,KAAK,CAAEH,IAAI,CAACI,MAAM,CAAE;MACpD;IACD;;IAEA;IACA,IAAKF,IAAI,CAACC,KAAK,CAAEH,IAAI,CAACK,GAAG,CAAE,IAAIN,wBAAwB,EAAG;MACzD,OAAO,KAAK;IACb;IAEAA,wBAAwB,GAAGG,IAAI,CAACI,GAAG,CAAEP,wBAAwB,EAAEG,IAAI,CAACC,KAAK,CAAEH,IAAI,CAACI,MAAM,CAAE,CAAE;EAC3F;EAEA,OAAO,IAAI;AACZ;AAEA,SAAS9D,mBAAmB,CAAEH,SAAS,EAAEE,SAAS,EAAG;EACpD,OAAO,CAACF,SAAS,CAACM,WAAW,IAAIN,SAAS,CAACoE,UAAU,IAAIlE,SAAS;AACnE"},"metadata":{},"sourceType":"module"}