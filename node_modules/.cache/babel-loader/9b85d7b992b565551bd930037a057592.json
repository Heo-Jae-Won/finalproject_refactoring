{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/emittermixin\n */\n/* eslint-disable new-cap */\nimport EventInfo from './eventinfo';\nimport uid from './uid';\nimport priorities from './priorities';\nimport insertToPriorityArray from './inserttopriorityarray';\n// To check if component is loaded more than once.\nimport './version';\nimport CKEditorError from './ckeditorerror';\nconst _listeningTo = Symbol('listeningTo');\nconst _emitterId = Symbol('emitterId');\nconst _delegations = Symbol('delegations');\n/**\n * Mixin that injects the {@link ~Emitter events API} into its host.\n *\n * Read more about the concept of emitters in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @mixin EmitterMixin\n * @implements module:utils/emittermixin~Emitter\n */\nexport default function EmitterMixin(base) {\n  class Mixin extends base {\n    on(event, callback, options) {\n      this.listenTo(this, event, callback, options);\n    }\n    once(event, callback, options) {\n      var _this = this;\n      let wasFired = false;\n      const onceCallback = function (event) {\n        // Ensure the callback is called only once even if the callback itself leads to re-firing the event\n        // (which would call the callback again).\n        if (!wasFired) {\n          wasFired = true;\n          // Go off() at the first call.\n          event.off();\n          // Go with the original callback.\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          callback.call(_this, event, ...args);\n        }\n      };\n      // Make a similar on() call, simply replacing the callback.\n      this.listenTo(this, event, onceCallback, options);\n    }\n    off(event, callback) {\n      this.stopListening(this, event, callback);\n    }\n    listenTo(emitter, event, callback) {\n      let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      let emitterInfo, eventCallbacks;\n      // _listeningTo contains a list of emitters that this object is listening to.\n      // This list has the following format:\n      //\n      // _listeningTo: {\n      //     emitterId: {\n      //         emitter: emitter,\n      //         callbacks: {\n      //             event1: [ callback1, callback2, ... ]\n      //             ....\n      //         }\n      //     },\n      //     ...\n      // }\n      if (!this[_listeningTo]) {\n        this[_listeningTo] = {};\n      }\n      const emitters = this[_listeningTo];\n      if (!_getEmitterId(emitter)) {\n        _setEmitterId(emitter);\n      }\n      const emitterId = _getEmitterId(emitter);\n      if (!(emitterInfo = emitters[emitterId])) {\n        emitterInfo = emitters[emitterId] = {\n          emitter,\n          callbacks: {}\n        };\n      }\n      if (!(eventCallbacks = emitterInfo.callbacks[event])) {\n        eventCallbacks = emitterInfo.callbacks[event] = [];\n      }\n      eventCallbacks.push(callback);\n      // Finally register the callback to the event.\n      addEventListener(this, emitter, event, callback, options);\n    }\n    stopListening(emitter, event, callback) {\n      const emitters = this[_listeningTo];\n      let emitterId = emitter && _getEmitterId(emitter);\n      const emitterInfo = emitters && emitterId ? emitters[emitterId] : undefined;\n      const eventCallbacks = emitterInfo && event ? emitterInfo.callbacks[event] : undefined;\n      // Stop if nothing has been listened.\n      if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {\n        return;\n      }\n      // All params provided. off() that single callback.\n      if (callback) {\n        removeEventListener(this, emitter, event, callback);\n        // We must remove callbacks as well in order to prevent memory leaks.\n        // See https://github.com/ckeditor/ckeditor5/pull/8480\n        const index = eventCallbacks.indexOf(callback);\n        if (index !== -1) {\n          if (eventCallbacks.length === 1) {\n            delete emitterInfo.callbacks[event];\n          } else {\n            removeEventListener(this, emitter, event, callback);\n          }\n        }\n      }\n      // Only `emitter` and `event` provided. off() all callbacks for that event.\n      else if (eventCallbacks) {\n        while (callback = eventCallbacks.pop()) {\n          removeEventListener(this, emitter, event, callback);\n        }\n        delete emitterInfo.callbacks[event];\n      }\n      // Only `emitter` provided. off() all events for that emitter.\n      else if (emitterInfo) {\n        for (event in emitterInfo.callbacks) {\n          this.stopListening(emitter, event);\n        }\n        delete emitters[emitterId];\n      }\n      // No params provided. off() all emitters.\n      else {\n        for (emitterId in emitters) {\n          this.stopListening(emitters[emitterId].emitter);\n        }\n        delete this[_listeningTo];\n      }\n    }\n    fire(eventOrInfo) {\n      try {\n        const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);\n        const event = eventInfo.name;\n        let callbacks = getCallbacksForEvent(this, event);\n        // Record that the event passed this emitter on its path.\n        eventInfo.path.push(this);\n        // Handle event listener callbacks first.\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        if (callbacks) {\n          // Arguments passed to each callback.\n          const callbackArgs = [eventInfo, ...args];\n          // Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks\n          // are added while processing other callbacks. Previous solution involved adding counters (unique ids) but\n          // failed if callbacks were added to the queue before currently processed callback.\n          // If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same\n          // event is currently processed. Then, `.fire()` at the end, would have to add all stored events.\n          callbacks = Array.from(callbacks);\n          for (let i = 0; i < callbacks.length; i++) {\n            callbacks[i].callback.apply(this, callbackArgs);\n            // Remove the callback from future requests if off() has been called.\n            if (eventInfo.off.called) {\n              // Remove the called mark for the next calls.\n              delete eventInfo.off.called;\n              this._removeEventListener(event, callbacks[i].callback);\n            }\n            // Do not execute next callbacks if stop() was called.\n            if (eventInfo.stop.called) {\n              break;\n            }\n          }\n        }\n        // Delegate event to other emitters if needed.\n        const delegations = this[_delegations];\n        if (delegations) {\n          const destinations = delegations.get(event);\n          const passAllDestinations = delegations.get('*');\n          if (destinations) {\n            fireDelegatedEvents(destinations, eventInfo, args);\n          }\n          if (passAllDestinations) {\n            fireDelegatedEvents(passAllDestinations, eventInfo, args);\n          }\n        }\n        return eventInfo.return;\n      } catch (err) {\n        // @if CK_DEBUG // throw err;\n        /* istanbul ignore next */\n        CKEditorError.rethrowUnexpectedError(err, this);\n      }\n    }\n    delegate() {\n      for (var _len3 = arguments.length, events = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        events[_key3] = arguments[_key3];\n      }\n      return {\n        to: (emitter, nameOrFunction) => {\n          if (!this[_delegations]) {\n            this[_delegations] = new Map();\n          }\n          // Originally there was a for..of loop which unfortunately caused an error in Babel that didn't allow\n          // build an application. See: https://github.com/ckeditor/ckeditor5-react/issues/40.\n          events.forEach(eventName => {\n            const destinations = this[_delegations].get(eventName);\n            if (!destinations) {\n              this[_delegations].set(eventName, new Map([[emitter, nameOrFunction]]));\n            } else {\n              destinations.set(emitter, nameOrFunction);\n            }\n          });\n        }\n      };\n    }\n    stopDelegating(event, emitter) {\n      if (!this[_delegations]) {\n        return;\n      }\n      if (!event) {\n        this[_delegations].clear();\n      } else if (!emitter) {\n        this[_delegations].delete(event);\n      } else {\n        const destinations = this[_delegations].get(event);\n        if (destinations) {\n          destinations.delete(emitter);\n        }\n      }\n    }\n    _addEventListener(event, callback, options) {\n      createEventNamespace(this, event);\n      const lists = getCallbacksListsForNamespace(this, event);\n      const priority = priorities.get(options.priority);\n      const callbackDefinition = {\n        callback,\n        priority\n      };\n      // Add the callback to all callbacks list.\n      for (const callbacks of lists) {\n        // Add the callback to the list in the right priority position.\n        insertToPriorityArray(callbacks, callbackDefinition);\n      }\n    }\n    _removeEventListener(event, callback) {\n      const lists = getCallbacksListsForNamespace(this, event);\n      for (const callbacks of lists) {\n        for (let i = 0; i < callbacks.length; i++) {\n          if (callbacks[i].callback == callback) {\n            // Remove the callback from the list (fixing the next index).\n            callbacks.splice(i, 1);\n            i--;\n          }\n        }\n      }\n    }\n  }\n  return Mixin;\n}\nexport const Emitter = EmitterMixin(Object);\n// Backward compatibility with `mix`\n['on', 'once', 'off', 'listenTo', 'stopListening', 'fire', 'delegate', 'stopDelegating', '_addEventListener', '_removeEventListener'].forEach(key => {\n  EmitterMixin[key] = Emitter.prototype[key];\n});\n/**\n * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.\n * If not, returns `null`.\n *\n * @internal\n * @protected\n * @param {module:utils/emittermixin~Emitter} listeningEmitter An emitter that listens.\n * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.\n * @returns {module:utils/emittermixin~Emitter|null}\n */\nexport function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {\n  const listeningTo = listeningEmitter[_listeningTo];\n  if (listeningTo && listeningTo[listenedToEmitterId]) {\n    return listeningTo[listenedToEmitterId].emitter;\n  }\n  return null;\n}\n/**\n * Sets emitter's unique id.\n *\n * **Note:** `_emitterId` can be set only once.\n *\n * @internal\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter for which id will be set.\n * @param {String} [id] Unique id to set. If not passed, random unique id will be set.\n */\nexport function _setEmitterId(emitter, id) {\n  if (!emitter[_emitterId]) {\n    emitter[_emitterId] = id || uid();\n  }\n}\n/**\n * Returns emitter's unique id.\n *\n * @internal\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter which id will be returned.\n * @returns {String|undefined}\n */\nexport function _getEmitterId(emitter) {\n  return emitter[_emitterId];\n}\n// Gets the internal `_events` property of the given object.\n// `_events` property store all lists with callbacks for registered event names.\n// If there were no events registered on the object, empty `_events` object is created.\nfunction getEvents(source) {\n  if (!source._events) {\n    Object.defineProperty(source, '_events', {\n      value: {}\n    });\n  }\n  return source._events;\n}\n// Creates event node for generic-specific events relation architecture.\nfunction makeEventNode() {\n  return {\n    callbacks: [],\n    childEvents: []\n  };\n}\n// Creates an architecture for generic-specific events relation.\n// If needed, creates all events for given eventName, i.e. if the first registered event\n// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.\n// It also copies callbacks from more generic events to more specific events when\n// specific events are created.\nfunction createEventNamespace(source, eventName) {\n  const events = getEvents(source);\n  // First, check if the event we want to add to the structure already exists.\n  if (events[eventName]) {\n    // If it exists, we don't have to do anything.\n    return;\n  }\n  // In other case, we have to create the structure for the event.\n  // Note, that we might need to create intermediate events too.\n  // I.e. if foo:bar:abc is being registered and we only have foo in the structure,\n  // we need to also register foo:bar.\n  // Currently processed event name.\n  let name = eventName;\n  // Name of the event that is a child event for currently processed event.\n  let childEventName = null;\n  // Array containing all newly created specific events.\n  const newEventNodes = [];\n  // While loop can't check for ':' index because we have to handle generic events too.\n  // In each loop, we truncate event name, going from the most specific name to the generic one.\n  // I.e. foo:bar:abc -> foo:bar -> foo.\n  while (name !== '') {\n    if (events[name]) {\n      // If the currently processed event name is already registered, we can be sure\n      // that it already has all the structure created, so we can break the loop here\n      // as no more events need to be registered.\n      break;\n    }\n    // If this event is not yet registered, create a new object for it.\n    events[name] = makeEventNode();\n    // Add it to the array with newly created events.\n    newEventNodes.push(events[name]);\n    // Add previously processed event name as a child of this event.\n    if (childEventName) {\n      events[name].childEvents.push(childEventName);\n    }\n    childEventName = name;\n    // If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.\n    name = name.substr(0, name.lastIndexOf(':'));\n  }\n  if (name !== '') {\n    // If name is not empty, we found an already registered event that was a parent of the\n    // event we wanted to register.\n    // Copy that event's callbacks to newly registered events.\n    for (const node of newEventNodes) {\n      node.callbacks = events[name].callbacks.slice();\n    }\n    // Add last newly created event to the already registered event.\n    events[name].childEvents.push(childEventName);\n  }\n}\n// Gets an array containing callbacks list for a given event and it's more specific events.\n// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will\n// return callback list of foo:bar and foo:bar:abc (but not foo).\nfunction getCallbacksListsForNamespace(source, eventName) {\n  const eventNode = getEvents(source)[eventName];\n  if (!eventNode) {\n    return [];\n  }\n  let callbacksLists = [eventNode.callbacks];\n  for (let i = 0; i < eventNode.childEvents.length; i++) {\n    const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);\n    callbacksLists = callbacksLists.concat(childCallbacksLists);\n  }\n  return callbacksLists;\n}\n// Get the list of callbacks for a given event, but only if there any callbacks have been registered.\n// If there are no callbacks registered for given event, it checks if this is a specific event and looks\n// for callbacks for it's more generic version.\nfunction getCallbacksForEvent(source, eventName) {\n  let event;\n  if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {\n    // There are no callbacks registered for specified eventName.\n    // But this could be a specific-type event that is in a namespace.\n    if (eventName.indexOf(':') > -1) {\n      // If the eventName is specific, try to find callback lists for more generic event.\n      return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(':')));\n    } else {\n      // If this is a top-level generic event, return null;\n      return null;\n    }\n  }\n  return event.callbacks;\n}\n// Fires delegated events for given map of destinations.\n//\n// @private\n// * @param {Map.<utils.Emitter>} destinations A map containing\n// `[ {@link module:utils/emittermixin~Emitter}, \"event name\" ]` pair destinations.\n// * @param {utils.EventInfo} eventInfo The original event info object.\n// * @param {Array.<*>} fireArgs Arguments the original event was fired with.\nfunction fireDelegatedEvents(destinations, eventInfo, fireArgs) {\n  for (let [emitter, name] of destinations) {\n    if (!name) {\n      name = eventInfo.name;\n    } else if (typeof name == 'function') {\n      name = name(eventInfo.name);\n    }\n    const delegatedInfo = new EventInfo(eventInfo.source, name);\n    delegatedInfo.path = [...eventInfo.path];\n    emitter.fire(delegatedInfo, ...fireArgs);\n  }\n}\n// Helper for registering event callback on the emitter.\nfunction addEventListener(listener, emitter, event, callback, options) {\n  if (emitter._addEventListener) {\n    emitter._addEventListener(event, callback, options);\n  } else {\n    // Allow listening on objects that do not implement Emitter interface.\n    // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n    listener._addEventListener.call(emitter, event, callback, options);\n  }\n}\n// Helper for removing event callback from the emitter.\nfunction removeEventListener(listener, emitter, event, callback) {\n  if (emitter._removeEventListener) {\n    emitter._removeEventListener(event, callback);\n  } else {\n    // Allow listening on objects that do not implement Emitter interface.\n    // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n    listener._removeEventListener.call(emitter, event, callback);\n  }\n}","map":{"version":3,"names":["EventInfo","uid","priorities","insertToPriorityArray","CKEditorError","_listeningTo","Symbol","_emitterId","_delegations","EmitterMixin","base","Mixin","on","event","callback","options","listenTo","once","wasFired","onceCallback","off","args","call","stopListening","emitter","emitterInfo","eventCallbacks","emitters","_getEmitterId","_setEmitterId","emitterId","callbacks","push","addEventListener","undefined","removeEventListener","index","indexOf","length","pop","fire","eventOrInfo","eventInfo","name","getCallbacksForEvent","path","callbackArgs","Array","from","i","apply","called","_removeEventListener","stop","delegations","destinations","get","passAllDestinations","fireDelegatedEvents","return","err","rethrowUnexpectedError","delegate","events","to","nameOrFunction","Map","forEach","eventName","set","stopDelegating","clear","delete","_addEventListener","createEventNamespace","lists","getCallbacksListsForNamespace","priority","callbackDefinition","splice","Emitter","Object","key","prototype","_getEmitterListenedTo","listeningEmitter","listenedToEmitterId","listeningTo","id","getEvents","source","_events","defineProperty","value","makeEventNode","childEvents","childEventName","newEventNodes","substr","lastIndexOf","node","slice","eventNode","callbacksLists","childCallbacksLists","concat","fireArgs","delegatedInfo","listener"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/emittermixin\n */\n/* eslint-disable new-cap */\nimport EventInfo from './eventinfo';\nimport uid from './uid';\nimport priorities from './priorities';\nimport insertToPriorityArray from './inserttopriorityarray';\n// To check if component is loaded more than once.\nimport './version';\nimport CKEditorError from './ckeditorerror';\nconst _listeningTo = Symbol('listeningTo');\nconst _emitterId = Symbol('emitterId');\nconst _delegations = Symbol('delegations');\n/**\n * Mixin that injects the {@link ~Emitter events API} into its host.\n *\n * Read more about the concept of emitters in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @mixin EmitterMixin\n * @implements module:utils/emittermixin~Emitter\n */\nexport default function EmitterMixin(base) {\n    class Mixin extends base {\n        on(event, callback, options) {\n            this.listenTo(this, event, callback, options);\n        }\n        once(event, callback, options) {\n            let wasFired = false;\n            const onceCallback = (event, ...args) => {\n                // Ensure the callback is called only once even if the callback itself leads to re-firing the event\n                // (which would call the callback again).\n                if (!wasFired) {\n                    wasFired = true;\n                    // Go off() at the first call.\n                    event.off();\n                    // Go with the original callback.\n                    callback.call(this, event, ...args);\n                }\n            };\n            // Make a similar on() call, simply replacing the callback.\n            this.listenTo(this, event, onceCallback, options);\n        }\n        off(event, callback) {\n            this.stopListening(this, event, callback);\n        }\n        listenTo(emitter, event, callback, options = {}) {\n            let emitterInfo, eventCallbacks;\n            // _listeningTo contains a list of emitters that this object is listening to.\n            // This list has the following format:\n            //\n            // _listeningTo: {\n            //     emitterId: {\n            //         emitter: emitter,\n            //         callbacks: {\n            //             event1: [ callback1, callback2, ... ]\n            //             ....\n            //         }\n            //     },\n            //     ...\n            // }\n            if (!this[_listeningTo]) {\n                this[_listeningTo] = {};\n            }\n            const emitters = this[_listeningTo];\n            if (!_getEmitterId(emitter)) {\n                _setEmitterId(emitter);\n            }\n            const emitterId = _getEmitterId(emitter);\n            if (!(emitterInfo = emitters[emitterId])) {\n                emitterInfo = emitters[emitterId] = {\n                    emitter,\n                    callbacks: {}\n                };\n            }\n            if (!(eventCallbacks = emitterInfo.callbacks[event])) {\n                eventCallbacks = emitterInfo.callbacks[event] = [];\n            }\n            eventCallbacks.push(callback);\n            // Finally register the callback to the event.\n            addEventListener(this, emitter, event, callback, options);\n        }\n        stopListening(emitter, event, callback) {\n            const emitters = this[_listeningTo];\n            let emitterId = emitter && _getEmitterId(emitter);\n            const emitterInfo = (emitters && emitterId) ? emitters[emitterId] : undefined;\n            const eventCallbacks = (emitterInfo && event) ? emitterInfo.callbacks[event] : undefined;\n            // Stop if nothing has been listened.\n            if (!emitters || (emitter && !emitterInfo) || (event && !eventCallbacks)) {\n                return;\n            }\n            // All params provided. off() that single callback.\n            if (callback) {\n                removeEventListener(this, emitter, event, callback);\n                // We must remove callbacks as well in order to prevent memory leaks.\n                // See https://github.com/ckeditor/ckeditor5/pull/8480\n                const index = eventCallbacks.indexOf(callback);\n                if (index !== -1) {\n                    if (eventCallbacks.length === 1) {\n                        delete emitterInfo.callbacks[event];\n                    }\n                    else {\n                        removeEventListener(this, emitter, event, callback);\n                    }\n                }\n            }\n            // Only `emitter` and `event` provided. off() all callbacks for that event.\n            else if (eventCallbacks) {\n                while ((callback = eventCallbacks.pop())) {\n                    removeEventListener(this, emitter, event, callback);\n                }\n                delete emitterInfo.callbacks[event];\n            }\n            // Only `emitter` provided. off() all events for that emitter.\n            else if (emitterInfo) {\n                for (event in emitterInfo.callbacks) {\n                    this.stopListening(emitter, event);\n                }\n                delete emitters[emitterId];\n            }\n            // No params provided. off() all emitters.\n            else {\n                for (emitterId in emitters) {\n                    this.stopListening(emitters[emitterId].emitter);\n                }\n                delete this[_listeningTo];\n            }\n        }\n        fire(eventOrInfo, ...args) {\n            try {\n                const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);\n                const event = eventInfo.name;\n                let callbacks = getCallbacksForEvent(this, event);\n                // Record that the event passed this emitter on its path.\n                eventInfo.path.push(this);\n                // Handle event listener callbacks first.\n                if (callbacks) {\n                    // Arguments passed to each callback.\n                    const callbackArgs = [eventInfo, ...args];\n                    // Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks\n                    // are added while processing other callbacks. Previous solution involved adding counters (unique ids) but\n                    // failed if callbacks were added to the queue before currently processed callback.\n                    // If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same\n                    // event is currently processed. Then, `.fire()` at the end, would have to add all stored events.\n                    callbacks = Array.from(callbacks);\n                    for (let i = 0; i < callbacks.length; i++) {\n                        callbacks[i].callback.apply(this, callbackArgs);\n                        // Remove the callback from future requests if off() has been called.\n                        if (eventInfo.off.called) {\n                            // Remove the called mark for the next calls.\n                            delete eventInfo.off.called;\n                            this._removeEventListener(event, callbacks[i].callback);\n                        }\n                        // Do not execute next callbacks if stop() was called.\n                        if (eventInfo.stop.called) {\n                            break;\n                        }\n                    }\n                }\n                // Delegate event to other emitters if needed.\n                const delegations = this[_delegations];\n                if (delegations) {\n                    const destinations = delegations.get(event);\n                    const passAllDestinations = delegations.get('*');\n                    if (destinations) {\n                        fireDelegatedEvents(destinations, eventInfo, args);\n                    }\n                    if (passAllDestinations) {\n                        fireDelegatedEvents(passAllDestinations, eventInfo, args);\n                    }\n                }\n                return eventInfo.return;\n            }\n            catch (err) {\n                // @if CK_DEBUG // throw err;\n                /* istanbul ignore next */\n                CKEditorError.rethrowUnexpectedError(err, this);\n            }\n        }\n        delegate(...events) {\n            return {\n                to: (emitter, nameOrFunction) => {\n                    if (!this[_delegations]) {\n                        this[_delegations] = new Map();\n                    }\n                    // Originally there was a for..of loop which unfortunately caused an error in Babel that didn't allow\n                    // build an application. See: https://github.com/ckeditor/ckeditor5-react/issues/40.\n                    events.forEach(eventName => {\n                        const destinations = this[_delegations].get(eventName);\n                        if (!destinations) {\n                            this[_delegations].set(eventName, new Map([[emitter, nameOrFunction]]));\n                        }\n                        else {\n                            destinations.set(emitter, nameOrFunction);\n                        }\n                    });\n                }\n            };\n        }\n        stopDelegating(event, emitter) {\n            if (!this[_delegations]) {\n                return;\n            }\n            if (!event) {\n                this[_delegations].clear();\n            }\n            else if (!emitter) {\n                this[_delegations].delete(event);\n            }\n            else {\n                const destinations = this[_delegations].get(event);\n                if (destinations) {\n                    destinations.delete(emitter);\n                }\n            }\n        }\n        _addEventListener(event, callback, options) {\n            createEventNamespace(this, event);\n            const lists = getCallbacksListsForNamespace(this, event);\n            const priority = priorities.get(options.priority);\n            const callbackDefinition = {\n                callback,\n                priority\n            };\n            // Add the callback to all callbacks list.\n            for (const callbacks of lists) {\n                // Add the callback to the list in the right priority position.\n                insertToPriorityArray(callbacks, callbackDefinition);\n            }\n        }\n        _removeEventListener(event, callback) {\n            const lists = getCallbacksListsForNamespace(this, event);\n            for (const callbacks of lists) {\n                for (let i = 0; i < callbacks.length; i++) {\n                    if (callbacks[i].callback == callback) {\n                        // Remove the callback from the list (fixing the next index).\n                        callbacks.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n        }\n    }\n    return Mixin;\n}\nexport const Emitter = EmitterMixin(Object);\n// Backward compatibility with `mix`\n([\n    'on', 'once', 'off', 'listenTo',\n    'stopListening', 'fire', 'delegate', 'stopDelegating',\n    '_addEventListener', '_removeEventListener'\n]).forEach(key => {\n    EmitterMixin[key] = Emitter.prototype[key];\n});\n/**\n * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.\n * If not, returns `null`.\n *\n * @internal\n * @protected\n * @param {module:utils/emittermixin~Emitter} listeningEmitter An emitter that listens.\n * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.\n * @returns {module:utils/emittermixin~Emitter|null}\n */\nexport function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {\n    const listeningTo = listeningEmitter[_listeningTo];\n    if (listeningTo && listeningTo[listenedToEmitterId]) {\n        return listeningTo[listenedToEmitterId].emitter;\n    }\n    return null;\n}\n/**\n * Sets emitter's unique id.\n *\n * **Note:** `_emitterId` can be set only once.\n *\n * @internal\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter for which id will be set.\n * @param {String} [id] Unique id to set. If not passed, random unique id will be set.\n */\nexport function _setEmitterId(emitter, id) {\n    if (!emitter[_emitterId]) {\n        emitter[_emitterId] = id || uid();\n    }\n}\n/**\n * Returns emitter's unique id.\n *\n * @internal\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter which id will be returned.\n * @returns {String|undefined}\n */\nexport function _getEmitterId(emitter) {\n    return emitter[_emitterId];\n}\n// Gets the internal `_events` property of the given object.\n// `_events` property store all lists with callbacks for registered event names.\n// If there were no events registered on the object, empty `_events` object is created.\nfunction getEvents(source) {\n    if (!source._events) {\n        Object.defineProperty(source, '_events', {\n            value: {}\n        });\n    }\n    return source._events;\n}\n// Creates event node for generic-specific events relation architecture.\nfunction makeEventNode() {\n    return {\n        callbacks: [],\n        childEvents: []\n    };\n}\n// Creates an architecture for generic-specific events relation.\n// If needed, creates all events for given eventName, i.e. if the first registered event\n// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.\n// It also copies callbacks from more generic events to more specific events when\n// specific events are created.\nfunction createEventNamespace(source, eventName) {\n    const events = getEvents(source);\n    // First, check if the event we want to add to the structure already exists.\n    if (events[eventName]) {\n        // If it exists, we don't have to do anything.\n        return;\n    }\n    // In other case, we have to create the structure for the event.\n    // Note, that we might need to create intermediate events too.\n    // I.e. if foo:bar:abc is being registered and we only have foo in the structure,\n    // we need to also register foo:bar.\n    // Currently processed event name.\n    let name = eventName;\n    // Name of the event that is a child event for currently processed event.\n    let childEventName = null;\n    // Array containing all newly created specific events.\n    const newEventNodes = [];\n    // While loop can't check for ':' index because we have to handle generic events too.\n    // In each loop, we truncate event name, going from the most specific name to the generic one.\n    // I.e. foo:bar:abc -> foo:bar -> foo.\n    while (name !== '') {\n        if (events[name]) {\n            // If the currently processed event name is already registered, we can be sure\n            // that it already has all the structure created, so we can break the loop here\n            // as no more events need to be registered.\n            break;\n        }\n        // If this event is not yet registered, create a new object for it.\n        events[name] = makeEventNode();\n        // Add it to the array with newly created events.\n        newEventNodes.push(events[name]);\n        // Add previously processed event name as a child of this event.\n        if (childEventName) {\n            events[name].childEvents.push(childEventName);\n        }\n        childEventName = name;\n        // If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.\n        name = name.substr(0, name.lastIndexOf(':'));\n    }\n    if (name !== '') {\n        // If name is not empty, we found an already registered event that was a parent of the\n        // event we wanted to register.\n        // Copy that event's callbacks to newly registered events.\n        for (const node of newEventNodes) {\n            node.callbacks = events[name].callbacks.slice();\n        }\n        // Add last newly created event to the already registered event.\n        events[name].childEvents.push(childEventName);\n    }\n}\n// Gets an array containing callbacks list for a given event and it's more specific events.\n// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will\n// return callback list of foo:bar and foo:bar:abc (but not foo).\nfunction getCallbacksListsForNamespace(source, eventName) {\n    const eventNode = getEvents(source)[eventName];\n    if (!eventNode) {\n        return [];\n    }\n    let callbacksLists = [eventNode.callbacks];\n    for (let i = 0; i < eventNode.childEvents.length; i++) {\n        const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);\n        callbacksLists = callbacksLists.concat(childCallbacksLists);\n    }\n    return callbacksLists;\n}\n// Get the list of callbacks for a given event, but only if there any callbacks have been registered.\n// If there are no callbacks registered for given event, it checks if this is a specific event and looks\n// for callbacks for it's more generic version.\nfunction getCallbacksForEvent(source, eventName) {\n    let event;\n    if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {\n        // There are no callbacks registered for specified eventName.\n        // But this could be a specific-type event that is in a namespace.\n        if (eventName.indexOf(':') > -1) {\n            // If the eventName is specific, try to find callback lists for more generic event.\n            return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(':')));\n        }\n        else {\n            // If this is a top-level generic event, return null;\n            return null;\n        }\n    }\n    return event.callbacks;\n}\n// Fires delegated events for given map of destinations.\n//\n// @private\n// * @param {Map.<utils.Emitter>} destinations A map containing\n// `[ {@link module:utils/emittermixin~Emitter}, \"event name\" ]` pair destinations.\n// * @param {utils.EventInfo} eventInfo The original event info object.\n// * @param {Array.<*>} fireArgs Arguments the original event was fired with.\nfunction fireDelegatedEvents(destinations, eventInfo, fireArgs) {\n    for (let [emitter, name] of destinations) {\n        if (!name) {\n            name = eventInfo.name;\n        }\n        else if (typeof name == 'function') {\n            name = name(eventInfo.name);\n        }\n        const delegatedInfo = new EventInfo(eventInfo.source, name);\n        delegatedInfo.path = [...eventInfo.path];\n        emitter.fire(delegatedInfo, ...fireArgs);\n    }\n}\n// Helper for registering event callback on the emitter.\nfunction addEventListener(listener, emitter, event, callback, options) {\n    if (emitter._addEventListener) {\n        emitter._addEventListener(event, callback, options);\n    }\n    else {\n        // Allow listening on objects that do not implement Emitter interface.\n        // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n        (listener._addEventListener).call(emitter, event, callback, options);\n    }\n}\n// Helper for removing event callback from the emitter.\nfunction removeEventListener(listener, emitter, event, callback) {\n    if (emitter._removeEventListener) {\n        emitter._removeEventListener(event, callback);\n    }\n    else {\n        // Allow listening on objects that do not implement Emitter interface.\n        // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n        listener._removeEventListener.call(emitter, event, callback);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}