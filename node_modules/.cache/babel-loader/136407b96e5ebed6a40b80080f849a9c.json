{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport MergeOperation from './mergeoperation';\nimport SplitOperation from './splitoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport Position from '../position';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nconst transformations = new Map();\n/**\n * @module engine/model/operation/transform\n */\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\nfunction setTransformation(OperationA, OperationB, transformationFunction) {\n  let aGroup = transformations.get(OperationA);\n  if (!aGroup) {\n    aGroup = new Map();\n    transformations.set(OperationA, aGroup);\n  }\n  aGroup.set(OperationB, transformationFunction);\n}\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\nfunction getTransformation(OperationA, OperationB) {\n  const aGroup = transformations.get(OperationA);\n  if (aGroup && aGroup.has(OperationB)) {\n    return aGroup.get(OperationB);\n  }\n  return noUpdateTransformation;\n}\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\nfunction noUpdateTransformation(a) {\n  return [a];\n}\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} [context] Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\nexport function transform(a, b) {\n  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const transformationFunction = getTransformation(a.constructor, b.constructor);\n  /* eslint-disable no-useless-catch */\n  try {\n    a = a.clone();\n    return transformationFunction(a, b, context);\n  } catch (e) {\n    // @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );\n    // @if CK_DEBUG // console.warn( 'Transformed operation', a );\n    // @if CK_DEBUG // console.warn( 'Operation transformed by', b );\n    // @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );\n    // @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );\n    // @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );\n    // @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );\n    // @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );\n    throw e;\n  }\n  /* eslint-enable no-useless-catch */\n}\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @param {Boolean} [options.forceWeakRemove] If set to `false`, remove operation will be always stronger than move operation,\n * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed\n * operations and the values are the original operations from the input (`operationsA` and `operationsB`).\n */\nexport function transformSets(operationsA, operationsB, options) {\n  // Create new arrays so the originally passed arguments are not changed.\n  // No need to clone operations, they are cloned as they are transformed.\n  operationsA = operationsA.slice();\n  operationsB = operationsB.slice();\n  const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);\n  contextFactory.setOriginalOperations(operationsA);\n  contextFactory.setOriginalOperations(operationsB);\n  const originalOperations = contextFactory.originalOperations;\n  // If one of sets is empty there is simply nothing to transform, so return sets as they are.\n  if (operationsA.length == 0 || operationsB.length == 0) {\n    return {\n      operationsA,\n      operationsB,\n      originalOperations\n    };\n  }\n  //\n  // Following is a description of transformation process:\n  //\n  // There are `operationsA` and `operationsB` to be transformed, both by both.\n  //\n  // So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n  //\n  // Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n  // the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n  // is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n  //\n  // However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n  // we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n  // All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n  //\n  // The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n  //\n  //          [the initial state]\n  //         [common for a1 and b1]\n  //\n  //                   *\n  //                  / \\\n  //                 /   \\\n  //               b1     a1\n  //               /       \\\n  //              /         \\\n  //             *           *\n  //            / \\         / \\\n  //           /   \\       /   \\\n  //         b2    a1'   b1'    a2\n  //         /       \\   /       \\\n  //        /         \\ /         \\\n  //       *           *           *\n  //        \\         / \\         /\n  //         \\       /   \\       /\n  //        a1''   b2'   a2'   b1''\n  //           \\   /       \\   /\n  //            \\ /         \\ /\n  //             *           *\n  //              \\         /\n  //               \\       /\n  //              a2''   b2''\n  //                 \\   /\n  //                  \\ /\n  //                   *\n  //\n  //           [the final state]\n  //\n  // The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n  // applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n  // transformed.\n  //\n  // Another thing to consider is that an operation during transformation can be broken into multiple operations.\n  // Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n  //\n  // In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n  // (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n  // by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n  // from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n  // by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n  // following `operationsA` (in our case it is just `a2`).\n  //\n  // Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n  // the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n  // be transformed by both of them.\n  //\n  //                       *\n  //                      / \\\n  //                     /   \\\n  //                    /     \\\n  //                  b1       a1\n  //                  /         \\\n  //                 /           \\\n  //                /             \\\n  //               *               *\n  //              / \\             / \\\n  //             /  a11'         /   \\\n  //            /     \\         /     \\\n  //          b2       *      b1'      a2\n  //          /       / \\     /         \\\n  //         /       /  a12' /           \\\n  //        /       /     \\ /             \\\n  //       *       b2'     *               *\n  //        \\     /       / \\             /\n  //       a11'' /     b21'' \\           /\n  //          \\ /       /     \\         /\n  //           *       *      a2'     b1''\n  //            \\     / \\       \\     /\n  //          a12'' b22''\\       \\   /\n  //              \\ /     \\       \\ /\n  //               *      a2''     *\n  //                \\       \\     /\n  //                 \\       \\  b21'''\n  //                  \\       \\ /\n  //                a2'''      *\n  //                    \\     /\n  //                     \\  b22'''\n  //                      \\ /\n  //                       *\n  //\n  // Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n  //\n  // Having all that on mind, here is an outline for the transformation process algorithm:\n  //\n  // 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n  //\n  // 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n  // All original `operationsA` are set to be transformed starting from the first operation `b`.\n  //\n  // 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n  // by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n  // with the transformation results.\n  //\n  // 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n  // original operation.\n  //\n  // 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n  // be transformed by.\n  //\n  // 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n  // unless the last operation `a` was transformed.\n  //\n  // The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n  // The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n  // to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n  // index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n  // operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n  // current `a` operation index to the next one.\n  //\n  // For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n  const nextTransformIndex = new WeakMap();\n  // For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n  for (const op of operationsA) {\n    nextTransformIndex.set(op, 0);\n  }\n  // Additional data that is used for some postprocessing after the main transformation process is done.\n  const data = {\n    nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,\n    nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,\n    originalOperationsACount: operationsA.length,\n    originalOperationsBCount: operationsB.length\n  };\n  // Index of currently transformed operation `a`.\n  let i = 0;\n  // While not all `operationsA` are transformed...\n  while (i < operationsA.length) {\n    // Get \"current\" operation `a`.\n    const opA = operationsA[i];\n    // For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n    const indexB = nextTransformIndex.get(opA);\n    // If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n    if (indexB == operationsB.length) {\n      i++;\n      continue;\n    }\n    const opB = operationsB[indexB];\n    // Transform `a` by `b` and `b` by `a`.\n    const newOpsA = transform(opA, opB, contextFactory.getContext(opA, opB, true));\n    const newOpsB = transform(opB, opA, contextFactory.getContext(opB, opA, false));\n    // As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n    // Update contextual information about operations.\n    contextFactory.updateRelation(opA, opB);\n    contextFactory.setOriginalOperations(newOpsA, opA);\n    contextFactory.setOriginalOperations(newOpsB, opB);\n    // For new `a` operations, update their index of the next operation `b` to transform them by.\n    //\n    // This is needed even if there was only one result (`a` was not broken) because that information is used\n    // at the beginning of this loop every time.\n    for (const newOpA of newOpsA) {\n      // Acknowledge, that operation `b` also might be broken into multiple operations.\n      //\n      // This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n      // spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n      // be transformed by the same operation (part of it) again.\n      nextTransformIndex.set(newOpA, indexB + newOpsB.length);\n    }\n    // Update `operationsA` and `operationsB` with the transformed versions.\n    operationsA.splice(i, 1, ...newOpsA);\n    operationsB.splice(indexB, 1, ...newOpsB);\n  }\n  if (options.padWithNoOps) {\n    // If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n    const brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n    const brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;\n    // Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n    // that the base versions are equalled.\n    //\n    // Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n    padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);\n    padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);\n  }\n  // Finally, update base versions of transformed operations.\n  updateBaseVersions(operationsA, data.nextBaseVersionB);\n  updateBaseVersions(operationsB, data.nextBaseVersionA);\n  return {\n    operationsA,\n    operationsB,\n    originalOperations\n  };\n}\n// Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\nclass ContextFactory {\n  // Creates `ContextFactory` instance.\n  //\n  // @param {module:engine/model/document~Document} document Document which the operations change.\n  // @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n  // better conflict resolution).\n  // @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n  // so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n  constructor(document, useRelations) {\n    let forceWeakRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // For each operation that is created during transformation process, we keep a reference to the original operation\n    // which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n    // gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n    // This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n    // gathered data through original operation reference.\n    this.originalOperations = new Map();\n    // `model.History` instance which information about undone operations will be taken from.\n    this._history = document.history;\n    // Whether additional context should be used.\n    this._useRelations = useRelations;\n    this._forceWeakRemove = !!forceWeakRemove;\n    // Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n    // to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n    // we keep relations between them.\n    this._relations = new Map();\n  }\n  // Sets \"original operation\" for given operations.\n  //\n  // During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n  // or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n  // so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n  //\n  // The original operation object will be used as such an universal linking id. Throughout the transformation process\n  // all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n  //\n  // If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n  // This should be used as an initialization step.\n  //\n  // If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n  // for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n  // `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n  //\n  // @param {Array.<module:engine/model/operation/operation~Operation>} operations\n  // @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n  setOriginalOperations(operations) {\n    let takeFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;\n    for (const operation of operations) {\n      this.originalOperations.set(operation, originalOperation || operation);\n    }\n  }\n  // Saves a relation between operations `opA` and `opB`.\n  //\n  // Relations are then later used to help solve conflicts when operations are transformed.\n  //\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n  updateRelation(opA, opB) {\n    // The use of relations is described in a bigger detail in transformation functions.\n    //\n    // In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n    // Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n    // position is before the other operation source position. This kind of information gives contextual information when\n    // transformation is used during undo. Similar checks are done for other pairs of operations.\n    //\n    if (opA instanceof MoveOperation) {\n      if (opB instanceof MergeOperation) {\n        if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {\n          this._setRelation(opA, opB, 'insertAtSource');\n        } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {\n          this._setRelation(opA, opB, 'insertBetween');\n        } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {\n          this._setRelation(opA, opB, 'moveTargetAfter');\n        }\n      } else if (opB instanceof MoveOperation) {\n        if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {\n          this._setRelation(opA, opB, 'insertBefore');\n        } else {\n          this._setRelation(opA, opB, 'insertAfter');\n        }\n      }\n    } else if (opA instanceof SplitOperation) {\n      if (opB instanceof MergeOperation) {\n        if (opA.splitPosition.isBefore(opB.sourcePosition)) {\n          this._setRelation(opA, opB, 'splitBefore');\n        }\n      } else if (opB instanceof MoveOperation) {\n        if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {\n          this._setRelation(opA, opB, 'splitBefore');\n        } else {\n          const range = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);\n          if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range.containsPosition(opA.splitPosition)) {\n            const howMany = range.end.offset - opA.splitPosition.offset;\n            const offset = opA.splitPosition.offset - range.start.offset;\n            this._setRelation(opA, opB, {\n              howMany,\n              offset\n            });\n          }\n        }\n      }\n    } else if (opA instanceof MergeOperation) {\n      if (opB instanceof MergeOperation) {\n        if (!opA.targetPosition.isEqual(opB.sourcePosition)) {\n          this._setRelation(opA, opB, 'mergeTargetNotMoved');\n        }\n        if (opA.sourcePosition.isEqual(opB.targetPosition)) {\n          this._setRelation(opA, opB, 'mergeSourceNotMoved');\n        }\n        if (opA.sourcePosition.isEqual(opB.sourcePosition)) {\n          this._setRelation(opA, opB, 'mergeSameElement');\n        }\n      } else if (opB instanceof SplitOperation) {\n        if (opA.sourcePosition.isEqual(opB.splitPosition)) {\n          this._setRelation(opA, opB, 'splitAtSource');\n        }\n      }\n    } else if (opA instanceof MarkerOperation) {\n      const markerRange = opA.newRange;\n      if (!markerRange) {\n        return;\n      }\n      if (opB instanceof MoveOperation) {\n        const movedRange = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);\n        const affectedLeft = movedRange.containsPosition(markerRange.start) || movedRange.start.isEqual(markerRange.start);\n        const affectedRight = movedRange.containsPosition(markerRange.end) || movedRange.end.isEqual(markerRange.end);\n        if ((affectedLeft || affectedRight) && !movedRange.containsRange(markerRange)) {\n          this._setRelation(opA, opB, {\n            side: affectedLeft ? 'left' : 'right',\n            path: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n          });\n        }\n      } else if (opB instanceof MergeOperation) {\n        const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);\n        const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);\n        const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);\n        const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);\n        if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {\n          this._setRelation(opA, opB, {\n            wasInLeftElement,\n            wasStartBeforeMergedElement,\n            wasEndBeforeMergedElement,\n            wasInRightElement\n          });\n        }\n      }\n    }\n  }\n  // Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n  //\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n  // @returns {module:engine/model/operation/transform~TransformationContext}\n  getContext(opA, opB, aIsStrong) {\n    return {\n      aIsStrong,\n      aWasUndone: this._wasUndone(opA),\n      bWasUndone: this._wasUndone(opB),\n      abRelation: this._useRelations ? this._getRelation(opA, opB) : null,\n      baRelation: this._useRelations ? this._getRelation(opB, opA) : null,\n      forceWeakRemove: this._forceWeakRemove\n    };\n  }\n  // Returns whether given operation `op` has already been undone.\n  //\n  // Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n  //\n  // @param {module:engine/model/operation/operation~Operation} op\n  // @returns {Boolean}\n  _wasUndone(op) {\n    // For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n    // operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n    // from which was undone. So get that original operation.\n    const originalOp = this.originalOperations.get(op);\n    // And check with the document if the original operation was undone.\n    return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);\n  }\n  // Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n  // was set earlier or `null` if there was no relation between those operations.\n  //\n  // This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n  //\n  // When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n  // undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n  // we look forward in the future and ask if in that future `opB` was undone.\n  //\n  // Relations is a backward process to `wasUndone()`.\n  //\n  // Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n  // operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n  // a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n  // between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n  // a better decision when resolving a conflict between two operations, because we know more about the context of\n  // those two operations.\n  //\n  // This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n  // back to search for a meaningful contextual information.\n  //\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n  // @returns {String|null}\n  _getRelation(opA, opB) {\n    // Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n    const origB = this.originalOperations.get(opB);\n    const undoneB = this._history.getUndoneOperation(origB);\n    // If `opB` is not undoing any operation, there is no relation.\n    if (!undoneB) {\n      return null;\n    }\n    const origA = this.originalOperations.get(opA);\n    const relationsA = this._relations.get(origA);\n    // Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n    if (relationsA) {\n      return relationsA.get(undoneB) || null;\n    }\n    return null;\n  }\n  // Helper function for `ContextFactory#updateRelations`.\n  //\n  // @private\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n  // @param {String} relation\n  _setRelation(opA, opB, relation) {\n    // As always, setting is for original operations, not the clones/transformed operations.\n    const origA = this.originalOperations.get(opA);\n    const origB = this.originalOperations.get(opB);\n    let relationsA = this._relations.get(origA);\n    if (!relationsA) {\n      relationsA = new Map();\n      this._relations.set(origA, relationsA);\n    }\n    relationsA.set(origB, relation);\n  }\n}\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\nfunction updateBaseVersions(operations, baseVersion) {\n  for (const operation of operations) {\n    operation.baseVersion = baseVersion++;\n  }\n}\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\nfunction padWithNoOps(operations, howMany) {\n  for (let i = 0; i < howMany; i++) {\n    operations.push(new NoOperation(0));\n  }\n}\n// -----------------------\nsetTransformation(AttributeOperation, AttributeOperation, (a, b, context) => {\n  // If operations in conflict, check if their ranges intersect and manage them properly.\n  //\n  // Operations can be in conflict only if:\n  //\n  // * their key is the same (they change the same attribute), and\n  // * they are in the same parent (operations for ranges [ 1 ] - [ 3 ] and [ 2, 0 ] - [ 2, 5 ] change different\n  // elements and can't be in conflict).\n  if (a.key === b.key && a.range.start.hasSameParentAs(b.range.start)) {\n    // First, we want to apply change to the part of a range that has not been changed by the other operation.\n    const operations = a.range.getDifference(b.range).map(range => {\n      return new AttributeOperation(range, a.key, a.oldValue, a.newValue, 0);\n    });\n    // Then we take care of the common part of ranges.\n    const common = a.range.getIntersection(b.range);\n    if (common) {\n      // If this operation is more important, we also want to apply change to the part of the\n      // original range that has already been changed by the other operation. Since that range\n      // got changed we also have to update `oldValue`.\n      if (context.aIsStrong) {\n        operations.push(new AttributeOperation(common, b.key, b.newValue, a.newValue, 0));\n      }\n    }\n    if (operations.length == 0) {\n      return [new NoOperation(0)];\n    }\n    return operations;\n  } else {\n    // If operations don't conflict, simply return an array containing just a clone of this operation.\n    return [a];\n  }\n});\nsetTransformation(AttributeOperation, InsertOperation, (a, b) => {\n  // Case 1:\n  //\n  // The attribute operation range includes the position where nodes were inserted.\n  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n  // the inserted nodes were elements and they should not receive attributes.\n  //\n  if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {\n    // If new nodes should not receive attributes, two separated ranges will be returned.\n    // Otherwise, one expanded range will be returned.\n    const range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);\n    const result = range.map(r => {\n      return new AttributeOperation(r, a.key, a.oldValue, a.newValue, a.baseVersion);\n    });\n    if (b.shouldReceiveAttributes) {\n      // `AttributeOperation#range` includes some newly inserted text.\n      // The operation should also change the attribute of that text. An example:\n      //\n      // Bold should be applied on the following range:\n      // <p>Fo[zb]ar</p>\n      //\n      // In meantime, new text is typed:\n      // <p>Fozxxbar</p>\n      //\n      // Bold should be applied also on the new text:\n      // <p>Fo[zxxb]ar</p>\n      // <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n      //\n      // There is a special case to consider here to consider.\n      //\n      // Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n      // have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n      //\n      // Attribute `highlight=\"yellow\"` should be applied on the following range:\n      // <p>Fo[zb]ar<p>\n      //\n      // In meantime, character `x` with `highlight=\"red\"` is typed:\n      // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n      //\n      // In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n      // because that would lead to an exception (`oldValue` is incorrect for `x`).\n      //\n      // We also cannot break the original range as this would mess up a scenario when there are multiple following\n      // insert operations, because then only the first inserted character is included in those ranges:\n      // <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n      //\n      // So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n      //\n      // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n      //\n      // But before that operation would be applied, we will add an additional attribute operation that will change\n      // attributes on the inserted nodes in a way which would make the original operation correct:\n      //\n      // <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n      // <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n      //\n      // Generate complementary attribute operation. Be sure to add it before the original operation.\n      const op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);\n      if (op) {\n        result.unshift(op);\n      }\n    }\n    // If nodes should not receive new attribute, we are done here.\n    return result;\n  }\n  // If insert operation is not expanding the attribute operation range, simply transform the range.\n  a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];\n  return [a];\n});\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\nfunction _getComplementaryAttributeOperations(insertOperation, key, newValue) {\n  const nodes = insertOperation.nodes;\n  // At the beginning we store the attribute value from the first node.\n  const insertValue = nodes.getNode(0).getAttribute(key);\n  if (insertValue == newValue) {\n    return null;\n  }\n  const range = new Range(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));\n  return new AttributeOperation(range, key, insertValue, newValue, 0);\n}\nsetTransformation(AttributeOperation, MergeOperation, (a, b) => {\n  const ranges = [];\n  // Case 1:\n  //\n  // Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n  // An additional attribute operation that will change the (re)moved element needs to be generated.\n  //\n  if (a.range.start.hasSameParentAs(b.deletionPosition)) {\n    if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {\n      ranges.push(Range._createFromPositionAndShift(b.graveyardPosition, 1));\n    }\n  }\n  const range = a.range._getTransformedByMergeOperation(b);\n  // Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n  if (!range.isCollapsed) {\n    ranges.push(range);\n  }\n  // Create `AttributeOperation`s out of the ranges.\n  return ranges.map(range => {\n    return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);\n  });\n});\nsetTransformation(AttributeOperation, MoveOperation, (a, b) => {\n  const ranges = _breakRangeByMoveOperation(a.range, b);\n  // Create `AttributeOperation`s out of the ranges.\n  return ranges.map(range => new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion));\n});\n// Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\nfunction _breakRangeByMoveOperation(range, moveOp) {\n  const moveRange = Range._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany);\n  // We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n  // transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n  let common = null;\n  let difference = [];\n  // Let's compare the ranges.\n  if (moveRange.containsRange(range, true)) {\n    // If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n    common = range;\n  } else if (range.start.hasSameParentAs(moveRange.start)) {\n    // If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n    // that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n    difference = range.getDifference(moveRange);\n    common = range.getIntersection(moveRange);\n  } else {\n    // In any other situation we assume that original range is different than move range, that is that move operation\n    // moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n    //\n    // Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n    // than `.getDifference` (we would get two ranges).\n    difference = [range];\n  }\n  const result = [];\n  // The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n  // we do it by hand.\n  for (let diff of difference) {\n    // First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n    // as the range is different than the moved range.\n    diff = diff._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany);\n    // Transform also `targetPosition`.\n    const targetPosition = moveOp.getMovedRangeStart();\n    // Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n    const spread = diff.start.hasSameParentAs(targetPosition);\n    // Transform by insertion of moved nodes.\n    const diffs = diff._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);\n    result.push(...diffs);\n  }\n  // Common part can be simply transformed by the move operation. This is because move operation will not target to\n  // that common part (the operation would have to target inside its own moved range).\n  if (common) {\n    result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);\n  }\n  return result;\n}\nsetTransformation(AttributeOperation, SplitOperation, (a, b) => {\n  // Case 1:\n  //\n  // Split node is the last node in `AttributeOperation#range`.\n  // `AttributeOperation#range` needs to be expanded to include the new (split) node.\n  //\n  // Attribute `type` to be changed to `numbered` but the `listItem` is split.\n  // <listItem type=\"bulleted\">foobar</listItem>\n  //\n  // After split:\n  // <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n  //\n  // After attribute change:\n  // <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n  //\n  if (a.range.end.isEqual(b.insertionPosition)) {\n    if (!b.graveyardPosition) {\n      a.range.end.offset++;\n    }\n    return [a];\n  }\n  // Case 2:\n  //\n  // Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n  // not going to make a flat range.\n  //\n  // Content with range-to-change and split position:\n  // <p>Fo[zb^a]r</p>\n  //\n  // After split:\n  // <p>Fozb</p><p>ar</p>\n  //\n  // Make two separate ranges containing all nodes to change:\n  // <p>Fo[zb]</p><p>[a]r</p>\n  //\n  if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {\n    const secondPart = a.clone();\n    secondPart.range = new Range(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));\n    a.range.end = b.splitPosition.clone();\n    a.range.end.stickiness = 'toPrevious';\n    return [a, secondPart];\n  }\n  // The default case.\n  //\n  a.range = a.range._getTransformedBySplitOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, AttributeOperation, (a, b) => {\n  const result = [a];\n  // Case 1:\n  //\n  // The attribute operation range includes the position where nodes were inserted.\n  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n  // the inserted nodes were elements and they should not receive attributes.\n  //\n  // This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n  // although this case is a little less complicated. In this case we simply need to change attributes of the\n  // inserted nodes and that's it.\n  //\n  if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {\n    const op = _getComplementaryAttributeOperations(a, b.key, b.newValue);\n    if (op) {\n      result.push(op);\n    }\n  }\n  // The default case is: do nothing.\n  // `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n  //\n  return result;\n});\nsetTransformation(InsertOperation, InsertOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n  // what will be the order of inserted nodes. However, there is no additional information to help in that\n  // decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n  //\n  // To achieve that, we will check if the operation is strong.\n  // If it is, it won't get transformed. If it is not, it will be moved.\n  //\n  if (a.position.isEqual(b.position) && context.aIsStrong) {\n    return [a];\n  }\n  // The default case.\n  //\n  a.position = a.position._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, MoveOperation, (a, b) => {\n  // The default case.\n  //\n  a.position = a.position._getTransformedByMoveOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, SplitOperation, (a, b) => {\n  // The default case.\n  //\n  a.position = a.position._getTransformedBySplitOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, MergeOperation, (a, b) => {\n  a.position = a.position._getTransformedByMergeOperation(b);\n  return [a];\n});\n// -----------------------\nsetTransformation(MarkerOperation, InsertOperation, (a, b) => {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];\n  }\n  if (a.newRange) {\n    a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];\n  }\n  return [a];\n});\nsetTransformation(MarkerOperation, MarkerOperation, (a, b, context) => {\n  if (a.name == b.name) {\n    if (context.aIsStrong) {\n      a.oldRange = b.newRange ? b.newRange.clone() : null;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n  return [a];\n});\nsetTransformation(MarkerOperation, MergeOperation, (a, b) => {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedByMergeOperation(b);\n  }\n  if (a.newRange) {\n    a.newRange = a.newRange._getTransformedByMergeOperation(b);\n  }\n  return [a];\n});\nsetTransformation(MarkerOperation, MoveOperation, (a, b, context) => {\n  if (a.oldRange) {\n    a.oldRange = Range._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));\n  }\n  if (a.newRange) {\n    if (context.abRelation) {\n      const aNewRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n      if (context.abRelation.side == 'left' && b.targetPosition.isEqual(a.newRange.start)) {\n        a.newRange.end = aNewRange.end;\n        a.newRange.start.path = context.abRelation.path;\n        return [a];\n      } else if (context.abRelation.side == 'right' && b.targetPosition.isEqual(a.newRange.end)) {\n        a.newRange.start = aNewRange.start;\n        a.newRange.end.path = context.abRelation.path;\n        return [a];\n      }\n    }\n    a.newRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n  }\n  return [a];\n});\nsetTransformation(MarkerOperation, SplitOperation, (a, b, context) => {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedBySplitOperation(b);\n  }\n  if (a.newRange) {\n    if (context.abRelation) {\n      const aNewRange = a.newRange._getTransformedBySplitOperation(b);\n      if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {\n        a.newRange.start = Position._createAt(b.insertionPosition);\n      } else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {\n        a.newRange.start = Position._createAt(b.moveTargetPosition);\n      }\n      if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {\n        a.newRange.end = Position._createAt(b.moveTargetPosition);\n      } else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {\n        a.newRange.end = Position._createAt(b.insertionPosition);\n      } else {\n        a.newRange.end = aNewRange.end;\n      }\n      return [a];\n    }\n    a.newRange = a.newRange._getTransformedBySplitOperation(b);\n  }\n  return [a];\n});\n// -----------------------\nsetTransformation(MergeOperation, InsertOperation, (a, b) => {\n  if (a.sourcePosition.hasSameParentAs(b.position)) {\n    a.howMany += b.howMany;\n  }\n  a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(MergeOperation, MergeOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Same merge operations.\n  //\n  // Both operations have same source and target positions. So the element already got merged and there is\n  // theoretically nothing to do.\n  //\n  if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {\n    // There are two ways that we can provide a do-nothing operation.\n    //\n    // First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n    //\n    // Second is a merge operation that has the source operation in the merged element - in the graveyard -\n    // same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n    // which is almost the same as NoOperation.\n    //\n    // This way the merge operation can be later transformed by split operation\n    // to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n    //\n    if (!context.bWasUndone) {\n      return [new NoOperation(0)];\n    } else {\n      const path = b.graveyardPosition.path.slice();\n      path.push(0);\n      a.sourcePosition = new Position(b.graveyardPosition.root, path);\n      a.howMany = 0;\n      return [a];\n    }\n  }\n  // Case 2:\n  //\n  // Same merge source position but different target position.\n  //\n  // This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n  // and the other person removed that paragraph and merged the same paragraph to something before:\n  //\n  // Client A:\n  // <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n  // <p>Foo</p><p>BarXyz</p>\n  //\n  // Client B:\n  // <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n  // <p>Foo</p><p>[]Xyz</p>\n  // <p>FooXyz</p>\n  //\n  // In this case we need to decide where finally \"Xyz\" will land:\n  //\n  // <p>FooXyz</p>               graveyard: <p>Bar</p>\n  // <p>Foo</p>                  graveyard: <p>BarXyz</p>\n  //\n  // Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n  // nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n  // end up in the graveyard (see above).\n  //\n  // If neither or both operations point to graveyard, then let `aIsStrong` decide.\n  //\n  if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != 'splitAtSource') {\n    const aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n    const bToGraveyard = b.targetPosition.root.rootName == '$graveyard';\n    // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n    const aIsWeak = aToGraveyard && !bToGraveyard;\n    // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n    const bIsWeak = bToGraveyard && !aToGraveyard;\n    // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;\n    if (forceMove) {\n      const sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);\n      const targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n      return [new MoveOperation(sourcePosition, a.howMany, targetPosition, 0)];\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n  // The default case.\n  //\n  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n  a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n  // Handle positions in graveyard.\n  // If graveyard positions are same and `a` operation is strong - do not transform.\n  if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n  }\n  return [a];\n});\nsetTransformation(MergeOperation, MoveOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // The element to merge got removed.\n  //\n  // Merge operation does support merging elements which are not siblings. So it would not be a problem\n  // from technical point of view. However, if the element was removed, the intention of the user deleting it\n  // was to have it all deleted, together with its children. From user experience point of view, moving back the\n  // removed nodes might be unexpected. This means that in this scenario we will block the merging.\n  //\n  // The exception of this rule would be if the remove operation was later undone.\n  //\n  const removedRange = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n  if (b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n    if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {\n      return [new NoOperation(0)];\n    }\n  }\n  // The default case.\n  //\n  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n  if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {\n    a.howMany -= b.howMany;\n  }\n  a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b);\n  // `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n  // be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n  // Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n  // This means that we won't transform graveyard position if it is equal to move operation target position.\n  if (!a.graveyardPosition.isEqual(b.targetPosition)) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n  }\n  return [a];\n});\nsetTransformation(MergeOperation, SplitOperation, (a, b, context) => {\n  if (b.graveyardPosition) {\n    // If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n    // transform `a.graveyardPosition` accordingly.\n    a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1);\n    // This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n    //\n    // So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n    // source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n    // means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n    //\n    // If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n    // `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n    // properties.\n    //\n    if (a.deletionPosition.isEqual(b.graveyardPosition)) {\n      a.howMany = b.howMany;\n    }\n  }\n  // Case 1:\n  //\n  // Merge operation moves nodes to the place where split happens.\n  // This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n  // paragraph and there is a merge (delete) at the beginning of the second paragraph:\n  //\n  // <p>Foo{}</p><p>[]Bar</p>.\n  //\n  // Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n  //\n  // State after split:\n  // <p>Foo</p><p></p><p>Bar</p>\n  //\n  // Now, `Bar` should be merged to the new paragraph:\n  // <p>Foo</p><p>Bar</p>\n  //\n  // Instead of merging it to the original paragraph:\n  // <p>FooBar</p><p></p>\n  //\n  // This means that `targetPosition` needs to be transformed. This is the default case though.\n  // For example, if the split would be after `F`, `targetPosition` should also be transformed.\n  //\n  // There are three exceptions, though, when we want to keep `targetPosition` as it was.\n  //\n  // First exception is when the merge target position is inside an element (not at the end, as usual). This\n  // happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n  // targets inside the element we want to keep the original target position (and not transform it) because\n  // we have additional context telling us that we want to merge to the original element. We can check if the\n  // merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n  // is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n  //\n  // Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n  // if target position would be transformed, the merge operation would target at the source position:\n  //\n  // root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n  //\n  // SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n  // MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n  //\n  // Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n  // We would like to merge from the empty <p> to the \"Foo\" <p>:\n  //\n  // root: <p>Foo</p><p></p>\t\t\tgraveyard:\n  //\n  // MergeOperation#sourcePosition = root [ 1, 0 ]\n  //\n  // If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n  //\n  // Third exception is connected with relations. If this happens during undo and we have explicit information\n  // that target position has not been affected by the operation which is undone by this split then this split should\n  // not move the target position either.\n  //\n  if (a.targetPosition.isEqual(b.splitPosition)) {\n    const mergeInside = b.howMany != 0;\n    const mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);\n    if (mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved') {\n      a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  }\n  // Case 2:\n  //\n  // Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n  // The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n  // split element) or should be move to the beginning of the new element.\n  //\n  if (a.sourcePosition.isEqual(b.splitPosition)) {\n    // Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n    // This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n    // In that case `a` operation source position should stay where it is.\n    if (context.abRelation == 'mergeSourceNotMoved') {\n      a.howMany = 0;\n      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n    // This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n    // See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n    // the special case is not applied.\n    //\n    // Now, the merge operation is transformed by the split which has undone that previous merge operation.\n    // So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n    //\n    if (context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0) {\n      a.sourcePosition = b.moveTargetPosition.clone();\n      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  }\n  // The default case.\n  //\n  if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {\n    a.howMany = b.splitPosition.offset;\n  }\n  a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n  return [a];\n});\n// -----------------------\nsetTransformation(MoveOperation, InsertOperation, (a, b) => {\n  const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n  const transformed = moveRange._getTransformedByInsertOperation(b, false)[0];\n  a.sourcePosition = transformed.start;\n  a.howMany = transformed.end.offset - transformed.start.offset;\n  // See `InsertOperation` x `MoveOperation` transformation for details on this case.\n  //\n  // In summary, both operations point to the same place, so the order of nodes needs to be decided.\n  // `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n  // between operations.\n  //\n  if (!a.targetPosition.isEqual(b.position)) {\n    a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n  }\n  return [a];\n});\nsetTransformation(MoveOperation, MoveOperation, (a, b, context) => {\n  //\n  // Setting and evaluating some variables that will be used in special cases and default algorithm.\n  //\n  // Create ranges from `MoveOperations` properties.\n  const rangeA = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n  const rangeB = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n  // Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n  // this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n  let aIsStrong = context.aIsStrong;\n  // This will be used to decide the order of nodes if both operations target at the same position.\n  // By default, use strong/weak operation mechanism.\n  let insertBefore = !context.aIsStrong;\n  // If the relation is set, then use it to decide nodes order.\n  if (context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter') {\n    insertBefore = true;\n  } else if (context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore') {\n    insertBefore = false;\n  }\n  // `a.targetPosition` could be affected by the `b` operation. We will transform it.\n  let newTargetPosition;\n  if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {\n    newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n  } else {\n    newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n  }\n  //\n  // Special case #1 + mirror.\n  //\n  // Special case when both move operations' target positions are inside nodes that are\n  // being moved by the other move operation. So in other words, we move ranges into inside of each other.\n  // This case can't be solved reasonably (on the other hand, it should not happen often).\n  if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {\n    // Instead of transforming operation, we return a reverse of the operation that we transform by.\n    // So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n    return [b.getReversed()];\n  }\n  //\n  // End of special case #1.\n  //\n  //\n  // Special case #2.\n  //\n  // Check if `b` operation targets inside `rangeA`.\n  const bTargetsToA = rangeA.containsPosition(b.targetPosition);\n  // If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n  // You might say that operation `b` is captured inside operation `a`.\n  if (bTargetsToA && rangeA.containsRange(rangeB, true)) {\n    // There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n    // we need to transform `a` operation anyway.\n    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  }\n  //\n  // Special case #2 mirror.\n  //\n  const aTargetsToB = rangeB.containsPosition(a.targetPosition);\n  if (aTargetsToB && rangeB.containsRange(rangeA, true)) {\n    // `a` operation is \"moved together\" with `b` operation.\n    // Here, just move `rangeA` \"inside\" `rangeB`.\n    rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  }\n  //\n  // End of special case #2.\n  //\n  //\n  // Special case #3 + mirror.\n  //\n  // `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n  // but not on the same tree level. In such case ranges have common part but we have to treat it\n  // differently, because in such case those ranges are not really conflicting and should be treated like\n  // two separate ranges. Also we have to discard two difference parts.\n  const aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());\n  if (aCompB == 'prefix' || aCompB == 'extension') {\n    // Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n    // Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n    // like a one difference part.\n    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  }\n  //\n  // End of special case #3.\n  //\n  //\n  // Default case - ranges are on the same level or are not connected with each other.\n  //\n  // Modifier for default case.\n  // Modifies `aIsStrong` flag in certain conditions.\n  //\n  // If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n  // to provide more expected results.\n  if (a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove) {\n    aIsStrong = true;\n  } else if (a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n    aIsStrong = false;\n  }\n  // Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n  // This will aggregate transformed ranges.\n  const ranges = [];\n  // Get the \"difference part\" of `a` operation source range.\n  // This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n  const difference = rangeA.getDifference(rangeB);\n  for (const range of difference) {\n    // Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n    range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);\n    range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany);\n    // If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n    const shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == 'same';\n    const newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);\n    ranges.push(...newRanges);\n  }\n  // Then, we have to manage the \"common part\" of both move ranges.\n  const common = rangeA.getIntersection(rangeB);\n  if (common !== null && aIsStrong) {\n    // Calculate the new position of that part of original range.\n    common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    // Take care of proper range order.\n    //\n    // Put `common` at appropriate place. Keep in mind that we are interested in original order.\n    // Basically there are only three cases: there is zero, one or two difference ranges.\n    //\n    // If there is zero difference ranges, just push `common` in the array.\n    if (ranges.length === 0) {\n      ranges.push(common);\n    }\n    // If there is one difference range, we need to check whether common part was before it or after it.\n    else if (ranges.length == 1) {\n      if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {\n        ranges.unshift(common);\n      } else {\n        ranges.push(common);\n      }\n    }\n    // If there are more ranges (which means two), put common part between them. This is the only scenario\n    // where there could be two difference ranges so we don't have to make any comparisons.\n    else {\n      ranges.splice(1, 0, common);\n    }\n  }\n  if (ranges.length === 0) {\n    // If there are no \"source ranges\", nothing should be changed.\n    // Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n    return [new NoOperation(a.baseVersion)];\n  }\n  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, SplitOperation, (a, b, context) => {\n  let newTargetPosition = a.targetPosition.clone();\n  // Do not transform if target position is same as split insertion position and this split comes from undo.\n  // This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n  // We need to make a decision how we will resolve such conflict and this is less harmful way.\n  if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter') {\n    newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n  }\n  // Case 1:\n  //\n  // Last element in the moved range got split.\n  //\n  // In this case the default range transformation will not work correctly as the element created by\n  // split operation would be outside the range. The range to move needs to be fixed manually.\n  //\n  const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n  if (moveRange.end.isEqual(b.insertionPosition)) {\n    // Do it only if this is a \"natural\" split, not a one that comes from undo.\n    // If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n    if (!b.graveyardPosition) {\n      a.howMany++;\n    }\n    a.targetPosition = newTargetPosition;\n    return [a];\n  }\n  // Case 2:\n  //\n  // Split happened between the moved nodes. In this case two ranges to move need to be generated.\n  //\n  // Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n  // <p>F[oz|ba]r</p><p>Xyz</p>\n  //\n  // After split:\n  // <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n  //\n  // Correct ranges:\n  // <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n  //\n  // After move:\n  // <p>F</p><p>r</p><p>Xyzozba</p>\n  //\n  if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {\n    let rightRange = new Range(b.splitPosition, moveRange.end);\n    rightRange = rightRange._getTransformedBySplitOperation(b);\n    const ranges = [new Range(moveRange.start, b.splitPosition), rightRange];\n    return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n  }\n  // Case 3:\n  //\n  // Move operation targets at the split position. We need to decide if the nodes should be inserted\n  // at the end of the split element or at the beginning of the new element.\n  //\n  if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == 'insertAtSource') {\n    newTargetPosition = b.moveTargetPosition;\n  }\n  // Case 4:\n  //\n  // Move operation targets just after the split element. We need to decide if the nodes should be inserted\n  // between two parts of split element, or after the new element.\n  //\n  // Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n  // <p>Foo|bar</p>^<p>baz</p>\n  // <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n  //\n  // If there is no contextual information between operations (for example, they come from collaborative\n  // editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n  // However, if the split is from undo, in the past, the moved content might be targeting between the\n  // split parts, meaning that was exactly user's intention:\n  //\n  // <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n  // <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n  // <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n  //\n  // In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n  // so we need to transform accordingly. We can detect this scenario thanks to relations.\n  //\n  if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == 'insertBetween') {\n    newTargetPosition = a.targetPosition;\n  }\n  // The default case.\n  //\n  const transformed = moveRange._getTransformedBySplitOperation(b);\n  const ranges = [transformed];\n  // Case 5:\n  //\n  // Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n  //\n  if (b.graveyardPosition) {\n    const movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);\n    if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {\n      ranges.push(Range._createFromPositionAndShift(b.insertionPosition, 1));\n    }\n  }\n  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, MergeOperation, (a, b, context) => {\n  const movedRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n  if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {\n    if (a.type == 'remove' && !context.forceWeakRemove) {\n      // Case 1:\n      //\n      // The element to remove got merged.\n      //\n      // Merge operation does support merging elements which are not siblings. So it would not be a problem\n      // from technical point of view. However, if the element was removed, the intention of the user\n      // deleting it was to have it all deleted. From user experience point of view, moving back the\n      // removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n      //\n      if (!context.aWasUndone) {\n        const results = [];\n        let gyMoveSource = b.graveyardPosition.clone();\n        let splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);\n        if (a.howMany > 1) {\n          results.push(new MoveOperation(a.sourcePosition, a.howMany - 1, a.targetPosition, 0));\n          gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n          splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n        }\n        const gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, a.targetPosition);\n        const gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);\n        const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n        splitNodesMoveTargetPath.push(0);\n        const splitNodesMoveTarget = new Position(gyMove.targetPosition.root, splitNodesMoveTargetPath);\n        splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);\n        const splitNodesMove = new MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);\n        results.push(gyMove);\n        results.push(splitNodesMove);\n        return results;\n      }\n    } else {\n      // Case 2:\n      //\n      // The element to move got merged and it was the only element to move.\n      // In this case just don't do anything, leave the node in the graveyard. Without special case\n      // it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n      //\n      if (a.howMany == 1) {\n        if (!context.bWasUndone) {\n          return [new NoOperation(0)];\n        } else {\n          a.sourcePosition = b.graveyardPosition.clone();\n          a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n          return [a];\n        }\n      }\n    }\n  }\n  // The default case.\n  //\n  const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n  const transformed = moveRange._getTransformedByMergeOperation(b);\n  a.sourcePosition = transformed.start;\n  a.howMany = transformed.end.offset - transformed.start.offset;\n  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n  return [a];\n});\n// -----------------------\nsetTransformation(RenameOperation, InsertOperation, (a, b) => {\n  a.position = a.position._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, MergeOperation, (a, b) => {\n  // Case 1:\n  //\n  // Element to rename got merged, so it was moved to `b.graveyardPosition`.\n  //\n  if (a.position.isEqual(b.deletionPosition)) {\n    a.position = b.graveyardPosition.clone();\n    a.position.stickiness = 'toNext';\n    return [a];\n  }\n  a.position = a.position._getTransformedByMergeOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, MoveOperation, (a, b) => {\n  a.position = a.position._getTransformedByMoveOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, RenameOperation, (a, b, context) => {\n  if (a.position.isEqual(b.position)) {\n    if (context.aIsStrong) {\n      a.oldName = b.newName;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n  return [a];\n});\nsetTransformation(RenameOperation, SplitOperation, (a, b) => {\n  // Case 1:\n  //\n  // The element to rename has been split. In this case, the new element should be also renamed.\n  //\n  // User decides to change the paragraph to a list item:\n  // <paragraph>Foobar</paragraph>\n  //\n  // However, in meantime, split happens:\n  // <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n  //\n  // As a result, rename both elements:\n  // <listItem>Foo</listItem><listItem>bar</listItem>\n  //\n  const renamePath = a.position.path;\n  const splitPath = b.splitPosition.getParentPath();\n  if (compareArrays(renamePath, splitPath) == 'same' && !b.graveyardPosition) {\n    const extraRename = new RenameOperation(a.position.getShiftedBy(1), a.oldName, a.newName, 0);\n    return [a, extraRename];\n  }\n  // The default case.\n  //\n  a.position = a.position._getTransformedBySplitOperation(b);\n  return [a];\n});\n// -----------------------\nsetTransformation(RootAttributeOperation, RootAttributeOperation, (a, b, context) => {\n  if (a.root === b.root && a.key === b.key) {\n    if (!context.aIsStrong || a.newValue === b.newValue) {\n      return [new NoOperation(0)];\n    } else {\n      a.oldValue = b.newValue;\n    }\n  }\n  return [a];\n});\n// -----------------------\nsetTransformation(SplitOperation, InsertOperation, (a, b) => {\n  // The default case.\n  //\n  if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {\n    a.howMany += b.howMany;\n  }\n  a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);\n  a.insertionPosition = a.insertionPosition._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(SplitOperation, MergeOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Split element got merged. If two different elements were merged, clients will have different content.\n  //\n  // Example. Merge at `{}`, split at `[]`:\n  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n  //\n  // On merge side it will look like this:\n  // <heading>FooB[]ar</heading>\n  // <heading>FooB</heading><heading>ar</heading>\n  //\n  // On split side it will look like this:\n  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n  // <heading>FooB</heading><paragraph>ar</paragraph>\n  //\n  // Clearly, the second element is different for both clients.\n  //\n  // We could use the removed merge element from graveyard as a split element but then clients would have a different\n  // model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n  //\n  // To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n  // in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n  // used for splitting. Example below.\n  //\n  // Original state:\n  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n  //\n  // Merge side client:\n  //\n  // After merge:\n  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n  //\n  // Extra split:\n  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n  //\n  // Use the \"cloned\" element from graveyard:\n  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n  //\n  // Split side client:\n  //\n  // After split:\n  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n  //\n  // After merge:\n  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n  //\n  // This special case scenario only applies if the original split operation clones the split element.\n  // If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n  // knows exactly which element it should use. So there would be no original problem with different contents.\n  //\n  // Additionally, the special case applies only if the merge wasn't already undone.\n  //\n  if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {\n    const splitPath = b.graveyardPosition.path.slice();\n    splitPath.push(0);\n    const splitPosition = new Position(b.graveyardPosition.root, splitPath);\n    const insertionPosition = SplitOperation.getInsertionPosition(new Position(b.graveyardPosition.root, splitPath));\n    const additionalSplit = new SplitOperation(splitPosition, 0, insertionPosition, null, 0);\n    a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    a.graveyardPosition = additionalSplit.insertionPosition.clone();\n    a.graveyardPosition.stickiness = 'toNext';\n    return [additionalSplit, a];\n  }\n  // The default case.\n  //\n  if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {\n    a.howMany--;\n  }\n  if (a.splitPosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n  a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  if (a.graveyardPosition) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n  }\n  return [a];\n});\nsetTransformation(SplitOperation, MoveOperation, (a, b, context) => {\n  const rangeToMove = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n  if (a.graveyardPosition) {\n    // Case 1:\n    //\n    // Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n    // is already moved to the correct position, we need to only move the nodes after the split position.\n    // This will be done by `MoveOperation` instead of `SplitOperation`.\n    //\n    const gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);\n    if (!context.bWasUndone && gyElementMoved) {\n      const sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);\n      const newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n      const newTargetPath = newParentPosition.path.slice();\n      newTargetPath.push(0);\n      const newTargetPosition = new Position(newParentPosition.root, newTargetPath);\n      const moveOp = new MoveOperation(sourcePosition, a.howMany, newTargetPosition, 0);\n      return [moveOp];\n    }\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n  }\n  // Case 2:\n  //\n  // Split is at a position where nodes were moved.\n  //\n  // This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n  // \"split operation point of view\".\n  //\n  const splitAtTarget = a.splitPosition.isEqual(b.targetPosition);\n  if (splitAtTarget && (context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore')) {\n    a.howMany += b.howMany;\n    a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    return [a];\n  }\n  if (splitAtTarget && context.abRelation && context.abRelation.howMany) {\n    const {\n      howMany,\n      offset\n    } = context.abRelation;\n    a.howMany += howMany;\n    a.splitPosition = a.splitPosition.getShiftedBy(offset);\n    return [a];\n  }\n  // Case 3:\n  //\n  // If the split position is inside the moved range, we need to shift the split position to a proper place.\n  // The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n  //\n  // Characters `bc` should be moved to the second paragraph while split position is between them:\n  // <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n  //\n  // After move, new split position is incorrect:\n  // <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n  //\n  // Correct split position:\n  // <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n  //\n  // After split:\n  // <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n  //\n  if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {\n    const howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);\n    a.howMany -= howManyRemoved;\n    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n      a.howMany += b.howMany;\n    }\n    a.splitPosition = b.sourcePosition.clone();\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    return [a];\n  }\n  // The default case.\n  // Don't change `howMany` if move operation does not really move anything.\n  //\n  if (!b.sourcePosition.isEqual(b.targetPosition)) {\n    if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {\n      a.howMany -= b.howMany;\n    }\n    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n      a.howMany += b.howMany;\n    }\n  }\n  // Change position stickiness to force a correct transformation.\n  a.splitPosition.stickiness = 'toNone';\n  a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);\n  a.splitPosition.stickiness = 'toNext';\n  if (a.graveyardPosition) {\n    a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);\n  } else {\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  }\n  return [a];\n});\nsetTransformation(SplitOperation, SplitOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Split at the same position.\n  //\n  // If there already was a split at the same position as in `a` operation, it means that the intention\n  // conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n  //\n  // However, there is a difference if these are new splits or splits created by undo. These have different\n  // intentions. Also splits moving back different elements from graveyard have different intentions. They\n  // are just different operations.\n  //\n  // So we cancel split operation only if it was really identical.\n  //\n  // Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n  // default transformation is incorrect too.\n  //\n  if (a.splitPosition.isEqual(b.splitPosition)) {\n    if (!a.graveyardPosition && !b.graveyardPosition) {\n      return [new NoOperation(0)];\n    }\n    if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n      return [new NoOperation(0)];\n    }\n    // Use context to know that the `a.splitPosition` should stay where it is.\n    // This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n    if (context.abRelation == 'splitBefore') {\n      // Since split is at the same position, there are no nodes left to split.\n      a.howMany = 0;\n      // Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n      // That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n      // It could happen if `context` is enabled in collaboration.\n      a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  }\n  // Case 2:\n  //\n  // Same node is using to split different elements. This happens in undo when previously same element was merged to\n  // two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n  //\n  // In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n  // split operations. This might not always be true but in the real cases that were experienced it was. After all,\n  // if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n  // should be same for both of those splits.\n  //\n  // Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n  //\n  if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n    const aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n    const bInGraveyard = b.splitPosition.root.rootName == '$graveyard';\n    // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n    const aIsWeak = aInGraveyard && !bInGraveyard;\n    // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n    const bIsWeak = bInGraveyard && !aInGraveyard;\n    // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;\n    if (forceMove) {\n      const result = [];\n      // First we need to move any nodes split by `b` back to where they were.\n      // Do it only if `b` actually moved something.\n      if (b.howMany) {\n        result.push(new MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));\n      }\n      // Then we need to move nodes from `a` split position to their new element.\n      // Do it only if `a` actually should move something.\n      if (a.howMany) {\n        result.push(new MoveOperation(a.splitPosition, a.howMany, a.moveTargetPosition, 0));\n      }\n      return result;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n  if (a.graveyardPosition) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n  }\n  // Case 3:\n  //\n  // Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n  // As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n  //\n  if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == 'splitBefore') {\n    a.howMany++;\n    return [a];\n  }\n  // Case 4:\n  //\n  // This is a mirror to the case 2. above.\n  //\n  if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == 'splitBefore') {\n    const newPositionPath = b.insertionPosition.path.slice();\n    newPositionPath.push(0);\n    const newPosition = new Position(b.insertionPosition.root, newPositionPath);\n    const moveOp = new MoveOperation(a.insertionPosition, 1, newPosition, 0);\n    return [a, moveOp];\n  }\n  // The default case.\n  //\n  if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {\n    a.howMany -= b.howMany;\n  }\n  a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);\n  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  return [a];\n});\n// Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\nfunction _moveTargetIntoMovedRange(a, b) {\n  return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;\n}\n// Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\nfunction _makeMoveOperationsFromRanges(ranges, targetPosition) {\n  // At this moment we have some ranges and a target position, to which those ranges should be moved.\n  // Order in `ranges` array is the go-to order of after transformation.\n  //\n  // We are almost done. We have `ranges` and `targetPosition` to make operations from.\n  // Unfortunately, those operations may affect each other. Precisely, first operation after move\n  // may affect source range and target position of second and third operation. Same with second\n  // operation affecting third.\n  //\n  // We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n  const operations = [];\n  // Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n  for (let i = 0; i < ranges.length; i++) {\n    // Create new operation out of a range and target position.\n    const range = ranges[i];\n    const op = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, 0);\n    operations.push(op);\n    // Transform other ranges by the generated operation.\n    for (let j = i + 1; j < ranges.length; j++) {\n      // All ranges in `ranges` array should be:\n      //\n      // * non-intersecting (these are part of original operation source range), and\n      // * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n      //\n      // This means that the transformation will be \"clean\" and always return one result.\n      ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];\n    }\n    targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);\n  }\n  return operations;\n}","map":{"version":3,"names":["InsertOperation","AttributeOperation","RenameOperation","MarkerOperation","MoveOperation","RootAttributeOperation","MergeOperation","SplitOperation","NoOperation","Range","Position","compareArrays","transformations","Map","setTransformation","OperationA","OperationB","transformationFunction","aGroup","get","set","getTransformation","has","noUpdateTransformation","a","transform","b","context","constructor","clone","e","transformSets","operationsA","operationsB","options","slice","contextFactory","ContextFactory","document","useRelations","forceWeakRemove","setOriginalOperations","originalOperations","length","nextTransformIndex","WeakMap","op","data","nextBaseVersionA","baseVersion","nextBaseVersionB","originalOperationsACount","originalOperationsBCount","i","opA","indexB","opB","newOpsA","getContext","newOpsB","updateRelation","newOpA","splice","padWithNoOps","brokenOperationsACount","brokenOperationsBCount","updateBaseVersions","_history","history","_useRelations","_forceWeakRemove","_relations","operations","takeFrom","originalOperation","operation","targetPosition","isEqual","sourcePosition","movedRange","containsPosition","_setRelation","deletionPosition","isAfter","isBefore","splitPosition","range","_createFromPositionAndShift","howMany","hasSameParentAs","end","offset","start","markerRange","newRange","affectedLeft","affectedRight","containsRange","side","path","wasInLeftElement","wasStartBeforeMergedElement","wasEndBeforeMergedElement","wasInRightElement","aIsStrong","aWasUndone","_wasUndone","bWasUndone","abRelation","_getRelation","baRelation","originalOp","wasUndone","isUndoneOperation","origB","undoneB","getUndoneOperation","origA","relationsA","relation","push","key","getDifference","map","oldValue","newValue","common","getIntersection","position","_getTransformedByInsertion","shouldReceiveAttributes","result","r","_getComplementaryAttributeOperations","unshift","insertOperation","nodes","insertValue","getNode","getAttribute","getShiftedBy","ranges","graveyardPosition","_getTransformedByMergeOperation","isCollapsed","_breakRangeByMoveOperation","moveOp","moveRange","difference","diff","_getTransformedByDeletion","getMovedRangeStart","spread","diffs","_getTransformedByMove","insertionPosition","secondPart","moveTargetPosition","_getCombined","stickiness","_getTransformedBySplitOperation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","oldRange","name","_createFromRanges","aNewRange","_createAt","root","aToGraveyard","rootName","bToGraveyard","aIsWeak","bIsWeak","forceMove","removedRange","type","mergeInside","mergeSplittingElement","transformed","rangeA","rangeB","insertBefore","newTargetPosition","_moveTargetIntoMovedRange","getReversed","bTargetsToA","_makeMoveOperationsFromRanges","aTargetsToB","aCompB","getParentPath","shouldSpread","newRanges","rightRange","movesGraveyardElement","results","gyMoveSource","splitNodesMoveSource","gyMoveTarget","gyMove","splitNodesMoveTargetPath","splitNodesMoveTarget","splitNodesMove","oldName","newName","renamePath","splitPath","extraRename","getInsertionPosition","additionalSplit","rangeToMove","gyElementMoved","newParentPosition","newTargetPath","splitAtTarget","howManyRemoved","aInGraveyard","bInGraveyard","newPositionPath","newPosition","j"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport MergeOperation from './mergeoperation';\nimport SplitOperation from './splitoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport Position from '../position';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nconst transformations = new Map();\n/**\n * @module engine/model/operation/transform\n */\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\nfunction setTransformation(OperationA, OperationB, transformationFunction) {\n    let aGroup = transformations.get(OperationA);\n    if (!aGroup) {\n        aGroup = new Map();\n        transformations.set(OperationA, aGroup);\n    }\n    aGroup.set(OperationB, transformationFunction);\n}\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\nfunction getTransformation(OperationA, OperationB) {\n    const aGroup = transformations.get(OperationA);\n    if (aGroup && aGroup.has(OperationB)) {\n        return aGroup.get(OperationB);\n    }\n    return noUpdateTransformation;\n}\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\nfunction noUpdateTransformation(a) {\n    return [a];\n}\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} [context] Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\nexport function transform(a, b, context = {}) {\n    const transformationFunction = getTransformation(a.constructor, b.constructor);\n    /* eslint-disable no-useless-catch */\n    try {\n        a = a.clone();\n        return transformationFunction(a, b, context);\n    }\n    catch (e) {\n        // @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );\n        // @if CK_DEBUG // console.warn( 'Transformed operation', a );\n        // @if CK_DEBUG // console.warn( 'Operation transformed by', b );\n        // @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );\n        // @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );\n        // @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );\n        // @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );\n        // @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );\n        throw e;\n    }\n    /* eslint-enable no-useless-catch */\n}\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @param {Boolean} [options.forceWeakRemove] If set to `false`, remove operation will be always stronger than move operation,\n * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed\n * operations and the values are the original operations from the input (`operationsA` and `operationsB`).\n */\nexport function transformSets(operationsA, operationsB, options) {\n    // Create new arrays so the originally passed arguments are not changed.\n    // No need to clone operations, they are cloned as they are transformed.\n    operationsA = operationsA.slice();\n    operationsB = operationsB.slice();\n    const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);\n    contextFactory.setOriginalOperations(operationsA);\n    contextFactory.setOriginalOperations(operationsB);\n    const originalOperations = contextFactory.originalOperations;\n    // If one of sets is empty there is simply nothing to transform, so return sets as they are.\n    if (operationsA.length == 0 || operationsB.length == 0) {\n        return { operationsA, operationsB, originalOperations };\n    }\n    //\n    // Following is a description of transformation process:\n    //\n    // There are `operationsA` and `operationsB` to be transformed, both by both.\n    //\n    // So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n    //\n    // Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n    // the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n    // is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n    //\n    // However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n    // we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n    // All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n    //\n    // The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n    //\n    //          [the initial state]\n    //         [common for a1 and b1]\n    //\n    //                   *\n    //                  / \\\n    //                 /   \\\n    //               b1     a1\n    //               /       \\\n    //              /         \\\n    //             *           *\n    //            / \\         / \\\n    //           /   \\       /   \\\n    //         b2    a1'   b1'    a2\n    //         /       \\   /       \\\n    //        /         \\ /         \\\n    //       *           *           *\n    //        \\         / \\         /\n    //         \\       /   \\       /\n    //        a1''   b2'   a2'   b1''\n    //           \\   /       \\   /\n    //            \\ /         \\ /\n    //             *           *\n    //              \\         /\n    //               \\       /\n    //              a2''   b2''\n    //                 \\   /\n    //                  \\ /\n    //                   *\n    //\n    //           [the final state]\n    //\n    // The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n    // applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n    // transformed.\n    //\n    // Another thing to consider is that an operation during transformation can be broken into multiple operations.\n    // Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n    //\n    // In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n    // (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n    // by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n    // from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n    // by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n    // following `operationsA` (in our case it is just `a2`).\n    //\n    // Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n    // the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n    // be transformed by both of them.\n    //\n    //                       *\n    //                      / \\\n    //                     /   \\\n    //                    /     \\\n    //                  b1       a1\n    //                  /         \\\n    //                 /           \\\n    //                /             \\\n    //               *               *\n    //              / \\             / \\\n    //             /  a11'         /   \\\n    //            /     \\         /     \\\n    //          b2       *      b1'      a2\n    //          /       / \\     /         \\\n    //         /       /  a12' /           \\\n    //        /       /     \\ /             \\\n    //       *       b2'     *               *\n    //        \\     /       / \\             /\n    //       a11'' /     b21'' \\           /\n    //          \\ /       /     \\         /\n    //           *       *      a2'     b1''\n    //            \\     / \\       \\     /\n    //          a12'' b22''\\       \\   /\n    //              \\ /     \\       \\ /\n    //               *      a2''     *\n    //                \\       \\     /\n    //                 \\       \\  b21'''\n    //                  \\       \\ /\n    //                a2'''      *\n    //                    \\     /\n    //                     \\  b22'''\n    //                      \\ /\n    //                       *\n    //\n    // Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n    //\n    // Having all that on mind, here is an outline for the transformation process algorithm:\n    //\n    // 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n    //\n    // 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n    // All original `operationsA` are set to be transformed starting from the first operation `b`.\n    //\n    // 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n    // by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n    // with the transformation results.\n    //\n    // 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n    // original operation.\n    //\n    // 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n    // be transformed by.\n    //\n    // 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n    // unless the last operation `a` was transformed.\n    //\n    // The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n    // The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n    // to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n    // index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n    // operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n    // current `a` operation index to the next one.\n    //\n    // For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n    const nextTransformIndex = new WeakMap();\n    // For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n    for (const op of operationsA) {\n        nextTransformIndex.set(op, 0);\n    }\n    // Additional data that is used for some postprocessing after the main transformation process is done.\n    const data = {\n        nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,\n        nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,\n        originalOperationsACount: operationsA.length,\n        originalOperationsBCount: operationsB.length\n    };\n    // Index of currently transformed operation `a`.\n    let i = 0;\n    // While not all `operationsA` are transformed...\n    while (i < operationsA.length) {\n        // Get \"current\" operation `a`.\n        const opA = operationsA[i];\n        // For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n        const indexB = nextTransformIndex.get(opA);\n        // If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n        if (indexB == operationsB.length) {\n            i++;\n            continue;\n        }\n        const opB = operationsB[indexB];\n        // Transform `a` by `b` and `b` by `a`.\n        const newOpsA = transform(opA, opB, contextFactory.getContext(opA, opB, true));\n        const newOpsB = transform(opB, opA, contextFactory.getContext(opB, opA, false));\n        // As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n        // Update contextual information about operations.\n        contextFactory.updateRelation(opA, opB);\n        contextFactory.setOriginalOperations(newOpsA, opA);\n        contextFactory.setOriginalOperations(newOpsB, opB);\n        // For new `a` operations, update their index of the next operation `b` to transform them by.\n        //\n        // This is needed even if there was only one result (`a` was not broken) because that information is used\n        // at the beginning of this loop every time.\n        for (const newOpA of newOpsA) {\n            // Acknowledge, that operation `b` also might be broken into multiple operations.\n            //\n            // This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n            // spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n            // be transformed by the same operation (part of it) again.\n            nextTransformIndex.set(newOpA, indexB + newOpsB.length);\n        }\n        // Update `operationsA` and `operationsB` with the transformed versions.\n        operationsA.splice(i, 1, ...newOpsA);\n        operationsB.splice(indexB, 1, ...newOpsB);\n    }\n    if (options.padWithNoOps) {\n        // If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n        const brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n        const brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;\n        // Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n        // that the base versions are equalled.\n        //\n        // Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n        padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);\n        padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);\n    }\n    // Finally, update base versions of transformed operations.\n    updateBaseVersions(operationsA, data.nextBaseVersionB);\n    updateBaseVersions(operationsB, data.nextBaseVersionA);\n    return { operationsA, operationsB, originalOperations };\n}\n// Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\nclass ContextFactory {\n    // Creates `ContextFactory` instance.\n    //\n    // @param {module:engine/model/document~Document} document Document which the operations change.\n    // @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n    // better conflict resolution).\n    // @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n    // so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n    constructor(document, useRelations, forceWeakRemove = false) {\n        // For each operation that is created during transformation process, we keep a reference to the original operation\n        // which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n        // gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n        // This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n        // gathered data through original operation reference.\n        this.originalOperations = new Map();\n        // `model.History` instance which information about undone operations will be taken from.\n        this._history = document.history;\n        // Whether additional context should be used.\n        this._useRelations = useRelations;\n        this._forceWeakRemove = !!forceWeakRemove;\n        // Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n        // to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n        // we keep relations between them.\n        this._relations = new Map();\n    }\n    // Sets \"original operation\" for given operations.\n    //\n    // During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n    // or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n    // so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n    //\n    // The original operation object will be used as such an universal linking id. Throughout the transformation process\n    // all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n    //\n    // If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n    // This should be used as an initialization step.\n    //\n    // If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n    // for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n    // `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n    //\n    // @param {Array.<module:engine/model/operation/operation~Operation>} operations\n    // @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n    setOriginalOperations(operations, takeFrom = null) {\n        const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;\n        for (const operation of operations) {\n            this.originalOperations.set(operation, originalOperation || operation);\n        }\n    }\n    // Saves a relation between operations `opA` and `opB`.\n    //\n    // Relations are then later used to help solve conflicts when operations are transformed.\n    //\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n    updateRelation(opA, opB) {\n        // The use of relations is described in a bigger detail in transformation functions.\n        //\n        // In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n        // Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n        // position is before the other operation source position. This kind of information gives contextual information when\n        // transformation is used during undo. Similar checks are done for other pairs of operations.\n        //\n        if (opA instanceof MoveOperation) {\n            if (opB instanceof MergeOperation) {\n                if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {\n                    this._setRelation(opA, opB, 'insertAtSource');\n                }\n                else if (opA.targetPosition.isEqual(opB.deletionPosition)) {\n                    this._setRelation(opA, opB, 'insertBetween');\n                }\n                else if (opA.targetPosition.isAfter(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'moveTargetAfter');\n                }\n            }\n            else if (opB instanceof MoveOperation) {\n                if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'insertBefore');\n                }\n                else {\n                    this._setRelation(opA, opB, 'insertAfter');\n                }\n            }\n        }\n        else if (opA instanceof SplitOperation) {\n            if (opB instanceof MergeOperation) {\n                if (opA.splitPosition.isBefore(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'splitBefore');\n                }\n            }\n            else if (opB instanceof MoveOperation) {\n                if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'splitBefore');\n                }\n                else {\n                    const range = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);\n                    if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range.containsPosition(opA.splitPosition)) {\n                        const howMany = range.end.offset - opA.splitPosition.offset;\n                        const offset = opA.splitPosition.offset - range.start.offset;\n                        this._setRelation(opA, opB, { howMany, offset });\n                    }\n                }\n            }\n        }\n        else if (opA instanceof MergeOperation) {\n            if (opB instanceof MergeOperation) {\n                if (!opA.targetPosition.isEqual(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'mergeTargetNotMoved');\n                }\n                if (opA.sourcePosition.isEqual(opB.targetPosition)) {\n                    this._setRelation(opA, opB, 'mergeSourceNotMoved');\n                }\n                if (opA.sourcePosition.isEqual(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'mergeSameElement');\n                }\n            }\n            else if (opB instanceof SplitOperation) {\n                if (opA.sourcePosition.isEqual(opB.splitPosition)) {\n                    this._setRelation(opA, opB, 'splitAtSource');\n                }\n            }\n        }\n        else if (opA instanceof MarkerOperation) {\n            const markerRange = opA.newRange;\n            if (!markerRange) {\n                return;\n            }\n            if (opB instanceof MoveOperation) {\n                const movedRange = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);\n                const affectedLeft = movedRange.containsPosition(markerRange.start) ||\n                    movedRange.start.isEqual(markerRange.start);\n                const affectedRight = movedRange.containsPosition(markerRange.end) ||\n                    movedRange.end.isEqual(markerRange.end);\n                if ((affectedLeft || affectedRight) && !movedRange.containsRange(markerRange)) {\n                    this._setRelation(opA, opB, {\n                        side: affectedLeft ? 'left' : 'right',\n                        path: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n                    });\n                }\n            }\n            else if (opB instanceof MergeOperation) {\n                const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);\n                const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);\n                const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);\n                const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);\n                if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {\n                    this._setRelation(opA, opB, {\n                        wasInLeftElement,\n                        wasStartBeforeMergedElement,\n                        wasEndBeforeMergedElement,\n                        wasInRightElement\n                    });\n                }\n            }\n        }\n    }\n    // Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n    //\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n    // @returns {module:engine/model/operation/transform~TransformationContext}\n    getContext(opA, opB, aIsStrong) {\n        return {\n            aIsStrong,\n            aWasUndone: this._wasUndone(opA),\n            bWasUndone: this._wasUndone(opB),\n            abRelation: this._useRelations ? this._getRelation(opA, opB) : null,\n            baRelation: this._useRelations ? this._getRelation(opB, opA) : null,\n            forceWeakRemove: this._forceWeakRemove\n        };\n    }\n    // Returns whether given operation `op` has already been undone.\n    //\n    // Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n    //\n    // @param {module:engine/model/operation/operation~Operation} op\n    // @returns {Boolean}\n    _wasUndone(op) {\n        // For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n        // operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n        // from which was undone. So get that original operation.\n        const originalOp = this.originalOperations.get(op);\n        // And check with the document if the original operation was undone.\n        return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);\n    }\n    // Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n    // was set earlier or `null` if there was no relation between those operations.\n    //\n    // This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n    //\n    // When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n    // undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n    // we look forward in the future and ask if in that future `opB` was undone.\n    //\n    // Relations is a backward process to `wasUndone()`.\n    //\n    // Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n    // operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n    // a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n    // between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n    // a better decision when resolving a conflict between two operations, because we know more about the context of\n    // those two operations.\n    //\n    // This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n    // back to search for a meaningful contextual information.\n    //\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n    // @returns {String|null}\n    _getRelation(opA, opB) {\n        // Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n        const origB = this.originalOperations.get(opB);\n        const undoneB = this._history.getUndoneOperation(origB);\n        // If `opB` is not undoing any operation, there is no relation.\n        if (!undoneB) {\n            return null;\n        }\n        const origA = this.originalOperations.get(opA);\n        const relationsA = this._relations.get(origA);\n        // Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n        if (relationsA) {\n            return relationsA.get(undoneB) || null;\n        }\n        return null;\n    }\n    // Helper function for `ContextFactory#updateRelations`.\n    //\n    // @private\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n    // @param {String} relation\n    _setRelation(opA, opB, relation) {\n        // As always, setting is for original operations, not the clones/transformed operations.\n        const origA = this.originalOperations.get(opA);\n        const origB = this.originalOperations.get(opB);\n        let relationsA = this._relations.get(origA);\n        if (!relationsA) {\n            relationsA = new Map();\n            this._relations.set(origA, relationsA);\n        }\n        relationsA.set(origB, relation);\n    }\n}\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\nfunction updateBaseVersions(operations, baseVersion) {\n    for (const operation of operations) {\n        operation.baseVersion = baseVersion++;\n    }\n}\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\nfunction padWithNoOps(operations, howMany) {\n    for (let i = 0; i < howMany; i++) {\n        operations.push(new NoOperation(0));\n    }\n}\n// -----------------------\nsetTransformation(AttributeOperation, AttributeOperation, (a, b, context) => {\n    // If operations in conflict, check if their ranges intersect and manage them properly.\n    //\n    // Operations can be in conflict only if:\n    //\n    // * their key is the same (they change the same attribute), and\n    // * they are in the same parent (operations for ranges [ 1 ] - [ 3 ] and [ 2, 0 ] - [ 2, 5 ] change different\n    // elements and can't be in conflict).\n    if (a.key === b.key && a.range.start.hasSameParentAs(b.range.start)) {\n        // First, we want to apply change to the part of a range that has not been changed by the other operation.\n        const operations = a.range.getDifference(b.range).map(range => {\n            return new AttributeOperation(range, a.key, a.oldValue, a.newValue, 0);\n        });\n        // Then we take care of the common part of ranges.\n        const common = a.range.getIntersection(b.range);\n        if (common) {\n            // If this operation is more important, we also want to apply change to the part of the\n            // original range that has already been changed by the other operation. Since that range\n            // got changed we also have to update `oldValue`.\n            if (context.aIsStrong) {\n                operations.push(new AttributeOperation(common, b.key, b.newValue, a.newValue, 0));\n            }\n        }\n        if (operations.length == 0) {\n            return [new NoOperation(0)];\n        }\n        return operations;\n    }\n    else {\n        // If operations don't conflict, simply return an array containing just a clone of this operation.\n        return [a];\n    }\n});\nsetTransformation(AttributeOperation, InsertOperation, (a, b) => {\n    // Case 1:\n    //\n    // The attribute operation range includes the position where nodes were inserted.\n    // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n    // the inserted nodes were elements and they should not receive attributes.\n    //\n    if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {\n        // If new nodes should not receive attributes, two separated ranges will be returned.\n        // Otherwise, one expanded range will be returned.\n        const range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);\n        const result = range.map(r => {\n            return new AttributeOperation(r, a.key, a.oldValue, a.newValue, a.baseVersion);\n        });\n        if (b.shouldReceiveAttributes) {\n            // `AttributeOperation#range` includes some newly inserted text.\n            // The operation should also change the attribute of that text. An example:\n            //\n            // Bold should be applied on the following range:\n            // <p>Fo[zb]ar</p>\n            //\n            // In meantime, new text is typed:\n            // <p>Fozxxbar</p>\n            //\n            // Bold should be applied also on the new text:\n            // <p>Fo[zxxb]ar</p>\n            // <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n            //\n            // There is a special case to consider here to consider.\n            //\n            // Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n            // have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n            //\n            // Attribute `highlight=\"yellow\"` should be applied on the following range:\n            // <p>Fo[zb]ar<p>\n            //\n            // In meantime, character `x` with `highlight=\"red\"` is typed:\n            // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n            //\n            // In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n            // because that would lead to an exception (`oldValue` is incorrect for `x`).\n            //\n            // We also cannot break the original range as this would mess up a scenario when there are multiple following\n            // insert operations, because then only the first inserted character is included in those ranges:\n            // <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n            //\n            // So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n            //\n            // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n            //\n            // But before that operation would be applied, we will add an additional attribute operation that will change\n            // attributes on the inserted nodes in a way which would make the original operation correct:\n            //\n            // <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n            // <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n            //\n            // Generate complementary attribute operation. Be sure to add it before the original operation.\n            const op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);\n            if (op) {\n                result.unshift(op);\n            }\n        }\n        // If nodes should not receive new attribute, we are done here.\n        return result;\n    }\n    // If insert operation is not expanding the attribute operation range, simply transform the range.\n    a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];\n    return [a];\n});\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\nfunction _getComplementaryAttributeOperations(insertOperation, key, newValue) {\n    const nodes = insertOperation.nodes;\n    // At the beginning we store the attribute value from the first node.\n    const insertValue = nodes.getNode(0).getAttribute(key);\n    if (insertValue == newValue) {\n        return null;\n    }\n    const range = new Range(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));\n    return new AttributeOperation(range, key, insertValue, newValue, 0);\n}\nsetTransformation(AttributeOperation, MergeOperation, (a, b) => {\n    const ranges = [];\n    // Case 1:\n    //\n    // Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n    // An additional attribute operation that will change the (re)moved element needs to be generated.\n    //\n    if (a.range.start.hasSameParentAs(b.deletionPosition)) {\n        if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {\n            ranges.push(Range._createFromPositionAndShift(b.graveyardPosition, 1));\n        }\n    }\n    const range = a.range._getTransformedByMergeOperation(b);\n    // Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n    if (!range.isCollapsed) {\n        ranges.push(range);\n    }\n    // Create `AttributeOperation`s out of the ranges.\n    return ranges.map(range => {\n        return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);\n    });\n});\nsetTransformation(AttributeOperation, MoveOperation, (a, b) => {\n    const ranges = _breakRangeByMoveOperation(a.range, b);\n    // Create `AttributeOperation`s out of the ranges.\n    return ranges.map(range => new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion));\n});\n// Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\nfunction _breakRangeByMoveOperation(range, moveOp) {\n    const moveRange = Range._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany);\n    // We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n    // transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n    let common = null;\n    let difference = [];\n    // Let's compare the ranges.\n    if (moveRange.containsRange(range, true)) {\n        // If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n        common = range;\n    }\n    else if (range.start.hasSameParentAs(moveRange.start)) {\n        // If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n        // that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n        difference = range.getDifference(moveRange);\n        common = range.getIntersection(moveRange);\n    }\n    else {\n        // In any other situation we assume that original range is different than move range, that is that move operation\n        // moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n        //\n        // Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n        // than `.getDifference` (we would get two ranges).\n        difference = [range];\n    }\n    const result = [];\n    // The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n    // we do it by hand.\n    for (let diff of difference) {\n        // First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n        // as the range is different than the moved range.\n        diff = diff._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany);\n        // Transform also `targetPosition`.\n        const targetPosition = moveOp.getMovedRangeStart();\n        // Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n        const spread = diff.start.hasSameParentAs(targetPosition);\n        // Transform by insertion of moved nodes.\n        const diffs = diff._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);\n        result.push(...diffs);\n    }\n    // Common part can be simply transformed by the move operation. This is because move operation will not target to\n    // that common part (the operation would have to target inside its own moved range).\n    if (common) {\n        result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);\n    }\n    return result;\n}\nsetTransformation(AttributeOperation, SplitOperation, (a, b) => {\n    // Case 1:\n    //\n    // Split node is the last node in `AttributeOperation#range`.\n    // `AttributeOperation#range` needs to be expanded to include the new (split) node.\n    //\n    // Attribute `type` to be changed to `numbered` but the `listItem` is split.\n    // <listItem type=\"bulleted\">foobar</listItem>\n    //\n    // After split:\n    // <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n    //\n    // After attribute change:\n    // <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n    //\n    if (a.range.end.isEqual(b.insertionPosition)) {\n        if (!b.graveyardPosition) {\n            a.range.end.offset++;\n        }\n        return [a];\n    }\n    // Case 2:\n    //\n    // Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n    // not going to make a flat range.\n    //\n    // Content with range-to-change and split position:\n    // <p>Fo[zb^a]r</p>\n    //\n    // After split:\n    // <p>Fozb</p><p>ar</p>\n    //\n    // Make two separate ranges containing all nodes to change:\n    // <p>Fo[zb]</p><p>[a]r</p>\n    //\n    if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {\n        const secondPart = a.clone();\n        secondPart.range = new Range(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));\n        a.range.end = b.splitPosition.clone();\n        a.range.end.stickiness = 'toPrevious';\n        return [a, secondPart];\n    }\n    // The default case.\n    //\n    a.range = a.range._getTransformedBySplitOperation(b);\n    return [a];\n});\nsetTransformation(InsertOperation, AttributeOperation, (a, b) => {\n    const result = [a];\n    // Case 1:\n    //\n    // The attribute operation range includes the position where nodes were inserted.\n    // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n    // the inserted nodes were elements and they should not receive attributes.\n    //\n    // This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n    // although this case is a little less complicated. In this case we simply need to change attributes of the\n    // inserted nodes and that's it.\n    //\n    if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {\n        const op = _getComplementaryAttributeOperations(a, b.key, b.newValue);\n        if (op) {\n            result.push(op);\n        }\n    }\n    // The default case is: do nothing.\n    // `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n    //\n    return result;\n});\nsetTransformation(InsertOperation, InsertOperation, (a, b, context) => {\n    // Case 1:\n    //\n    // Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n    // what will be the order of inserted nodes. However, there is no additional information to help in that\n    // decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n    //\n    // To achieve that, we will check if the operation is strong.\n    // If it is, it won't get transformed. If it is not, it will be moved.\n    //\n    if (a.position.isEqual(b.position) && context.aIsStrong) {\n        return [a];\n    }\n    // The default case.\n    //\n    a.position = a.position._getTransformedByInsertOperation(b);\n    return [a];\n});\nsetTransformation(InsertOperation, MoveOperation, (a, b) => {\n    // The default case.\n    //\n    a.position = a.position._getTransformedByMoveOperation(b);\n    return [a];\n});\nsetTransformation(InsertOperation, SplitOperation, (a, b) => {\n    // The default case.\n    //\n    a.position = a.position._getTransformedBySplitOperation(b);\n    return [a];\n});\nsetTransformation(InsertOperation, MergeOperation, (a, b) => {\n    a.position = a.position._getTransformedByMergeOperation(b);\n    return [a];\n});\n// -----------------------\nsetTransformation(MarkerOperation, InsertOperation, (a, b) => {\n    if (a.oldRange) {\n        a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];\n    }\n    if (a.newRange) {\n        a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];\n    }\n    return [a];\n});\nsetTransformation(MarkerOperation, MarkerOperation, (a, b, context) => {\n    if (a.name == b.name) {\n        if (context.aIsStrong) {\n            a.oldRange = b.newRange ? b.newRange.clone() : null;\n        }\n        else {\n            return [new NoOperation(0)];\n        }\n    }\n    return [a];\n});\nsetTransformation(MarkerOperation, MergeOperation, (a, b) => {\n    if (a.oldRange) {\n        a.oldRange = a.oldRange._getTransformedByMergeOperation(b);\n    }\n    if (a.newRange) {\n        a.newRange = a.newRange._getTransformedByMergeOperation(b);\n    }\n    return [a];\n});\nsetTransformation(MarkerOperation, MoveOperation, (a, b, context) => {\n    if (a.oldRange) {\n        a.oldRange = Range._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));\n    }\n    if (a.newRange) {\n        if (context.abRelation) {\n            const aNewRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n            if (context.abRelation.side == 'left' && b.targetPosition.isEqual(a.newRange.start)) {\n                a.newRange.end = aNewRange.end;\n                a.newRange.start.path = context.abRelation.path;\n                return [a];\n            }\n            else if (context.abRelation.side == 'right' && b.targetPosition.isEqual(a.newRange.end)) {\n                a.newRange.start = aNewRange.start;\n                a.newRange.end.path = context.abRelation.path;\n                return [a];\n            }\n        }\n        a.newRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n    }\n    return [a];\n});\nsetTransformation(MarkerOperation, SplitOperation, (a, b, context) => {\n    if (a.oldRange) {\n        a.oldRange = a.oldRange._getTransformedBySplitOperation(b);\n    }\n    if (a.newRange) {\n        if (context.abRelation) {\n            const aNewRange = a.newRange._getTransformedBySplitOperation(b);\n            if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {\n                a.newRange.start = Position._createAt(b.insertionPosition);\n            }\n            else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {\n                a.newRange.start = Position._createAt(b.moveTargetPosition);\n            }\n            if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {\n                a.newRange.end = Position._createAt(b.moveTargetPosition);\n            }\n            else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {\n                a.newRange.end = Position._createAt(b.insertionPosition);\n            }\n            else {\n                a.newRange.end = aNewRange.end;\n            }\n            return [a];\n        }\n        a.newRange = a.newRange._getTransformedBySplitOperation(b);\n    }\n    return [a];\n});\n// -----------------------\nsetTransformation(MergeOperation, InsertOperation, (a, b) => {\n    if (a.sourcePosition.hasSameParentAs(b.position)) {\n        a.howMany += b.howMany;\n    }\n    a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);\n    a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n    return [a];\n});\nsetTransformation(MergeOperation, MergeOperation, (a, b, context) => {\n    // Case 1:\n    //\n    // Same merge operations.\n    //\n    // Both operations have same source and target positions. So the element already got merged and there is\n    // theoretically nothing to do.\n    //\n    if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {\n        // There are two ways that we can provide a do-nothing operation.\n        //\n        // First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n        //\n        // Second is a merge operation that has the source operation in the merged element - in the graveyard -\n        // same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n        // which is almost the same as NoOperation.\n        //\n        // This way the merge operation can be later transformed by split operation\n        // to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n        //\n        if (!context.bWasUndone) {\n            return [new NoOperation(0)];\n        }\n        else {\n            const path = b.graveyardPosition.path.slice();\n            path.push(0);\n            a.sourcePosition = new Position(b.graveyardPosition.root, path);\n            a.howMany = 0;\n            return [a];\n        }\n    }\n    // Case 2:\n    //\n    // Same merge source position but different target position.\n    //\n    // This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n    // and the other person removed that paragraph and merged the same paragraph to something before:\n    //\n    // Client A:\n    // <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n    // <p>Foo</p><p>BarXyz</p>\n    //\n    // Client B:\n    // <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n    // <p>Foo</p><p>[]Xyz</p>\n    // <p>FooXyz</p>\n    //\n    // In this case we need to decide where finally \"Xyz\" will land:\n    //\n    // <p>FooXyz</p>               graveyard: <p>Bar</p>\n    // <p>Foo</p>                  graveyard: <p>BarXyz</p>\n    //\n    // Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n    // nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n    // end up in the graveyard (see above).\n    //\n    // If neither or both operations point to graveyard, then let `aIsStrong` decide.\n    //\n    if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) &&\n        !context.bWasUndone && context.abRelation != 'splitAtSource') {\n        const aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n        const bToGraveyard = b.targetPosition.root.rootName == '$graveyard';\n        // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n        const aIsWeak = aToGraveyard && !bToGraveyard;\n        // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n        const bIsWeak = bToGraveyard && !aToGraveyard;\n        // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n        const forceMove = bIsWeak || (!aIsWeak && context.aIsStrong);\n        if (forceMove) {\n            const sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);\n            const targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n            return [new MoveOperation(sourcePosition, a.howMany, targetPosition, 0)];\n        }\n        else {\n            return [new NoOperation(0)];\n        }\n    }\n    // The default case.\n    //\n    if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n        a.howMany += b.howMany;\n    }\n    a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);\n    a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n    // Handle positions in graveyard.\n    // If graveyard positions are same and `a` operation is strong - do not transform.\n    if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {\n        a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n    }\n    return [a];\n});\nsetTransformation(MergeOperation, MoveOperation, (a, b, context) => {\n    // Case 1:\n    //\n    // The element to merge got removed.\n    //\n    // Merge operation does support merging elements which are not siblings. So it would not be a problem\n    // from technical point of view. However, if the element was removed, the intention of the user deleting it\n    // was to have it all deleted, together with its children. From user experience point of view, moving back the\n    // removed nodes might be unexpected. This means that in this scenario we will block the merging.\n    //\n    // The exception of this rule would be if the remove operation was later undone.\n    //\n    const removedRange = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n    if (b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n        if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {\n            return [new NoOperation(0)];\n        }\n    }\n    // The default case.\n    //\n    if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n        a.howMany += b.howMany;\n    }\n    if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {\n        a.howMany -= b.howMany;\n    }\n    a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);\n    a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b);\n    // `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n    // be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n    // Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n    // This means that we won't transform graveyard position if it is equal to move operation target position.\n    if (!a.graveyardPosition.isEqual(b.targetPosition)) {\n        a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n    }\n    return [a];\n});\nsetTransformation(MergeOperation, SplitOperation, (a, b, context) => {\n    if (b.graveyardPosition) {\n        // If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n        // transform `a.graveyardPosition` accordingly.\n        a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1);\n        // This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n        //\n        // So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n        // source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n        // means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n        //\n        // If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n        // `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n        // properties.\n        //\n        if (a.deletionPosition.isEqual(b.graveyardPosition)) {\n            a.howMany = b.howMany;\n        }\n    }\n    // Case 1:\n    //\n    // Merge operation moves nodes to the place where split happens.\n    // This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n    // paragraph and there is a merge (delete) at the beginning of the second paragraph:\n    //\n    // <p>Foo{}</p><p>[]Bar</p>.\n    //\n    // Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n    //\n    // State after split:\n    // <p>Foo</p><p></p><p>Bar</p>\n    //\n    // Now, `Bar` should be merged to the new paragraph:\n    // <p>Foo</p><p>Bar</p>\n    //\n    // Instead of merging it to the original paragraph:\n    // <p>FooBar</p><p></p>\n    //\n    // This means that `targetPosition` needs to be transformed. This is the default case though.\n    // For example, if the split would be after `F`, `targetPosition` should also be transformed.\n    //\n    // There are three exceptions, though, when we want to keep `targetPosition` as it was.\n    //\n    // First exception is when the merge target position is inside an element (not at the end, as usual). This\n    // happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n    // targets inside the element we want to keep the original target position (and not transform it) because\n    // we have additional context telling us that we want to merge to the original element. We can check if the\n    // merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n    // is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n    //\n    // Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n    // if target position would be transformed, the merge operation would target at the source position:\n    //\n    // root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n    //\n    // SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n    // MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n    //\n    // Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n    // We would like to merge from the empty <p> to the \"Foo\" <p>:\n    //\n    // root: <p>Foo</p><p></p>\t\t\tgraveyard:\n    //\n    // MergeOperation#sourcePosition = root [ 1, 0 ]\n    //\n    // If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n    //\n    // Third exception is connected with relations. If this happens during undo and we have explicit information\n    // that target position has not been affected by the operation which is undone by this split then this split should\n    // not move the target position either.\n    //\n    if (a.targetPosition.isEqual(b.splitPosition)) {\n        const mergeInside = b.howMany != 0;\n        const mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);\n        if (mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved') {\n            a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n            return [a];\n        }\n    }\n    // Case 2:\n    //\n    // Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n    // The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n    // split element) or should be move to the beginning of the new element.\n    //\n    if (a.sourcePosition.isEqual(b.splitPosition)) {\n        // Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n        // This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n        // In that case `a` operation source position should stay where it is.\n        if (context.abRelation == 'mergeSourceNotMoved') {\n            a.howMany = 0;\n            a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n            return [a];\n        }\n        // This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n        // See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n        // the special case is not applied.\n        //\n        // Now, the merge operation is transformed by the split which has undone that previous merge operation.\n        // So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n        //\n        if (context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0) {\n            a.sourcePosition = b.moveTargetPosition.clone();\n            a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n            return [a];\n        }\n    }\n    // The default case.\n    //\n    if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {\n        a.howMany = b.splitPosition.offset;\n    }\n    a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n    a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n    return [a];\n});\n// -----------------------\nsetTransformation(MoveOperation, InsertOperation, (a, b) => {\n    const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n    const transformed = moveRange._getTransformedByInsertOperation(b, false)[0];\n    a.sourcePosition = transformed.start;\n    a.howMany = transformed.end.offset - transformed.start.offset;\n    // See `InsertOperation` x `MoveOperation` transformation for details on this case.\n    //\n    // In summary, both operations point to the same place, so the order of nodes needs to be decided.\n    // `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n    // between operations.\n    //\n    if (!a.targetPosition.isEqual(b.position)) {\n        a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n    }\n    return [a];\n});\nsetTransformation(MoveOperation, MoveOperation, (a, b, context) => {\n    //\n    // Setting and evaluating some variables that will be used in special cases and default algorithm.\n    //\n    // Create ranges from `MoveOperations` properties.\n    const rangeA = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n    const rangeB = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n    // Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n    // this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n    let aIsStrong = context.aIsStrong;\n    // This will be used to decide the order of nodes if both operations target at the same position.\n    // By default, use strong/weak operation mechanism.\n    let insertBefore = !context.aIsStrong;\n    // If the relation is set, then use it to decide nodes order.\n    if (context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter') {\n        insertBefore = true;\n    }\n    else if (context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore') {\n        insertBefore = false;\n    }\n    // `a.targetPosition` could be affected by the `b` operation. We will transform it.\n    let newTargetPosition;\n    if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {\n        newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n    }\n    else {\n        newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    }\n    //\n    // Special case #1 + mirror.\n    //\n    // Special case when both move operations' target positions are inside nodes that are\n    // being moved by the other move operation. So in other words, we move ranges into inside of each other.\n    // This case can't be solved reasonably (on the other hand, it should not happen often).\n    if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {\n        // Instead of transforming operation, we return a reverse of the operation that we transform by.\n        // So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n        return [b.getReversed()];\n    }\n    //\n    // End of special case #1.\n    //\n    //\n    // Special case #2.\n    //\n    // Check if `b` operation targets inside `rangeA`.\n    const bTargetsToA = rangeA.containsPosition(b.targetPosition);\n    // If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n    // You might say that operation `b` is captured inside operation `a`.\n    if (bTargetsToA && rangeA.containsRange(rangeB, true)) {\n        // There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n        // we need to transform `a` operation anyway.\n        rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n        rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n        return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n    }\n    //\n    // Special case #2 mirror.\n    //\n    const aTargetsToB = rangeB.containsPosition(a.targetPosition);\n    if (aTargetsToB && rangeB.containsRange(rangeA, true)) {\n        // `a` operation is \"moved together\" with `b` operation.\n        // Here, just move `rangeA` \"inside\" `rangeB`.\n        rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n        rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());\n        return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n    }\n    //\n    // End of special case #2.\n    //\n    //\n    // Special case #3 + mirror.\n    //\n    // `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n    // but not on the same tree level. In such case ranges have common part but we have to treat it\n    // differently, because in such case those ranges are not really conflicting and should be treated like\n    // two separate ranges. Also we have to discard two difference parts.\n    const aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());\n    if (aCompB == 'prefix' || aCompB == 'extension') {\n        // Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n        // Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n        // like a one difference part.\n        rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n        rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n        return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n    }\n    //\n    // End of special case #3.\n    //\n    //\n    // Default case - ranges are on the same level or are not connected with each other.\n    //\n    // Modifier for default case.\n    // Modifies `aIsStrong` flag in certain conditions.\n    //\n    // If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n    // to provide more expected results.\n    if (a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove) {\n        aIsStrong = true;\n    }\n    else if (a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n        aIsStrong = false;\n    }\n    // Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n    // This will aggregate transformed ranges.\n    const ranges = [];\n    // Get the \"difference part\" of `a` operation source range.\n    // This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n    const difference = rangeA.getDifference(rangeB);\n    for (const range of difference) {\n        // Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n        range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);\n        range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany);\n        // If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n        const shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == 'same';\n        const newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);\n        ranges.push(...newRanges);\n    }\n    // Then, we have to manage the \"common part\" of both move ranges.\n    const common = rangeA.getIntersection(rangeB);\n    if (common !== null && aIsStrong) {\n        // Calculate the new position of that part of original range.\n        common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n        common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart());\n        // Take care of proper range order.\n        //\n        // Put `common` at appropriate place. Keep in mind that we are interested in original order.\n        // Basically there are only three cases: there is zero, one or two difference ranges.\n        //\n        // If there is zero difference ranges, just push `common` in the array.\n        if (ranges.length === 0) {\n            ranges.push(common);\n        }\n        // If there is one difference range, we need to check whether common part was before it or after it.\n        else if (ranges.length == 1) {\n            if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {\n                ranges.unshift(common);\n            }\n            else {\n                ranges.push(common);\n            }\n        }\n        // If there are more ranges (which means two), put common part between them. This is the only scenario\n        // where there could be two difference ranges so we don't have to make any comparisons.\n        else {\n            ranges.splice(1, 0, common);\n        }\n    }\n    if (ranges.length === 0) {\n        // If there are no \"source ranges\", nothing should be changed.\n        // Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n        return [new NoOperation(a.baseVersion)];\n    }\n    return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, SplitOperation, (a, b, context) => {\n    let newTargetPosition = a.targetPosition.clone();\n    // Do not transform if target position is same as split insertion position and this split comes from undo.\n    // This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n    // We need to make a decision how we will resolve such conflict and this is less harmful way.\n    if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter') {\n        newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n    }\n    // Case 1:\n    //\n    // Last element in the moved range got split.\n    //\n    // In this case the default range transformation will not work correctly as the element created by\n    // split operation would be outside the range. The range to move needs to be fixed manually.\n    //\n    const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n    if (moveRange.end.isEqual(b.insertionPosition)) {\n        // Do it only if this is a \"natural\" split, not a one that comes from undo.\n        // If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n        if (!b.graveyardPosition) {\n            a.howMany++;\n        }\n        a.targetPosition = newTargetPosition;\n        return [a];\n    }\n    // Case 2:\n    //\n    // Split happened between the moved nodes. In this case two ranges to move need to be generated.\n    //\n    // Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n    // <p>F[oz|ba]r</p><p>Xyz</p>\n    //\n    // After split:\n    // <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n    //\n    // Correct ranges:\n    // <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n    //\n    // After move:\n    // <p>F</p><p>r</p><p>Xyzozba</p>\n    //\n    if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {\n        let rightRange = new Range(b.splitPosition, moveRange.end);\n        rightRange = rightRange._getTransformedBySplitOperation(b);\n        const ranges = [\n            new Range(moveRange.start, b.splitPosition),\n            rightRange\n        ];\n        return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n    }\n    // Case 3:\n    //\n    // Move operation targets at the split position. We need to decide if the nodes should be inserted\n    // at the end of the split element or at the beginning of the new element.\n    //\n    if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == 'insertAtSource') {\n        newTargetPosition = b.moveTargetPosition;\n    }\n    // Case 4:\n    //\n    // Move operation targets just after the split element. We need to decide if the nodes should be inserted\n    // between two parts of split element, or after the new element.\n    //\n    // Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n    // <p>Foo|bar</p>^<p>baz</p>\n    // <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n    //\n    // If there is no contextual information between operations (for example, they come from collaborative\n    // editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n    // However, if the split is from undo, in the past, the moved content might be targeting between the\n    // split parts, meaning that was exactly user's intention:\n    //\n    // <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n    // <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n    // <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n    //\n    // In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n    // so we need to transform accordingly. We can detect this scenario thanks to relations.\n    //\n    if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == 'insertBetween') {\n        newTargetPosition = a.targetPosition;\n    }\n    // The default case.\n    //\n    const transformed = moveRange._getTransformedBySplitOperation(b);\n    const ranges = [transformed];\n    // Case 5:\n    //\n    // Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n    //\n    if (b.graveyardPosition) {\n        const movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);\n        if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {\n            ranges.push(Range._createFromPositionAndShift(b.insertionPosition, 1));\n        }\n    }\n    return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, MergeOperation, (a, b, context) => {\n    const movedRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n    if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {\n        if (a.type == 'remove' && !context.forceWeakRemove) {\n            // Case 1:\n            //\n            // The element to remove got merged.\n            //\n            // Merge operation does support merging elements which are not siblings. So it would not be a problem\n            // from technical point of view. However, if the element was removed, the intention of the user\n            // deleting it was to have it all deleted. From user experience point of view, moving back the\n            // removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n            //\n            if (!context.aWasUndone) {\n                const results = [];\n                let gyMoveSource = b.graveyardPosition.clone();\n                let splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);\n                if (a.howMany > 1) {\n                    results.push(new MoveOperation(a.sourcePosition, a.howMany - 1, a.targetPosition, 0));\n                    gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n                    splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n                }\n                const gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, a.targetPosition);\n                const gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);\n                const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n                splitNodesMoveTargetPath.push(0);\n                const splitNodesMoveTarget = new Position(gyMove.targetPosition.root, splitNodesMoveTargetPath);\n                splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);\n                const splitNodesMove = new MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);\n                results.push(gyMove);\n                results.push(splitNodesMove);\n                return results;\n            }\n        }\n        else {\n            // Case 2:\n            //\n            // The element to move got merged and it was the only element to move.\n            // In this case just don't do anything, leave the node in the graveyard. Without special case\n            // it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n            //\n            if (a.howMany == 1) {\n                if (!context.bWasUndone) {\n                    return [new NoOperation(0)];\n                }\n                else {\n                    a.sourcePosition = b.graveyardPosition.clone();\n                    a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n                    return [a];\n                }\n            }\n        }\n    }\n    // The default case.\n    //\n    const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n    const transformed = moveRange._getTransformedByMergeOperation(b);\n    a.sourcePosition = transformed.start;\n    a.howMany = transformed.end.offset - transformed.start.offset;\n    a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n    return [a];\n});\n// -----------------------\nsetTransformation(RenameOperation, InsertOperation, (a, b) => {\n    a.position = a.position._getTransformedByInsertOperation(b);\n    return [a];\n});\nsetTransformation(RenameOperation, MergeOperation, (a, b) => {\n    // Case 1:\n    //\n    // Element to rename got merged, so it was moved to `b.graveyardPosition`.\n    //\n    if (a.position.isEqual(b.deletionPosition)) {\n        a.position = b.graveyardPosition.clone();\n        a.position.stickiness = 'toNext';\n        return [a];\n    }\n    a.position = a.position._getTransformedByMergeOperation(b);\n    return [a];\n});\nsetTransformation(RenameOperation, MoveOperation, (a, b) => {\n    a.position = a.position._getTransformedByMoveOperation(b);\n    return [a];\n});\nsetTransformation(RenameOperation, RenameOperation, (a, b, context) => {\n    if (a.position.isEqual(b.position)) {\n        if (context.aIsStrong) {\n            a.oldName = b.newName;\n        }\n        else {\n            return [new NoOperation(0)];\n        }\n    }\n    return [a];\n});\nsetTransformation(RenameOperation, SplitOperation, (a, b) => {\n    // Case 1:\n    //\n    // The element to rename has been split. In this case, the new element should be also renamed.\n    //\n    // User decides to change the paragraph to a list item:\n    // <paragraph>Foobar</paragraph>\n    //\n    // However, in meantime, split happens:\n    // <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n    //\n    // As a result, rename both elements:\n    // <listItem>Foo</listItem><listItem>bar</listItem>\n    //\n    const renamePath = a.position.path;\n    const splitPath = b.splitPosition.getParentPath();\n    if (compareArrays(renamePath, splitPath) == 'same' && !b.graveyardPosition) {\n        const extraRename = new RenameOperation(a.position.getShiftedBy(1), a.oldName, a.newName, 0);\n        return [a, extraRename];\n    }\n    // The default case.\n    //\n    a.position = a.position._getTransformedBySplitOperation(b);\n    return [a];\n});\n// -----------------------\nsetTransformation(RootAttributeOperation, RootAttributeOperation, (a, b, context) => {\n    if (a.root === b.root && a.key === b.key) {\n        if (!context.aIsStrong || a.newValue === b.newValue) {\n            return [new NoOperation(0)];\n        }\n        else {\n            a.oldValue = b.newValue;\n        }\n    }\n    return [a];\n});\n// -----------------------\nsetTransformation(SplitOperation, InsertOperation, (a, b) => {\n    // The default case.\n    //\n    if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {\n        a.howMany += b.howMany;\n    }\n    a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);\n    a.insertionPosition = a.insertionPosition._getTransformedByInsertOperation(b);\n    return [a];\n});\nsetTransformation(SplitOperation, MergeOperation, (a, b, context) => {\n    // Case 1:\n    //\n    // Split element got merged. If two different elements were merged, clients will have different content.\n    //\n    // Example. Merge at `{}`, split at `[]`:\n    // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n    //\n    // On merge side it will look like this:\n    // <heading>FooB[]ar</heading>\n    // <heading>FooB</heading><heading>ar</heading>\n    //\n    // On split side it will look like this:\n    // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n    // <heading>FooB</heading><paragraph>ar</paragraph>\n    //\n    // Clearly, the second element is different for both clients.\n    //\n    // We could use the removed merge element from graveyard as a split element but then clients would have a different\n    // model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n    //\n    // To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n    // in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n    // used for splitting. Example below.\n    //\n    // Original state:\n    // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n    //\n    // Merge side client:\n    //\n    // After merge:\n    // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n    //\n    // Extra split:\n    // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n    //\n    // Use the \"cloned\" element from graveyard:\n    // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n    //\n    // Split side client:\n    //\n    // After split:\n    // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n    //\n    // After merge:\n    // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n    //\n    // This special case scenario only applies if the original split operation clones the split element.\n    // If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n    // knows exactly which element it should use. So there would be no original problem with different contents.\n    //\n    // Additionally, the special case applies only if the merge wasn't already undone.\n    //\n    if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {\n        const splitPath = b.graveyardPosition.path.slice();\n        splitPath.push(0);\n        const splitPosition = new Position(b.graveyardPosition.root, splitPath);\n        const insertionPosition = SplitOperation.getInsertionPosition(new Position(b.graveyardPosition.root, splitPath));\n        const additionalSplit = new SplitOperation(splitPosition, 0, insertionPosition, null, 0);\n        a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n        a.graveyardPosition = additionalSplit.insertionPosition.clone();\n        a.graveyardPosition.stickiness = 'toNext';\n        return [additionalSplit, a];\n    }\n    // The default case.\n    //\n    if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {\n        a.howMany--;\n    }\n    if (a.splitPosition.hasSameParentAs(b.targetPosition)) {\n        a.howMany += b.howMany;\n    }\n    a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    if (a.graveyardPosition) {\n        a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n    }\n    return [a];\n});\nsetTransformation(SplitOperation, MoveOperation, (a, b, context) => {\n    const rangeToMove = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n    if (a.graveyardPosition) {\n        // Case 1:\n        //\n        // Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n        // is already moved to the correct position, we need to only move the nodes after the split position.\n        // This will be done by `MoveOperation` instead of `SplitOperation`.\n        //\n        const gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);\n        if (!context.bWasUndone && gyElementMoved) {\n            const sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);\n            const newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n            const newTargetPath = newParentPosition.path.slice();\n            newTargetPath.push(0);\n            const newTargetPosition = new Position(newParentPosition.root, newTargetPath);\n            const moveOp = new MoveOperation(sourcePosition, a.howMany, newTargetPosition, 0);\n            return [moveOp];\n        }\n        a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n    }\n    // Case 2:\n    //\n    // Split is at a position where nodes were moved.\n    //\n    // This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n    // \"split operation point of view\".\n    //\n    const splitAtTarget = a.splitPosition.isEqual(b.targetPosition);\n    if (splitAtTarget && (context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore')) {\n        a.howMany += b.howMany;\n        a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n        return [a];\n    }\n    if (splitAtTarget && context.abRelation && context.abRelation.howMany) {\n        const { howMany, offset } = context.abRelation;\n        a.howMany += howMany;\n        a.splitPosition = a.splitPosition.getShiftedBy(offset);\n        return [a];\n    }\n    // Case 3:\n    //\n    // If the split position is inside the moved range, we need to shift the split position to a proper place.\n    // The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n    //\n    // Characters `bc` should be moved to the second paragraph while split position is between them:\n    // <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n    //\n    // After move, new split position is incorrect:\n    // <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n    //\n    // Correct split position:\n    // <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n    //\n    // After split:\n    // <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n    //\n    if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {\n        const howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);\n        a.howMany -= howManyRemoved;\n        if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n            a.howMany += b.howMany;\n        }\n        a.splitPosition = b.sourcePosition.clone();\n        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n        return [a];\n    }\n    // The default case.\n    // Don't change `howMany` if move operation does not really move anything.\n    //\n    if (!b.sourcePosition.isEqual(b.targetPosition)) {\n        if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {\n            a.howMany -= b.howMany;\n        }\n        if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n            a.howMany += b.howMany;\n        }\n    }\n    // Change position stickiness to force a correct transformation.\n    a.splitPosition.stickiness = 'toNone';\n    a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);\n    a.splitPosition.stickiness = 'toNext';\n    if (a.graveyardPosition) {\n        a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);\n    }\n    else {\n        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    }\n    return [a];\n});\nsetTransformation(SplitOperation, SplitOperation, (a, b, context) => {\n    // Case 1:\n    //\n    // Split at the same position.\n    //\n    // If there already was a split at the same position as in `a` operation, it means that the intention\n    // conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n    //\n    // However, there is a difference if these are new splits or splits created by undo. These have different\n    // intentions. Also splits moving back different elements from graveyard have different intentions. They\n    // are just different operations.\n    //\n    // So we cancel split operation only if it was really identical.\n    //\n    // Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n    // default transformation is incorrect too.\n    //\n    if (a.splitPosition.isEqual(b.splitPosition)) {\n        if (!a.graveyardPosition && !b.graveyardPosition) {\n            return [new NoOperation(0)];\n        }\n        if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n            return [new NoOperation(0)];\n        }\n        // Use context to know that the `a.splitPosition` should stay where it is.\n        // This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n        if (context.abRelation == 'splitBefore') {\n            // Since split is at the same position, there are no nodes left to split.\n            a.howMany = 0;\n            // Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n            // That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n            // It could happen if `context` is enabled in collaboration.\n            a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n            return [a];\n        }\n    }\n    // Case 2:\n    //\n    // Same node is using to split different elements. This happens in undo when previously same element was merged to\n    // two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n    //\n    // In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n    // split operations. This might not always be true but in the real cases that were experienced it was. After all,\n    // if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n    // should be same for both of those splits.\n    //\n    // Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n    //\n    if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n        const aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n        const bInGraveyard = b.splitPosition.root.rootName == '$graveyard';\n        // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n        const aIsWeak = aInGraveyard && !bInGraveyard;\n        // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n        const bIsWeak = bInGraveyard && !aInGraveyard;\n        // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n        const forceMove = bIsWeak || (!aIsWeak && context.aIsStrong);\n        if (forceMove) {\n            const result = [];\n            // First we need to move any nodes split by `b` back to where they were.\n            // Do it only if `b` actually moved something.\n            if (b.howMany) {\n                result.push(new MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));\n            }\n            // Then we need to move nodes from `a` split position to their new element.\n            // Do it only if `a` actually should move something.\n            if (a.howMany) {\n                result.push(new MoveOperation(a.splitPosition, a.howMany, a.moveTargetPosition, 0));\n            }\n            return result;\n        }\n        else {\n            return [new NoOperation(0)];\n        }\n    }\n    if (a.graveyardPosition) {\n        a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n    }\n    // Case 3:\n    //\n    // Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n    // As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n    //\n    if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == 'splitBefore') {\n        a.howMany++;\n        return [a];\n    }\n    // Case 4:\n    //\n    // This is a mirror to the case 2. above.\n    //\n    if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == 'splitBefore') {\n        const newPositionPath = b.insertionPosition.path.slice();\n        newPositionPath.push(0);\n        const newPosition = new Position(b.insertionPosition.root, newPositionPath);\n        const moveOp = new MoveOperation(a.insertionPosition, 1, newPosition, 0);\n        return [a, moveOp];\n    }\n    // The default case.\n    //\n    if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {\n        a.howMany -= b.howMany;\n    }\n    a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    return [a];\n});\n// Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\nfunction _moveTargetIntoMovedRange(a, b) {\n    return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;\n}\n// Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\nfunction _makeMoveOperationsFromRanges(ranges, targetPosition) {\n    // At this moment we have some ranges and a target position, to which those ranges should be moved.\n    // Order in `ranges` array is the go-to order of after transformation.\n    //\n    // We are almost done. We have `ranges` and `targetPosition` to make operations from.\n    // Unfortunately, those operations may affect each other. Precisely, first operation after move\n    // may affect source range and target position of second and third operation. Same with second\n    // operation affecting third.\n    //\n    // We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n    const operations = [];\n    // Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n    for (let i = 0; i < ranges.length; i++) {\n        // Create new operation out of a range and target position.\n        const range = ranges[i];\n        const op = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, 0);\n        operations.push(op);\n        // Transform other ranges by the generated operation.\n        for (let j = i + 1; j < ranges.length; j++) {\n            // All ranges in `ranges` array should be:\n            //\n            // * non-intersecting (these are part of original operation source range), and\n            // * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n            //\n            // This means that the transformation will be \"clean\" and always return one result.\n            ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];\n        }\n        targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);\n    }\n    return operations;\n}\n"],"mappings":"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;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAME,kBAAkB,GAAG,IAAIC,OAAO,EAAE;EACxC;EACA,KAAK,MAAMC,EAAE,IAAId,WAAW,EAAE;IAC1BY,kBAAkB,CAACxB,GAAG,CAAC0B,EAAE,EAAE,CAAC,CAAC;EACjC;EACA;EACA,MAAMC,IAAI,GAAG;IACTC,gBAAgB,EAAEhB,WAAW,CAACA,WAAW,CAACW,MAAM,GAAG,CAAC,CAAC,CAACM,WAAW,GAAG,CAAC;IACrEC,gBAAgB,EAAEjB,WAAW,CAACA,WAAW,CAACU,MAAM,GAAG,CAAC,CAAC,CAACM,WAAW,GAAG,CAAC;IACrEE,wBAAwB,EAAEnB,WAAW,CAACW,MAAM;IAC5CS,wBAAwB,EAAEnB,WAAW,CAACU;EAC1C,CAAC;EACD;EACA,IAAIU,CAAC,GAAG,CAAC;EACT;EACA,OAAOA,CAAC,GAAGrB,WAAW,CAACW,MAAM,EAAE;IAC3B;IACA,MAAMW,GAAG,GAAGtB,WAAW,CAACqB,CAAC,CAAC;IAC1B;IACA,MAAME,MAAM,GAAGX,kBAAkB,CAACzB,GAAG,CAACmC,GAAG,CAAC;IAC1C;IACA,IAAIC,MAAM,IAAItB,W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"},"metadata":{},"sourceType":"module"}