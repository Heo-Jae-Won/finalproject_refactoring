{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class PluginCollection {\n  /**\n   * Creates an instance of the plugin collection class.\n   * Allows loading and initializing plugins and their dependencies.\n   * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.\n   *\n   * @param {module:core/editor/editor~Editor|module:core/context~Context} context\n   * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n   * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).\n   * Usually, the editor will pass its built-in plugins to the collection so they can later be\n   * used in `config.plugins` or `config.removePlugins` by names.\n   * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a\n   * `[ PluginConstructor, pluginInstance ]` pair.\n   */\n  constructor(context) {\n    let availablePlugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let contextPlugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    /**\n     * @protected\n     * @type {module:core/editor/editor~Editor|module:core/context~Context}\n     */\n    this._context = context;\n\n    /**\n     * @protected\n     * @type {Map}\n     */\n    this._plugins = new Map();\n\n    /**\n     * A map of plugin constructors that can be retrieved by their names.\n     *\n     * @protected\n     * @type {Map.<String|Function,Function>}\n     */\n    this._availablePlugins = new Map();\n    for (const PluginConstructor of availablePlugins) {\n      if (PluginConstructor.pluginName) {\n        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n      }\n    }\n\n    /**\n     * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.\n     *\n     * @protected\n     * @type {Map<Function,Function>}\n     */\n    this._contextPlugins = new Map();\n    for (const [PluginConstructor, pluginInstance] of contextPlugins) {\n      this._contextPlugins.set(PluginConstructor, pluginInstance);\n      this._contextPlugins.set(pluginInstance, PluginConstructor);\n\n      // To make it possible to require a plugin by its name.\n      if (PluginConstructor.pluginName) {\n        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n      }\n    }\n  }\n\n  /**\n   * Iterable interface.\n   *\n   * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n   *\n   * @returns {Iterable.<Array>}\n   */\n  *[Symbol.iterator]() {\n    for (const entry of this._plugins) {\n      if (typeof entry[0] == 'function') {\n        yield entry;\n      }\n    }\n  }\n\n  /**\n   * Gets the plugin instance by its constructor or name.\n   *\n   *\t\t// Check if 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n   *\t\t\t// Get clipboard plugin instance\n   *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n   *\n   *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n   *\t\t\t\t// Do something on clipboard input.\n   *\t\t\t} );\n   *\t\t}\n   *\n   * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n   * to check if a plugin is available.\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {module:core/plugin~PluginInterface}\n   */\n  get(key) {\n    const plugin = this._plugins.get(key);\n    if (!plugin) {\n      let pluginName = key;\n      if (typeof key == 'function') {\n        pluginName = key.pluginName || key.name;\n      }\n\n      /**\n       * The plugin is not loaded and could not be obtained.\n       *\n       * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n       * the plugin collection.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n       * to check if a plugin was loaded.\n       *\n       * @error plugincollection-plugin-not-loaded\n       * @param {String} plugin The name of the plugin which is not loaded.\n       */\n      throw new CKEditorError('plugincollection-plugin-not-loaded', this._context, {\n        plugin: pluginName\n      });\n    }\n    return plugin;\n  }\n\n  /**\n   * Checks if a plugin is loaded.\n   *\n   *\t\t// Check if the 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n   *\t\t\t// Now use the clipboard plugin instance:\n   *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n   *\n   *\t\t\t// ...\n   *\t\t}\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {Boolean}\n   */\n  has(key) {\n    return this._plugins.has(key);\n  }\n\n  /**\n   * Initializes a set of plugins and adds them to the collection.\n   *\n   * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n   * or {@link module:core/plugin~PluginInterface.pluginName plugin names}.\n   * @param {Array.<String|Function>} [pluginsToRemove] Names of the plugins or plugin constructors\n   * that should not be loaded (despite being specified in the `plugins` array).\n   * @param {Array.<Function>} [pluginsSubstitutions] An array of {@link module:core/plugin~PluginInterface plugin constructors}\n   * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.\n   * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced\n   * must follow these rules:\n   *   * The new plugin must be a class.\n   *   * The new plugin must be named.\n   *   * Both plugins must not depend on other plugins.\n   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n   * and available in the collection.\n   */\n  init(plugins) {\n    let pluginsToRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let pluginsSubstitutions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // Plugin initialization procedure consists of 2 main steps:\n    // 1) collecting all available plugin constructors,\n    // 2) verification whether all required plugins can be instantiated.\n    //\n    // In the first step, all plugin constructors, available in the provided `plugins` array and inside\n    // plugin's dependencies (from the `Plugin.requires` array), are recursively collected and added to the existing\n    // `this._availablePlugins` map, but without any verification at the given moment. Performing the verification\n    // at this point (during the plugin constructor searching) would cause false errors to occur, that some plugin\n    // is missing but in fact it may be defined further in the array as the dependency of other plugin. After\n    // traversing the entire dependency tree, it will be checked if all required \"top level\" plugins are available.\n    //\n    // In the second step, the list of plugins that have not been explicitly removed is traversed to get all the\n    // plugin constructors to be instantiated in the correct order and to validate against some rules. Finally, if\n    // no plugin is missing and no other error has been found, they all will be instantiated.\n    const that = this;\n    const context = this._context;\n    findAvailablePluginConstructors(plugins);\n    validatePlugins(plugins);\n    const pluginsToLoad = plugins.filter(plugin => !isPluginRemoved(plugin, pluginsToRemove));\n    const pluginConstructors = [...getPluginConstructors(pluginsToLoad)];\n    substitutePlugins(pluginConstructors, pluginsSubstitutions);\n    const pluginInstances = loadPlugins(pluginConstructors);\n    return initPlugins(pluginInstances, 'init').then(() => initPlugins(pluginInstances, 'afterInit')).then(() => pluginInstances);\n    function isPluginConstructor(plugin) {\n      return typeof plugin === 'function';\n    }\n    function isContextPlugin(plugin) {\n      return isPluginConstructor(plugin) && plugin.isContextPlugin;\n    }\n    function isPluginRemoved(plugin, pluginsToRemove) {\n      return pluginsToRemove.some(removedPlugin => {\n        if (removedPlugin === plugin) {\n          return true;\n        }\n        if (getPluginName(plugin) === removedPlugin) {\n          return true;\n        }\n        if (getPluginName(removedPlugin) === plugin) {\n          return true;\n        }\n        return false;\n      });\n    }\n    function getPluginName(plugin) {\n      return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;\n    }\n    function findAvailablePluginConstructors(plugins) {\n      let processed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n      plugins.forEach(plugin => {\n        if (!isPluginConstructor(plugin)) {\n          return;\n        }\n        if (processed.has(plugin)) {\n          return;\n        }\n        processed.add(plugin);\n        if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {\n          that._availablePlugins.set(plugin.pluginName, plugin);\n        }\n        if (plugin.requires) {\n          findAvailablePluginConstructors(plugin.requires, processed);\n        }\n      });\n    }\n    function getPluginConstructors(plugins) {\n      let processed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n      return plugins.map(plugin => {\n        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);\n      }).reduce((result, plugin) => {\n        if (processed.has(plugin)) {\n          return result;\n        }\n        processed.add(plugin);\n        if (plugin.requires) {\n          validatePlugins(plugin.requires, plugin);\n          getPluginConstructors(plugin.requires, processed).forEach(plugin => result.add(plugin));\n        }\n        return result.add(plugin);\n      }, new Set());\n    }\n    function validatePlugins(plugins) {\n      let parentPluginConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      plugins.map(plugin => {\n        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;\n      }).forEach(plugin => {\n        checkMissingPlugin(plugin, parentPluginConstructor);\n        checkContextPlugin(plugin, parentPluginConstructor);\n        checkRemovedPlugin(plugin, parentPluginConstructor);\n      });\n    }\n    function checkMissingPlugin(plugin, parentPluginConstructor) {\n      if (isPluginConstructor(plugin)) {\n        return;\n      }\n      if (parentPluginConstructor) {\n        /**\n         * A required \"soft\" dependency was not found on the plugin list.\n         *\n         * When configuring the editor, either prior to building (via\n         * {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}) or when\n         * creating a new instance of the editor (e.g. via\n         * {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`}), you need to provide\n         * some of the dependencies for other plugins that you used.\n         *\n         * This error is thrown when one of these dependencies was not provided. The name of the missing plugin\n         * can be found in `missingPlugin` and the plugin that required it in `requiredBy`.\n         *\n         * In order to resolve it, you need to import the missing plugin and add it to the\n         * current list of plugins (`Editor.builtinPlugins` or `config.plugins`/`config.extraPlugins`).\n         *\n         * Soft requirements were introduced in version 26.0.0. If you happen to stumble upon this error\n         * when upgrading to version 26.0.0, read also the\n         * {@glink updating/migration-to-26 Migration to 26.0.0} guide.\n         *\n         * @error plugincollection-soft-required\n         * @param {String} missingPlugin The name of the required plugin.\n         * @param {String} requiredBy The name of the plugin that requires the other plugin.\n         */\n        throw new CKEditorError('plugincollection-soft-required', context, {\n          missingPlugin: plugin,\n          requiredBy: getPluginName(parentPluginConstructor)\n        });\n      }\n\n      /**\n       * A plugin is not available and could not be loaded.\n       *\n       * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **If you see this warning when using one of the {@glink installation/getting-started/predefined-builds\n       * CKEditor 5 Builds}**,\n       * it means that you try to enable a plugin which was not included in that build. This may be due to a typo\n       * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n       * read more about {@glink installation/getting-started/quick-start custom builds}.\n       *\n       * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n       * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n       * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n       * provide each plugin through a reference (as a constructor function). Check out the examples in\n       * {@glink installation/advanced/alternative-setups/integrating-from-source \"Building from source\"}.\n       *\n       * @error plugincollection-plugin-not-found\n       * @param {String} plugin The name of the plugin which could not be loaded.\n       */\n      throw new CKEditorError('plugincollection-plugin-not-found', context, {\n        plugin\n      });\n    }\n    function checkContextPlugin(plugin, parentPluginConstructor) {\n      if (!isContextPlugin(parentPluginConstructor)) {\n        return;\n      }\n      if (isContextPlugin(plugin)) {\n        return;\n      }\n\n      /**\n       * If a plugin is a context plugin, all plugins it requires should also be context plugins\n       * instead of plugins. In other words, if one plugin can be used in the context,\n       * all its requirements should also be ready to be used in the context. Note that the context\n       * provides only a part of the API provided by the editor. If one plugin needs a full\n       * editor API, all plugins which require it are considered as plugins that need a full\n       * editor API.\n       *\n       * @error plugincollection-context-required\n       * @param {String} plugin The name of the required plugin.\n       * @param {String} requiredBy The name of the parent plugin.\n       */\n      throw new CKEditorError('plugincollection-context-required', context, {\n        plugin: getPluginName(plugin),\n        requiredBy: getPluginName(parentPluginConstructor)\n      });\n    }\n    function checkRemovedPlugin(plugin, parentPluginConstructor) {\n      if (!parentPluginConstructor) {\n        return;\n      }\n      if (!isPluginRemoved(plugin, pluginsToRemove)) {\n        return;\n      }\n\n      /**\n       * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n       *\n       * @error plugincollection-required\n       * @param {String} plugin The name of the required plugin.\n       * @param {String} requiredBy The name of the parent plugin.\n       */\n      throw new CKEditorError('plugincollection-required', context, {\n        plugin: getPluginName(plugin),\n        requiredBy: getPluginName(parentPluginConstructor)\n      });\n    }\n    function loadPlugins(pluginConstructors) {\n      return pluginConstructors.map(PluginConstructor => {\n        const pluginInstance = that._contextPlugins.get(PluginConstructor) || new PluginConstructor(context);\n        that._add(PluginConstructor, pluginInstance);\n        return pluginInstance;\n      });\n    }\n    function initPlugins(pluginInstances, method) {\n      return pluginInstances.reduce((promise, plugin) => {\n        if (!plugin[method]) {\n          return promise;\n        }\n        if (that._contextPlugins.has(plugin)) {\n          return promise;\n        }\n        return promise.then(plugin[method].bind(plugin));\n      }, Promise.resolve());\n    }\n\n    // Replaces plugin constructors with the specified set of plugins.\n    //\n    // @param {Array.<Function>} pluginConstructors\n    // @param {Array.<Function>} pluginsSubstitutions\n    function substitutePlugins(pluginConstructors, pluginsSubstitutions) {\n      for (const pluginItem of pluginsSubstitutions) {\n        if (typeof pluginItem != 'function') {\n          /**\n           * The plugin replacing an existing plugin must be a function.\n           *\n           * @error plugincollection-replace-plugin-invalid-type\n           */\n          throw new CKEditorError('plugincollection-replace-plugin-invalid-type', null, {\n            pluginItem\n          });\n        }\n        const pluginName = pluginItem.pluginName;\n        if (!pluginName) {\n          /**\n           * The plugin replacing an existing plugin must have a name.\n           *\n           * @error plugincollection-replace-plugin-missing-name\n           */\n          throw new CKEditorError('plugincollection-replace-plugin-missing-name', null, {\n            pluginItem\n          });\n        }\n        if (pluginItem.requires && pluginItem.requires.length) {\n          /**\n           * The plugin replacing an existing plugin cannot depend on other plugins.\n           *\n           * @error plugincollection-plugin-for-replacing-cannot-have-dependencies\n           */\n          throw new CKEditorError('plugincollection-plugin-for-replacing-cannot-have-dependencies', null, {\n            pluginName\n          });\n        }\n        const pluginToReplace = that._availablePlugins.get(pluginName);\n        if (!pluginToReplace) {\n          /**\n           * The replaced plugin does not exist in the\n           * {@link module:core/plugincollection~PluginCollection available plugins} collection.\n           *\n           * @error plugincollection-plugin-for-replacing-not-exist\n           */\n          throw new CKEditorError('plugincollection-plugin-for-replacing-not-exist', null, {\n            pluginName\n          });\n        }\n        const indexInPluginConstructors = pluginConstructors.indexOf(pluginToReplace);\n        if (indexInPluginConstructors === -1) {\n          // The Context feature can substitute plugins as well.\n          // It may happen that the editor will be created with the given context, where the plugin for substitute\n          // was already replaced. In such a case, we don't want to do it again.\n          if (that._contextPlugins.has(pluginToReplace)) {\n            return;\n          }\n\n          /**\n           * The replaced plugin will not be loaded so it cannot be replaced.\n           *\n           * @error plugincollection-plugin-for-replacing-not-loaded\n           */\n          throw new CKEditorError('plugincollection-plugin-for-replacing-not-loaded', null, {\n            pluginName\n          });\n        }\n        if (pluginToReplace.requires && pluginToReplace.requires.length) {\n          /**\n           * The replaced plugin cannot depend on other plugins.\n           *\n           * @error plugincollection-replaced-plugin-cannot-have-dependencies\n           */\n          throw new CKEditorError('plugincollection-replaced-plugin-cannot-have-dependencies', null, {\n            pluginName\n          });\n        }\n        pluginConstructors.splice(indexInPluginConstructors, 1, pluginItem);\n        that._availablePlugins.set(pluginName, pluginItem);\n      }\n    }\n  }\n\n  /**\n   * Destroys all loaded plugins.\n   *\n   * @returns {Promise}\n   */\n  destroy() {\n    const promises = [];\n    for (const [, pluginInstance] of this) {\n      if (typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has(pluginInstance)) {\n        promises.push(pluginInstance.destroy());\n      }\n    }\n    return Promise.all(promises);\n  }\n\n  /**\n   * Adds the plugin to the collection. Exposed mainly for testing purposes.\n   *\n   * @protected\n   * @param {Function} PluginConstructor The plugin constructor.\n   * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n   */\n  _add(PluginConstructor, plugin) {\n    this._plugins.set(PluginConstructor, plugin);\n    const pluginName = PluginConstructor.pluginName;\n    if (!pluginName) {\n      return;\n    }\n    if (this._plugins.has(pluginName)) {\n      /**\n       * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n       * This will lead to runtime conflicts between these plugins.\n       *\n       * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n       * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n       * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n       *\n       * Check your import paths and the list of plugins passed to\n       * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n       * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n       *\n       * The second option is that your `node_modules/` directory contains duplicated versions of the same\n       * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n       * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n       * of some packages, their dependencies may need to be installed in more than one version which may lead to this\n       * warning.\n       *\n       * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n       * the dependencies of this plugin are being duplicated.\n       * They are already built into that editor build and now get added for the second time as dependencies\n       * of the plugin you are installing.\n       *\n       * Read more about {@glink installation/getting-started/installing-plugins installing plugins}.\n       *\n       * @error plugincollection-plugin-name-conflict\n       * @param {String} pluginName The duplicated plugin name.\n       * @param {Function} plugin1 The first plugin constructor.\n       * @param {Function} plugin2 The second plugin constructor.\n       */\n      throw new CKEditorError('plugincollection-plugin-name-conflict', null, {\n        pluginName,\n        plugin1: this._plugins.get(pluginName).constructor,\n        plugin2: PluginConstructor\n      });\n    }\n    this._plugins.set(pluginName, plugin);\n  }\n}\nmix(PluginCollection, EmitterMixin);","map":{"version":3,"names":["CKEditorError","EmitterMixin","mix","PluginCollection","constructor","context","availablePlugins","contextPlugins","_context","_plugins","Map","_availablePlugins","PluginConstructor","pluginName","set","_contextPlugins","pluginInstance","Symbol","iterator","entry","get","key","plugin","name","has","init","plugins","pluginsToRemove","pluginsSubstitutions","that","findAvailablePluginConstructors","validatePlugins","pluginsToLoad","filter","isPluginRemoved","pluginConstructors","getPluginConstructors","substitutePlugins","pluginInstances","loadPlugins","initPlugins","then","isPluginConstructor","isContextPlugin","some","removedPlugin","getPluginName","processed","Set","forEach","add","requires","map","reduce","result","parentPluginConstructor","checkMissingPlugin","checkContextPlugin","checkRemovedPlugin","missingPlugin","requiredBy","_add","method","promise","bind","Promise","resolve","pluginItem","length","pluginToReplace","indexInPluginConstructors","indexOf","splice","destroy","promises","push","all","plugin1","plugin2"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class PluginCollection {\n\t/**\n\t * Creates an instance of the plugin collection class.\n\t * Allows loading and initializing plugins and their dependencies.\n\t * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.\n\t *\n\t * @param {module:core/editor/editor~Editor|module:core/context~Context} context\n\t * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n\t * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).\n\t * Usually, the editor will pass its built-in plugins to the collection so they can later be\n\t * used in `config.plugins` or `config.removePlugins` by names.\n\t * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a\n\t * `[ PluginConstructor, pluginInstance ]` pair.\n\t */\n\tconstructor( context, availablePlugins = [], contextPlugins = [] ) {\n\t\t/**\n\t\t * @protected\n\t\t * @type {module:core/editor/editor~Editor|module:core/context~Context}\n\t\t */\n\t\tthis._context = context;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Map}\n\t\t */\n\t\tthis._plugins = new Map();\n\n\t\t/**\n\t\t * A map of plugin constructors that can be retrieved by their names.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map.<String|Function,Function>}\n\t\t */\n\t\tthis._availablePlugins = new Map();\n\n\t\tfor ( const PluginConstructor of availablePlugins ) {\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map<Function,Function>}\n\t\t */\n\t\tthis._contextPlugins = new Map();\n\n\t\tfor ( const [ PluginConstructor, pluginInstance ] of contextPlugins ) {\n\t\t\tthis._contextPlugins.set( PluginConstructor, pluginInstance );\n\t\t\tthis._contextPlugins.set( pluginInstance, PluginConstructor );\n\n\t\t\t// To make it possible to require a plugin by its name.\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n\t *\n\t * @returns {Iterable.<Array>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tfor ( const entry of this._plugins ) {\n\t\t\tif ( typeof entry[ 0 ] == 'function' ) {\n\t\t\t\tyield entry;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the plugin instance by its constructor or name.\n\t *\n\t *\t\t// Check if 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n\t *\t\t\t// Get clipboard plugin instance\n\t *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n\t *\n\t *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n\t *\t\t\t\t// Do something on clipboard input.\n\t *\t\t\t} );\n\t *\t\t}\n\t *\n\t * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n\t * to check if a plugin is available.\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {module:core/plugin~PluginInterface}\n\t */\n\tget( key ) {\n\t\tconst plugin = this._plugins.get( key );\n\n\t\tif ( !plugin ) {\n\t\t\tlet pluginName = key;\n\n\t\t\tif ( typeof key == 'function' ) {\n\t\t\t\tpluginName = key.pluginName || key.name;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * The plugin is not loaded and could not be obtained.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n\t\t\t * the plugin collection.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n\t\t\t * to check if a plugin was loaded.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-loaded\n\t\t\t * @param {String} plugin The name of the plugin which is not loaded.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'plugincollection-plugin-not-loaded', this._context, { plugin: pluginName } );\n\t\t}\n\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Checks if a plugin is loaded.\n\t *\n\t *\t\t// Check if the 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n\t *\t\t\t// Now use the clipboard plugin instance:\n\t *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n\t *\n\t *\t\t\t// ...\n\t *\t\t}\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {Boolean}\n\t */\n\thas( key ) {\n\t\treturn this._plugins.has( key );\n\t}\n\n\t/**\n\t * Initializes a set of plugins and adds them to the collection.\n\t *\n\t * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n\t * or {@link module:core/plugin~PluginInterface.pluginName plugin names}.\n\t * @param {Array.<String|Function>} [pluginsToRemove] Names of the plugins or plugin constructors\n\t * that should not be loaded (despite being specified in the `plugins` array).\n\t * @param {Array.<Function>} [pluginsSubstitutions] An array of {@link module:core/plugin~PluginInterface plugin constructors}\n\t * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.\n\t * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced\n\t * must follow these rules:\n\t *   * The new plugin must be a class.\n\t *   * The new plugin must be named.\n\t *   * Both plugins must not depend on other plugins.\n\t * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n\t * and available in the collection.\n\t */\n\tinit( plugins, pluginsToRemove = [], pluginsSubstitutions = [] ) {\n\t\t// Plugin initialization procedure consists of 2 main steps:\n\t\t// 1) collecting all available plugin constructors,\n\t\t// 2) verification whether all required plugins can be instantiated.\n\t\t//\n\t\t// In the first step, all plugin constructors, available in the provided `plugins` array and inside\n\t\t// plugin's dependencies (from the `Plugin.requires` array), are recursively collected and added to the existing\n\t\t// `this._availablePlugins` map, but without any verification at the given moment. Performing the verification\n\t\t// at this point (during the plugin constructor searching) would cause false errors to occur, that some plugin\n\t\t// is missing but in fact it may be defined further in the array as the dependency of other plugin. After\n\t\t// traversing the entire dependency tree, it will be checked if all required \"top level\" plugins are available.\n\t\t//\n\t\t// In the second step, the list of plugins that have not been explicitly removed is traversed to get all the\n\t\t// plugin constructors to be instantiated in the correct order and to validate against some rules. Finally, if\n\t\t// no plugin is missing and no other error has been found, they all will be instantiated.\n\t\tconst that = this;\n\t\tconst context = this._context;\n\n\t\tfindAvailablePluginConstructors( plugins );\n\n\t\tvalidatePlugins( plugins );\n\n\t\tconst pluginsToLoad = plugins.filter( plugin => !isPluginRemoved( plugin, pluginsToRemove ) );\n\n\t\tconst pluginConstructors = [ ...getPluginConstructors( pluginsToLoad ) ];\n\n\t\tsubstitutePlugins( pluginConstructors, pluginsSubstitutions );\n\n\t\tconst pluginInstances = loadPlugins( pluginConstructors );\n\n\t\treturn initPlugins( pluginInstances, 'init' )\n\t\t\t.then( () => initPlugins( pluginInstances, 'afterInit' ) )\n\t\t\t.then( () => pluginInstances );\n\n\t\tfunction isPluginConstructor( plugin ) {\n\t\t\treturn typeof plugin === 'function';\n\t\t}\n\n\t\tfunction isContextPlugin( plugin ) {\n\t\t\treturn isPluginConstructor( plugin ) && plugin.isContextPlugin;\n\t\t}\n\n\t\tfunction isPluginRemoved( plugin, pluginsToRemove ) {\n\t\t\treturn pluginsToRemove.some( removedPlugin => {\n\t\t\t\tif ( removedPlugin === plugin ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif ( getPluginName( plugin ) === removedPlugin ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif ( getPluginName( removedPlugin ) === plugin ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t} );\n\t\t}\n\n\t\tfunction getPluginName( plugin ) {\n\t\t\treturn isPluginConstructor( plugin ) ?\n\t\t\t\tplugin.pluginName || plugin.name :\n\t\t\t\tplugin;\n\t\t}\n\n\t\tfunction findAvailablePluginConstructors( plugins, processed = new Set() ) {\n\t\t\tplugins.forEach( plugin => {\n\t\t\t\tif ( !isPluginConstructor( plugin ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( processed.has( plugin ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tprocessed.add( plugin );\n\n\t\t\t\tif ( plugin.pluginName && !that._availablePlugins.has( plugin.pluginName ) ) {\n\t\t\t\t\tthat._availablePlugins.set( plugin.pluginName, plugin );\n\t\t\t\t}\n\n\t\t\t\tif ( plugin.requires ) {\n\t\t\t\t\tfindAvailablePluginConstructors( plugin.requires, processed );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tfunction getPluginConstructors( plugins, processed = new Set() ) {\n\t\t\treturn plugins\n\t\t\t\t.map( plugin => {\n\t\t\t\t\treturn isPluginConstructor( plugin ) ?\n\t\t\t\t\t\tplugin :\n\t\t\t\t\t\tthat._availablePlugins.get( plugin );\n\t\t\t\t} )\n\t\t\t\t.reduce( ( result, plugin ) => {\n\t\t\t\t\tif ( processed.has( plugin ) ) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t\tprocessed.add( plugin );\n\n\t\t\t\t\tif ( plugin.requires ) {\n\t\t\t\t\t\tvalidatePlugins( plugin.requires, plugin );\n\n\t\t\t\t\t\tgetPluginConstructors( plugin.requires, processed ).forEach( plugin => result.add( plugin ) );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result.add( plugin );\n\t\t\t\t}, new Set() );\n\t\t}\n\n\t\tfunction validatePlugins( plugins, parentPluginConstructor = null ) {\n\t\t\tplugins\n\t\t\t\t.map( plugin => {\n\t\t\t\t\treturn isPluginConstructor( plugin ) ?\n\t\t\t\t\t\tplugin :\n\t\t\t\t\t\tthat._availablePlugins.get( plugin ) || plugin;\n\t\t\t\t} )\n\t\t\t\t.forEach( plugin => {\n\t\t\t\t\tcheckMissingPlugin( plugin, parentPluginConstructor );\n\t\t\t\t\tcheckContextPlugin( plugin, parentPluginConstructor );\n\t\t\t\t\tcheckRemovedPlugin( plugin, parentPluginConstructor );\n\t\t\t\t} );\n\t\t}\n\n\t\tfunction checkMissingPlugin( plugin, parentPluginConstructor ) {\n\t\t\tif ( isPluginConstructor( plugin ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( parentPluginConstructor ) {\n\t\t\t\t/**\n\t\t\t\t * A required \"soft\" dependency was not found on the plugin list.\n\t\t\t\t *\n\t\t\t\t * When configuring the editor, either prior to building (via\n\t\t\t\t * {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}) or when\n\t\t\t\t * creating a new instance of the editor (e.g. via\n\t\t\t\t * {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`}), you need to provide\n\t\t\t\t * some of the dependencies for other plugins that you used.\n\t\t\t\t *\n\t\t\t\t * This error is thrown when one of these dependencies was not provided. The name of the missing plugin\n\t\t\t\t * can be found in `missingPlugin` and the plugin that required it in `requiredBy`.\n\t\t\t\t *\n\t\t\t\t * In order to resolve it, you need to import the missing plugin and add it to the\n\t\t\t\t * current list of plugins (`Editor.builtinPlugins` or `config.plugins`/`config.extraPlugins`).\n\t\t\t\t *\n\t\t\t\t * Soft requirements were introduced in version 26.0.0. If you happen to stumble upon this error\n\t\t\t\t * when upgrading to version 26.0.0, read also the\n\t\t\t\t * {@glink updating/migration-to-26 Migration to 26.0.0} guide.\n\t\t\t\t *\n\t\t\t\t * @error plugincollection-soft-required\n\t\t\t\t * @param {String} missingPlugin The name of the required plugin.\n\t\t\t\t * @param {String} requiredBy The name of the plugin that requires the other plugin.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'plugincollection-soft-required',\n\t\t\t\t\tcontext,\n\t\t\t\t\t{ missingPlugin: plugin, requiredBy: getPluginName( parentPluginConstructor ) }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * A plugin is not available and could not be loaded.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the {@glink installation/getting-started/predefined-builds\n\t\t\t * CKEditor 5 Builds}**,\n\t\t\t * it means that you try to enable a plugin which was not included in that build. This may be due to a typo\n\t\t\t * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n\t\t\t * read more about {@glink installation/getting-started/quick-start custom builds}.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n\t\t\t * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n\t\t\t * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n\t\t\t * provide each plugin through a reference (as a constructor function). Check out the examples in\n\t\t\t * {@glink installation/advanced/alternative-setups/integrating-from-source \"Building from source\"}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-found\n\t\t\t * @param {String} plugin The name of the plugin which could not be loaded.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-plugin-not-found',\n\t\t\t\tcontext,\n\t\t\t\t{ plugin }\n\t\t\t);\n\t\t}\n\n\t\tfunction checkContextPlugin( plugin, parentPluginConstructor ) {\n\t\t\tif ( !isContextPlugin( parentPluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isContextPlugin( plugin ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * If a plugin is a context plugin, all plugins it requires should also be context plugins\n\t\t\t * instead of plugins. In other words, if one plugin can be used in the context,\n\t\t\t * all its requirements should also be ready to be used in the context. Note that the context\n\t\t\t * provides only a part of the API provided by the editor. If one plugin needs a full\n\t\t\t * editor API, all plugins which require it are considered as plugins that need a full\n\t\t\t * editor API.\n\t\t\t *\n\t\t\t * @error plugincollection-context-required\n\t\t\t * @param {String} plugin The name of the required plugin.\n\t\t\t * @param {String} requiredBy The name of the parent plugin.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-context-required',\n\t\t\t\tcontext,\n\t\t\t\t{ plugin: getPluginName( plugin ), requiredBy: getPluginName( parentPluginConstructor ) }\n\t\t\t);\n\t\t}\n\n\t\tfunction checkRemovedPlugin( plugin, parentPluginConstructor ) {\n\t\t\tif ( !parentPluginConstructor ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !isPluginRemoved( plugin, pluginsToRemove ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n\t\t\t *\n\t\t\t * @error plugincollection-required\n\t\t\t * @param {String} plugin The name of the required plugin.\n\t\t\t * @param {String} requiredBy The name of the parent plugin.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-required',\n\t\t\t\tcontext,\n\t\t\t\t{ plugin: getPluginName( plugin ), requiredBy: getPluginName( parentPluginConstructor ) }\n\t\t\t);\n\t\t}\n\n\t\tfunction loadPlugins( pluginConstructors ) {\n\t\t\treturn pluginConstructors.map( PluginConstructor => {\n\t\t\t\tconst pluginInstance = that._contextPlugins.get( PluginConstructor ) || new PluginConstructor( context );\n\n\t\t\t\tthat._add( PluginConstructor, pluginInstance );\n\n\t\t\t\treturn pluginInstance;\n\t\t\t} );\n\t\t}\n\n\t\tfunction initPlugins( pluginInstances, method ) {\n\t\t\treturn pluginInstances.reduce( ( promise, plugin ) => {\n\t\t\t\tif ( !plugin[ method ] ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\tif ( that._contextPlugins.has( plugin ) ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\treturn promise.then( plugin[ method ].bind( plugin ) );\n\t\t\t}, Promise.resolve() );\n\t\t}\n\n\t\t// Replaces plugin constructors with the specified set of plugins.\n\t\t//\n\t\t// @param {Array.<Function>} pluginConstructors\n\t\t// @param {Array.<Function>} pluginsSubstitutions\n\t\tfunction substitutePlugins( pluginConstructors, pluginsSubstitutions ) {\n\t\t\tfor ( const pluginItem of pluginsSubstitutions ) {\n\t\t\t\tif ( typeof pluginItem != 'function' ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The plugin replacing an existing plugin must be a function.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-replace-plugin-invalid-type\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-replace-plugin-invalid-type', null, { pluginItem } );\n\t\t\t\t}\n\t\t\t\tconst pluginName = pluginItem.pluginName;\n\n\t\t\t\tif ( !pluginName ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The plugin replacing an existing plugin must have a name.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-replace-plugin-missing-name\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-replace-plugin-missing-name', null, { pluginItem } );\n\t\t\t\t}\n\n\t\t\t\tif ( pluginItem.requires && pluginItem.requires.length ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The plugin replacing an existing plugin cannot depend on other plugins.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-plugin-for-replacing-cannot-have-dependencies\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-plugin-for-replacing-cannot-have-dependencies', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tconst pluginToReplace = that._availablePlugins.get( pluginName );\n\n\t\t\t\tif ( !pluginToReplace ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The replaced plugin does not exist in the\n\t\t\t\t\t * {@link module:core/plugincollection~PluginCollection available plugins} collection.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-plugin-for-replacing-not-exist\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-plugin-for-replacing-not-exist', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tconst indexInPluginConstructors = pluginConstructors.indexOf( pluginToReplace );\n\n\t\t\t\tif ( indexInPluginConstructors === -1 ) {\n\t\t\t\t\t// The Context feature can substitute plugins as well.\n\t\t\t\t\t// It may happen that the editor will be created with the given context, where the plugin for substitute\n\t\t\t\t\t// was already replaced. In such a case, we don't want to do it again.\n\t\t\t\t\tif ( that._contextPlugins.has( pluginToReplace ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * The replaced plugin will not be loaded so it cannot be replaced.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-plugin-for-replacing-not-loaded\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-plugin-for-replacing-not-loaded', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tif ( pluginToReplace.requires && pluginToReplace.requires.length ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The replaced plugin cannot depend on other plugins.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-replaced-plugin-cannot-have-dependencies\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-replaced-plugin-cannot-have-dependencies', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tpluginConstructors.splice( indexInPluginConstructors, 1, pluginItem );\n\t\t\t\tthat._availablePlugins.set( pluginName, pluginItem );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys all loaded plugins.\n\t *\n\t * @returns {Promise}\n\t */\n\tdestroy() {\n\t\tconst promises = [];\n\n\t\tfor ( const [ , pluginInstance ] of this ) {\n\t\t\tif ( typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has( pluginInstance ) ) {\n\t\t\t\tpromises.push( pluginInstance.destroy() );\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all( promises );\n\t}\n\n\t/**\n\t * Adds the plugin to the collection. Exposed mainly for testing purposes.\n\t *\n\t * @protected\n\t * @param {Function} PluginConstructor The plugin constructor.\n\t * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n\t */\n\t_add( PluginConstructor, plugin ) {\n\t\tthis._plugins.set( PluginConstructor, plugin );\n\n\t\tconst pluginName = PluginConstructor.pluginName;\n\n\t\tif ( !pluginName ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._plugins.has( pluginName ) ) {\n\t\t\t/**\n\t\t\t * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n\t\t\t * This will lead to runtime conflicts between these plugins.\n\t\t\t *\n\t\t\t * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n\t\t\t * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n\t\t\t * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n\t\t\t *\n\t\t\t * Check your import paths and the list of plugins passed to\n\t\t\t * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n\t\t\t * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n\t\t\t *\n\t\t\t * The second option is that your `node_modules/` directory contains duplicated versions of the same\n\t\t\t * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n\t\t\t * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n\t\t\t * of some packages, their dependencies may need to be installed in more than one version which may lead to this\n\t\t\t * warning.\n\t\t\t *\n\t\t\t * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n\t\t\t * the dependencies of this plugin are being duplicated.\n\t\t\t * They are already built into that editor build and now get added for the second time as dependencies\n\t\t\t * of the plugin you are installing.\n\t\t\t *\n\t\t\t * Read more about {@glink installation/getting-started/installing-plugins installing plugins}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-name-conflict\n\t\t\t * @param {String} pluginName The duplicated plugin name.\n\t\t\t * @param {Function} plugin1 The first plugin constructor.\n\t\t\t * @param {Function} plugin2 The second plugin constructor.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-plugin-name-conflict',\n\t\t\t\tnull,\n\t\t\t\t{ pluginName, plugin1: this._plugins.get( pluginName ).constructor, plugin2: PluginConstructor }\n\t\t\t);\n\t\t}\n\n\t\tthis._plugins.set( pluginName, plugin );\n\t}\n}\n\nmix( PluginCollection, EmitterMixin );\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}