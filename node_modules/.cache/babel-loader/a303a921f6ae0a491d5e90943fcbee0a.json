{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/domconverter\n */\n/* globals Node, NodeFilter, DOMParser, Text */\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewUIElement from './uielement';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { default as Matcher } from './matcher';\nimport { BR_FILLER, INLINE_FILLER_LENGTH, NBSP_FILLER, MARKED_NBSP_FILLER, getDataWithoutFiller, isInlineFiller, startsWithFiller } from './filler';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nconst BR_FILLER_REF = BR_FILLER(global.document); // eslint-disable-line new-cap\nconst NBSP_FILLER_REF = NBSP_FILLER(global.document); // eslint-disable-line new-cap\nconst MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(global.document); // eslint-disable-line new-cap\nconst UNSAFE_ATTRIBUTE_NAME_PREFIX = 'data-ck-unsafe-attribute-';\nconst UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = 'data-ck-unsafe-element';\n/**\n * `DomConverter` is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements bindings} between these nodes.\n *\n * An instance of the DOM converter is available under\n * {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * The DOM converter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep the\n * state of a tree nor keeps the synchronization between the tree view and the DOM tree (use {@link module:engine/view/document~Document}).\n *\n * The DOM converter keeps DOM elements to view element bindings, so when the converter gets destroyed, the bindings are lost.\n * Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n  /**\n   * Creates a DOM converter.\n   *\n   * @param {module:engine/view/document~Document} document The view document instance.\n   * @param {Object} options An object with configuration options.\n   * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode] The type of the block filler to use.\n   * Default value depends on the options.renderingMode:\n   *  'nbsp' when options.renderingMode == 'data',\n   *  'br' when options.renderingMode == 'editing'.\n   * @param {'data'|'editing'} [options.renderingMode='editing'] Whether to leave the View-to-DOM conversion result unchanged\n   * or improve editing experience by filtering out interactive data.\n   */\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /**\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.\n     *\n     * @member {'data'|'editing'} module:engine/view/domconverter~DomConverter#renderingMode\n     */\n    this.renderingMode = options.renderingMode || 'editing';\n    /**\n     * The mode of a block filler used by the DOM converter.\n     *\n     * @member {'br'|'nbsp'|'markedNbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n     */\n    this.blockFillerMode = options.blockFillerMode || (this.renderingMode === 'editing' ? 'br' : 'nbsp');\n    /**\n     * Elements which are considered pre-formatted elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n     */\n    this.preElements = ['pre'];\n    /**\n     * Elements which are considered block elements (and hence should be filled with a\n     * {@link #isBlockFiller block filler}).\n     *\n     * Whether an element is considered a block element also affects handling of trailing whitespaces.\n     *\n     * You can extend this array if you introduce support for block elements which are not yet recognized here.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n     */\n    this.blockElements = ['address', 'article', 'aside', 'blockquote', 'caption', 'center', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'legend', 'li', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'];\n    /**\n     * A list of elements that exist inline (in text) but their inner structure cannot be edited because\n     * of the way they are rendered by the browser. They are mostly HTML form elements but there are other\n     * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.\n     *\n     * Whether an element is considered an inline object has an impact on white space rendering (trimming)\n     * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.\n     *\n     * You can extend this array if you introduce support for inline object elements which are not yet recognized here.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#inlineObjectElements\n     */\n    this.inlineObjectElements = ['object', 'iframe', 'input', 'button', 'textarea', 'select', 'option', 'video', 'embed', 'audio', 'img', 'canvas'];\n    /**\n     * A list of elements which may affect the editing experience. To avoid this, those elements are replaced with\n     * `<span data-ck-unsafe-element=\"[element name]\"></span>` while rendering in the editing mode.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#unsafeElements\n     */\n    this.unsafeElements = ['script', 'style'];\n    /**\n     * The DOM Document used to create DOM nodes.\n     *\n     * @type {Document}\n     * @private\n     */\n    this._domDocument = this.renderingMode === 'editing' ? global.document : global.document.implementation.createHTMLDocument('');\n    /**\n     * The DOM-to-view mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n     */\n    this._domToViewMapping = new WeakMap();\n    /**\n     * The view-to-DOM mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n     */\n    this._viewToDomMapping = new WeakMap();\n    /**\n     * Holds the mapping between fake selection containers and corresponding view selections.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n     */\n    this._fakeSelectionMapping = new WeakMap();\n    /**\n     * Matcher for view elements whose content should be treated as raw data\n     * and not processed during the conversion from DOM nodes to view elements.\n     *\n     * @private\n     * @type {module:engine/view/matcher~Matcher}\n     */\n    this._rawContentElementMatcher = new Matcher();\n    /**\n     * A set of encountered raw content DOM nodes. It is used for preventing left trimming of the following text node.\n     *\n     * @private\n     * @type {WeakSet.<Node>}\n     */\n    this._encounteredRawContentDomNodes = new WeakSet();\n  }\n  /**\n   * Binds a given DOM element that represents fake selection to a **position** of a\n   * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n   * Document selection copy is stored and can be retrieved by the\n   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n   *\n   * @param {HTMLElement} domElement\n   * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n   */\n  bindFakeSelection(domElement, viewDocumentSelection) {\n    this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));\n  }\n  /**\n   * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given\n   * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.\n   *\n   * @param {HTMLElement} domElement\n   * @returns {module:engine/view/selection~Selection|undefined}\n   */\n  fakeSelectionToView(domElement) {\n    return this._fakeSelectionMapping.get(domElement);\n  }\n  /**\n   * Binds DOM and view elements, so it will be possible to get corresponding elements using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {HTMLElement} domElement The DOM element to bind.\n   * @param {module:engine/view/element~Element} viewElement The view element to bind.\n   */\n  bindElements(domElement, viewElement) {\n    this._domToViewMapping.set(domElement, viewElement);\n    this._viewToDomMapping.set(viewElement, domElement);\n  }\n  /**\n   * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of\n   * the DOM element will be unbound too.\n   *\n   * @param {HTMLElement} domElement The DOM element to unbind.\n   */\n  unbindDomElement(domElement) {\n    const viewElement = this._domToViewMapping.get(domElement);\n    if (viewElement) {\n      this._domToViewMapping.delete(domElement);\n      this._viewToDomMapping.delete(viewElement);\n      for (const child of Array.from(domElement.children)) {\n        this.unbindDomElement(child);\n      }\n    }\n  }\n  /**\n   * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {DocumentFragment} domFragment The DOM document fragment to bind.\n   * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment The view document fragment to bind.\n   */\n  bindDocumentFragments(domFragment, viewFragment) {\n    this._domToViewMapping.set(domFragment, viewFragment);\n    this._viewToDomMapping.set(viewFragment, domFragment);\n  }\n  /**\n   * Decides whether a given pair of attribute key and value should be passed further down the pipeline.\n   *\n   * @param {String} attributeKey\n   * @param {String} attributeValue\n   * @param {String} elementName Element name in lower case.\n   * @returns {Boolean}\n   */\n  shouldRenderAttribute(attributeKey, attributeValue, elementName) {\n    if (this.renderingMode === 'data') {\n      return true;\n    }\n    attributeKey = attributeKey.toLowerCase();\n    if (attributeKey.startsWith('on')) {\n      return false;\n    }\n    if (attributeKey === 'srcdoc' && attributeValue.match(/\\bon\\S+\\s*=|javascript:|<\\s*\\/*script/i)) {\n      return false;\n    }\n    if (elementName === 'img' && (attributeKey === 'src' || attributeKey === 'srcset')) {\n      return true;\n    }\n    if (elementName === 'source' && attributeKey === 'srcset') {\n      return true;\n    }\n    if (attributeValue.match(/^\\s*(javascript:|data:(image\\/svg|text\\/x?html))/i)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.\n   *\n   * @param {Element} domElement DOM element that should have `html` set as its content.\n   * @param {String} html Textual representation of the HTML that will be set on `domElement`.\n   */\n  setContentOf(domElement, html) {\n    // For data pipeline we pass the HTML as-is.\n    if (this.renderingMode === 'data') {\n      domElement.innerHTML = html;\n      return;\n    }\n    const document = new DOMParser().parseFromString(html, 'text/html');\n    const fragment = document.createDocumentFragment();\n    const bodyChildNodes = document.body.childNodes;\n    while (bodyChildNodes.length > 0) {\n      fragment.appendChild(bodyChildNodes[0]);\n    }\n    const treeWalker = document.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);\n    const nodes = [];\n    let currentNode;\n    // eslint-disable-next-line no-cond-assign\n    while (currentNode = treeWalker.nextNode()) {\n      nodes.push(currentNode);\n    }\n    for (const currentNode of nodes) {\n      // Go through nodes to remove those that are prohibited in editing pipeline.\n      for (const attributeName of currentNode.getAttributeNames()) {\n        this.setDomElementAttribute(currentNode, attributeName, currentNode.getAttribute(attributeName));\n      }\n      const elementName = currentNode.tagName.toLowerCase();\n      // There are certain nodes, that should be renamed to <span> in editing pipeline.\n      if (this._shouldRenameElement(elementName)) {\n        _logUnsafeElement(elementName);\n        currentNode.replaceWith(this._createReplacementDomElement(elementName, currentNode));\n      }\n    }\n    // Empty the target element.\n    while (domElement.firstChild) {\n      domElement.firstChild.remove();\n    }\n    domElement.append(fragment);\n  }\n  /**\n   * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments the method will return corresponding items.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View node or document fragment to transform.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n   */\n  viewToDom(viewNode) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (viewNode.is('$text')) {\n      const textData = this._processDataFromViewText(viewNode);\n      return this._domDocument.createTextNode(textData);\n    } else {\n      if (this.mapViewToDom(viewNode)) {\n        return this.mapViewToDom(viewNode);\n      }\n      let domElement;\n      if (viewNode.is('documentFragment')) {\n        // Create DOM document fragment.\n        domElement = this._domDocument.createDocumentFragment();\n        if (options.bind) {\n          this.bindDocumentFragments(domElement, viewNode);\n        }\n      } else if (viewNode.is('uiElement')) {\n        if (viewNode.name === '$comment') {\n          domElement = this._domDocument.createComment(viewNode.getCustomProperty('$rawContent'));\n        } else {\n          // UIElement has its own render() method (see #799).\n          domElement = viewNode.render(this._domDocument, this);\n        }\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        }\n        return domElement;\n      } else {\n        // Create DOM element.\n        if (this._shouldRenameElement(viewNode.name)) {\n          _logUnsafeElement(viewNode.name);\n          domElement = this._createReplacementDomElement(viewNode.name);\n        } else if (viewNode.hasAttribute('xmlns')) {\n          domElement = this._domDocument.createElementNS(viewNode.getAttribute('xmlns'), viewNode.name);\n        } else {\n          domElement = this._domDocument.createElement(viewNode.name);\n        }\n        // RawElement take care of their children in RawElement#render() method which can be customized\n        // (see https://github.com/ckeditor/ckeditor5/issues/4469).\n        if (viewNode.is('rawElement')) {\n          viewNode.render(domElement, this);\n        }\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        }\n        // Copy element's attributes.\n        for (const key of viewNode.getAttributeKeys()) {\n          this.setDomElementAttribute(domElement, key, viewNode.getAttribute(key), viewNode);\n        }\n      }\n      if (options.withChildren !== false) {\n        for (const child of this.viewChildrenToDom(viewNode, options)) {\n          domElement.appendChild(child);\n        }\n      }\n      return domElement;\n    }\n  }\n  /**\n   * Sets the attribute on a DOM element.\n   *\n   * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.\n   *\n   * @param {HTMLElement} domElement The DOM element the attribute should be set on.\n   * @param {String} key The name of the attribute.\n   * @param {String} value The value of the attribute.\n   * @param {module:engine/view/element~Element} [relatedViewElement] The view element related to the `domElement` (if there is any).\n   * It helps decide whether the attribute set is unsafe. For instance, view elements created via the\n   * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.\n   */\n  setDomElementAttribute(domElement, key, value, relatedViewElement) {\n    const shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);\n    if (!shouldRenderAttribute) {\n      logWarning('domconverter-unsafe-attribute-detected', {\n        domElement,\n        key,\n        value\n      });\n    }\n    // The old value was safe but the new value is unsafe.\n    if (domElement.hasAttribute(key) && !shouldRenderAttribute) {\n      domElement.removeAttribute(key);\n    }\n    // The old value was unsafe (but prefixed) but the new value will be safe (will be unprefixed).\n    else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {\n      domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);\n    }\n    // If the attribute should not be rendered, rename it (instead of removing) to give developers some idea of what\n    // is going on (https://github.com/ckeditor/ckeditor5/issues/10801).\n    domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);\n  }\n  /**\n   * Removes an attribute from a DOM element.\n   *\n   * **Note**: To set the attribute, use {@link #setDomElementAttribute}.\n   *\n   * @param {HTMLElement} domElement The DOM element the attribute should be removed from.\n   * @param {String} key The name of the attribute.\n   */\n  removeDomElementAttribute(domElement, key) {\n    // See #_createReplacementDomElement() to learn what this is.\n    if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {\n      return;\n    }\n    domElement.removeAttribute(key);\n    // See setDomElementAttribute() to learn what this is.\n    domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);\n  }\n  /**\n   * Converts children of the view element to DOM using the\n   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n   * @returns {Iterable.<Node>} DOM nodes.\n   */\n  *viewChildrenToDom(viewElement) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n    let offset = 0;\n    for (const childView of viewElement.getChildren()) {\n      if (fillerPositionOffset === offset) {\n        yield this._getBlockFiller();\n      }\n      const transparentRendering = childView.is('element') && childView.getCustomProperty('dataPipeline:transparentRendering');\n      if (transparentRendering && this.renderingMode == 'data') {\n        yield* this.viewChildrenToDom(childView, options);\n      } else {\n        if (transparentRendering) {\n          /**\n           * The `dataPipeline:transparentRendering` flag is supported only in the data pipeline.\n           *\n           * @error domconverter-transparent-rendering-unsupported-in-editing-pipeline\n           */\n          logWarning('domconverter-transparent-rendering-unsupported-in-editing-pipeline', {\n            viewElement: childView\n          });\n        }\n        yield this.viewToDom(childView, options);\n      }\n      offset++;\n    }\n    if (fillerPositionOffset === offset) {\n      yield this._getBlockFiller();\n    }\n  }\n  /**\n   * Converts view {@link module:engine/view/range~Range} to DOM range.\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   *\n   * @param {module:engine/view/range~Range} viewRange View range.\n   * @returns {Range} DOM range.\n   */\n  viewRangeToDom(viewRange) {\n    const domStart = this.viewPositionToDom(viewRange.start);\n    const domEnd = this.viewPositionToDom(viewRange.end);\n    const domRange = this._domDocument.createRange();\n    domRange.setStart(domStart.parent, domStart.offset);\n    domRange.setEnd(domEnd.parent, domEnd.offset);\n    return domRange;\n  }\n  /**\n   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n   *\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   * If the converted position is directly before inline filler it is moved inside the filler.\n   *\n   * @param {module:engine/view/position~Position} viewPosition View position.\n   * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n   * @returns {Node} position.parent DOM position parent.\n   * @returns {Number} position.offset DOM position offset.\n   */\n  viewPositionToDom(viewPosition) {\n    const viewParent = viewPosition.parent;\n    if (viewParent.is('$text')) {\n      const domParent = this.findCorrespondingDomText(viewParent);\n      if (!domParent) {\n        // Position is in a view text node that has not been rendered to DOM yet.\n        return null;\n      }\n      let offset = viewPosition.offset;\n      if (startsWithFiller(domParent)) {\n        offset += INLINE_FILLER_LENGTH;\n      }\n      return {\n        parent: domParent,\n        offset\n      };\n    } else {\n      // viewParent is instance of ViewElement.\n      let domParent, domBefore, domAfter;\n      if (viewPosition.offset === 0) {\n        domParent = this.mapViewToDom(viewParent);\n        if (!domParent) {\n          // Position is in a view element that has not been rendered to DOM yet.\n          return null;\n        }\n        domAfter = domParent.childNodes[0];\n      } else {\n        const nodeBefore = viewPosition.nodeBefore;\n        domBefore = nodeBefore.is('$text') ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(nodeBefore);\n        if (!domBefore) {\n          // Position is after a view element that has not been rendered to DOM yet.\n          return null;\n        }\n        domParent = domBefore.parentNode;\n        domAfter = domBefore.nextSibling;\n      }\n      // If there is an inline filler at position return position inside the filler. We should never return\n      // the position before the inline filler.\n      if (isText(domAfter) && startsWithFiller(domAfter)) {\n        return {\n          parent: domAfter,\n          offset: INLINE_FILLER_LENGTH\n        };\n      }\n      const offset = domBefore ? indexOf(domBefore) + 1 : 0;\n      return {\n        parent: domParent,\n        offset\n      };\n    }\n  }\n  /**\n   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments function will return corresponding items. For\n   * {@link module:engine/view/filler fillers} `null` will be returned.\n   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converted to lower case.\n   * @param {Boolean} [options.skipComments=false] If `false`, comment nodes will be converted to `$comment`\n   * {@link module:engine/view/uielement~UIElement view UI elements}.\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n   * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n   */\n  domToView(domNode) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.isBlockFiller(domNode)) {\n      return null;\n    }\n    // When node is inside a UIElement or a RawElement return that parent as it's view representation.\n    const hostElement = this.getHostViewElement(domNode);\n    if (hostElement) {\n      return hostElement;\n    }\n    if (isComment(domNode) && options.skipComments) {\n      return null;\n    }\n    if (isText(domNode)) {\n      if (isInlineFiller(domNode)) {\n        return null;\n      } else {\n        const textData = this._processDataFromDomText(domNode);\n        return textData === '' ? null : new ViewText(this.document, textData);\n      }\n    } else {\n      if (this.mapDomToView(domNode)) {\n        return this.mapDomToView(domNode);\n      }\n      let viewElement;\n      if (this.isDocumentFragment(domNode)) {\n        // Create view document fragment.\n        viewElement = new ViewDocumentFragment(this.document);\n        if (options.bind) {\n          this.bindDocumentFragments(domNode, viewElement);\n        }\n      } else {\n        // Create view element.\n        viewElement = this._createViewElement(domNode, options);\n        if (options.bind) {\n          this.bindElements(domNode, viewElement);\n        }\n        // Copy element's attributes.\n        const attrs = domNode.attributes;\n        if (attrs) {\n          for (let l = attrs.length, i = 0; i < l; i++) {\n            viewElement._setAttribute(attrs[i].name, attrs[i].value);\n          }\n        }\n        // Treat this element's content as a raw data if it was registered as such.\n        // Comment node is also treated as an element with raw data.\n        if (this._isViewElementWithRawContent(viewElement, options) || isComment(domNode)) {\n          const rawContent = isComment(domNode) ? domNode.data : domNode.innerHTML;\n          viewElement._setCustomProperty('$rawContent', rawContent);\n          // Store a DOM node to prevent left trimming of the following text node.\n          this._encounteredRawContentDomNodes.add(domNode);\n          return viewElement;\n        }\n      }\n      if (options.withChildren !== false) {\n        for (const child of this.domChildrenToView(domNode, options)) {\n          viewElement._appendChild(child);\n        }\n      }\n      return viewElement;\n    }\n  }\n  /**\n   * Converts children of the DOM element to view nodes using\n   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n   *\n   * @param {HTMLElement} domElement Parent DOM element.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n   */\n  *domChildrenToView(domElement, options) {\n    for (let i = 0; i < domElement.childNodes.length; i++) {\n      const domChild = domElement.childNodes[i];\n      const viewChild = this.domToView(domChild, options);\n      if (viewChild !== null) {\n        yield viewChild;\n      }\n    }\n  }\n  /**\n   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n   * Ranges which cannot be converted will be omitted.\n   *\n   * @param {Selection} domSelection DOM selection.\n   * @returns {module:engine/view/selection~Selection} View selection.\n   */\n  domSelectionToView(domSelection) {\n    // DOM selection might be placed in fake selection container.\n    // If container contains fake selection - return corresponding view selection.\n    if (domSelection.rangeCount === 1) {\n      let container = domSelection.getRangeAt(0).startContainer;\n      // The DOM selection might be moved to the text node inside the fake selection container.\n      if (isText(container)) {\n        container = container.parentNode;\n      }\n      const viewSelection = this.fakeSelectionToView(container);\n      if (viewSelection) {\n        return viewSelection;\n      }\n    }\n    const isBackward = this.isDomSelectionBackward(domSelection);\n    const viewRanges = [];\n    for (let i = 0; i < domSelection.rangeCount; i++) {\n      // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n      const domRange = domSelection.getRangeAt(i);\n      const viewRange = this.domRangeToView(domRange);\n      if (viewRange) {\n        viewRanges.push(viewRange);\n      }\n    }\n    return new ViewSelection(viewRanges, {\n      backward: isBackward\n    });\n  }\n  /**\n   * Converts DOM Range to view {@link module:engine/view/range~Range}.\n   * If the start or end position can not be converted `null` is returned.\n   *\n   * @param {Range} domRange DOM range.\n   * @returns {module:engine/view/range~Range|null} View range.\n   */\n  domRangeToView(domRange) {\n    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);\n    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);\n    if (viewStart && viewEnd) {\n      return new ViewRange(viewStart, viewEnd);\n    }\n    return null;\n  }\n  /**\n   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n   *\n   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n   * position of the filler will be converted and returned.\n   *\n   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n   * that position will be converted to view position before that UIElement.\n   *\n   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n   *\n   * @param {Node} domParent DOM position parent.\n   * @param {Number} [domOffset=0] DOM position offset. You can skip it when converting the inline filler node.\n   * @returns {module:engine/view/position~Position} viewPosition View position.\n   */\n  domPositionToView(domParent) {\n    let domOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this.isBlockFiller(domParent)) {\n      return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n    }\n    // If position is somewhere inside UIElement or a RawElement - return position before that element.\n    const viewElement = this.mapDomToView(domParent);\n    if (viewElement && (viewElement.is('uiElement') || viewElement.is('rawElement'))) {\n      return ViewPosition._createBefore(viewElement);\n    }\n    if (isText(domParent)) {\n      if (isInlineFiller(domParent)) {\n        return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n      }\n      const viewParent = this.findCorrespondingViewText(domParent);\n      let offset = domOffset;\n      if (!viewParent) {\n        return null;\n      }\n      if (startsWithFiller(domParent)) {\n        offset -= INLINE_FILLER_LENGTH;\n        offset = offset < 0 ? 0 : offset;\n      }\n      return new ViewPosition(viewParent, offset);\n    }\n    // domParent instanceof HTMLElement.\n    else {\n      if (domOffset === 0) {\n        const viewParent = this.mapDomToView(domParent);\n        if (viewParent) {\n          return new ViewPosition(viewParent, 0);\n        }\n      } else {\n        const domBefore = domParent.childNodes[domOffset - 1];\n        const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore);\n        // TODO #663\n        if (viewBefore && viewBefore.parent) {\n          return new ViewPosition(viewBefore.parent, viewBefore.index + 1);\n        }\n      }\n      return null;\n    }\n  }\n  /**\n   * Returns corresponding view {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * to the given DOM - `undefined` is returned.\n   *\n   * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or\n   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n   *\n   * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n   * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n   * Corresponding view element, document fragment or `undefined` if no element was bound.\n   */\n  mapDomToView(domElementOrDocumentFragment) {\n    const hostElement = this.getHostViewElement(domElementOrDocumentFragment);\n    return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or\n   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n   *\n   * Otherwise `null` is returned.\n   *\n   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n   *\n   * @param {Text} domText DOM text node.\n   * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n   * corresponding node.\n   */\n  findCorrespondingViewText(domText) {\n    if (isInlineFiller(domText)) {\n      return null;\n    }\n    // If DOM text was rendered by a UIElement or a RawElement - return this parent element.\n    const hostElement = this.getHostViewElement(domText);\n    if (hostElement) {\n      return hostElement;\n    }\n    const previousSibling = domText.previousSibling;\n    // Try to use previous sibling to find the corresponding text node.\n    if (previousSibling) {\n      if (!this.isElement(previousSibling)) {\n        // The previous is text or comment.\n        return null;\n      }\n      const viewElement = this.mapDomToView(previousSibling);\n      if (viewElement) {\n        const nextSibling = viewElement.nextSibling;\n        // It might be filler which has no corresponding view node.\n        if (nextSibling instanceof ViewText) {\n          return nextSibling;\n        } else {\n          return null;\n        }\n      }\n    }\n    // Try to use parent to find the corresponding text node.\n    else {\n      const viewElement = this.mapDomToView(domText.parentNode);\n      if (viewElement) {\n        const firstChild = viewElement.getChild(0);\n        // It might be filler which has no corresponding view node.\n        if (firstChild instanceof ViewText) {\n          return firstChild;\n        } else {\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n   * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n   * use {@link #findCorrespondingDomText}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View element or document fragment.\n   * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n   */\n  mapViewToDom(documentFragmentOrElement) {\n    return this._viewToDomMapping.get(documentFragmentOrElement);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * Otherwise `null` is returned.\n   *\n   * @param {module:engine/view/text~Text} viewText View text node.\n   * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n   */\n  findCorrespondingDomText(viewText) {\n    const previousSibling = viewText.previousSibling;\n    // Try to use previous sibling to find the corresponding text node.\n    if (previousSibling && this.mapViewToDom(previousSibling)) {\n      return this.mapViewToDom(previousSibling).nextSibling;\n    }\n    // If this is a first node, try to use parent to find the corresponding text node.\n    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {\n      return this.mapViewToDom(viewText.parent).childNodes[0];\n    }\n    return null;\n  }\n  /**\n   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n   *\n   * @param {module:engine/view/editableelement~EditableElement} viewEditable\n   */\n  focus(viewEditable) {\n    const domEditable = this.mapViewToDom(viewEditable);\n    if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {\n      // Save the scrollX and scrollY positions before the focus.\n      const {\n        scrollX,\n        scrollY\n      } = global.window;\n      const scrollPositions = [];\n      // Save all scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n      forEachDomElementAncestor(domEditable, node => {\n        const {\n          scrollLeft,\n          scrollTop\n        } = node;\n        scrollPositions.push([scrollLeft, scrollTop]);\n      });\n      domEditable.focus();\n      // Restore scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n      // https://github.com/ckeditor/ckeditor5-engine/issues/957\n      forEachDomElementAncestor(domEditable, node => {\n        const [scrollLeft, scrollTop] = scrollPositions.shift();\n        node.scrollLeft = scrollLeft;\n        node.scrollTop = scrollTop;\n      });\n      // Restore the scrollX and scrollY positions after the focus.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n      global.window.scrollTo(scrollX, scrollY);\n    }\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n  isElement(node) {\n    return node && node.nodeType == Node.ELEMENT_NODE;\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n  isDocumentFragment(node) {\n    return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Checks if the node is an instance of the block filler for this DOM converter.\n   *\n   *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n   *\n   *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n   *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n   *\n   * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n   *\n   * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n   *\n   * @param {Node} domNode DOM node to check.\n   * @returns {Boolean} True if a node is considered a block filler for given mode.\n   */\n  isBlockFiller(domNode) {\n    if (this.blockFillerMode == 'br') {\n      return domNode.isEqualNode(BR_FILLER_REF);\n    }\n    // Special case for <p><br></p> in which <br> should be treated as filler even when we are not in the 'br' mode. See ckeditor5#5564.\n    if (domNode.tagName === 'BR' && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {\n      return true;\n    }\n    // If not in 'br' mode, try recognizing both marked and regular nbsp block fillers.\n    return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);\n  }\n  /**\n   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n   *\n   * @param {Selection} DOM Selection instance to check.\n   * @returns {Boolean}\n   */\n  isDomSelectionBackward(selection) {\n    if (selection.isCollapsed) {\n      return false;\n    }\n    // Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n    // we will use the fact that range will collapse if it's end is before it's start.\n    const range = this._domDocument.createRange();\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(selection.focusNode, selection.focusOffset);\n    const backward = range.collapsed;\n    range.detach();\n    return backward;\n  }\n  /**\n   * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}\n   * that hosts the provided DOM node. Returns `null` if there is no such parent.\n   *\n   * @param {Node} domNode\n   * @returns {module:engine/view/uielement~UIElement|module:engine/view/rawelement~RawElement|null}\n   */\n  getHostViewElement(domNode) {\n    const ancestors = getAncestors(domNode);\n    // Remove domNode from the list.\n    ancestors.pop();\n    while (ancestors.length) {\n      const domNode = ancestors.pop();\n      const viewNode = this._domToViewMapping.get(domNode);\n      if (viewNode && (viewNode.is('uiElement') || viewNode.is('rawElement'))) {\n        return viewNode;\n      }\n    }\n    return null;\n  }\n  /**\n   * Checks if the given selection's boundaries are at correct places.\n   *\n   * The following places are considered as incorrect for selection boundaries:\n   *\n   * * before or in the middle of an inline filler sequence,\n   * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},\n   * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.\n   *\n   * @param {Selection} domSelection The DOM selection object to be checked.\n   * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n   */\n  isDomSelectionCorrect(domSelection) {\n    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);\n  }\n  /**\n   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data\n   * and not processed during the conversion from DOM nodes to view elements.\n   *\n   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and\n   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.\n   *\n   * The raw data can be later accessed by a\n   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `\"$rawContent\"`.\n   *\n   * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching a view element whose content should\n   * be treated as raw data.\n   */\n  registerRawContentMatcher(pattern) {\n    this._rawContentElementMatcher.add(pattern);\n  }\n  /**\n   * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.\n   *\n   * @private\n   * @returns {Node} filler\n   */\n  _getBlockFiller() {\n    switch (this.blockFillerMode) {\n      case 'nbsp':\n        return NBSP_FILLER(this._domDocument);\n      // eslint-disable-line new-cap\n      case 'markedNbsp':\n        return MARKED_NBSP_FILLER(this._domDocument);\n      // eslint-disable-line new-cap\n      case 'br':\n        return BR_FILLER(this._domDocument);\n      // eslint-disable-line new-cap\n    }\n  }\n  /**\n   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n   *\n   * @private\n   * @param {Element} domParent Position parent.\n   * @param {Number} offset Position offset.\n   * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n   */\n  _isDomSelectionPositionCorrect(domParent, offset) {\n    // If selection is before or in the middle of inline filler string, it is incorrect.\n    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {\n      // Selection in a text node, at wrong position (before or in the middle of filler).\n      return false;\n    }\n    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {\n      // Selection in an element node, before filler text node.\n      return false;\n    }\n    const viewParent = this.mapDomToView(domParent);\n    // The position is incorrect when anchored inside a UIElement or a RawElement.\n    // Note: In case of UIElement and RawElement, mapDomToView() returns a parent element for any DOM child\n    // so there's no need to perform any additional checks.\n    if (viewParent && (viewParent.is('uiElement') || viewParent.is('rawElement'))) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n   * it is correctly displayed in the DOM.\n   *\n   * Following changes are done:\n   *\n   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n   * element or if a previous text node ends with a space character,\n   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container,\n   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n   *\n   * Content of {@link #preElements} is not processed.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node View text node to process.\n   * @returns {String} Processed text data.\n   */\n  _processDataFromViewText(node) {\n    let data = node.data;\n    // If any of node ancestors has a name which is in `preElements` array, then currently processed\n    // view text node is (will be) in preformatted element. We should not change whitespaces then.\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return data;\n    }\n    // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n    // (container element boundary).\n    if (data.charAt(0) == ' ') {\n      const prevNode = this._getTouchingInlineViewNode(node, false);\n      const prevEndsWithSpace = prevNode && prevNode.is('$textProxy') && this._nodeEndsWithSpace(prevNode);\n      if (prevEndsWithSpace || !prevNode) {\n        data = '\\u00A0' + data.substr(1);\n      }\n    }\n    // 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n    // next node (container element boundary).\n    //\n    // Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n    //\n    // Foo <span>&nbsp;bar</span>  <-- bad.\n    // Foo&nbsp;<span> bar</span>  <-- good.\n    //\n    // More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n    if (data.charAt(data.length - 1) == ' ') {\n      const nextNode = this._getTouchingInlineViewNode(node, true);\n      const nextStartsWithSpace = nextNode && nextNode.is('$textProxy') && nextNode.data.charAt(0) == ' ';\n      if (data.charAt(data.length - 2) == ' ' || !nextNode || nextStartsWithSpace) {\n        data = data.substr(0, data.length - 1) + '\\u00A0';\n      }\n    }\n    // 3. Create space+nbsp pairs.\n    return data.replace(/ {2}/g, ' \\u00A0');\n  }\n  /**\n   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node Node to check.\n   * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n   */\n  _nodeEndsWithSpace(node) {\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return false;\n    }\n    const data = this._processDataFromViewText(node);\n    return data.charAt(data.length - 1) == ' ';\n  }\n  /**\n   * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n   *\n   * Following changes are done:\n   *\n   * * multiple whitespaces are replaced to a single space,\n   * * space at the beginning of a text node is removed if it is the first text node in its container\n   * element or if the previous text node ends with a space character,\n   * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container\n   * * nbsps are converted to spaces.\n   *\n   * @param {Node} node DOM text node to process.\n   * @returns {String} Processed data.\n   * @private\n   */\n  _processDataFromDomText(node) {\n    let data = node.data;\n    if (_hasDomParentOfType(node, this.preElements)) {\n      return getDataWithoutFiller(node);\n    }\n    // Change all consecutive whitespace characters (from the [ \\n\\t\\r] set \n    // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n    // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n    // We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n    data = data.replace(/[ \\n\\t\\r]{1,}/g, ' ');\n    const prevNode = this._getTouchingInlineDomNode(node, false);\n    const nextNode = this._getTouchingInlineDomNode(node, true);\n    const shouldLeftTrim = this._checkShouldLeftTrimDomText(node, prevNode);\n    const shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode);\n    // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n    // of this text node. Such space character is treated as a whitespace.\n    if (shouldLeftTrim) {\n      data = data.replace(/^ /, '');\n    }\n    // If the next text node does not exist remove space character from the end of this text node.\n    if (shouldRightTrim) {\n      data = data.replace(/ $/, '');\n    }\n    // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n    // This means that the text node starts/end with normal space instead of non-breaking space.\n    // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n    // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n    data = getDataWithoutFiller(new Text(data));\n    // At this point we should have removed all whitespaces from DOM text data.\n    //\n    // Now, We will reverse the process that happens in `_processDataFromViewText`.\n    //\n    // We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n    // First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n    // ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n    data = data.replace(/ \\u00A0/g, '  ');\n    const isNextNodeInlineObjectElement = nextNode && this.isElement(nextNode) && nextNode.tagName != 'BR';\n    const isNextNodeStartingWithSpace = nextNode && isText(nextNode) && nextNode.data.charAt(0) == ' ';\n    // Then, let's change the last nbsp to a space.\n    if (/( |\\u00A0)\\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {\n      data = data.replace(/\\u00A0$/, ' ');\n    }\n    // Then, change &nbsp; character that is at the beginning of the text node to space character.\n    // We do that replacement only if this is the first node or the previous node ends on whitespace character.\n    if (shouldLeftTrim || prevNode && this.isElement(prevNode) && prevNode.tagName != 'BR') {\n      data = data.replace(/^\\u00A0/, ' ');\n    }\n    // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n    // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n    return data;\n  }\n  /**\n   * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n   * be trimmed from the left side.\n   *\n   * @private\n   * @param {Node} node\n   * @param {Node} prevNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n   */\n  _checkShouldLeftTrimDomText(node, prevNode) {\n    if (!prevNode) {\n      return true;\n    }\n    if (this.isElement(prevNode)) {\n      return prevNode.tagName === 'BR';\n    }\n    // Shouldn't left trim if previous node is a node that was encountered as a raw content node.\n    if (this._encounteredRawContentDomNodes.has(node.previousSibling)) {\n      return false;\n    }\n    return /[^\\S\\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));\n  }\n  /**\n   * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n   * be trimmed from the right side.\n   *\n   * @private\n   * @param {Node} node\n   * @param {Node} nextNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n   */\n  _checkShouldRightTrimDomText(node, nextNode) {\n    if (nextNode) {\n      return false;\n    }\n    return !startsWithFiller(node);\n  }\n  /**\n   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n   * that is contained in the same container element. If there is no such sibling, `null` is returned.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node Reference node.\n   * @param {Boolean} getNext\n   * @returns {module:engine/view/text~Text|module:engine/view/element~Element|null} Touching text node, an inline object\n   * or `null` if there is no next or previous touching text node.\n   */\n  _getTouchingInlineViewNode(node, getNext) {\n    const treeWalker = new ViewTreeWalker({\n      startPosition: getNext ? ViewPosition._createAfter(node) : ViewPosition._createBefore(node),\n      direction: getNext ? 'forward' : 'backward'\n    });\n    for (const value of treeWalker) {\n      // Found an inline object (for example an image).\n      if (value.item.is('element') && this.inlineObjectElements.includes(value.item.name)) {\n        return value.item;\n      }\n      // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n      // text node in its container element.\n      else if (value.item.is('containerElement')) {\n        return null;\n      }\n      // <br> found  it works like a block boundary, so do not scan further.\n      else if (value.item.is('element', 'br')) {\n        return null;\n      }\n      // Found a text node in the same container element.\n      else if (value.item.is('$textProxy')) {\n        return value.item;\n      }\n    }\n    return null;\n  }\n  /**\n   * Helper function. For the given text node, it finds the closest touching node which is either\n   * a text, `<br>` or an {@link #inlineObjectElements inline object}.\n   *\n   * If no such node is found, `null` is returned.\n   *\n   * For instance, in the following DOM structure:\n   *\n   *\t\t<p>foo<b>bar</b><br>bom</p>\n   *\n   * * `foo` doesn't have its previous touching inline node (`null` is returned),\n   * * `foo`'s next touching inline node is `bar`\n   * * `bar`'s next touching inline node is `<br>`\n   *\n   * This method returns text nodes and `<br>` elements because these types of nodes affect how\n   * spaces in the given text node need to be converted.\n   *\n   * @private\n   * @param {Text} node\n   * @param {Boolean} getNext\n   * @returns {Text|Element|null}\n   */\n  _getTouchingInlineDomNode(node, getNext) {\n    if (!node.parentNode) {\n      return null;\n    }\n    const stepInto = getNext ? 'firstChild' : 'lastChild';\n    const stepOver = getNext ? 'nextSibling' : 'previousSibling';\n    let skipChildren = true;\n    let returnNode = node;\n    do {\n      if (!skipChildren && returnNode[stepInto]) {\n        returnNode = returnNode[stepInto];\n      } else if (returnNode[stepOver]) {\n        returnNode = returnNode[stepOver];\n        skipChildren = false;\n      } else {\n        returnNode = returnNode.parentNode;\n        skipChildren = true;\n      }\n      if (!returnNode || this._isBlockElement(returnNode)) {\n        return null;\n      }\n    } while (!(isText(returnNode) || returnNode.tagName == 'BR' || this._isInlineObjectElement(returnNode)));\n    return returnNode;\n  }\n  /**\n   * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.\n   *\n   * @private\n   * @param {Node} node\n   * @returns {Boolean}\n   */\n  _isBlockElement(node) {\n    return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());\n  }\n  /**\n   * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.\n   *\n   * @private\n   * @param {Node} node\n   * @returns {Boolean}\n   */\n  _isInlineObjectElement(node) {\n    return this.isElement(node) && this.inlineObjectElements.includes(node.tagName.toLowerCase());\n  }\n  /**\n   * Creates view element basing on the node type.\n   *\n   * @private\n   * @param {Node} node DOM node to check.\n   * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Element}\n   */\n  _createViewElement(node, options) {\n    if (isComment(node)) {\n      return new ViewUIElement(this.document, '$comment');\n    }\n    const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();\n    return new ViewElement(this.document, viewName);\n  }\n  /**\n   * Checks if view element's content should be treated as a raw data.\n   *\n   * @private\n   * @param {Element} viewElement View element to check.\n   * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Boolean}\n   */\n  _isViewElementWithRawContent(viewElement, options) {\n    return options.withChildren !== false && !!this._rawContentElementMatcher.match(viewElement);\n  }\n  /**\n   * Checks whether a given element name should be renamed in a current rendering mode.\n   *\n   * @private\n   * @param {String} elementName The name of view element.\n   * @returns {Boolean}\n   */\n  _shouldRenameElement(elementName) {\n    const name = elementName.toLowerCase();\n    return this.renderingMode === 'editing' && this.unsafeElements.includes(name);\n  }\n  /**\n   * Return a <span> element with a special attribute holding the name of the original element.\n   * Optionally, copy all the attributes of the original element if that element is provided.\n   *\n   * @private\n   * @param {String} elementName The name of view element.\n   * @param {Element} [originalDomElement] The original DOM element to copy attributes and content from.\n   * @returns {Element}\n   */\n  _createReplacementDomElement(elementName, originalDomElement) {\n    const newDomElement = this._domDocument.createElement('span');\n    // Mark the span replacing a script as hidden.\n    newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);\n    if (originalDomElement) {\n      while (originalDomElement.firstChild) {\n        newDomElement.appendChild(originalDomElement.firstChild);\n      }\n      for (const attributeName of originalDomElement.getAttributeNames()) {\n        newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));\n      }\n    }\n    return newDomElement;\n  }\n}\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType(node, types) {\n  const parents = getAncestors(node);\n  return parents.some(parent => parent.tagName && types.includes(parent.tagName.toLowerCase()));\n}\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomElementAncestor(element, callback) {\n  let node = element;\n  while (node) {\n    callback(node);\n    node = node.parentElement;\n  }\n}\n// Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\nfunction isNbspBlockFiller(domNode, blockElements) {\n  const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);\n  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;\n}\n// Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\nfunction hasBlockParent(domNode, blockElements) {\n  const parent = domNode.parentNode;\n  return !!parent && !!parent.tagName && blockElements.includes(parent.tagName.toLowerCase());\n}\n// Log to console the information about element that was replaced.\n// Check UNSAFE_ELEMENTS for all recognized unsafe elements.\n//\n// @param {String} elementName The name of the view element\nfunction _logUnsafeElement(elementName) {\n  if (elementName === 'script') {\n    logWarning('domconverter-unsafe-script-element-detected');\n  }\n  if (elementName === 'style') {\n    logWarning('domconverter-unsafe-style-element-detected');\n  }\n}\n/**\n * While rendering the editor content, the {@link module:engine/view/domconverter~DomConverter} detected a `<script>` element that may\n * disrupt the editing experience. To avoid this, the `<script>` element was replaced with `<span data-ck-unsafe-element=\"script\"></span>`.\n *\n * @error domconverter-unsafe-script-element-detected\n */\n/**\n * While rendering the editor content, the {@link module:engine/view/domconverter~DomConverter} detected a `<style>` element that may affect\n * the editing experience. To avoid this, the `<style>` element was replaced with `<span data-ck-unsafe-element=\"style\"></span>`.\n *\n * @error domconverter-unsafe-style-element-detected\n */\n/**\n * The {@link module:engine/view/domconverter~DomConverter} detected an interactive attribute in the\n * {@glink framework/guides/architecture/editing-engine#editing-pipeline editing pipeline}. For the best\n * editing experience, the attribute was renamed to `data-ck-unsafe-attribute-[original attribute name]`.\n *\n * If you are the author of the plugin that generated this attribute and you want it to be preserved\n * in the editing pipeline, you can configure this when creating the element\n * using {@link module:engine/view/downcastwriter~DowncastWriter} during the\n * {@glink framework/guides/architecture/editing-engine#conversion modelview conversion}. Methods such as\n * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement},\n * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement}, or\n * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement}\n * accept an option that will disable filtering of specific attributes:\n *\n *\t\tconst paragraph = writer.createContainerElement( 'p',\n *\t\t\t{\n *\t\t\t\tclass: 'clickable-paragraph',\n *\t\t\t\tonclick: 'alert( \"Paragraph clicked!\" )'\n *\t\t\t},\n *\t\t\t{\n *\t\t\t\t// Make sure the \"onclick\" attribute will pass through.\n *\t\t\t\trenderUnsafeAttributes: [ 'onclick' ]\n *\t\t\t}\n *\t\t);\n *\n * @error domconverter-unsafe-attribute-detected\n * @param {HTMLElement} domElement The DOM element the attribute was set on.\n * @param {String} key The original name of the attribute\n * @param {String} value The value of the original attribute\n */","map":{"version":3,"names":["ViewText","ViewElement","ViewUIElement","ViewPosition","ViewRange","ViewSelection","ViewDocumentFragment","ViewTreeWalker","default","Matcher","BR_FILLER","INLINE_FILLER_LENGTH","NBSP_FILLER","MARKED_NBSP_FILLER","getDataWithoutFiller","isInlineFiller","startsWithFiller","global","logWarning","indexOf","getAncestors","isText","isComment","BR_FILLER_REF","document","NBSP_FILLER_REF","MARKED_NBSP_FILLER_REF","UNSAFE_ATTRIBUTE_NAME_PREFIX","UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE","DomConverter","constructor","options","renderingMode","blockFillerMode","preElements","blockElements","inlineObjectElements","unsafeElements","_domDocument","implementation","createHTMLDocument","_domToViewMapping","WeakMap","_viewToDomMapping","_fakeSelectionMapping","_rawContentElementMatcher","_encounteredRawContentDomNodes","WeakSet","bindFakeSelection","domElement","viewDocumentSelection","set","fakeSelectionToView","get","bindElements","viewElement","unbindDomElement","delete","child","Array","from","children","bindDocumentFragments","domFragment","viewFragment","shouldRenderAttribute","attributeKey","attributeValue","elementName","toLowerCase","startsWith","match","setContentOf","html","innerHTML","DOMParser","parseFromString","fragment","createDocumentFragment","bodyChildNodes","body","childNodes","length","appendChild","treeWalker","createTreeWalker","NodeFilter","SHOW_ELEMENT","nodes","currentNode","nextNode","push","attributeName","getAttributeNames","setDomElementAttribute","getAttribute","tagName","_shouldRenameElement","_logUnsafeElement","replaceWith","_createReplacementDomElement","firstChild","remove","append","viewToDom","viewNode","is","textData","_processDataFromViewText","createTextNode","mapViewToDom","bind","name","createComment","getCustomProperty","render","hasAttribute","createElementNS","createElement","key","getAttributeKeys","withChildren","viewChildrenToDom","value","relatedViewElement","shouldRenderUnsafeAttribute","removeAttribute","setAttribute","removeDomElementAttribute","fillerPositionOffset","getFillerOffset","offset","childView","getChildren","_getBlockFiller","transparentRendering","viewRangeToDom","viewRange","domStart","viewPositionToDom","start","domEnd","end","domRange","createRange","setStart","parent","setEnd","viewPosition","viewParent","domParent","findCorrespondingDomText","domBefore","domAfter","nodeBefore","parentNode","nextSibling","domToView","domNode","isBlockFiller","hostElement","getHostViewElement","skipComments","_processDataFromDomText","mapDomToView","isDocumentFragment","_createViewElement","attrs","attributes","l","i","_setAttribute","_isViewElementWithRawContent","rawContent","data","_setCustomProperty","add","domChildrenToView","_appendChild","domChild","viewChild","domSelectionToView","domSelection","rangeCount","container","getRangeAt","startContainer","viewSelection","isBackward","isDomSelectionBackward","viewRanges","domRangeToView","backward","viewStart","domPositionToView","startOffset","viewEnd","endContainer","endOffset","domOffset","_createBefore","findCorrespondingViewText","viewBefore","index","domElementOrDocumentFragment","domText","previousSibling","isElement","getChild","documentFragmentOrElement","viewText","focus","viewEditable","domEditable","ownerDocument","activeElement","scrollX","scrollY","window","scrollPositions","forEachDomElementAncestor","node","scrollLeft","scrollTop","shift","scrollTo","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","isEqualNode","hasBlockParent","isNbspBlockFiller","selection","isCollapsed","range","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","detach","ancestors","pop","isDomSelectionCorrect","_isDomSelectionPositionCorrect","registerRawContentMatcher","pattern","some","includes","charAt","prevNode","_getTouchingInlineViewNode","prevEndsWithSpace","_nodeEndsWithSpace","substr","nextStartsWithSpace","replace","_hasDomParentOfType","_getTouchingInlineDomNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","Text","isNextNodeInlineObjectElement","isNextNodeStartingWithSpace","test","has","getNext","startPosition","_createAfter","direction","item","stepInto","stepOver","skipChildren","returnNode","_isBlockElement","_isInlineObjectElement","viewName","keepOriginalCase","originalDomElement","newDomElement","types","parents","element","callback","parentElement","isNBSP"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/domconverter\n */\n/* globals Node, NodeFilter, DOMParser, Text */\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewUIElement from './uielement';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { default as Matcher } from './matcher';\nimport { BR_FILLER, INLINE_FILLER_LENGTH, NBSP_FILLER, MARKED_NBSP_FILLER, getDataWithoutFiller, isInlineFiller, startsWithFiller } from './filler';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nconst BR_FILLER_REF = BR_FILLER(global.document); // eslint-disable-line new-cap\nconst NBSP_FILLER_REF = NBSP_FILLER(global.document); // eslint-disable-line new-cap\nconst MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(global.document); // eslint-disable-line new-cap\nconst UNSAFE_ATTRIBUTE_NAME_PREFIX = 'data-ck-unsafe-attribute-';\nconst UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = 'data-ck-unsafe-element';\n/**\n * `DomConverter` is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements bindings} between these nodes.\n *\n * An instance of the DOM converter is available under\n * {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * The DOM converter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep the\n * state of a tree nor keeps the synchronization between the tree view and the DOM tree (use {@link module:engine/view/document~Document}).\n *\n * The DOM converter keeps DOM elements to view element bindings, so when the converter gets destroyed, the bindings are lost.\n * Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n    /**\n     * Creates a DOM converter.\n     *\n     * @param {module:engine/view/document~Document} document The view document instance.\n     * @param {Object} options An object with configuration options.\n     * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode] The type of the block filler to use.\n     * Default value depends on the options.renderingMode:\n     *  'nbsp' when options.renderingMode == 'data',\n     *  'br' when options.renderingMode == 'editing'.\n     * @param {'data'|'editing'} [options.renderingMode='editing'] Whether to leave the View-to-DOM conversion result unchanged\n     * or improve editing experience by filtering out interactive data.\n     */\n    constructor(document, options = {}) {\n        /**\n         * @readonly\n         * @type {module:engine/view/document~Document}\n         */\n        this.document = document;\n        /**\n         * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.\n         *\n         * @member {'data'|'editing'} module:engine/view/domconverter~DomConverter#renderingMode\n         */\n        this.renderingMode = options.renderingMode || 'editing';\n        /**\n         * The mode of a block filler used by the DOM converter.\n         *\n         * @member {'br'|'nbsp'|'markedNbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n         */\n        this.blockFillerMode = options.blockFillerMode || (this.renderingMode === 'editing' ? 'br' : 'nbsp');\n        /**\n         * Elements which are considered pre-formatted elements.\n         *\n         * @readonly\n         * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n         */\n        this.preElements = ['pre'];\n        /**\n         * Elements which are considered block elements (and hence should be filled with a\n         * {@link #isBlockFiller block filler}).\n         *\n         * Whether an element is considered a block element also affects handling of trailing whitespaces.\n         *\n         * You can extend this array if you introduce support for block elements which are not yet recognized here.\n         *\n         * @readonly\n         * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n         */\n        this.blockElements = [\n            'address', 'article', 'aside', 'blockquote', 'caption', 'center', 'dd', 'details', 'dir', 'div',\n            'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header',\n            'hgroup', 'legend', 'li', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'summary', 'table', 'tbody',\n            'td', 'tfoot', 'th', 'thead', 'tr', 'ul'\n        ];\n        /**\n         * A list of elements that exist inline (in text) but their inner structure cannot be edited because\n         * of the way they are rendered by the browser. They are mostly HTML form elements but there are other\n         * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.\n         *\n         * Whether an element is considered an inline object has an impact on white space rendering (trimming)\n         * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.\n         *\n         * You can extend this array if you introduce support for inline object elements which are not yet recognized here.\n         *\n         * @readonly\n         * @member {Array.<String>} module:engine/view/domconverter~DomConverter#inlineObjectElements\n         */\n        this.inlineObjectElements = [\n            'object', 'iframe', 'input', 'button', 'textarea', 'select', 'option', 'video', 'embed', 'audio', 'img', 'canvas'\n        ];\n        /**\n         * A list of elements which may affect the editing experience. To avoid this, those elements are replaced with\n         * `<span data-ck-unsafe-element=\"[element name]\"></span>` while rendering in the editing mode.\n         *\n         * @readonly\n         * @member {Array.<String>} module:engine/view/domconverter~DomConverter#unsafeElements\n         */\n        this.unsafeElements = ['script', 'style'];\n        /**\n         * The DOM Document used to create DOM nodes.\n         *\n         * @type {Document}\n         * @private\n         */\n        this._domDocument = this.renderingMode === 'editing' ? global.document : global.document.implementation.createHTMLDocument('');\n        /**\n         * The DOM-to-view mapping.\n         *\n         * @private\n         * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n         */\n        this._domToViewMapping = new WeakMap();\n        /**\n         * The view-to-DOM mapping.\n         *\n         * @private\n         * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n         */\n        this._viewToDomMapping = new WeakMap();\n        /**\n         * Holds the mapping between fake selection containers and corresponding view selections.\n         *\n         * @private\n         * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n         */\n        this._fakeSelectionMapping = new WeakMap();\n        /**\n         * Matcher for view elements whose content should be treated as raw data\n         * and not processed during the conversion from DOM nodes to view elements.\n         *\n         * @private\n         * @type {module:engine/view/matcher~Matcher}\n         */\n        this._rawContentElementMatcher = new Matcher();\n        /**\n         * A set of encountered raw content DOM nodes. It is used for preventing left trimming of the following text node.\n         *\n         * @private\n         * @type {WeakSet.<Node>}\n         */\n        this._encounteredRawContentDomNodes = new WeakSet();\n    }\n    /**\n     * Binds a given DOM element that represents fake selection to a **position** of a\n     * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n     * Document selection copy is stored and can be retrieved by the\n     * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n     *\n     * @param {HTMLElement} domElement\n     * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n     */\n    bindFakeSelection(domElement, viewDocumentSelection) {\n        this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));\n    }\n    /**\n     * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given\n     * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.\n     *\n     * @param {HTMLElement} domElement\n     * @returns {module:engine/view/selection~Selection|undefined}\n     */\n    fakeSelectionToView(domElement) {\n        return this._fakeSelectionMapping.get(domElement);\n    }\n    /**\n     * Binds DOM and view elements, so it will be possible to get corresponding elements using\n     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n     *\n     * @param {HTMLElement} domElement The DOM element to bind.\n     * @param {module:engine/view/element~Element} viewElement The view element to bind.\n     */\n    bindElements(domElement, viewElement) {\n        this._domToViewMapping.set(domElement, viewElement);\n        this._viewToDomMapping.set(viewElement, domElement);\n    }\n    /**\n     * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of\n     * the DOM element will be unbound too.\n     *\n     * @param {HTMLElement} domElement The DOM element to unbind.\n     */\n    unbindDomElement(domElement) {\n        const viewElement = this._domToViewMapping.get(domElement);\n        if (viewElement) {\n            this._domToViewMapping.delete(domElement);\n            this._viewToDomMapping.delete(viewElement);\n            for (const child of Array.from(domElement.children)) {\n                this.unbindDomElement(child);\n            }\n        }\n    }\n    /**\n     * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using\n     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n     *\n     * @param {DocumentFragment} domFragment The DOM document fragment to bind.\n     * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment The view document fragment to bind.\n     */\n    bindDocumentFragments(domFragment, viewFragment) {\n        this._domToViewMapping.set(domFragment, viewFragment);\n        this._viewToDomMapping.set(viewFragment, domFragment);\n    }\n    /**\n     * Decides whether a given pair of attribute key and value should be passed further down the pipeline.\n     *\n     * @param {String} attributeKey\n     * @param {String} attributeValue\n     * @param {String} elementName Element name in lower case.\n     * @returns {Boolean}\n     */\n    shouldRenderAttribute(attributeKey, attributeValue, elementName) {\n        if (this.renderingMode === 'data') {\n            return true;\n        }\n        attributeKey = attributeKey.toLowerCase();\n        if (attributeKey.startsWith('on')) {\n            return false;\n        }\n        if (attributeKey === 'srcdoc' &&\n            attributeValue.match(/\\bon\\S+\\s*=|javascript:|<\\s*\\/*script/i)) {\n            return false;\n        }\n        if (elementName === 'img' &&\n            (attributeKey === 'src' || attributeKey === 'srcset')) {\n            return true;\n        }\n        if (elementName === 'source' && attributeKey === 'srcset') {\n            return true;\n        }\n        if (attributeValue.match(/^\\s*(javascript:|data:(image\\/svg|text\\/x?html))/i)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.\n     *\n     * @param {Element} domElement DOM element that should have `html` set as its content.\n     * @param {String} html Textual representation of the HTML that will be set on `domElement`.\n     */\n    setContentOf(domElement, html) {\n        // For data pipeline we pass the HTML as-is.\n        if (this.renderingMode === 'data') {\n            domElement.innerHTML = html;\n            return;\n        }\n        const document = new DOMParser().parseFromString(html, 'text/html');\n        const fragment = document.createDocumentFragment();\n        const bodyChildNodes = document.body.childNodes;\n        while (bodyChildNodes.length > 0) {\n            fragment.appendChild(bodyChildNodes[0]);\n        }\n        const treeWalker = document.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);\n        const nodes = [];\n        let currentNode;\n        // eslint-disable-next-line no-cond-assign\n        while (currentNode = treeWalker.nextNode()) {\n            nodes.push(currentNode);\n        }\n        for (const currentNode of nodes) {\n            // Go through nodes to remove those that are prohibited in editing pipeline.\n            for (const attributeName of currentNode.getAttributeNames()) {\n                this.setDomElementAttribute(currentNode, attributeName, currentNode.getAttribute(attributeName));\n            }\n            const elementName = currentNode.tagName.toLowerCase();\n            // There are certain nodes, that should be renamed to <span> in editing pipeline.\n            if (this._shouldRenameElement(elementName)) {\n                _logUnsafeElement(elementName);\n                currentNode.replaceWith(this._createReplacementDomElement(elementName, currentNode));\n            }\n        }\n        // Empty the target element.\n        while (domElement.firstChild) {\n            domElement.firstChild.remove();\n        }\n        domElement.append(fragment);\n    }\n    /**\n     * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will\n     * be created. For bound elements and document fragments the method will return corresponding items.\n     *\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n     * View node or document fragment to transform.\n     * @param {Object} [options] Conversion options.\n     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n     * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n     */\n    viewToDom(viewNode, options = {}) {\n        if (viewNode.is('$text')) {\n            const textData = this._processDataFromViewText(viewNode);\n            return this._domDocument.createTextNode(textData);\n        }\n        else {\n            if (this.mapViewToDom(viewNode)) {\n                return this.mapViewToDom(viewNode);\n            }\n            let domElement;\n            if (viewNode.is('documentFragment')) {\n                // Create DOM document fragment.\n                domElement = this._domDocument.createDocumentFragment();\n                if (options.bind) {\n                    this.bindDocumentFragments(domElement, viewNode);\n                }\n            }\n            else if (viewNode.is('uiElement')) {\n                if (viewNode.name === '$comment') {\n                    domElement = this._domDocument.createComment(viewNode.getCustomProperty('$rawContent'));\n                }\n                else {\n                    // UIElement has its own render() method (see #799).\n                    domElement = viewNode.render(this._domDocument, this);\n                }\n                if (options.bind) {\n                    this.bindElements(domElement, viewNode);\n                }\n                return domElement;\n            }\n            else {\n                // Create DOM element.\n                if (this._shouldRenameElement(viewNode.name)) {\n                    _logUnsafeElement(viewNode.name);\n                    domElement = this._createReplacementDomElement(viewNode.name);\n                }\n                else if (viewNode.hasAttribute('xmlns')) {\n                    domElement = this._domDocument.createElementNS(viewNode.getAttribute('xmlns'), viewNode.name);\n                }\n                else {\n                    domElement = this._domDocument.createElement(viewNode.name);\n                }\n                // RawElement take care of their children in RawElement#render() method which can be customized\n                // (see https://github.com/ckeditor/ckeditor5/issues/4469).\n                if (viewNode.is('rawElement')) {\n                    viewNode.render(domElement, this);\n                }\n                if (options.bind) {\n                    this.bindElements(domElement, viewNode);\n                }\n                // Copy element's attributes.\n                for (const key of viewNode.getAttributeKeys()) {\n                    this.setDomElementAttribute(domElement, key, viewNode.getAttribute(key), viewNode);\n                }\n            }\n            if (options.withChildren !== false) {\n                for (const child of this.viewChildrenToDom(viewNode, options)) {\n                    domElement.appendChild(child);\n                }\n            }\n            return domElement;\n        }\n    }\n    /**\n     * Sets the attribute on a DOM element.\n     *\n     * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.\n     *\n     * @param {HTMLElement} domElement The DOM element the attribute should be set on.\n     * @param {String} key The name of the attribute.\n     * @param {String} value The value of the attribute.\n     * @param {module:engine/view/element~Element} [relatedViewElement] The view element related to the `domElement` (if there is any).\n     * It helps decide whether the attribute set is unsafe. For instance, view elements created via the\n     * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.\n     */\n    setDomElementAttribute(domElement, key, value, relatedViewElement) {\n        const shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) ||\n            relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);\n        if (!shouldRenderAttribute) {\n            logWarning('domconverter-unsafe-attribute-detected', { domElement, key, value });\n        }\n        // The old value was safe but the new value is unsafe.\n        if (domElement.hasAttribute(key) && !shouldRenderAttribute) {\n            domElement.removeAttribute(key);\n        }\n        // The old value was unsafe (but prefixed) but the new value will be safe (will be unprefixed).\n        else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {\n            domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);\n        }\n        // If the attribute should not be rendered, rename it (instead of removing) to give developers some idea of what\n        // is going on (https://github.com/ckeditor/ckeditor5/issues/10801).\n        domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);\n    }\n    /**\n     * Removes an attribute from a DOM element.\n     *\n     * **Note**: To set the attribute, use {@link #setDomElementAttribute}.\n     *\n     * @param {HTMLElement} domElement The DOM element the attribute should be removed from.\n     * @param {String} key The name of the attribute.\n     */\n    removeDomElementAttribute(domElement, key) {\n        // See #_createReplacementDomElement() to learn what this is.\n        if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {\n            return;\n        }\n        domElement.removeAttribute(key);\n        // See setDomElementAttribute() to learn what this is.\n        domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);\n    }\n    /**\n     * Converts children of the view element to DOM using the\n     * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n     * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n     * @returns {Iterable.<Node>} DOM nodes.\n     */\n    *viewChildrenToDom(viewElement, options = {}) {\n        const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n        let offset = 0;\n        for (const childView of viewElement.getChildren()) {\n            if (fillerPositionOffset === offset) {\n                yield this._getBlockFiller();\n            }\n            const transparentRendering = childView.is('element') &&\n                childView.getCustomProperty('dataPipeline:transparentRendering');\n            if (transparentRendering && this.renderingMode == 'data') {\n                yield* this.viewChildrenToDom(childView, options);\n            }\n            else {\n                if (transparentRendering) {\n                    /**\n                     * The `dataPipeline:transparentRendering` flag is supported only in the data pipeline.\n                     *\n                     * @error domconverter-transparent-rendering-unsupported-in-editing-pipeline\n                     */\n                    logWarning('domconverter-transparent-rendering-unsupported-in-editing-pipeline', { viewElement: childView });\n                }\n                yield this.viewToDom(childView, options);\n            }\n            offset++;\n        }\n        if (fillerPositionOffset === offset) {\n            yield this._getBlockFiller();\n        }\n    }\n    /**\n     * Converts view {@link module:engine/view/range~Range} to DOM range.\n     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n     *\n     * @param {module:engine/view/range~Range} viewRange View range.\n     * @returns {Range} DOM range.\n     */\n    viewRangeToDom(viewRange) {\n        const domStart = this.viewPositionToDom(viewRange.start);\n        const domEnd = this.viewPositionToDom(viewRange.end);\n        const domRange = this._domDocument.createRange();\n        domRange.setStart(domStart.parent, domStart.offset);\n        domRange.setEnd(domEnd.parent, domEnd.offset);\n        return domRange;\n    }\n    /**\n     * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n     *\n     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n     * If the converted position is directly before inline filler it is moved inside the filler.\n     *\n     * @param {module:engine/view/position~Position} viewPosition View position.\n     * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n     * @returns {Node} position.parent DOM position parent.\n     * @returns {Number} position.offset DOM position offset.\n     */\n    viewPositionToDom(viewPosition) {\n        const viewParent = viewPosition.parent;\n        if (viewParent.is('$text')) {\n            const domParent = this.findCorrespondingDomText(viewParent);\n            if (!domParent) {\n                // Position is in a view text node that has not been rendered to DOM yet.\n                return null;\n            }\n            let offset = viewPosition.offset;\n            if (startsWithFiller(domParent)) {\n                offset += INLINE_FILLER_LENGTH;\n            }\n            return { parent: domParent, offset };\n        }\n        else {\n            // viewParent is instance of ViewElement.\n            let domParent, domBefore, domAfter;\n            if (viewPosition.offset === 0) {\n                domParent = this.mapViewToDom(viewParent);\n                if (!domParent) {\n                    // Position is in a view element that has not been rendered to DOM yet.\n                    return null;\n                }\n                domAfter = domParent.childNodes[0];\n            }\n            else {\n                const nodeBefore = viewPosition.nodeBefore;\n                domBefore = nodeBefore.is('$text') ?\n                    this.findCorrespondingDomText(nodeBefore) :\n                    this.mapViewToDom(nodeBefore);\n                if (!domBefore) {\n                    // Position is after a view element that has not been rendered to DOM yet.\n                    return null;\n                }\n                domParent = domBefore.parentNode;\n                domAfter = domBefore.nextSibling;\n            }\n            // If there is an inline filler at position return position inside the filler. We should never return\n            // the position before the inline filler.\n            if (isText(domAfter) && startsWithFiller(domAfter)) {\n                return { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n            }\n            const offset = domBefore ? indexOf(domBefore) + 1 : 0;\n            return { parent: domParent, offset };\n        }\n    }\n    /**\n     * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n     * be created. For bound elements and document fragments function will return corresponding items. For\n     * {@link module:engine/view/filler fillers} `null` will be returned.\n     * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n     *\n     * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n     * @param {Object} [options] Conversion options.\n     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n     * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converted to lower case.\n     * @param {Boolean} [options.skipComments=false] If `false`, comment nodes will be converted to `$comment`\n     * {@link module:engine/view/uielement~UIElement view UI elements}.\n     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n     * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n     */\n    domToView(domNode, options = {}) {\n        if (this.isBlockFiller(domNode)) {\n            return null;\n        }\n        // When node is inside a UIElement or a RawElement return that parent as it's view representation.\n        const hostElement = this.getHostViewElement(domNode);\n        if (hostElement) {\n            return hostElement;\n        }\n        if (isComment(domNode) && options.skipComments) {\n            return null;\n        }\n        if (isText(domNode)) {\n            if (isInlineFiller(domNode)) {\n                return null;\n            }\n            else {\n                const textData = this._processDataFromDomText(domNode);\n                return textData === '' ? null : new ViewText(this.document, textData);\n            }\n        }\n        else {\n            if (this.mapDomToView(domNode)) {\n                return this.mapDomToView(domNode);\n            }\n            let viewElement;\n            if (this.isDocumentFragment(domNode)) {\n                // Create view document fragment.\n                viewElement = new ViewDocumentFragment(this.document);\n                if (options.bind) {\n                    this.bindDocumentFragments(domNode, viewElement);\n                }\n            }\n            else {\n                // Create view element.\n                viewElement = this._createViewElement(domNode, options);\n                if (options.bind) {\n                    this.bindElements(domNode, viewElement);\n                }\n                // Copy element's attributes.\n                const attrs = domNode.attributes;\n                if (attrs) {\n                    for (let l = attrs.length, i = 0; i < l; i++) {\n                        viewElement._setAttribute(attrs[i].name, attrs[i].value);\n                    }\n                }\n                // Treat this element's content as a raw data if it was registered as such.\n                // Comment node is also treated as an element with raw data.\n                if (this._isViewElementWithRawContent(viewElement, options) || isComment(domNode)) {\n                    const rawContent = isComment(domNode) ? domNode.data : domNode.innerHTML;\n                    viewElement._setCustomProperty('$rawContent', rawContent);\n                    // Store a DOM node to prevent left trimming of the following text node.\n                    this._encounteredRawContentDomNodes.add(domNode);\n                    return viewElement;\n                }\n            }\n            if (options.withChildren !== false) {\n                for (const child of this.domChildrenToView(domNode, options)) {\n                    viewElement._appendChild(child);\n                }\n            }\n            return viewElement;\n        }\n    }\n    /**\n     * Converts children of the DOM element to view nodes using\n     * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n     * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n     *\n     * @param {HTMLElement} domElement Parent DOM element.\n     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n     * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n     */\n    *domChildrenToView(domElement, options) {\n        for (let i = 0; i < domElement.childNodes.length; i++) {\n            const domChild = domElement.childNodes[i];\n            const viewChild = this.domToView(domChild, options);\n            if (viewChild !== null) {\n                yield viewChild;\n            }\n        }\n    }\n    /**\n     * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n     * Ranges which cannot be converted will be omitted.\n     *\n     * @param {Selection} domSelection DOM selection.\n     * @returns {module:engine/view/selection~Selection} View selection.\n     */\n    domSelectionToView(domSelection) {\n        // DOM selection might be placed in fake selection container.\n        // If container contains fake selection - return corresponding view selection.\n        if (domSelection.rangeCount === 1) {\n            let container = domSelection.getRangeAt(0).startContainer;\n            // The DOM selection might be moved to the text node inside the fake selection container.\n            if (isText(container)) {\n                container = container.parentNode;\n            }\n            const viewSelection = this.fakeSelectionToView(container);\n            if (viewSelection) {\n                return viewSelection;\n            }\n        }\n        const isBackward = this.isDomSelectionBackward(domSelection);\n        const viewRanges = [];\n        for (let i = 0; i < domSelection.rangeCount; i++) {\n            // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n            const domRange = domSelection.getRangeAt(i);\n            const viewRange = this.domRangeToView(domRange);\n            if (viewRange) {\n                viewRanges.push(viewRange);\n            }\n        }\n        return new ViewSelection(viewRanges, { backward: isBackward });\n    }\n    /**\n     * Converts DOM Range to view {@link module:engine/view/range~Range}.\n     * If the start or end position can not be converted `null` is returned.\n     *\n     * @param {Range} domRange DOM range.\n     * @returns {module:engine/view/range~Range|null} View range.\n     */\n    domRangeToView(domRange) {\n        const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);\n        const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);\n        if (viewStart && viewEnd) {\n            return new ViewRange(viewStart, viewEnd);\n        }\n        return null;\n    }\n    /**\n     * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n     *\n     * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n     * position of the filler will be converted and returned.\n     *\n     * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n     * that position will be converted to view position before that UIElement.\n     *\n     * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n     *\n     * @param {Node} domParent DOM position parent.\n     * @param {Number} [domOffset=0] DOM position offset. You can skip it when converting the inline filler node.\n     * @returns {module:engine/view/position~Position} viewPosition View position.\n     */\n    domPositionToView(domParent, domOffset = 0) {\n        if (this.isBlockFiller(domParent)) {\n            return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n        }\n        // If position is somewhere inside UIElement or a RawElement - return position before that element.\n        const viewElement = this.mapDomToView(domParent);\n        if (viewElement && (viewElement.is('uiElement') || viewElement.is('rawElement'))) {\n            return ViewPosition._createBefore(viewElement);\n        }\n        if (isText(domParent)) {\n            if (isInlineFiller(domParent)) {\n                return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n            }\n            const viewParent = this.findCorrespondingViewText(domParent);\n            let offset = domOffset;\n            if (!viewParent) {\n                return null;\n            }\n            if (startsWithFiller(domParent)) {\n                offset -= INLINE_FILLER_LENGTH;\n                offset = offset < 0 ? 0 : offset;\n            }\n            return new ViewPosition(viewParent, offset);\n        }\n        // domParent instanceof HTMLElement.\n        else {\n            if (domOffset === 0) {\n                const viewParent = this.mapDomToView(domParent);\n                if (viewParent) {\n                    return new ViewPosition(viewParent, 0);\n                }\n            }\n            else {\n                const domBefore = domParent.childNodes[domOffset - 1];\n                const viewBefore = isText(domBefore) ?\n                    this.findCorrespondingViewText(domBefore) :\n                    this.mapDomToView(domBefore);\n                // TODO #663\n                if (viewBefore && viewBefore.parent) {\n                    return new ViewPosition(viewBefore.parent, viewBefore.index + 1);\n                }\n            }\n            return null;\n        }\n    }\n    /**\n     * Returns corresponding view {@link module:engine/view/element~Element Element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n     * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * to the given DOM - `undefined` is returned.\n     *\n     * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or\n     * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n     *\n     * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n     * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n     * Corresponding view element, document fragment or `undefined` if no element was bound.\n     */\n    mapDomToView(domElementOrDocumentFragment) {\n        const hostElement = this.getHostViewElement(domElementOrDocumentFragment);\n        return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);\n    }\n    /**\n     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n     * corresponding text node is returned based on the sibling or parent.\n     *\n     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n     * to find the corresponding text node.\n     *\n     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * element, it is used to find the corresponding text node.\n     *\n     * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or\n     * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n     *\n     * Otherwise `null` is returned.\n     *\n     * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n     *\n     * @param {Text} domText DOM text node.\n     * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n     * corresponding node.\n     */\n    findCorrespondingViewText(domText) {\n        if (isInlineFiller(domText)) {\n            return null;\n        }\n        // If DOM text was rendered by a UIElement or a RawElement - return this parent element.\n        const hostElement = this.getHostViewElement(domText);\n        if (hostElement) {\n            return hostElement;\n        }\n        const previousSibling = domText.previousSibling;\n        // Try to use previous sibling to find the corresponding text node.\n        if (previousSibling) {\n            if (!(this.isElement(previousSibling))) {\n                // The previous is text or comment.\n                return null;\n            }\n            const viewElement = this.mapDomToView(previousSibling);\n            if (viewElement) {\n                const nextSibling = viewElement.nextSibling;\n                // It might be filler which has no corresponding view node.\n                if (nextSibling instanceof ViewText) {\n                    return nextSibling;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        // Try to use parent to find the corresponding text node.\n        else {\n            const viewElement = this.mapDomToView(domText.parentNode);\n            if (viewElement) {\n                const firstChild = viewElement.getChild(0);\n                // It might be filler which has no corresponding view node.\n                if (firstChild instanceof ViewText) {\n                    return firstChild;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n     * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n     * use {@link #findCorrespondingDomText}.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n     * View element or document fragment.\n     * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n     */\n    mapViewToDom(documentFragmentOrElement) {\n        return this._viewToDomMapping.get(documentFragmentOrElement);\n    }\n    /**\n     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n     * corresponding text node is returned based on the sibling or parent.\n     *\n     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n     * to find the corresponding text node.\n     *\n     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * element, it is used to find the corresponding text node.\n     *\n     * Otherwise `null` is returned.\n     *\n     * @param {module:engine/view/text~Text} viewText View text node.\n     * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n     */\n    findCorrespondingDomText(viewText) {\n        const previousSibling = viewText.previousSibling;\n        // Try to use previous sibling to find the corresponding text node.\n        if (previousSibling && this.mapViewToDom(previousSibling)) {\n            return this.mapViewToDom(previousSibling).nextSibling;\n        }\n        // If this is a first node, try to use parent to find the corresponding text node.\n        if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {\n            return this.mapViewToDom(viewText.parent).childNodes[0];\n        }\n        return null;\n    }\n    /**\n     * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n     *\n     * @param {module:engine/view/editableelement~EditableElement} viewEditable\n     */\n    focus(viewEditable) {\n        const domEditable = this.mapViewToDom(viewEditable);\n        if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {\n            // Save the scrollX and scrollY positions before the focus.\n            const { scrollX, scrollY } = global.window;\n            const scrollPositions = [];\n            // Save all scrollLeft and scrollTop values starting from domEditable up to\n            // document#documentElement.\n            forEachDomElementAncestor(domEditable, node => {\n                const { scrollLeft, scrollTop } = node;\n                scrollPositions.push([scrollLeft, scrollTop]);\n            });\n            domEditable.focus();\n            // Restore scrollLeft and scrollTop values starting from domEditable up to\n            // document#documentElement.\n            // https://github.com/ckeditor/ckeditor5-engine/issues/951\n            // https://github.com/ckeditor/ckeditor5-engine/issues/957\n            forEachDomElementAncestor(domEditable, node => {\n                const [scrollLeft, scrollTop] = scrollPositions.shift();\n                node.scrollLeft = scrollLeft;\n                node.scrollTop = scrollTop;\n            });\n            // Restore the scrollX and scrollY positions after the focus.\n            // https://github.com/ckeditor/ckeditor5-engine/issues/951\n            global.window.scrollTo(scrollX, scrollY);\n        }\n    }\n    /**\n     * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n     *\n     * @param {Node} node Node to check.\n     * @returns {Boolean}\n     */\n    isElement(node) {\n        return node && node.nodeType == Node.ELEMENT_NODE;\n    }\n    /**\n     * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n     *\n     * @param {Node} node Node to check.\n     * @returns {Boolean}\n     */\n    isDocumentFragment(node) {\n        return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n    }\n    /**\n     * Checks if the node is an instance of the block filler for this DOM converter.\n     *\n     *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n     *\n     *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n     *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n     *\n     * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n     *\n     * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n     *\n     * @param {Node} domNode DOM node to check.\n     * @returns {Boolean} True if a node is considered a block filler for given mode.\n     */\n    isBlockFiller(domNode) {\n        if (this.blockFillerMode == 'br') {\n            return domNode.isEqualNode(BR_FILLER_REF);\n        }\n        // Special case for <p><br></p> in which <br> should be treated as filler even when we are not in the 'br' mode. See ckeditor5#5564.\n        if (domNode.tagName === 'BR' &&\n            hasBlockParent(domNode, this.blockElements) &&\n            domNode.parentNode.childNodes.length === 1) {\n            return true;\n        }\n        // If not in 'br' mode, try recognizing both marked and regular nbsp block fillers.\n        return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);\n    }\n    /**\n     * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n     *\n     * @param {Selection} DOM Selection instance to check.\n     * @returns {Boolean}\n     */\n    isDomSelectionBackward(selection) {\n        if (selection.isCollapsed) {\n            return false;\n        }\n        // Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n        // we will use the fact that range will collapse if it's end is before it's start.\n        const range = this._domDocument.createRange();\n        range.setStart(selection.anchorNode, selection.anchorOffset);\n        range.setEnd(selection.focusNode, selection.focusOffset);\n        const backward = range.collapsed;\n        range.detach();\n        return backward;\n    }\n    /**\n     * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}\n     * that hosts the provided DOM node. Returns `null` if there is no such parent.\n     *\n     * @param {Node} domNode\n     * @returns {module:engine/view/uielement~UIElement|module:engine/view/rawelement~RawElement|null}\n     */\n    getHostViewElement(domNode) {\n        const ancestors = getAncestors(domNode);\n        // Remove domNode from the list.\n        ancestors.pop();\n        while (ancestors.length) {\n            const domNode = ancestors.pop();\n            const viewNode = this._domToViewMapping.get(domNode);\n            if (viewNode && (viewNode.is('uiElement') || viewNode.is('rawElement'))) {\n                return viewNode;\n            }\n        }\n        return null;\n    }\n    /**\n     * Checks if the given selection's boundaries are at correct places.\n     *\n     * The following places are considered as incorrect for selection boundaries:\n     *\n     * * before or in the middle of an inline filler sequence,\n     * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},\n     * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.\n     *\n     * @param {Selection} domSelection The DOM selection object to be checked.\n     * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n     */\n    isDomSelectionCorrect(domSelection) {\n        return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) &&\n            this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);\n    }\n    /**\n     * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data\n     * and not processed during the conversion from DOM nodes to view elements.\n     *\n     * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and\n     * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.\n     *\n     * The raw data can be later accessed by a\n     * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `\"$rawContent\"`.\n     *\n     * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching a view element whose content should\n     * be treated as raw data.\n     */\n    registerRawContentMatcher(pattern) {\n        this._rawContentElementMatcher.add(pattern);\n    }\n    /**\n     * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.\n     *\n     * @private\n     * @returns {Node} filler\n     */\n    _getBlockFiller() {\n        switch (this.blockFillerMode) {\n            case 'nbsp':\n                return NBSP_FILLER(this._domDocument); // eslint-disable-line new-cap\n            case 'markedNbsp':\n                return MARKED_NBSP_FILLER(this._domDocument); // eslint-disable-line new-cap\n            case 'br':\n                return BR_FILLER(this._domDocument); // eslint-disable-line new-cap\n        }\n    }\n    /**\n     * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n     *\n     * @private\n     * @param {Element} domParent Position parent.\n     * @param {Number} offset Position offset.\n     * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n     */\n    _isDomSelectionPositionCorrect(domParent, offset) {\n        // If selection is before or in the middle of inline filler string, it is incorrect.\n        if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {\n            // Selection in a text node, at wrong position (before or in the middle of filler).\n            return false;\n        }\n        if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {\n            // Selection in an element node, before filler text node.\n            return false;\n        }\n        const viewParent = this.mapDomToView(domParent);\n        // The position is incorrect when anchored inside a UIElement or a RawElement.\n        // Note: In case of UIElement and RawElement, mapDomToView() returns a parent element for any DOM child\n        // so there's no need to perform any additional checks.\n        if (viewParent && (viewParent.is('uiElement') || viewParent.is('rawElement'))) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n     * it is correctly displayed in the DOM.\n     *\n     * Following changes are done:\n     *\n     * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n     * element or if a previous text node ends with a space character,\n     * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n     * starts with a space or if it is the last text node in its container,\n     * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n     *\n     * Content of {@link #preElements} is not processed.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node View text node to process.\n     * @returns {String} Processed text data.\n     */\n    _processDataFromViewText(node) {\n        let data = node.data;\n        // If any of node ancestors has a name which is in `preElements` array, then currently processed\n        // view text node is (will be) in preformatted element. We should not change whitespaces then.\n        if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n            return data;\n        }\n        // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n        // (container element boundary).\n        if (data.charAt(0) == ' ') {\n            const prevNode = this._getTouchingInlineViewNode(node, false);\n            const prevEndsWithSpace = prevNode && prevNode.is('$textProxy') && this._nodeEndsWithSpace(prevNode);\n            if (prevEndsWithSpace || !prevNode) {\n                data = '\\u00A0' + data.substr(1);\n            }\n        }\n        // 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n        // next node (container element boundary).\n        //\n        // Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n        //\n        // Foo <span>&nbsp;bar</span>  <-- bad.\n        // Foo&nbsp;<span> bar</span>  <-- good.\n        //\n        // More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n        if (data.charAt(data.length - 1) == ' ') {\n            const nextNode = this._getTouchingInlineViewNode(node, true);\n            const nextStartsWithSpace = nextNode && nextNode.is('$textProxy') && nextNode.data.charAt(0) == ' ';\n            if (data.charAt(data.length - 2) == ' ' || !nextNode || nextStartsWithSpace) {\n                data = data.substr(0, data.length - 1) + '\\u00A0';\n            }\n        }\n        // 3. Create space+nbsp pairs.\n        return data.replace(/ {2}/g, ' \\u00A0');\n    }\n    /**\n     * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node Node to check.\n     * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n     */\n    _nodeEndsWithSpace(node) {\n        if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n            return false;\n        }\n        const data = this._processDataFromViewText(node);\n        return data.charAt(data.length - 1) == ' ';\n    }\n    /**\n     * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n     *\n     * Following changes are done:\n     *\n     * * multiple whitespaces are replaced to a single space,\n     * * space at the beginning of a text node is removed if it is the first text node in its container\n     * element or if the previous text node ends with a space character,\n     * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n     * starts with a space or if it is the last text node in its container\n     * * nbsps are converted to spaces.\n     *\n     * @param {Node} node DOM text node to process.\n     * @returns {String} Processed data.\n     * @private\n     */\n    _processDataFromDomText(node) {\n        let data = node.data;\n        if (_hasDomParentOfType(node, this.preElements)) {\n            return getDataWithoutFiller(node);\n        }\n        // Change all consecutive whitespace characters (from the [ \\n\\t\\r] set \n        // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n        // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n        // We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n        data = data.replace(/[ \\n\\t\\r]{1,}/g, ' ');\n        const prevNode = this._getTouchingInlineDomNode(node, false);\n        const nextNode = this._getTouchingInlineDomNode(node, true);\n        const shouldLeftTrim = this._checkShouldLeftTrimDomText(node, prevNode);\n        const shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode);\n        // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n        // of this text node. Such space character is treated as a whitespace.\n        if (shouldLeftTrim) {\n            data = data.replace(/^ /, '');\n        }\n        // If the next text node does not exist remove space character from the end of this text node.\n        if (shouldRightTrim) {\n            data = data.replace(/ $/, '');\n        }\n        // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n        // This means that the text node starts/end with normal space instead of non-breaking space.\n        // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n        // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n        data = getDataWithoutFiller(new Text(data));\n        // At this point we should have removed all whitespaces from DOM text data.\n        //\n        // Now, We will reverse the process that happens in `_processDataFromViewText`.\n        //\n        // We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n        // First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n        // ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n        data = data.replace(/ \\u00A0/g, '  ');\n        const isNextNodeInlineObjectElement = nextNode && this.isElement(nextNode) && nextNode.tagName != 'BR';\n        const isNextNodeStartingWithSpace = nextNode && isText(nextNode) && nextNode.data.charAt(0) == ' ';\n        // Then, let's change the last nbsp to a space.\n        if (/( |\\u00A0)\\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {\n            data = data.replace(/\\u00A0$/, ' ');\n        }\n        // Then, change &nbsp; character that is at the beginning of the text node to space character.\n        // We do that replacement only if this is the first node or the previous node ends on whitespace character.\n        if (shouldLeftTrim || prevNode && this.isElement(prevNode) && prevNode.tagName != 'BR') {\n            data = data.replace(/^\\u00A0/, ' ');\n        }\n        // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n        // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n        return data;\n    }\n    /**\n     * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n     * be trimmed from the left side.\n     *\n     * @private\n     * @param {Node} node\n     * @param {Node} prevNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n     */\n    _checkShouldLeftTrimDomText(node, prevNode) {\n        if (!prevNode) {\n            return true;\n        }\n        if (this.isElement(prevNode)) {\n            return prevNode.tagName === 'BR';\n        }\n        // Shouldn't left trim if previous node is a node that was encountered as a raw content node.\n        if (this._encounteredRawContentDomNodes.has(node.previousSibling)) {\n            return false;\n        }\n        return /[^\\S\\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));\n    }\n    /**\n     * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n     * be trimmed from the right side.\n     *\n     * @private\n     * @param {Node} node\n     * @param {Node} nextNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n     */\n    _checkShouldRightTrimDomText(node, nextNode) {\n        if (nextNode) {\n            return false;\n        }\n        return !startsWithFiller(node);\n    }\n    /**\n     * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n     * that is contained in the same container element. If there is no such sibling, `null` is returned.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node Reference node.\n     * @param {Boolean} getNext\n     * @returns {module:engine/view/text~Text|module:engine/view/element~Element|null} Touching text node, an inline object\n     * or `null` if there is no next or previous touching text node.\n     */\n    _getTouchingInlineViewNode(node, getNext) {\n        const treeWalker = new ViewTreeWalker({\n            startPosition: getNext ? ViewPosition._createAfter(node) : ViewPosition._createBefore(node),\n            direction: getNext ? 'forward' : 'backward'\n        });\n        for (const value of treeWalker) {\n            // Found an inline object (for example an image).\n            if (value.item.is('element') && this.inlineObjectElements.includes(value.item.name)) {\n                return value.item;\n            }\n            // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n            // text node in its container element.\n            else if (value.item.is('containerElement')) {\n                return null;\n            }\n            // <br> found  it works like a block boundary, so do not scan further.\n            else if (value.item.is('element', 'br')) {\n                return null;\n            }\n            // Found a text node in the same container element.\n            else if (value.item.is('$textProxy')) {\n                return value.item;\n            }\n        }\n        return null;\n    }\n    /**\n     * Helper function. For the given text node, it finds the closest touching node which is either\n     * a text, `<br>` or an {@link #inlineObjectElements inline object}.\n     *\n     * If no such node is found, `null` is returned.\n     *\n     * For instance, in the following DOM structure:\n     *\n     *\t\t<p>foo<b>bar</b><br>bom</p>\n     *\n     * * `foo` doesn't have its previous touching inline node (`null` is returned),\n     * * `foo`'s next touching inline node is `bar`\n     * * `bar`'s next touching inline node is `<br>`\n     *\n     * This method returns text nodes and `<br>` elements because these types of nodes affect how\n     * spaces in the given text node need to be converted.\n     *\n     * @private\n     * @param {Text} node\n     * @param {Boolean} getNext\n     * @returns {Text|Element|null}\n     */\n    _getTouchingInlineDomNode(node, getNext) {\n        if (!node.parentNode) {\n            return null;\n        }\n        const stepInto = getNext ? 'firstChild' : 'lastChild';\n        const stepOver = getNext ? 'nextSibling' : 'previousSibling';\n        let skipChildren = true;\n        let returnNode = node;\n        do {\n            if (!skipChildren && returnNode[stepInto]) {\n                returnNode = returnNode[stepInto];\n            }\n            else if (returnNode[stepOver]) {\n                returnNode = returnNode[stepOver];\n                skipChildren = false;\n            }\n            else {\n                returnNode = returnNode.parentNode;\n                skipChildren = true;\n            }\n            if (!returnNode || this._isBlockElement(returnNode)) {\n                return null;\n            }\n        } while (!(isText(returnNode) || returnNode.tagName == 'BR' || this._isInlineObjectElement(returnNode)));\n        return returnNode;\n    }\n    /**\n     * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.\n     *\n     * @private\n     * @param {Node} node\n     * @returns {Boolean}\n     */\n    _isBlockElement(node) {\n        return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());\n    }\n    /**\n     * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.\n     *\n     * @private\n     * @param {Node} node\n     * @returns {Boolean}\n     */\n    _isInlineObjectElement(node) {\n        return this.isElement(node) && this.inlineObjectElements.includes(node.tagName.toLowerCase());\n    }\n    /**\n     * Creates view element basing on the node type.\n     *\n     * @private\n     * @param {Node} node DOM node to check.\n     * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n     * @returns {Element}\n     */\n    _createViewElement(node, options) {\n        if (isComment(node)) {\n            return new ViewUIElement(this.document, '$comment');\n        }\n        const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();\n        return new ViewElement(this.document, viewName);\n    }\n    /**\n     * Checks if view element's content should be treated as a raw data.\n     *\n     * @private\n     * @param {Element} viewElement View element to check.\n     * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n     * @returns {Boolean}\n     */\n    _isViewElementWithRawContent(viewElement, options) {\n        return options.withChildren !== false && !!this._rawContentElementMatcher.match(viewElement);\n    }\n    /**\n     * Checks whether a given element name should be renamed in a current rendering mode.\n     *\n     * @private\n     * @param {String} elementName The name of view element.\n     * @returns {Boolean}\n     */\n    _shouldRenameElement(elementName) {\n        const name = elementName.toLowerCase();\n        return this.renderingMode === 'editing' && this.unsafeElements.includes(name);\n    }\n    /**\n     * Return a <span> element with a special attribute holding the name of the original element.\n     * Optionally, copy all the attributes of the original element if that element is provided.\n     *\n     * @private\n     * @param {String} elementName The name of view element.\n     * @param {Element} [originalDomElement] The original DOM element to copy attributes and content from.\n     * @returns {Element}\n     */\n    _createReplacementDomElement(elementName, originalDomElement) {\n        const newDomElement = this._domDocument.createElement('span');\n        // Mark the span replacing a script as hidden.\n        newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);\n        if (originalDomElement) {\n            while (originalDomElement.firstChild) {\n                newDomElement.appendChild(originalDomElement.firstChild);\n            }\n            for (const attributeName of originalDomElement.getAttributeNames()) {\n                newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));\n            }\n        }\n        return newDomElement;\n    }\n}\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType(node, types) {\n    const parents = getAncestors(node);\n    return parents.some(parent => parent.tagName && types.includes(parent.tagName.toLowerCase()));\n}\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomElementAncestor(element, callback) {\n    let node = element;\n    while (node) {\n        callback(node);\n        node = node.parentElement;\n    }\n}\n// Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\nfunction isNbspBlockFiller(domNode, blockElements) {\n    const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);\n    return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;\n}\n// Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\nfunction hasBlockParent(domNode, blockElements) {\n    const parent = domNode.parentNode;\n    return !!parent && !!parent.tagName && blockElements.includes(parent.tagName.toLowerCase());\n}\n// Log to console the information about element that was replaced.\n// Check UNSAFE_ELEMENTS for all recognized unsafe elements.\n//\n// @param {String} elementName The name of the view element\nfunction _logUnsafeElement(elementName) {\n    if (elementName === 'script') {\n        logWarning('domconverter-unsafe-script-element-detected');\n    }\n    if (elementName === 'style') {\n        logWarning('domconverter-unsafe-style-element-detected');\n    }\n}\n/**\n * While rendering the editor content, the {@link module:engine/view/domconverter~DomConverter} detected a `<script>` element that may\n * disrupt the editing experience. To avoid this, the `<script>` element was replaced with `<span data-ck-unsafe-element=\"script\"></span>`.\n *\n * @error domconverter-unsafe-script-element-detected\n */\n/**\n * While rendering the editor content, the {@link module:engine/view/domconverter~DomConverter} detected a `<style>` element that may affect\n * the editing experience. To avoid this, the `<style>` element was replaced with `<span data-ck-unsafe-element=\"style\"></span>`.\n *\n * @error domconverter-unsafe-style-element-detected\n */\n/**\n * The {@link module:engine/view/domconverter~DomConverter} detected an interactive attribute in the\n * {@glink framework/guides/architecture/editing-engine#editing-pipeline editing pipeline}. For the best\n * editing experience, the attribute was renamed to `data-ck-unsafe-attribute-[original attribute name]`.\n *\n * If you are the author of the plugin that generated this attribute and you want it to be preserved\n * in the editing pipeline, you can configure this when creating the element\n * using {@link module:engine/view/downcastwriter~DowncastWriter} during the\n * {@glink framework/guides/architecture/editing-engine#conversion modelview conversion}. Methods such as\n * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement},\n * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement}, or\n * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement}\n * accept an option that will disable filtering of specific attributes:\n *\n *\t\tconst paragraph = writer.createContainerElement( 'p',\n *\t\t\t{\n *\t\t\t\tclass: 'clickable-paragraph',\n *\t\t\t\tonclick: 'alert( \"Paragraph clicked!\" )'\n *\t\t\t},\n *\t\t\t{\n *\t\t\t\t// Make sure the \"onclick\" attribute will pass through.\n *\t\t\t\trenderUnsafeAttributes: [ 'onclick' ]\n *\t\t\t}\n *\t\t);\n *\n * @error domconverter-unsafe-attribute-detected\n * @param {HTMLElement} domElement The DOM element the attribute was set on.\n * @param {String} key The original name of the attribute\n * @param {String} value The value of the original attribute\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}