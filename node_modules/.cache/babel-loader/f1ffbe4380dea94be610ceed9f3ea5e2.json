{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/nodelist\n */\nimport Node from './node';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport spliceArray from '@ckeditor/ckeditor5-utils/src/splicearray';\n/**\n * Provides an interface to operate on a list of {@link module:engine/model/node~Node nodes}. `NodeList` is used internally\n * in classes like {@link module:engine/model/element~Element Element}\n * or {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.\n */\nexport default class NodeList {\n  /**\n   * Creates an empty node list.\n   *\n   * @protected\n   * @param {Iterable.<module:engine/model/node~Node>} [nodes] Nodes contained in this node list.\n   */\n  constructor(nodes) {\n    /**\n     * Nodes contained in this node list.\n     *\n     * @private\n     * @member {Array.<module:engine/model/node~Node>}\n     */\n    this._nodes = [];\n    if (nodes) {\n      this._insertNodes(0, nodes);\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all nodes contained inside this node list.\n   *\n   * @returns {Iterator.<module:engine/model/node~Node>}\n   */\n  [Symbol.iterator]() {\n    return this._nodes[Symbol.iterator]();\n  }\n  /**\n   * Number of nodes contained inside this node list.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get length() {\n    return this._nodes.length;\n  }\n  /**\n   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get maxOffset() {\n    return this._nodes.reduce((sum, node) => sum + node.offsetSize, 0);\n  }\n  /**\n   * Gets the node at the given index. Returns `null` if incorrect index was passed.\n   *\n   * @param {Number} index Index of node.\n   * @returns {module:engine/model/node~Node|null} Node at given index.\n   */\n  getNode(index) {\n    return this._nodes[index] || null;\n  }\n  /**\n   * Returns an index of the given node. Returns `null` if given node is not inside this node list.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number|null} Child node's index.\n   */\n  getNodeIndex(node) {\n    const index = this._nodes.indexOf(node);\n    return index == -1 ? null : index;\n  }\n  /**\n   * Returns the starting offset of given node. Starting offset is equal to the sum of\n   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.\n   *\n   * @param {module:engine/model/node~Node} node Node to look for.\n   * @returns {Number|null} Node's starting offset.\n   */\n  getNodeStartOffset(node) {\n    const index = this.getNodeIndex(node);\n    return index === null ? null : this._nodes.slice(0, index).reduce((sum, node) => sum + node.offsetSize, 0);\n  }\n  /**\n   * Converts index to offset in node list.\n   *\n   * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.\n   *\n   * @param {Number} index Node's index.\n   * @returns {Number} Node's starting offset.\n   */\n  indexToOffset(index) {\n    if (index == this._nodes.length) {\n      return this.maxOffset;\n    }\n    const node = this._nodes[index];\n    if (!node) {\n      /**\n       * Given index cannot be found in the node list.\n       *\n       * @error model-nodelist-index-out-of-bounds\n       */\n      throw new CKEditorError('model-nodelist-index-out-of-bounds', this);\n    }\n    return this.getNodeStartOffset(node);\n  }\n  /**\n   * Converts offset in node list to index.\n   *\n   * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.\n   *\n   * @param {Number} offset Offset to look for.\n   * @returns {Number} Index of a node that occupies given offset.\n   */\n  offsetToIndex(offset) {\n    let totalOffset = 0;\n    for (const node of this._nodes) {\n      if (offset >= totalOffset && offset < totalOffset + node.offsetSize) {\n        return this.getNodeIndex(node);\n      }\n      totalOffset += node.offsetSize;\n    }\n    if (totalOffset != offset) {\n      /**\n       * Given offset cannot be found in the node list.\n       *\n       * @error model-nodelist-offset-out-of-bounds\n       * @param {Number} offset\n       * @param {module:engine/model/nodelist~NodeList} nodeList Stringified node list.\n       */\n      throw new CKEditorError('model-nodelist-offset-out-of-bounds', this, {\n        offset,\n        nodeList: this\n      });\n    }\n    return this.length;\n  }\n  /**\n   * Inserts given nodes at given index.\n   *\n   * @internal\n   * @protected\n   * @param {Number} index Index at which nodes should be inserted.\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.\n   */\n  _insertNodes(index, nodes) {\n    // Validation.\n    for (const node of nodes) {\n      if (!(node instanceof Node)) {\n        /**\n         * Trying to insert an object which is not a Node instance.\n         *\n         * @error model-nodelist-insertnodes-not-node\n         */\n        throw new CKEditorError('model-nodelist-insertnodes-not-node', this);\n      }\n    }\n    this._nodes = spliceArray(this._nodes, Array.from(nodes), index, 0);\n  }\n  /**\n   * Removes one or more nodes starting at the given index.\n   *\n   * @internal\n   * @protected\n   * @param {Number} indexStart Index of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n   */\n  _removeNodes(indexStart) {\n    let howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return this._nodes.splice(indexStart, howMany);\n  }\n  /**\n   * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes\n   * are also converted to their plain object representation.\n   *\n   * @returns {Array.<module:engine/model/node~Node>} `NodeList` instance converted to `Array`.\n   */\n  toJSON() {\n    return this._nodes.map(node => node.toJSON());\n  }\n}","map":{"version":3,"names":["Node","CKEditorError","spliceArray","NodeList","constructor","nodes","_nodes","_insertNodes","Symbol","iterator","length","maxOffset","reduce","sum","node","offsetSize","getNode","index","getNodeIndex","indexOf","getNodeStartOffset","slice","indexToOffset","offsetToIndex","offset","totalOffset","nodeList","Array","from","_removeNodes","indexStart","howMany","splice","toJSON","map"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/model/nodelist.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/model/nodelist\n */\nimport Node from './node';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport spliceArray from '@ckeditor/ckeditor5-utils/src/splicearray';\n/**\n * Provides an interface to operate on a list of {@link module:engine/model/node~Node nodes}. `NodeList` is used internally\n * in classes like {@link module:engine/model/element~Element Element}\n * or {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.\n */\nexport default class NodeList {\n    /**\n     * Creates an empty node list.\n     *\n     * @protected\n     * @param {Iterable.<module:engine/model/node~Node>} [nodes] Nodes contained in this node list.\n     */\n    constructor(nodes) {\n        /**\n         * Nodes contained in this node list.\n         *\n         * @private\n         * @member {Array.<module:engine/model/node~Node>}\n         */\n        this._nodes = [];\n        if (nodes) {\n            this._insertNodes(0, nodes);\n        }\n    }\n    /**\n     * Iterable interface.\n     *\n     * Iterates over all nodes contained inside this node list.\n     *\n     * @returns {Iterator.<module:engine/model/node~Node>}\n     */\n    [Symbol.iterator]() {\n        return this._nodes[Symbol.iterator]();\n    }\n    /**\n     * Number of nodes contained inside this node list.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get length() {\n        return this._nodes.length;\n    }\n    /**\n     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get maxOffset() {\n        return this._nodes.reduce((sum, node) => sum + node.offsetSize, 0);\n    }\n    /**\n     * Gets the node at the given index. Returns `null` if incorrect index was passed.\n     *\n     * @param {Number} index Index of node.\n     * @returns {module:engine/model/node~Node|null} Node at given index.\n     */\n    getNode(index) {\n        return this._nodes[index] || null;\n    }\n    /**\n     * Returns an index of the given node. Returns `null` if given node is not inside this node list.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number|null} Child node's index.\n     */\n    getNodeIndex(node) {\n        const index = this._nodes.indexOf(node);\n        return index == -1 ? null : index;\n    }\n    /**\n     * Returns the starting offset of given node. Starting offset is equal to the sum of\n     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.\n     *\n     * @param {module:engine/model/node~Node} node Node to look for.\n     * @returns {Number|null} Node's starting offset.\n     */\n    getNodeStartOffset(node) {\n        const index = this.getNodeIndex(node);\n        return index === null ? null : this._nodes.slice(0, index).reduce((sum, node) => sum + node.offsetSize, 0);\n    }\n    /**\n     * Converts index to offset in node list.\n     *\n     * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.\n     *\n     * @param {Number} index Node's index.\n     * @returns {Number} Node's starting offset.\n     */\n    indexToOffset(index) {\n        if (index == this._nodes.length) {\n            return this.maxOffset;\n        }\n        const node = this._nodes[index];\n        if (!node) {\n            /**\n             * Given index cannot be found in the node list.\n             *\n             * @error model-nodelist-index-out-of-bounds\n             */\n            throw new CKEditorError('model-nodelist-index-out-of-bounds', this);\n        }\n        return this.getNodeStartOffset(node);\n    }\n    /**\n     * Converts offset in node list to index.\n     *\n     * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.\n     *\n     * @param {Number} offset Offset to look for.\n     * @returns {Number} Index of a node that occupies given offset.\n     */\n    offsetToIndex(offset) {\n        let totalOffset = 0;\n        for (const node of this._nodes) {\n            if (offset >= totalOffset && offset < totalOffset + node.offsetSize) {\n                return this.getNodeIndex(node);\n            }\n            totalOffset += node.offsetSize;\n        }\n        if (totalOffset != offset) {\n            /**\n             * Given offset cannot be found in the node list.\n             *\n             * @error model-nodelist-offset-out-of-bounds\n             * @param {Number} offset\n             * @param {module:engine/model/nodelist~NodeList} nodeList Stringified node list.\n             */\n            throw new CKEditorError('model-nodelist-offset-out-of-bounds', this, {\n                offset,\n                nodeList: this\n            });\n        }\n        return this.length;\n    }\n    /**\n     * Inserts given nodes at given index.\n     *\n     * @internal\n     * @protected\n     * @param {Number} index Index at which nodes should be inserted.\n     * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.\n     */\n    _insertNodes(index, nodes) {\n        // Validation.\n        for (const node of nodes) {\n            if (!(node instanceof Node)) {\n                /**\n                 * Trying to insert an object which is not a Node instance.\n                 *\n                 * @error model-nodelist-insertnodes-not-node\n                 */\n                throw new CKEditorError('model-nodelist-insertnodes-not-node', this);\n            }\n        }\n        this._nodes = spliceArray(this._nodes, Array.from(nodes), index, 0);\n    }\n    /**\n     * Removes one or more nodes starting at the given index.\n     *\n     * @internal\n     * @protected\n     * @param {Number} indexStart Index of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n     */\n    _removeNodes(indexStart, howMany = 1) {\n        return this._nodes.splice(indexStart, howMany);\n    }\n    /**\n     * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes\n     * are also converted to their plain object representation.\n     *\n     * @returns {Array.<module:engine/model/node~Node>} `NodeList` instance converted to `Array`.\n     */\n    toJSON() {\n        return this._nodes.map(node => node.toJSON());\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}