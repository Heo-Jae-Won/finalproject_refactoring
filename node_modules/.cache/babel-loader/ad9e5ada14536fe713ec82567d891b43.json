{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/element\n */\nimport Node from './node';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport { default as Matcher } from './matcher';\nimport { default as StylesMap } from './stylesmap';\nimport { isPlainObject } from 'lodash-es';\n// @if CK_DEBUG_ENGINE // const { convertMapToTags } = require( '../dev-utils/utils' );\n/**\n * View element.\n *\n * The editing engine does not define a fixed semantics of its elements (it is \"DTD-free\").\n * This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer. When creating an element you should use one of the following methods:\n *\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `downcastWriter#createContainerElement()`}\n * in order to create a {@link module:engine/view/containerelement~ContainerElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `downcastWriter#createAttributeElement()`}\n * in order to create a {@link module:engine/view/attributeelement~AttributeElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`}\n * in order to create a {@link module:engine/view/emptyelement~EmptyElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}\n * in order to create a {@link module:engine/view/uielement~UIElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`}\n * in order to create a {@link module:engine/view/editableelement~EditableElement}.\n *\n * Note that for view elements which are not created from the model, like elements from mutations, paste or\n * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element.\n * In such cases the {@link module:engine/view/upcastwriter~UpcastWriter#createElement `UpcastWriter#createElement()`} method\n * should be used to create generic view elements.\n *\n * @extends module:engine/view/node~Node\n */\nexport default class Element extends Node {\n  /**\n   * Creates a view element.\n   *\n   * Attributes can be passed in various formats:\n   *\n   *\t\tnew Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object\n   *\t\tnew Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator\n   *\t\tnew Element( viewDocument, 'div', mapOfAttributes ); // map\n   *\n   * @protected\n   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n   * @param {String} name Node name.\n   * @param {Object|Iterable} [attrs] Collection of attributes.\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into created element.\n   */\n  constructor(document, name, attrs, children) {\n    super(document);\n    /**\n     * Name of the element.\n     *\n     * @readonly\n     * @member {String}\n     */\n    this.name = name;\n    /**\n     * Map of attributes, where attributes names are keys and attributes values are values.\n     *\n     * @protected\n     * @member {Map} #_attrs\n     */\n    this._attrs = parseAttributes(attrs);\n    /**\n     * Array of child nodes.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/node~Node>}\n     */\n    this._children = [];\n    if (children) {\n      this._insertChild(0, children);\n    }\n    /**\n     * Set of classes associated with element instance.\n     *\n     * @protected\n     * @member {Set}\n     */\n    this._classes = new Set();\n    if (this._attrs.has('class')) {\n      // Remove class attribute and handle it by class set.\n      const classString = this._attrs.get('class');\n      parseClasses(this._classes, classString);\n      this._attrs.delete('class');\n    }\n    /**\n     * Normalized styles.\n     *\n     * @protected\n     * @member {module:engine/view/stylesmap~StylesMap} module:engine/view/element~Element#_styles\n     */\n    this._styles = new StylesMap(this.document.stylesProcessor);\n    if (this._attrs.has('style')) {\n      // Remove style attribute and handle it by styles map.\n      this._styles.setTo(this._attrs.get('style'));\n      this._attrs.delete('style');\n    }\n    /**\n     * Map of custom properties.\n     * Custom properties can be added to element instance, will be cloned but not rendered into DOM.\n     *\n     * @protected\n     * @member {Map}\n     */\n    this._customProperties = new Map();\n    /**\n     * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms\n     * implemented in the {@link module:engine/view/domconverter~DomConverter} (for instance,\n     * {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute}) would filter them out.\n     *\n     * These attributes can be specified as an option when the element is created by\n     * the {@link module:engine/view/downcastwriter~DowncastWriter}. To check whether an unsafe an attribute should\n     * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.\n     *\n     * @private\n     * @readonly\n     * @member {Array.<String>}\n     */\n    this._unsafeAttributesToRender = [];\n  }\n  /**\n   * Number of element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Is `true` if there are no nodes inside this element, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n  get isEmpty() {\n    return this._children.length === 0;\n  }\n  /**\n   * Gets child at the given index.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/view/node~Node} Child node.\n   */\n  getChild(index) {\n    return this._children[index];\n  }\n  /**\n   * Gets index of the given child node. Returns `-1` if child node is not found.\n   *\n   * @param {module:engine/view/node~Node} node Child node.\n   * @returns {Number} Index of the child node.\n   */\n  getChildIndex(node) {\n    return this._children.indexOf(node);\n  }\n  /**\n   * Gets child nodes iterator.\n   *\n   * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n   */\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.\n   *\n   * @returns {Iterable.<String>} Keys for attributes.\n   */\n  *getAttributeKeys() {\n    if (this._classes.size > 0) {\n      yield 'class';\n    }\n    if (!this._styles.isEmpty) {\n      yield 'style';\n    }\n    yield* this._attrs.keys();\n  }\n  /**\n   * Returns iterator that iterates over this element's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n  *getAttributes() {\n    yield* this._attrs.entries();\n    if (this._classes.size > 0) {\n      yield ['class', this.getAttribute('class')];\n    }\n    if (!this._styles.isEmpty) {\n      yield ['style', this.getAttribute('style')];\n    }\n  }\n  /**\n   * Gets attribute by key. If attribute is not present - returns undefined.\n   *\n   * @param {String} key Attribute key.\n   * @returns {String|undefined} Attribute value.\n   */\n  getAttribute(key) {\n    if (key == 'class') {\n      if (this._classes.size > 0) {\n        return [...this._classes].join(' ');\n      }\n      return undefined;\n    }\n    if (key == 'style') {\n      const inlineStyle = this._styles.toString();\n      return inlineStyle == '' ? undefined : inlineStyle;\n    }\n    return this._attrs.get(key);\n  }\n  /**\n   * Returns a boolean indicating whether an attribute with the specified key exists in the element.\n   *\n   * @param {String} key Attribute key.\n   * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.\n   */\n  hasAttribute(key) {\n    if (key == 'class') {\n      return this._classes.size > 0;\n    }\n    if (key == 'style') {\n      return !this._styles.isEmpty;\n    }\n    return this._attrs.has(key);\n  }\n  /**\n   * Checks if this element is similar to other element.\n   * Both elements should have the same name and attributes to be considered as similar. Two similar elements\n   * can contain different set of children nodes.\n   *\n   * @param {module:engine/view/element~Element} otherElement\n   * @returns {Boolean}\n   */\n  isSimilar(otherElement) {\n    if (!(otherElement instanceof Element)) {\n      return false;\n    }\n    // If exactly the same Element is provided - return true immediately.\n    if (this === otherElement) {\n      return true;\n    }\n    // Check element name.\n    if (this.name != otherElement.name) {\n      return false;\n    }\n    // Check number of attributes, classes and styles.\n    if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {\n      return false;\n    }\n    // Check if attributes are the same.\n    for (const [key, value] of this._attrs) {\n      if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {\n        return false;\n      }\n    }\n    // Check if classes are the same.\n    for (const className of this._classes) {\n      if (!otherElement._classes.has(className)) {\n        return false;\n      }\n    }\n    // Check if styles are the same.\n    for (const property of this._styles.getStyleNames()) {\n      if (!otherElement._styles.has(property) || otherElement._styles.getAsString(property) !== this._styles.getAsString(property)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Returns true if class is present.\n   * If more then one class is provided - returns true only when all classes are present.\n   *\n   *\t\telement.hasClass( 'foo' ); // Returns true if 'foo' class is present.\n   *\t\telement.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.\n   *\n   * @param {...String} className\n   */\n  hasClass() {\n    for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {\n      className[_key] = arguments[_key];\n    }\n    for (const name of className) {\n      if (!this._classes.has(name)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Returns iterator that contains all class names.\n   *\n   * @returns {Iterable.<String>}\n   */\n  getClassNames() {\n    return this._classes.keys();\n  }\n  /**\n   * Returns style value for the given property mae.\n   * If the style does not exist `undefined` is returned.\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.\n   *\n   * For an element with style set to `'margin:1px'`:\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tconst element = view.change( writer => {\n   *\t\t\tconst element = writer.createElement();\n   *\t\t\twriter.setStyle( 'margin', '1px' );\n   *\t\t\twriter.setStyle( 'margin-bottom', '3em' );\n   *\n   *\t\t\treturn element;\n   *\t\t} );\n   *\n   *\t\telement.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'\n   *\n   * @param {String} property\n   * @returns {String|undefined}\n   */\n  getStyle(property) {\n    return this._styles.getAsString(property);\n  }\n  /**\n   * Returns a normalized style object or single style value.\n   *\n   * For an element with style set to: margin:1px 2px 3em;\n   *\n   *\t\telement.getNormalizedStyle( 'margin' ) );\n   *\n   * will return:\n   *\n   *\t\t{\n   *\t\t\ttop: '1px',\n   *\t\t\tright: '2px',\n   *\t\t\tbottom: '3em',\n   *\t\t\tleft: '2px'    // a normalized value from margin shorthand\n   *\t\t}\n   *\n   * and reading for single style value:\n   *\n   *\t\tstyles.getNormalizedStyle( 'margin-left' );\n   *\n   * Will return a `2px` string.\n   *\n   * **Note**: This method will return normalized values only if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.\n   *\n   *\n   * @param {String} property Name of CSS property\n   * @returns {Object|String|undefined}\n   */\n  getNormalizedStyle(property) {\n    return this._styles.getNormalized(property);\n  }\n  /**\n   * Returns iterator that contains all style names.\n   *\n   * @param {Boolean} [expand=false] Expand shorthand style properties and return all equivalent style representations.\n   * @returns {Iterable.<String>}\n   */\n  getStyleNames(expand) {\n    return this._styles.getStyleNames(expand);\n  }\n  /**\n   * Returns true if style keys are present.\n   * If more then one style property is provided - returns true only when all properties are present.\n   *\n   *\t\telement.hasStyle( 'color' ); // Returns true if 'border-top' style is present.\n   *\t\telement.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.\n   *\n   * @param {...String} property\n   */\n  hasStyle() {\n    for (var _len2 = arguments.length, property = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      property[_key2] = arguments[_key2];\n    }\n    for (const name of property) {\n      if (!this._styles.has(name)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Returns ancestor element that match specified pattern.\n   * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.\n   *\n   * @see module:engine/view/matcher~Matcher\n   * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.\n   * See {@link module:engine/view/matcher~Matcher}.\n   * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.\n   */\n  findAncestor() {\n    for (var _len3 = arguments.length, patterns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      patterns[_key3] = arguments[_key3];\n    }\n    const matcher = new Matcher(...patterns);\n    let parent = this.parent;\n    while (parent && !parent.is('documentFragment')) {\n      if (matcher.match(parent)) {\n        return parent;\n      }\n      parent = parent.parent;\n    }\n    return null;\n  }\n  /**\n   * Returns the custom property value for the given key.\n   *\n   * @param {String|Symbol} key\n   * @returns {*}\n   */\n  getCustomProperty(key) {\n    return this._customProperties.get(key);\n  }\n  /**\n   * Returns an iterator which iterates over this element's custom properties.\n   * Iterator provides `[ key, value ]` pairs for each stored property.\n   *\n   * @returns {Iterable.<*>}\n   */\n  *getCustomProperties() {\n    yield* this._customProperties.entries();\n  }\n  /**\n   * Returns identity string based on element's name, styles, classes and other attributes.\n   * Two elements that {@link #isSimilar are similar} will have same identity string.\n   * It has the following format:\n   *\n   *\t\t'name class=\"class1,class2\" style=\"style1:value1;style2:value2\" attr1=\"val1\" attr2=\"val2\"'\n   *\n   * For example:\n   *\n   *\t\tconst element = writer.createContainerElement( 'foo', {\n   *\t\t\tbanana: '10',\n   *\t\t\tapple: '20',\n   *\t\t\tstyle: 'color: red; border-color: white;',\n   *\t\t\tclass: 'baz'\n   *\t\t} );\n   *\n   *\t\t// returns 'foo class=\"baz\" style=\"border-color:white;color:red\" apple=\"20\" banana=\"10\"'\n   *\t\telement.getIdentity();\n   *\n   * **Note**: Classes, styles and other attributes are sorted alphabetically.\n   *\n   * @returns {String}\n   */\n  getIdentity() {\n    const classes = Array.from(this._classes).sort().join(',');\n    const styles = this._styles.toString();\n    const attributes = Array.from(this._attrs).map(i => `${i[0]}=\"${i[1]}\"`).sort().join(' ');\n    return this.name + (classes == '' ? '' : ` class=\"${classes}\"`) + (!styles ? '' : ` style=\"${styles}\"`) + (attributes == '' ? '' : ` ${attributes}`);\n  }\n  /**\n   * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms\n   * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.\n   *\n   * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.\n   *\n   * @param {String} attributeName The name of the attribute to be checked.\n   * @returns {Boolean}\n   */\n  shouldRenderUnsafeAttribute(attributeName) {\n    return this._unsafeAttributesToRender.includes(attributeName);\n  }\n  /**\n   * Clones provided element.\n   *\n   * @protected\n   * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n   * element will be cloned without any children.\n   * @returns {module:engine/view/element~Element} Clone of this element.\n   */\n  _clone() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const childrenClone = [];\n    if (deep) {\n      for (const child of this.getChildren()) {\n        childrenClone.push(child._clone(deep));\n      }\n    }\n    // ContainerElement and AttributeElement should be also cloned properly.\n    const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);\n    // Classes and styles are cloned separately - this solution is faster than adding them back to attributes and\n    // parse once again in constructor.\n    cloned._classes = new Set(this._classes);\n    cloned._styles.set(this._styles.getNormalized());\n    // Clone custom properties.\n    cloned._customProperties = new Map(this._customProperties);\n    // Clone filler offset method.\n    // We can't define this method in a prototype because it's behavior which\n    // is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.\n    cloned.getFillerOffset = this.getFillerOffset;\n    // Clone unsafe attributes list.\n    cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;\n    return cloned;\n  }\n  /**\n   * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node\n   * and sets the parent of these nodes to this element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#insert\n   * @protected\n   * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n   * @fires module:engine/view/node~Node#change\n   * @returns {Number} Number of appended nodes.\n   */\n  _appendChild(items) {\n    return this._insertChild(this.childCount, items);\n  }\n  /**\n   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n   * this element.\n   *\n   * @internal\n   * @see module:engine/view/downcastwriter~DowncastWriter#insert\n   * @protected\n   * @param {Number} index Position where nodes should be inserted.\n   * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n   * @fires module:engine/view/node~Node#change\n   * @returns {Number} Number of inserted nodes.\n   */\n  _insertChild(index, items) {\n    this._fireChange('children', this);\n    let count = 0;\n    const nodes = normalize(this.document, items);\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n      node.parent = this;\n      node.document = this.document;\n      this._children.splice(index, 0, node);\n      index++;\n      count++;\n    }\n    return count;\n  }\n  /**\n   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#remove\n   * @protected\n   * @param {Number} index Number of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @fires module:engine/view/node~Node#change\n   * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n   */\n  _removeChildren(index) {\n    let howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this._fireChange('children', this);\n    for (let i = index; i < index + howMany; i++) {\n      this._children[i].parent = null;\n    }\n    return this._children.splice(index, howMany);\n  }\n  /**\n   * Adds or overwrite attribute with a specified key and value.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute\n   * @protected\n   * @param {String} key Attribute key.\n   * @param {String} value Attribute value.\n   * @fires module:engine/view/node~Node#change\n   */\n  _setAttribute(key, value) {\n    value = String(value);\n    this._fireChange('attributes', this);\n    if (key == 'class') {\n      parseClasses(this._classes, value);\n    } else if (key == 'style') {\n      this._styles.setTo(value);\n    } else {\n      this._attrs.set(key, value);\n    }\n  }\n  /**\n   * Removes attribute from the element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute\n   * @protected\n   * @param {String} key Attribute key.\n   * @returns {Boolean} Returns true if an attribute existed and has been removed.\n   * @fires module:engine/view/node~Node#change\n   */\n  _removeAttribute(key) {\n    this._fireChange('attributes', this);\n    // Remove class attribute.\n    if (key == 'class') {\n      if (this._classes.size > 0) {\n        this._classes.clear();\n        return true;\n      }\n      return false;\n    }\n    // Remove style attribute.\n    if (key == 'style') {\n      if (!this._styles.isEmpty) {\n        this._styles.clear();\n        return true;\n      }\n      return false;\n    }\n    // Remove other attributes.\n    return this._attrs.delete(key);\n  }\n  /**\n   * Adds specified class.\n   *\n   *\t\telement._addClass( 'foo' ); // Adds 'foo' class.\n   *\t\telement._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#addClass\n   * @protected\n   * @param {Array.<String>|String} className\n   * @fires module:engine/view/node~Node#change\n   */\n  _addClass(className) {\n    this._fireChange('attributes', this);\n    for (const name of toArray(className)) {\n      this._classes.add(name);\n    }\n  }\n  /**\n   * Removes specified class.\n   *\n   *\t\telement._removeClass( 'foo' );  // Removes 'foo' class.\n   *\t\telement._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeClass\n   * @protected\n   * @param {Array.<String>|String} className\n   * @fires module:engine/view/node~Node#change\n   */\n  _removeClass(className) {\n    this._fireChange('attributes', this);\n    for (const name of toArray(className)) {\n      this._classes.delete(name);\n    }\n  }\n  _setStyle(property, value) {\n    this._fireChange('attributes', this);\n    if (isPlainObject(property)) {\n      this._styles.set(property);\n    } else {\n      this._styles.set(property, value);\n    }\n  }\n  /**\n   * Removes specified style.\n   *\n   *\t\telement._removeStyle( 'color' );  // Removes 'color' style.\n   *\t\telement._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle\n   * @protected\n   * @param {Array.<String>|String} property\n   * @fires module:engine/view/node~Node#change\n   */\n  _removeStyle(property) {\n    this._fireChange('attributes', this);\n    for (const name of toArray(property)) {\n      this._styles.remove(name);\n    }\n  }\n  /**\n   * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,\n   * so they can be used to add special data to elements.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty\n   * @protected\n   * @param {String|Symbol} key\n   * @param {*} value\n   */\n  _setCustomProperty(key, value) {\n    this._customProperties.set(key, value);\n  }\n  /**\n   * Removes the custom property stored under the given key.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty\n   * @protected\n   * @param {String|Symbol} key\n   * @returns {Boolean} Returns true if property was removed.\n   */\n  _removeCustomProperty(key) {\n    return this._customProperties.delete(key);\n  }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\telement.is( 'element' ); // -> true\n *\t\telement.is( 'node' ); // -> true\n *\t\telement.is( 'view:element' ); // -> true\n *\t\telement.is( 'view:node' ); // -> true\n *\n *\t\telement.is( 'model:element' ); // -> false\n *\t\telement.is( 'documentSelection' ); // -> false\n *\n * Assuming that the object being checked is an element, you can also check its\n * {@link module:engine/view/element~Element#name name}:\n *\n *\t\telement.is( 'element', 'img' ); // -> true if this is an <img> element\n *\t\ttext.is( 'element', 'img' ); -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nElement.prototype.is = function (type, name) {\n  if (!name) {\n    return type === 'element' || type === 'view:element' ||\n    // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n    type === 'node' || type === 'view:node';\n  } else {\n    return name === this.name && (type === 'element' || type === 'view:element');\n  }\n};\n// Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed\n// as an object (instead of `Iterable`), the object is transformed to the map. Attributes with `null` value are removed.\n// Attributes with non-`String` value are converted to `String`.\n//\n// @param {Object|Iterable} attrs Attributes to parse.\n// @returns {Map} Parsed attributes.\nfunction parseAttributes(attrs) {\n  const attrsMap = toMap(attrs);\n  for (const [key, value] of attrsMap) {\n    if (value === null) {\n      attrsMap.delete(key);\n    } else if (typeof value != 'string') {\n      attrsMap.set(key, String(value));\n    }\n  }\n  return attrsMap;\n}\n// Parses class attribute and puts all classes into classes set.\n// Classes set s cleared before insertion.\n//\n// @param {Set.<String>} classesSet Set to insert parsed classes.\n// @param {String} classesString String with classes to parse.\nfunction parseClasses(classesSet, classesString) {\n  const classArray = classesString.split(/\\s+/);\n  classesSet.clear();\n  classArray.forEach(name => classesSet.add(name));\n}\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\nfunction normalize(document, nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(document, nodes)];\n  }\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  }\n  // Array.from to enable .map() on non-arrays.\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(document, node);\n    }\n    if (node instanceof TextProxy) {\n      return new Text(document, node.data);\n    }\n    return node;\n  });\n}","map":{"version":3,"names":["Node","Text","TextProxy","toMap","toArray","isIterable","default","Matcher","StylesMap","isPlainObject","Element","constructor","document","name","attrs","children","_attrs","parseAttributes","_children","_insertChild","_classes","Set","has","classString","get","parseClasses","delete","_styles","stylesProcessor","setTo","_customProperties","Map","_unsafeAttributesToRender","childCount","length","isEmpty","getChild","index","getChildIndex","node","indexOf","getChildren","Symbol","iterator","getAttributeKeys","size","keys","getAttributes","entries","getAttribute","key","join","undefined","inlineStyle","toString","hasAttribute","isSimilar","otherElement","value","className","property","getStyleNames","getAsString","hasClass","getClassNames","getStyle","getNormalizedStyle","getNormalized","expand","hasStyle","findAncestor","patterns","matcher","parent","is","match","getCustomProperty","getCustomProperties","getIdentity","classes","Array","from","sort","styles","attributes","map","i","shouldRenderUnsafeAttribute","attributeName","includes","_clone","deep","childrenClone","child","push","cloned","set","getFillerOffset","_appendChild","items","_fireChange","count","nodes","normalize","_remove","splice","_removeChildren","howMany","_setAttribute","String","_removeAttribute","clear","_addClass","add","_removeClass","_setStyle","_removeStyle","remove","_setCustomProperty","_removeCustomProperty","prototype","type","attrsMap","classesSet","classesString","classArray","split","forEach","data"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/element.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/element\n */\nimport Node from './node';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport { default as Matcher } from './matcher';\nimport { default as StylesMap } from './stylesmap';\nimport { isPlainObject } from 'lodash-es';\n// @if CK_DEBUG_ENGINE // const { convertMapToTags } = require( '../dev-utils/utils' );\n/**\n * View element.\n *\n * The editing engine does not define a fixed semantics of its elements (it is \"DTD-free\").\n * This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer. When creating an element you should use one of the following methods:\n *\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `downcastWriter#createContainerElement()`}\n * in order to create a {@link module:engine/view/containerelement~ContainerElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `downcastWriter#createAttributeElement()`}\n * in order to create a {@link module:engine/view/attributeelement~AttributeElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`}\n * in order to create a {@link module:engine/view/emptyelement~EmptyElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}\n * in order to create a {@link module:engine/view/uielement~UIElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`}\n * in order to create a {@link module:engine/view/editableelement~EditableElement}.\n *\n * Note that for view elements which are not created from the model, like elements from mutations, paste or\n * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element.\n * In such cases the {@link module:engine/view/upcastwriter~UpcastWriter#createElement `UpcastWriter#createElement()`} method\n * should be used to create generic view elements.\n *\n * @extends module:engine/view/node~Node\n */\nexport default class Element extends Node {\n    /**\n     * Creates a view element.\n     *\n     * Attributes can be passed in various formats:\n     *\n     *\t\tnew Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object\n     *\t\tnew Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator\n     *\t\tnew Element( viewDocument, 'div', mapOfAttributes ); // map\n     *\n     * @protected\n     * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n     * @param {String} name Node name.\n     * @param {Object|Iterable} [attrs] Collection of attributes.\n     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n     * A list of nodes to be inserted into created element.\n     */\n    constructor(document, name, attrs, children) {\n        super(document);\n        /**\n         * Name of the element.\n         *\n         * @readonly\n         * @member {String}\n         */\n        this.name = name;\n        /**\n         * Map of attributes, where attributes names are keys and attributes values are values.\n         *\n         * @protected\n         * @member {Map} #_attrs\n         */\n        this._attrs = parseAttributes(attrs);\n        /**\n         * Array of child nodes.\n         *\n         * @protected\n         * @member {Array.<module:engine/view/node~Node>}\n         */\n        this._children = [];\n        if (children) {\n            this._insertChild(0, children);\n        }\n        /**\n         * Set of classes associated with element instance.\n         *\n         * @protected\n         * @member {Set}\n         */\n        this._classes = new Set();\n        if (this._attrs.has('class')) {\n            // Remove class attribute and handle it by class set.\n            const classString = this._attrs.get('class');\n            parseClasses(this._classes, classString);\n            this._attrs.delete('class');\n        }\n        /**\n         * Normalized styles.\n         *\n         * @protected\n         * @member {module:engine/view/stylesmap~StylesMap} module:engine/view/element~Element#_styles\n         */\n        this._styles = new StylesMap(this.document.stylesProcessor);\n        if (this._attrs.has('style')) {\n            // Remove style attribute and handle it by styles map.\n            this._styles.setTo(this._attrs.get('style'));\n            this._attrs.delete('style');\n        }\n        /**\n         * Map of custom properties.\n         * Custom properties can be added to element instance, will be cloned but not rendered into DOM.\n         *\n         * @protected\n         * @member {Map}\n         */\n        this._customProperties = new Map();\n        /**\n         * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms\n         * implemented in the {@link module:engine/view/domconverter~DomConverter} (for instance,\n         * {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute}) would filter them out.\n         *\n         * These attributes can be specified as an option when the element is created by\n         * the {@link module:engine/view/downcastwriter~DowncastWriter}. To check whether an unsafe an attribute should\n         * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.\n         *\n         * @private\n         * @readonly\n         * @member {Array.<String>}\n         */\n        this._unsafeAttributesToRender = [];\n    }\n    /**\n     * Number of element's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n    get childCount() {\n        return this._children.length;\n    }\n    /**\n     * Is `true` if there are no nodes inside this element, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n    get isEmpty() {\n        return this._children.length === 0;\n    }\n    /**\n     * Gets child at the given index.\n     *\n     * @param {Number} index Index of child.\n     * @returns {module:engine/view/node~Node} Child node.\n     */\n    getChild(index) {\n        return this._children[index];\n    }\n    /**\n     * Gets index of the given child node. Returns `-1` if child node is not found.\n     *\n     * @param {module:engine/view/node~Node} node Child node.\n     * @returns {Number} Index of the child node.\n     */\n    getChildIndex(node) {\n        return this._children.indexOf(node);\n    }\n    /**\n     * Gets child nodes iterator.\n     *\n     * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n     */\n    getChildren() {\n        return this._children[Symbol.iterator]();\n    }\n    /**\n     * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.\n     *\n     * @returns {Iterable.<String>} Keys for attributes.\n     */\n    *getAttributeKeys() {\n        if (this._classes.size > 0) {\n            yield 'class';\n        }\n        if (!this._styles.isEmpty) {\n            yield 'style';\n        }\n        yield* this._attrs.keys();\n    }\n    /**\n     * Returns iterator that iterates over this element's attributes.\n     *\n     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n    *getAttributes() {\n        yield* this._attrs.entries();\n        if (this._classes.size > 0) {\n            yield ['class', this.getAttribute('class')];\n        }\n        if (!this._styles.isEmpty) {\n            yield ['style', this.getAttribute('style')];\n        }\n    }\n    /**\n     * Gets attribute by key. If attribute is not present - returns undefined.\n     *\n     * @param {String} key Attribute key.\n     * @returns {String|undefined} Attribute value.\n     */\n    getAttribute(key) {\n        if (key == 'class') {\n            if (this._classes.size > 0) {\n                return [...this._classes].join(' ');\n            }\n            return undefined;\n        }\n        if (key == 'style') {\n            const inlineStyle = this._styles.toString();\n            return inlineStyle == '' ? undefined : inlineStyle;\n        }\n        return this._attrs.get(key);\n    }\n    /**\n     * Returns a boolean indicating whether an attribute with the specified key exists in the element.\n     *\n     * @param {String} key Attribute key.\n     * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.\n     */\n    hasAttribute(key) {\n        if (key == 'class') {\n            return this._classes.size > 0;\n        }\n        if (key == 'style') {\n            return !this._styles.isEmpty;\n        }\n        return this._attrs.has(key);\n    }\n    /**\n     * Checks if this element is similar to other element.\n     * Both elements should have the same name and attributes to be considered as similar. Two similar elements\n     * can contain different set of children nodes.\n     *\n     * @param {module:engine/view/element~Element} otherElement\n     * @returns {Boolean}\n     */\n    isSimilar(otherElement) {\n        if (!(otherElement instanceof Element)) {\n            return false;\n        }\n        // If exactly the same Element is provided - return true immediately.\n        if (this === otherElement) {\n            return true;\n        }\n        // Check element name.\n        if (this.name != otherElement.name) {\n            return false;\n        }\n        // Check number of attributes, classes and styles.\n        if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size ||\n            this._styles.size !== otherElement._styles.size) {\n            return false;\n        }\n        // Check if attributes are the same.\n        for (const [key, value] of this._attrs) {\n            if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {\n                return false;\n            }\n        }\n        // Check if classes are the same.\n        for (const className of this._classes) {\n            if (!otherElement._classes.has(className)) {\n                return false;\n            }\n        }\n        // Check if styles are the same.\n        for (const property of this._styles.getStyleNames()) {\n            if (!otherElement._styles.has(property) ||\n                otherElement._styles.getAsString(property) !== this._styles.getAsString(property)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns true if class is present.\n     * If more then one class is provided - returns true only when all classes are present.\n     *\n     *\t\telement.hasClass( 'foo' ); // Returns true if 'foo' class is present.\n     *\t\telement.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.\n     *\n     * @param {...String} className\n     */\n    hasClass(...className) {\n        for (const name of className) {\n            if (!this._classes.has(name)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns iterator that contains all class names.\n     *\n     * @returns {Iterable.<String>}\n     */\n    getClassNames() {\n        return this._classes.keys();\n    }\n    /**\n     * Returns style value for the given property mae.\n     * If the style does not exist `undefined` is returned.\n     *\n     * **Note**: This method can work with normalized style names if\n     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n     * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.\n     *\n     * For an element with style set to `'margin:1px'`:\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tconst element = view.change( writer => {\n     *\t\t\tconst element = writer.createElement();\n     *\t\t\twriter.setStyle( 'margin', '1px' );\n     *\t\t\twriter.setStyle( 'margin-bottom', '3em' );\n     *\n     *\t\t\treturn element;\n     *\t\t} );\n     *\n     *\t\telement.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'\n     *\n     * @param {String} property\n     * @returns {String|undefined}\n     */\n    getStyle(property) {\n        return this._styles.getAsString(property);\n    }\n    /**\n     * Returns a normalized style object or single style value.\n     *\n     * For an element with style set to: margin:1px 2px 3em;\n     *\n     *\t\telement.getNormalizedStyle( 'margin' ) );\n     *\n     * will return:\n     *\n     *\t\t{\n     *\t\t\ttop: '1px',\n     *\t\t\tright: '2px',\n     *\t\t\tbottom: '3em',\n     *\t\t\tleft: '2px'    // a normalized value from margin shorthand\n     *\t\t}\n     *\n     * and reading for single style value:\n     *\n     *\t\tstyles.getNormalizedStyle( 'margin-left' );\n     *\n     * Will return a `2px` string.\n     *\n     * **Note**: This method will return normalized values only if\n     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n     * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.\n     *\n     *\n     * @param {String} property Name of CSS property\n     * @returns {Object|String|undefined}\n     */\n    getNormalizedStyle(property) {\n        return this._styles.getNormalized(property);\n    }\n    /**\n     * Returns iterator that contains all style names.\n     *\n     * @param {Boolean} [expand=false] Expand shorthand style properties and return all equivalent style representations.\n     * @returns {Iterable.<String>}\n     */\n    getStyleNames(expand) {\n        return this._styles.getStyleNames(expand);\n    }\n    /**\n     * Returns true if style keys are present.\n     * If more then one style property is provided - returns true only when all properties are present.\n     *\n     *\t\telement.hasStyle( 'color' ); // Returns true if 'border-top' style is present.\n     *\t\telement.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.\n     *\n     * @param {...String} property\n     */\n    hasStyle(...property) {\n        for (const name of property) {\n            if (!this._styles.has(name)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns ancestor element that match specified pattern.\n     * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.\n     *\n     * @see module:engine/view/matcher~Matcher\n     * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.\n     * See {@link module:engine/view/matcher~Matcher}.\n     * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.\n     */\n    findAncestor(...patterns) {\n        const matcher = new Matcher(...patterns);\n        let parent = this.parent;\n        while (parent && !parent.is('documentFragment')) {\n            if (matcher.match(parent)) {\n                return parent;\n            }\n            parent = parent.parent;\n        }\n        return null;\n    }\n    /**\n     * Returns the custom property value for the given key.\n     *\n     * @param {String|Symbol} key\n     * @returns {*}\n     */\n    getCustomProperty(key) {\n        return this._customProperties.get(key);\n    }\n    /**\n     * Returns an iterator which iterates over this element's custom properties.\n     * Iterator provides `[ key, value ]` pairs for each stored property.\n     *\n     * @returns {Iterable.<*>}\n     */\n    *getCustomProperties() {\n        yield* this._customProperties.entries();\n    }\n    /**\n     * Returns identity string based on element's name, styles, classes and other attributes.\n     * Two elements that {@link #isSimilar are similar} will have same identity string.\n     * It has the following format:\n     *\n     *\t\t'name class=\"class1,class2\" style=\"style1:value1;style2:value2\" attr1=\"val1\" attr2=\"val2\"'\n     *\n     * For example:\n     *\n     *\t\tconst element = writer.createContainerElement( 'foo', {\n     *\t\t\tbanana: '10',\n     *\t\t\tapple: '20',\n     *\t\t\tstyle: 'color: red; border-color: white;',\n     *\t\t\tclass: 'baz'\n     *\t\t} );\n     *\n     *\t\t// returns 'foo class=\"baz\" style=\"border-color:white;color:red\" apple=\"20\" banana=\"10\"'\n     *\t\telement.getIdentity();\n     *\n     * **Note**: Classes, styles and other attributes are sorted alphabetically.\n     *\n     * @returns {String}\n     */\n    getIdentity() {\n        const classes = Array.from(this._classes).sort().join(',');\n        const styles = this._styles.toString();\n        const attributes = Array.from(this._attrs).map(i => `${i[0]}=\"${i[1]}\"`).sort().join(' ');\n        return this.name +\n            (classes == '' ? '' : ` class=\"${classes}\"`) +\n            (!styles ? '' : ` style=\"${styles}\"`) +\n            (attributes == '' ? '' : ` ${attributes}`);\n    }\n    /**\n     * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms\n     * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.\n     *\n     * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.\n     *\n     * @param {String} attributeName The name of the attribute to be checked.\n     * @returns {Boolean}\n     */\n    shouldRenderUnsafeAttribute(attributeName) {\n        return this._unsafeAttributesToRender.includes(attributeName);\n    }\n    /**\n     * Clones provided element.\n     *\n     * @protected\n     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any children.\n     * @returns {module:engine/view/element~Element} Clone of this element.\n     */\n    _clone(deep = false) {\n        const childrenClone = [];\n        if (deep) {\n            for (const child of this.getChildren()) {\n                childrenClone.push(child._clone(deep));\n            }\n        }\n        // ContainerElement and AttributeElement should be also cloned properly.\n        const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);\n        // Classes and styles are cloned separately - this solution is faster than adding them back to attributes and\n        // parse once again in constructor.\n        cloned._classes = new Set(this._classes);\n        cloned._styles.set(this._styles.getNormalized());\n        // Clone custom properties.\n        cloned._customProperties = new Map(this._customProperties);\n        // Clone filler offset method.\n        // We can't define this method in a prototype because it's behavior which\n        // is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.\n        cloned.getFillerOffset = this.getFillerOffset;\n        // Clone unsafe attributes list.\n        cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;\n        return cloned;\n    }\n    /**\n     * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node\n     * and sets the parent of these nodes to this element.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#insert\n     * @protected\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @fires module:engine/view/node~Node#change\n     * @returns {Number} Number of appended nodes.\n     */\n    _appendChild(items) {\n        return this._insertChild(this.childCount, items);\n    }\n    /**\n     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n     * this element.\n     *\n     * @internal\n     * @see module:engine/view/downcastwriter~DowncastWriter#insert\n     * @protected\n     * @param {Number} index Position where nodes should be inserted.\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @fires module:engine/view/node~Node#change\n     * @returns {Number} Number of inserted nodes.\n     */\n    _insertChild(index, items) {\n        this._fireChange('children', this);\n        let count = 0;\n        const nodes = normalize(this.document, items);\n        for (const node of nodes) {\n            // If node that is being added to this element is already inside another element, first remove it from the old parent.\n            if (node.parent !== null) {\n                node._remove();\n            }\n            node.parent = this;\n            node.document = this.document;\n            this._children.splice(index, 0, node);\n            index++;\n            count++;\n        }\n        return count;\n    }\n    /**\n     * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#remove\n     * @protected\n     * @param {Number} index Number of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @fires module:engine/view/node~Node#change\n     * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n     */\n    _removeChildren(index, howMany = 1) {\n        this._fireChange('children', this);\n        for (let i = index; i < index + howMany; i++) {\n            this._children[i].parent = null;\n        }\n        return this._children.splice(index, howMany);\n    }\n    /**\n     * Adds or overwrite attribute with a specified key and value.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute\n     * @protected\n     * @param {String} key Attribute key.\n     * @param {String} value Attribute value.\n     * @fires module:engine/view/node~Node#change\n     */\n    _setAttribute(key, value) {\n        value = String(value);\n        this._fireChange('attributes', this);\n        if (key == 'class') {\n            parseClasses(this._classes, value);\n        }\n        else if (key == 'style') {\n            this._styles.setTo(value);\n        }\n        else {\n            this._attrs.set(key, value);\n        }\n    }\n    /**\n     * Removes attribute from the element.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute\n     * @protected\n     * @param {String} key Attribute key.\n     * @returns {Boolean} Returns true if an attribute existed and has been removed.\n     * @fires module:engine/view/node~Node#change\n     */\n    _removeAttribute(key) {\n        this._fireChange('attributes', this);\n        // Remove class attribute.\n        if (key == 'class') {\n            if (this._classes.size > 0) {\n                this._classes.clear();\n                return true;\n            }\n            return false;\n        }\n        // Remove style attribute.\n        if (key == 'style') {\n            if (!this._styles.isEmpty) {\n                this._styles.clear();\n                return true;\n            }\n            return false;\n        }\n        // Remove other attributes.\n        return this._attrs.delete(key);\n    }\n    /**\n     * Adds specified class.\n     *\n     *\t\telement._addClass( 'foo' ); // Adds 'foo' class.\n     *\t\telement._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#addClass\n     * @protected\n     * @param {Array.<String>|String} className\n     * @fires module:engine/view/node~Node#change\n     */\n    _addClass(className) {\n        this._fireChange('attributes', this);\n        for (const name of toArray(className)) {\n            this._classes.add(name);\n        }\n    }\n    /**\n     * Removes specified class.\n     *\n     *\t\telement._removeClass( 'foo' );  // Removes 'foo' class.\n     *\t\telement._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeClass\n     * @protected\n     * @param {Array.<String>|String} className\n     * @fires module:engine/view/node~Node#change\n     */\n    _removeClass(className) {\n        this._fireChange('attributes', this);\n        for (const name of toArray(className)) {\n            this._classes.delete(name);\n        }\n    }\n    _setStyle(property, value) {\n        this._fireChange('attributes', this);\n        if (isPlainObject(property)) {\n            this._styles.set(property);\n        }\n        else {\n            this._styles.set(property, value);\n        }\n    }\n    /**\n     * Removes specified style.\n     *\n     *\t\telement._removeStyle( 'color' );  // Removes 'color' style.\n     *\t\telement._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.\n     *\n     * **Note**: This method can work with normalized style names if\n     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle\n     * @protected\n     * @param {Array.<String>|String} property\n     * @fires module:engine/view/node~Node#change\n     */\n    _removeStyle(property) {\n        this._fireChange('attributes', this);\n        for (const name of toArray(property)) {\n            this._styles.remove(name);\n        }\n    }\n    /**\n     * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,\n     * so they can be used to add special data to elements.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty\n     * @protected\n     * @param {String|Symbol} key\n     * @param {*} value\n     */\n    _setCustomProperty(key, value) {\n        this._customProperties.set(key, value);\n    }\n    /**\n     * Removes the custom property stored under the given key.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty\n     * @protected\n     * @param {String|Symbol} key\n     * @returns {Boolean} Returns true if property was removed.\n     */\n    _removeCustomProperty(key) {\n        return this._customProperties.delete(key);\n    }\n}\n/**\n * Checks whether this object is of the given.\n *\n *\t\telement.is( 'element' ); // -> true\n *\t\telement.is( 'node' ); // -> true\n *\t\telement.is( 'view:element' ); // -> true\n *\t\telement.is( 'view:node' ); // -> true\n *\n *\t\telement.is( 'model:element' ); // -> false\n *\t\telement.is( 'documentSelection' ); // -> false\n *\n * Assuming that the object being checked is an element, you can also check its\n * {@link module:engine/view/element~Element#name name}:\n *\n *\t\telement.is( 'element', 'img' ); // -> true if this is an <img> element\n *\t\ttext.is( 'element', 'img' ); -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type Type to check.\n * @param {String} [name] Element name.\n * @returns {Boolean}\n */\nElement.prototype.is = function (type, name) {\n    if (!name) {\n        return type === 'element' || type === 'view:element' ||\n            // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n            type === 'node' || type === 'view:node';\n    }\n    else {\n        return name === this.name && (type === 'element' || type === 'view:element');\n    }\n};\n// Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed\n// as an object (instead of `Iterable`), the object is transformed to the map. Attributes with `null` value are removed.\n// Attributes with non-`String` value are converted to `String`.\n//\n// @param {Object|Iterable} attrs Attributes to parse.\n// @returns {Map} Parsed attributes.\nfunction parseAttributes(attrs) {\n    const attrsMap = toMap(attrs);\n    for (const [key, value] of attrsMap) {\n        if (value === null) {\n            attrsMap.delete(key);\n        }\n        else if (typeof value != 'string') {\n            attrsMap.set(key, String(value));\n        }\n    }\n    return attrsMap;\n}\n// Parses class attribute and puts all classes into classes set.\n// Classes set s cleared before insertion.\n//\n// @param {Set.<String>} classesSet Set to insert parsed classes.\n// @param {String} classesString String with classes to parse.\nfunction parseClasses(classesSet, classesString) {\n    const classArray = classesString.split(/\\s+/);\n    classesSet.clear();\n    classArray.forEach(name => classesSet.add(name));\n}\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\nfunction normalize(document, nodes) {\n    // Separate condition because string is iterable.\n    if (typeof nodes == 'string') {\n        return [new Text(document, nodes)];\n    }\n    if (!isIterable(nodes)) {\n        nodes = [nodes];\n    }\n    // Array.from to enable .map() on non-arrays.\n    return Array.from(nodes)\n        .map(node => {\n        if (typeof node == 'string') {\n            return new Text(document, node);\n        }\n        if (node instanceof TextProxy) {\n            return new Text(document, node.data);\n        }\n        return node;\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,IAAI,MAAM,QAAQ;AACzB,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,KAAK,MAAM,qCAAqC;AACvD,OAAOC,OAAO,MAAM,uCAAuC;AAC3D,OAAOC,UAAU,MAAM,0CAA0C;AACjE,SAASC,OAAO,IAAIC,OAAO,QAAQ,WAAW;AAC9C,SAASD,OAAO,IAAIE,SAAS,QAAQ,aAAa;AAClD,SAASC,aAAa,QAAQ,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,OAAO,SAASV,IAAI,CAAC;EACtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIW,WAAW,CAACC,QAAQ,EAAEC,IAAI,EAAEC,KAAK,EAAEC,QAAQ,EAAE;IACzC,KAAK,CAACH,QAAQ,CAAC;IACf;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACG,MAAM,GAAGC,eAAe,CAACH,KAAK,CAAC;IACpC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACI,SAAS,GAAG,EAAE;IACnB,IAAIH,QAAQ,EAAE;MACV,IAAI,CAACI,YAAY,CAAC,CAAC,EAAEJ,QAAQ,CAAC;IAClC;IACA;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACK,QAAQ,GAAG,IAAIC,GAAG,EAAE;IACzB,IAAI,IAAI,CAACL,MAAM,CAACM,GAAG,CAAC,OAAO,CAAC,EAAE;MAC1B;MACA,MAAMC,WAAW,GAAG,IAAI,CAACP,MAAM,CAACQ,GAAG,CAAC,OAAO,CAAC;MAC5CC,YAAY,CAAC,IAAI,CAACL,QAAQ,EAAEG,WAAW,CAAC;MACxC,IAAI,CAACP,MAAM,CAACU,MAAM,CAAC,OAAO,CAAC;IAC/B;IACA;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,IAAInB,SAAS,CAAC,IAAI,CAACI,QAAQ,CAACgB,eAAe,CAAC;IAC3D,IAAI,IAAI,CAACZ,MAAM,CAACM,GAAG,CAAC,OAAO,CAAC,EAAE;MAC1B;MACA,IAAI,CAACK,OAAO,CAACE,KAAK,CAAC,IAAI,CAACb,MAAM,CAACQ,GAAG,CAAC,OAAO,CAAC,CAAC;MAC5C,IAAI,CAACR,MAAM,CAACU,MAAM,CAAC,OAAO,CAAC;IAC/B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACI,iBAAiB,GAAG,IAAIC,GAAG,EAAE;IAClC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,yBAAyB,GAAG,EAAE;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAG;IACb,OAAO,IAAI,CAACf,SAAS,CAACgB,MAAM;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,OAAO,GAAG;IACV,OAAO,IAAI,CAACjB,SAAS,CAACgB,MAAM,KAAK,CAAC;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,QAAQ,CAACC,KAAK,EAAE;IACZ,OAAO,IAAI,CAACnB,SAAS,CAACmB,KAAK,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,aAAa,CAACC,IAAI,EAAE;IAChB,OAAO,IAAI,CAACrB,SAAS,CAACsB,OAAO,CAACD,IAAI,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;EACIE,WAAW,GAAG;IACV,OAAO,IAAI,CAACvB,SAAS,CAACwB,MAAM,CAACC,QAAQ,CAAC,EAAE;EAC5C;EACA;AACJ;AACA;AACA;AACA;EACI,CAACC,gBAAgB,GAAG;IAChB,IAAI,IAAI,CAACxB,QAAQ,CAACyB,IAAI,GAAG,CAAC,EAAE;MACxB,MAAM,OAAO;IACjB;IACA,IAAI,CAAC,IAAI,CAAClB,OAAO,CAACQ,OAAO,EAAE;MACvB,MAAM,OAAO;IACjB;IACA,OAAO,IAAI,CAACnB,MAAM,CAAC8B,IAAI,EAAE;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAACC,aAAa,GAAG;IACb,OAAO,IAAI,CAAC/B,MAAM,CAACgC,OAAO,EAAE;IAC5B,IAAI,IAAI,CAAC5B,QAAQ,CAACyB,IAAI,GAAG,CAAC,EAAE;MACxB,MAAM,CAAC,OAAO,EAAE,IAAI,CAACI,YAAY,CAAC,OAAO,CAAC,CAAC;IAC/C;IACA,IAAI,CAAC,IAAI,CAACtB,OAAO,CAACQ,OAAO,EAAE;MACvB,MAAM,CAAC,OAAO,EAAE,IAAI,CAACc,YAAY,CAAC,OAAO,CAAC,CAAC;IAC/C;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIA,YAAY,CAACC,GAAG,EAAE;IACd,IAAIA,GAAG,IAAI,OAAO,EAAE;MAChB,IAAI,IAAI,CAAC9B,QAAQ,CAACyB,IAAI,GAAG,CAAC,EAAE;QACxB,OAAO,CAAC,GAAG,IAAI,CAACzB,QAAQ,CAAC,CAAC+B,IAAI,CAAC,GAAG,CAAC;MACvC;MACA,OAAOC,SAAS;IACpB;IACA,IAAIF,GAAG,IAAI,OAAO,EAAE;MAChB,MAAMG,WAAW,GAAG,IAAI,CAAC1B,OAAO,CAAC2B,QAAQ,EAAE;MAC3C,OAAOD,WAAW,IAAI,EAAE,GAAGD,SAAS,GAAGC,WAAW;IACtD;IACA,OAAO,IAAI,CAACrC,MAAM,CAACQ,GAAG,CAAC0B,GAAG,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;EACIK,YAAY,CAACL,GAAG,EAAE;IACd,IAAIA,GAAG,IAAI,OAAO,EAAE;MAChB,OAAO,IAAI,CAAC9B,QAAQ,CAACyB,IAAI,GAAG,CAAC;IACjC;IACA,IAAIK,GAAG,IAAI,OAAO,EAAE;MAChB,OAAO,CAAC,IAAI,CAACvB,OAAO,CAACQ,OAAO;IAChC;IACA,OAAO,IAAI,CAACnB,MAAM,CAACM,GAAG,CAAC4B,GAAG,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,SAAS,CAACC,YAAY,EAAE;IACpB,IAAI,EAAEA,YAAY,YAAY/C,OAAO,CAAC,EAAE;MACpC,OAAO,KAAK;IAChB;IACA;IACA,IAAI,IAAI,KAAK+C,YAAY,EAAE;MACvB,OAAO,IAAI;IACf;IACA;IACA,IAAI,IAAI,CAAC5C,IAAI,IAAI4C,YAAY,CAAC5C,IAAI,EAAE;MAChC,OAAO,KAAK;IAChB;IACA;IACA,IAAI,IAAI,CAACG,MAAM,CAAC6B,IAAI,KAAKY,YAAY,CAACzC,MAAM,CAAC6B,IAAI,IAAI,IAAI,CAACzB,QAAQ,CAACyB,IAAI,KAAKY,YAAY,CAACrC,QAAQ,CAACyB,IAAI,IAClG,IAAI,CAAClB,OAAO,CAACkB,IAAI,KAAKY,YAAY,CAAC9B,OAAO,CAACkB,IAAI,EAAE;MACjD,OAAO,KAAK;IAChB;IACA;IACA,KAAK,MAAM,CAACK,GAAG,EAAEQ,KAAK,CAAC,IAAI,IAAI,CAAC1C,MAAM,EAAE;MACpC,IAAI,CAACyC,YAAY,CAACzC,MAAM,CAACM,GAAG,CAAC4B,GAAG,CAAC,IAAIO,YAAY,CAACzC,MAAM,CAACQ,GAAG,CAAC0B,GAAG,CAAC,KAAKQ,KAAK,EAAE;QACzE,OAAO,KAAK;MAChB;IACJ;IACA;IACA,KAAK,MAAMC,SAAS,IAAI,IAAI,CAACvC,QAAQ,EAAE;MACnC,IAAI,CAACqC,YAAY,CAACrC,QAAQ,CAACE,GAAG,CAACqC,SAAS,CAAC,EAAE;QACvC,OAAO,KAAK;MAChB;IACJ;IACA;IACA,KAAK,MAAMC,QAAQ,IAAI,IAAI,CAACjC,OAAO,CAACkC,aAAa,EAAE,EAAE;MACjD,IAAI,CAACJ,YAAY,CAAC9B,OAAO,CAACL,GAAG,CAACsC,QAAQ,CAAC,IACnCH,YAAY,CAAC9B,OAAO,CAACmC,WAAW,CAACF,QAAQ,CAAC,KAAK,IAAI,CAACjC,OAAO,CAACmC,WAAW,CAACF,QAAQ,CAAC,EAAE;QACnF,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,QAAQ,GAAe;IAAA,kCAAXJ,SAAS;MAATA,SAAS;IAAA;IACjB,KAAK,MAAM9C,IAAI,IAAI8C,SAAS,EAAE;MAC1B,IAAI,CAAC,IAAI,CAACvC,QAAQ,CAACE,GAAG,CAACT,IAAI,CAAC,EAAE;QAC1B,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;EACImD,aAAa,GAAG;IACZ,OAAO,IAAI,CAAC5C,QAAQ,CAAC0B,IAAI,EAAE;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImB,QAAQ,CAACL,QAAQ,EAAE;IACf,OAAO,IAAI,CAACjC,OAAO,CAACmC,WAAW,CAACF,QAAQ,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,kBAAkB,CAACN,QAAQ,EAAE;IACzB,OAAO,IAAI,CAACjC,OAAO,CAACwC,aAAa,CAACP,QAAQ,CAAC;EAC/C;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,aAAa,CAACO,MAAM,EAAE;IAClB,OAAO,IAAI,CAACzC,OAAO,CAACkC,aAAa,CAACO,MAAM,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQ,GAAc;IAAA,mCAAVT,QAAQ;MAARA,QAAQ;IAAA;IAChB,KAAK,MAAM/C,IAAI,IAAI+C,QAAQ,EAAE;MACzB,IAAI,CAAC,IAAI,CAACjC,OAAO,CAACL,GAAG,CAACT,IAAI,CAAC,EAAE;QACzB,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIyD,YAAY,GAAc;IAAA,mCAAVC,QAAQ;MAARA,QAAQ;IAAA;IACpB,MAAMC,OAAO,GAAG,IAAIjE,OAAO,CAAC,GAAGgE,QAAQ,CAAC;IACxC,IAAIE,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,OAAOA,MAAM,IAAI,CAACA,MAAM,CAACC,EAAE,CAAC,kBAAkB,CAAC,EAAE;MAC7C,IAAIF,OAAO,CAACG,KAAK,CAACF,MAAM,CAAC,EAAE;QACvB,OAAOA,MAAM;MACjB;MACAA,MAAM,GAAGA,MAAM,CAACA,MAAM;IAC1B;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIG,iBAAiB,CAAC1B,GAAG,EAAE;IACnB,OAAO,IAAI,CAACpB,iBAAiB,CAACN,GAAG,CAAC0B,GAAG,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,CAAC2B,mBAAmB,GAAG;IACnB,OAAO,IAAI,CAAC/C,iBAAiB,CAACkB,OAAO,EAAE;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI8B,WAAW,GAAG;IACV,MAAMC,OAAO,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC7D,QAAQ,CAAC,CAAC8D,IAAI,EAAE,CAAC/B,IAAI,CAAC,GAAG,CAAC;IAC1D,MAAMgC,MAAM,GAAG,IAAI,CAACxD,OAAO,CAAC2B,QAAQ,EAAE;IACtC,MAAM8B,UAAU,GAAGJ,KAAK,CAACC,IAAI,CAAC,IAAI,CAACjE,MAAM,CAAC,CAACqE,GAAG,CAACC,CAAC,IAAK,GAAEA,CAAC,CAAC,CAAC,CAAE,KAAIA,CAAC,CAAC,CAAC,CAAE,GAAE,CAAC,CAACJ,IAAI,EAAE,CAAC/B,IAAI,CAAC,GAAG,CAAC;IACzF,OAAO,IAAI,CAACtC,IAAI,IACXkE,OAAO,IAAI,EAAE,GAAG,EAAE,GAAI,WAAUA,OAAQ,GAAE,CAAC,IAC3C,CAACI,MAAM,GAAG,EAAE,GAAI,WAAUA,MAAO,GAAE,CAAC,IACpCC,UAAU,IAAI,EAAE,GAAG,EAAE,GAAI,IAAGA,UAAW,EAAC,CAAC;EAClD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,2BAA2B,CAACC,aAAa,EAAE;IACvC,OAAO,IAAI,CAACxD,yBAAyB,CAACyD,QAAQ,CAACD,aAAa,CAAC;EACjE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,MAAM,GAAe;IAAA,IAAdC,IAAI,uEAAG,KAAK;IACf,MAAMC,aAAa,GAAG,EAAE;IACxB,IAAID,IAAI,EAAE;MACN,KAAK,MAAME,KAAK,IAAI,IAAI,CAACpD,WAAW,EAAE,EAAE;QACpCmD,aAAa,CAACE,IAAI,CAACD,KAAK,CAACH,MAAM,CAACC,IAAI,CAAC,CAAC;MAC1C;IACJ;IACA;IACA,MAAMI,MAAM,GAAG,IAAI,IAAI,CAACpF,WAAW,CAAC,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,IAAI,EAAE,IAAI,CAACG,MAAM,EAAE4E,aAAa,CAAC;IACzF;IACA;IACAG,MAAM,CAAC3E,QAAQ,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACD,QAAQ,CAAC;IACxC2E,MAAM,CAACpE,OAAO,CAACqE,GAAG,CAAC,IAAI,CAACrE,OAAO,CAACwC,aAAa,EAAE,CAAC;IAChD;IACA4B,MAAM,CAACjE,iBAAiB,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACD,iBAAiB,CAAC;IAC1D;IACA;IACA;IACAiE,MAAM,CAACE,eAAe,GAAG,IAAI,CAACA,eAAe;IAC7C;IACAF,MAAM,CAAC/D,yBAAyB,GAAG,IAAI,CAACA,yBAAyB;IACjE,OAAO+D,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,YAAY,CAACC,KAAK,EAAE;IAChB,OAAO,IAAI,CAAChF,YAAY,CAAC,IAAI,CAACc,UAAU,EAAEkE,KAAK,CAAC;EACpD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIhF,YAAY,CAACkB,KAAK,EAAE8D,KAAK,EAAE;IACvB,IAAI,CAACC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC;IAClC,IAAIC,KAAK,GAAG,CAAC;IACb,MAAMC,KAAK,GAAGC,SAAS,CAAC,IAAI,CAAC3F,QAAQ,EAAEuF,KAAK,CAAC;IAC7C,KAAK,MAAM5D,IAAI,IAAI+D,KAAK,EAAE;MACtB;MACA,IAAI/D,IAAI,CAACkC,MAAM,KAAK,IAAI,EAAE;QACtBlC,IAAI,CAACiE,OAAO,EAAE;MAClB;MACAjE,IAAI,CAACkC,MAAM,GAAG,IAAI;MAClBlC,IAAI,CAAC3B,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAC7B,IAAI,CAACM,SAAS,CAACuF,MAAM,CAACpE,KAAK,EAAE,CAAC,EAAEE,IAAI,CAAC;MACrCF,KAAK,EAAE;MACPgE,KAAK,EAAE;IACX;IACA,OAAOA,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,eAAe,CAACrE,KAAK,EAAe;IAAA,IAAbsE,OAAO,uEAAG,CAAC;IAC9B,IAAI,CAACP,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC;IAClC,KAAK,IAAId,CAAC,GAAGjD,KAAK,EAAEiD,CAAC,GAAGjD,KAAK,GAAGsE,OAAO,EAAErB,CAAC,EAAE,EAAE;MAC1C,IAAI,CAACpE,SAAS,CAACoE,CAAC,CAAC,CAACb,MAAM,GAAG,IAAI;IACnC;IACA,OAAO,IAAI,CAACvD,SAAS,CAACuF,MAAM,CAACpE,KAAK,EAAEsE,OAAO,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,CAAC1D,GAAG,EAAEQ,KAAK,EAAE;IACtBA,KAAK,GAAGmD,MAAM,CAACnD,KAAK,CAAC;IACrB,IAAI,CAAC0C,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;IACpC,IAAIlD,GAAG,IAAI,OAAO,EAAE;MAChBzB,YAAY,CAAC,IAAI,CAACL,QAAQ,EAAEsC,KAAK,CAAC;IACtC,CAAC,MACI,IAAIR,GAAG,IAAI,OAAO,EAAE;MACrB,IAAI,CAACvB,OAAO,CAACE,KAAK,CAAC6B,KAAK,CAAC;IAC7B,CAAC,MACI;MACD,IAAI,CAAC1C,MAAM,CAACgF,GAAG,CAAC9C,GAAG,EAAEQ,KAAK,CAAC;IAC/B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoD,gBAAgB,CAAC5D,GAAG,EAAE;IAClB,IAAI,CAACkD,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;IACpC;IACA,IAAIlD,GAAG,IAAI,OAAO,EAAE;MAChB,IAAI,IAAI,CAAC9B,QAAQ,CAACyB,IAAI,GAAG,CAAC,EAAE;QACxB,IAAI,CAACzB,QAAQ,CAAC2F,KAAK,EAAE;QACrB,OAAO,IAAI;MACf;MACA,OAAO,KAAK;IAChB;IACA;IACA,IAAI7D,GAAG,IAAI,OAAO,EAAE;MAChB,IAAI,CAAC,IAAI,CAACvB,OAAO,CAACQ,OAAO,EAAE;QACvB,IAAI,CAACR,OAAO,CAACoF,KAAK,EAAE;QACpB,OAAO,IAAI;MACf;MACA,OAAO,KAAK;IAChB;IACA;IACA,OAAO,IAAI,CAAC/F,MAAM,CAACU,MAAM,CAACwB,GAAG,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI8D,SAAS,CAACrD,SAAS,EAAE;IACjB,IAAI,CAACyC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;IACpC,KAAK,MAAMvF,IAAI,IAAIT,OAAO,CAACuD,SAAS,CAAC,EAAE;MACnC,IAAI,CAACvC,QAAQ,CAAC6F,GAAG,CAACpG,IAAI,CAAC;IAC3B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIqG,YAAY,CAACvD,SAAS,EAAE;IACpB,IAAI,CAACyC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;IACpC,KAAK,MAAMvF,IAAI,IAAIT,OAAO,CAACuD,SAAS,CAAC,EAAE;MACnC,IAAI,CAACvC,QAAQ,CAACM,MAAM,CAACb,IAAI,CAAC;IAC9B;EACJ;EACAsG,SAAS,CAACvD,QAAQ,EAAEF,KAAK,EAAE;IACvB,IAAI,CAAC0C,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;IACpC,IAAI3F,aAAa,CAACmD,QAAQ,CAAC,EAAE;MACzB,IAAI,CAACjC,OAAO,CAACqE,GAAG,CAACpC,QAAQ,CAAC;IAC9B,CAAC,MACI;MACD,IAAI,CAACjC,OAAO,CAACqE,GAAG,CAACpC,QAAQ,EAAEF,KAAK,CAAC;IACrC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0D,YAAY,CAACxD,QAAQ,EAAE;IACnB,IAAI,CAACwC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;IACpC,KAAK,MAAMvF,IAAI,IAAIT,OAAO,CAACwD,QAAQ,CAAC,EAAE;MAClC,IAAI,CAACjC,OAAO,CAAC0F,MAAM,CAACxG,IAAI,CAAC;IAC7B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIyG,kBAAkB,CAACpE,GAAG,EAAEQ,KAAK,EAAE;IAC3B,IAAI,CAAC5B,iBAAiB,CAACkE,GAAG,CAAC9C,GAAG,EAAEQ,KAAK,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI6D,qBAAqB,CAACrE,GAAG,EAAE;IACvB,OAAO,IAAI,CAACpB,iBAAiB,CAACJ,MAAM,CAACwB,GAAG,CAAC;EAC7C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxC,OAAO,CAAC8G,SAAS,CAAC9C,EAAE,GAAG,UAAU+C,IAAI,EAAE5G,IAAI,EAAE;EACzC,IAAI,CAACA,IAAI,EAAE;IACP,OAAO4G,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,cAAc;IAChD;IACAA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,WAAW;EAC/C,CAAC,MACI;IACD,OAAO5G,IAAI,KAAK,IAAI,CAACA,IAAI,KAAK4G,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,cAAc,CAAC;EAChF;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,SAASxG,eAAe,CAACH,KAAK,EAAE;EAC5B,MAAM4G,QAAQ,GAAGvH,KAAK,CAACW,KAAK,CAAC;EAC7B,KAAK,MAAM,CAACoC,GAAG,EAAEQ,KAAK,CAAC,IAAIgE,QAAQ,EAAE;IACjC,IAAIhE,KAAK,KAAK,IAAI,EAAE;MAChBgE,QAAQ,CAAChG,MAAM,CAACwB,GAAG,CAAC;IACxB,CAAC,MACI,IAAI,OAAOQ,KAAK,IAAI,QAAQ,EAAE;MAC/BgE,QAAQ,CAAC1B,GAAG,CAAC9C,GAAG,EAAE2D,MAAM,CAACnD,KAAK,CAAC,CAAC;IACpC;EACJ;EACA,OAAOgE,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,SAASjG,YAAY,CAACkG,UAAU,EAAEC,aAAa,EAAE;EAC7C,MAAMC,UAAU,GAAGD,aAAa,CAACE,KAAK,CAAC,KAAK,CAAC;EAC7CH,UAAU,CAACZ,KAAK,EAAE;EAClBc,UAAU,CAACE,OAAO,CAAClH,IAAI,IAAI8G,UAAU,CAACV,GAAG,CAACpG,IAAI,CAAC,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS0F,SAAS,CAAC3F,QAAQ,EAAE0F,KAAK,EAAE;EAChC;EACA,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;IAC1B,OAAO,CAAC,IAAIrG,IAAI,CAACW,QAAQ,EAAE0F,KAAK,CAAC,CAAC;EACtC;EACA,IAAI,CAACjG,UAAU,CAACiG,KAAK,CAAC,EAAE;IACpBA,KAAK,GAAG,CAACA,KAAK,CAAC;EACnB;EACA;EACA,OAAOtB,KAAK,CAACC,IAAI,CAACqB,KAAK,CAAC,CACnBjB,GAAG,CAAC9C,IAAI,IAAI;IACb,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAE;MACzB,OAAO,IAAItC,IAAI,CAACW,QAAQ,EAAE2B,IAAI,CAAC;IACnC;IACA,IAAIA,IAAI,YAAYrC,SAAS,EAAE;MAC3B,OAAO,IAAID,IAAI,CAACW,QAAQ,EAAE2B,IAAI,CAACyF,IAAI,CAAC;IACxC;IACA,OAAOzF,IAAI;EACf,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"module"}