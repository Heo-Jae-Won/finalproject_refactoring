{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/range\n */\nimport TypeCheckable from './typecheckable';\nimport Position from './position';\nimport { default as TreeWalker } from './treewalker';\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Range extends TypeCheckable {\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n   *\n   * @param {module:engine/view/position~Position} start Start position.\n   * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n   */\n  constructor(start) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    /**\n     * Start position.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position}\n     */\n    this.start = start.clone();\n    /**\n     * End position.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position}\n     */\n    this.end = end ? end.clone() : start.clone();\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n   * them together with additional information like length or {@link module:engine/view/position~Position positions},\n   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n   *\n   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n   * `ignoreElementEnd` option\n   * set to `true`.\n   *\n   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n   */\n  *[Symbol.iterator]() {\n    yield* new TreeWalker({\n      boundaries: this,\n      ignoreElementEnd: true\n    });\n  }\n  /**\n   * Returns whether the range is collapsed, that is it start and end positions are equal.\n   *\n   * @type {Boolean}\n   */\n  get isCollapsed() {\n    return this.start.isEqual(this.end);\n  }\n  /**\n   * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n   * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n   *\n   * @type {Boolean}\n   */\n  get isFlat() {\n    return this.start.parent === this.end.parent;\n  }\n  /**\n   * Range root element.\n   *\n   * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n   */\n  get root() {\n    return this.start.root;\n  }\n  /**\n   * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n   * and at the end).\n   *\n   * For example:\n   *\n   *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n   *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n   *\n   * Note that in the sample above:\n   *\n   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n   *\n   * @returns {module:engine/view/range~Range} Enlarged range.\n   */\n  getEnlarged() {\n    let start = this.start.getLastMatchingPosition(enlargeTrimSkip, {\n      direction: 'backward'\n    });\n    let end = this.end.getLastMatchingPosition(enlargeTrimSkip);\n    // Fix positions, in case if they are in Text node.\n    if (start.parent.is('$text') && start.isAtStart) {\n      start = Position._createBefore(start.parent);\n    }\n    if (end.parent.is('$text') && end.isAtEnd) {\n      end = Position._createAfter(end.parent);\n    }\n    return new Range(start, end);\n  }\n  /**\n   * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n   * and at the end).\n   *\n   * For example:\n   *\n   *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n   *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n   *\n   * Note that in the sample above:\n   *\n   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n   *\n   * @returns {module:engine/view/range~Range} Shrink range.\n   */\n  getTrimmed() {\n    let start = this.start.getLastMatchingPosition(enlargeTrimSkip);\n    if (start.isAfter(this.end) || start.isEqual(this.end)) {\n      return new Range(start, start);\n    }\n    let end = this.end.getLastMatchingPosition(enlargeTrimSkip, {\n      direction: 'backward'\n    });\n    const nodeAfterStart = start.nodeAfter;\n    const nodeBeforeEnd = end.nodeBefore;\n    // Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n    if (nodeAfterStart && nodeAfterStart.is('$text')) {\n      start = new Position(nodeAfterStart, 0);\n    }\n    if (nodeBeforeEnd && nodeBeforeEnd.is('$text')) {\n      end = new Position(nodeBeforeEnd, nodeBeforeEnd.data.length);\n    }\n    return new Range(start, end);\n  }\n  /**\n   * Two ranges are equal if their start and end positions are equal.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n   */\n  isEqual(otherRange) {\n    return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);\n  }\n  /**\n   * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n   *\n   * @param {module:engine/view/position~Position} position Position to check.\n   * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n   * `false` otherwise.\n   */\n  containsPosition(position) {\n    return position.isAfter(this.start) && position.isBefore(this.end);\n  }\n  /**\n   * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to check.\n   * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n   * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n   * otherwise.\n   */\n  containsRange(otherRange) {\n    let loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (otherRange.isCollapsed) {\n      loose = false;\n    }\n    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);\n    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);\n    return containsStart && containsEnd;\n  }\n  /**\n   * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n   * {@link module:engine/view/range~Range range}.\n   * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n   *\n   * Examples:\n   *\n   *\t\tlet foo = downcastWriter.createText( 'foo' );\n   *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n   *\t\tlet bar = downcastWriter.createText( 'bar' );\n   *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n   *\n   *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n   *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n   *\t\t\tview.createPositionAt( foo, 1 ),\n   *\t\t\tview.createPositionAt( bar, 2 )\n   *\t\t);\n   *\t\tlet transformed = range.getDifference( otherRange );\n   *\t\t// transformed array has no ranges because `otherRange` contains `range`\n   *\n   *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n   *\n   *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n   * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n   */\n  getDifference(otherRange) {\n    const ranges = [];\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect.\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means that we have to\n        // add shrunken range - from the start to the middle of this range.\n        ranges.push(new Range(this.start, otherRange.start));\n      }\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // add shrunken range - from the middle of this range to the end.\n        ranges.push(new Range(otherRange.end, this.end));\n      }\n    } else {\n      // Ranges do not intersect, return the original range.\n      ranges.push(this.clone());\n    }\n    return ranges;\n  }\n  /**\n   * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n   *\n   * Examples:\n   *\n   *\t\tlet foo = downcastWriter.createText( 'foo' );\n   *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n   *\t\tlet bar = downcastWriter.createText( 'bar' );\n   *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n   *\n   *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n   *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n   *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n   *\n   *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n   *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n   * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n   */\n  getIntersection(otherRange) {\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect, so a common range will be returned.\n      // At most, it will be same as this range.\n      let commonRangeStart = this.start;\n      let commonRangeEnd = this.end;\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means thaNt we have to\n        // shrink common range to the given range start.\n        commonRangeStart = otherRange.start;\n      }\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // shrink common range to the given range end.\n        commonRangeEnd = otherRange.end;\n      }\n      return new Range(commonRangeStart, commonRangeEnd);\n    }\n    // Ranges do not intersect, so they do not have common part.\n    return null;\n  }\n  /**\n   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   * @param {module:engine/view/position~Position} [options.startPosition]\n   * @param {Boolean} [options.singleCharacters=false]\n   * @param {Boolean} [options.shallow=false]\n   * @param {Boolean} [options.ignoreElementEnd=false]\n   * @returns {module:engine/view/treewalker~TreeWalker}\n   */\n  getWalker() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    return new TreeWalker(options);\n  }\n  /**\n   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n   * which is a common ancestor of range's both ends (in which the entire range is contained).\n   *\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n   */\n  getCommonAncestor() {\n    return this.start.getCommonAncestor(this.end);\n  }\n  /**\n   * Returns an {@link module:engine/view/element~Element Element} contained by the range.\n   * The element will be returned when it is the **only** node within the range and **fully–contained**\n   * at the same time.\n   *\n   * @returns {module:engine/view/element~Element|null}\n   */\n  getContainedElement() {\n    if (this.isCollapsed) {\n      return null;\n    }\n    let nodeAfterStart = this.start.nodeAfter;\n    let nodeBeforeEnd = this.end.nodeBefore;\n    // Handle the situation when the range position is at the beginning / at the end of a text node.\n    // In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning\n    // over one element.\n    //\n    // <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n    //\n    // These are basically the same range, only the difference is if the range position is at\n    // at the end/at the beginning of a text node or just before/just after the text node.\n    //\n    if (this.start.parent.is('$text') && this.start.isAtEnd && this.start.parent.nextSibling) {\n      nodeAfterStart = this.start.parent.nextSibling;\n    }\n    if (this.end.parent.is('$text') && this.end.isAtStart && this.end.parent.previousSibling) {\n      nodeBeforeEnd = this.end.parent.previousSibling;\n    }\n    if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n      return nodeAfterStart;\n    }\n    return null;\n  }\n  /**\n   * Clones this range.\n   *\n   * @returns {module:engine/view/range~Range}\n   */\n  clone() {\n    return new Range(this.start, this.end);\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n   * them.\n   *\n   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n   * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n   * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/view/item~Item>}\n   */\n  *getItems() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    options.ignoreElementEnd = true;\n    const treeWalker = new TreeWalker(options);\n    for (const value of treeWalker) {\n      yield value.item;\n    }\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n   * contained in this range.\n   *\n   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n   * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/view/position~Position>}\n   */\n  *getPositions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    const treeWalker = new TreeWalker(options);\n    yield treeWalker.position;\n    for (const value of treeWalker) {\n      yield value.nextPosition;\n    }\n  }\n  /**\n   * Checks and returns whether this range intersects with the given range.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} True if ranges intersect.\n   */\n  isIntersecting(otherRange) {\n    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n  }\n  /**\n   * Creates a range from the given parents and offsets.\n   *\n   * @protected\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n   * parent element.\n   * @param {Number} startOffset Start position offset.\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n   * parent element.\n   * @param {Number} endOffset End position offset.\n   * @returns {module:engine/view/range~Range} Created range.\n   */\n  static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {\n    return new this(new Position(startElement, startOffset), new Position(endElement, endOffset));\n  }\n  /**\n   * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n   *\n   * @protected\n   * @param {module:engine/view/position~Position} position Beginning of the range.\n   * @param {Number} shift How long the range should be.\n   * @returns {module:engine/view/range~Range}\n   */\n  static _createFromPositionAndShift(position, shift) {\n    const start = position;\n    const end = position.getShiftedBy(shift);\n    return shift > 0 ? new this(start, end) : new this(end, start);\n  }\n  /**\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * @protected\n   * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/view/range~Range}\n   */\n  static _createIn(element) {\n    return this._createFromParentsAndOffsets(element, 0, element, element.childCount);\n  }\n  /**\n   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item} item\n   * @returns {module:engine/view/range~Range}\n   */\n  static _createOn(item) {\n    const size = item.is('$textProxy') ? item.offsetSize : 1;\n    return this._createFromPositionAndShift(Position._createBefore(item), size);\n  }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\trange.is( 'range' ); // -> true\n *\t\trange.is( 'view:range' ); // -> true\n *\n *\t\trange.is( 'model:range' ); // -> false\n *\t\trange.is( 'element' ); // -> false\n *\t\trange.is( 'selection' ); // -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nRange.prototype.is = function (type) {\n  return type === 'range' || type === 'view:range';\n};\n// Function used by getEnlarged and getTrimmed methods.\nfunction enlargeTrimSkip(value) {\n  if (value.item.is('attributeElement') || value.item.is('uiElement')) {\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["TypeCheckable","Position","default","TreeWalker","Range","constructor","start","end","clone","Symbol","iterator","boundaries","ignoreElementEnd","isCollapsed","isEqual","isFlat","parent","root","getEnlarged","getLastMatchingPosition","enlargeTrimSkip","direction","is","isAtStart","_createBefore","isAtEnd","_createAfter","getTrimmed","isAfter","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","data","length","otherRange","containsPosition","position","isBefore","containsRange","loose","containsStart","containsEnd","getDifference","ranges","isIntersecting","push","getIntersection","commonRangeStart","commonRangeEnd","getWalker","options","getCommonAncestor","getContainedElement","nextSibling","previousSibling","getItems","treeWalker","value","item","getPositions","nextPosition","_createFromParentsAndOffsets","startElement","startOffset","endElement","endOffset","_createFromPositionAndShift","shift","getShiftedBy","_createIn","element","childCount","_createOn","size","offsetSize","prototype","type"],"sources":["C:/data/project/realproject/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module engine/view/range\n */\nimport TypeCheckable from './typecheckable';\nimport Position from './position';\nimport { default as TreeWalker } from './treewalker';\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Range extends TypeCheckable {\n    /**\n     * Creates a range spanning from `start` position to `end` position.\n     *\n     * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n     *\n     * @param {module:engine/view/position~Position} start Start position.\n     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n     */\n    constructor(start, end = null) {\n        super();\n        /**\n         * Start position.\n         *\n         * @readonly\n         * @member {module:engine/view/position~Position}\n         */\n        this.start = start.clone();\n        /**\n         * End position.\n         *\n         * @readonly\n         * @member {module:engine/view/position~Position}\n         */\n        this.end = end ? end.clone() : start.clone();\n    }\n    /**\n     * Iterable interface.\n     *\n     * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n     * them together with additional information like length or {@link module:engine/view/position~Position positions},\n     * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n     *\n     * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n     * `ignoreElementEnd` option\n     * set to `true`.\n     *\n     * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n     */\n    *[Symbol.iterator]() {\n        yield* new TreeWalker({ boundaries: this, ignoreElementEnd: true });\n    }\n    /**\n     * Returns whether the range is collapsed, that is it start and end positions are equal.\n     *\n     * @type {Boolean}\n     */\n    get isCollapsed() {\n        return this.start.isEqual(this.end);\n    }\n    /**\n     * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n     * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n     *\n     * @type {Boolean}\n     */\n    get isFlat() {\n        return this.start.parent === this.end.parent;\n    }\n    /**\n     * Range root element.\n     *\n     * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n     */\n    get root() {\n        return this.start.root;\n    }\n    /**\n     * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n     * and at the end).\n     *\n     * For example:\n     *\n     *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n     *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n     *\n     * Note that in the sample above:\n     *\n     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n     *\n     * @returns {module:engine/view/range~Range} Enlarged range.\n     */\n    getEnlarged() {\n        let start = this.start.getLastMatchingPosition(enlargeTrimSkip, { direction: 'backward' });\n        let end = this.end.getLastMatchingPosition(enlargeTrimSkip);\n        // Fix positions, in case if they are in Text node.\n        if (start.parent.is('$text') && start.isAtStart) {\n            start = Position._createBefore(start.parent);\n        }\n        if (end.parent.is('$text') && end.isAtEnd) {\n            end = Position._createAfter(end.parent);\n        }\n        return new Range(start, end);\n    }\n    /**\n     * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n     * and at the end).\n     *\n     * For example:\n     *\n     *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n     *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n     *\n     * Note that in the sample above:\n     *\n     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n     *\n     * @returns {module:engine/view/range~Range} Shrink range.\n     */\n    getTrimmed() {\n        let start = this.start.getLastMatchingPosition(enlargeTrimSkip);\n        if (start.isAfter(this.end) || start.isEqual(this.end)) {\n            return new Range(start, start);\n        }\n        let end = this.end.getLastMatchingPosition(enlargeTrimSkip, { direction: 'backward' });\n        const nodeAfterStart = start.nodeAfter;\n        const nodeBeforeEnd = end.nodeBefore;\n        // Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n        if (nodeAfterStart && nodeAfterStart.is('$text')) {\n            start = new Position(nodeAfterStart, 0);\n        }\n        if (nodeBeforeEnd && nodeBeforeEnd.is('$text')) {\n            end = new Position(nodeBeforeEnd, nodeBeforeEnd.data.length);\n        }\n        return new Range(start, end);\n    }\n    /**\n     * Two ranges are equal if their start and end positions are equal.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n     */\n    isEqual(otherRange) {\n        return this == otherRange || (this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end));\n    }\n    /**\n     * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n     *\n     * @param {module:engine/view/position~Position} position Position to check.\n     * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n     * `false` otherwise.\n     */\n    containsPosition(position) {\n        return position.isAfter(this.start) && position.isBefore(this.end);\n    }\n    /**\n     * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to check.\n     * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n     * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n     * otherwise.\n     */\n    containsRange(otherRange, loose = false) {\n        if (otherRange.isCollapsed) {\n            loose = false;\n        }\n        const containsStart = this.containsPosition(otherRange.start) || (loose && this.start.isEqual(otherRange.start));\n        const containsEnd = this.containsPosition(otherRange.end) || (loose && this.end.isEqual(otherRange.end));\n        return containsStart && containsEnd;\n    }\n    /**\n     * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n     * {@link module:engine/view/range~Range range}.\n     * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n     *\n     * Examples:\n     *\n     *\t\tlet foo = downcastWriter.createText( 'foo' );\n     *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n     *\t\tlet bar = downcastWriter.createText( 'bar' );\n     *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n     *\n     *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n     *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n     *\t\t\tview.createPositionAt( foo, 1 ),\n     *\t\t\tview.createPositionAt( bar, 2 )\n     *\t\t);\n     *\t\tlet transformed = range.getDifference( otherRange );\n     *\t\t// transformed array has no ranges because `otherRange` contains `range`\n     *\n     *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n     *\n     *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n     * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n     */\n    getDifference(otherRange) {\n        const ranges = [];\n        if (this.isIntersecting(otherRange)) {\n            // Ranges intersect.\n            if (this.containsPosition(otherRange.start)) {\n                // Given range start is inside this range. This means that we have to\n                // add shrunken range - from the start to the middle of this range.\n                ranges.push(new Range(this.start, otherRange.start));\n            }\n            if (this.containsPosition(otherRange.end)) {\n                // Given range end is inside this range. This means that we have to\n                // add shrunken range - from the middle of this range to the end.\n                ranges.push(new Range(otherRange.end, this.end));\n            }\n        }\n        else {\n            // Ranges do not intersect, return the original range.\n            ranges.push(this.clone());\n        }\n        return ranges;\n    }\n    /**\n     * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n     *\n     * Examples:\n     *\n     *\t\tlet foo = downcastWriter.createText( 'foo' );\n     *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n     *\t\tlet bar = downcastWriter.createText( 'bar' );\n     *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n     *\n     *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n     *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n     *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n     *\n     *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n     *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n     * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n     */\n    getIntersection(otherRange) {\n        if (this.isIntersecting(otherRange)) {\n            // Ranges intersect, so a common range will be returned.\n            // At most, it will be same as this range.\n            let commonRangeStart = this.start;\n            let commonRangeEnd = this.end;\n            if (this.containsPosition(otherRange.start)) {\n                // Given range start is inside this range. This means thaNt we have to\n                // shrink common range to the given range start.\n                commonRangeStart = otherRange.start;\n            }\n            if (this.containsPosition(otherRange.end)) {\n                // Given range end is inside this range. This means that we have to\n                // shrink common range to the given range end.\n                commonRangeEnd = otherRange.end;\n            }\n            return new Range(commonRangeStart, commonRangeEnd);\n        }\n        // Ranges do not intersect, so they do not have common part.\n        return null;\n    }\n    /**\n     * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n     * @param {module:engine/view/position~Position} [options.startPosition]\n     * @param {Boolean} [options.singleCharacters=false]\n     * @param {Boolean} [options.shallow=false]\n     * @param {Boolean} [options.ignoreElementEnd=false]\n     * @returns {module:engine/view/treewalker~TreeWalker}\n     */\n    getWalker(options = {}) {\n        options.boundaries = this;\n        return new TreeWalker(options);\n    }\n    /**\n     * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n     * which is a common ancestor of range's both ends (in which the entire range is contained).\n     *\n     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n     */\n    getCommonAncestor() {\n        return this.start.getCommonAncestor(this.end);\n    }\n    /**\n     * Returns an {@link module:engine/view/element~Element Element} contained by the range.\n     * The element will be returned when it is the **only** node within the range and **fully–contained**\n     * at the same time.\n     *\n     * @returns {module:engine/view/element~Element|null}\n     */\n    getContainedElement() {\n        if (this.isCollapsed) {\n            return null;\n        }\n        let nodeAfterStart = this.start.nodeAfter;\n        let nodeBeforeEnd = this.end.nodeBefore;\n        // Handle the situation when the range position is at the beginning / at the end of a text node.\n        // In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning\n        // over one element.\n        //\n        // <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n        //\n        // These are basically the same range, only the difference is if the range position is at\n        // at the end/at the beginning of a text node or just before/just after the text node.\n        //\n        if (this.start.parent.is('$text') && this.start.isAtEnd && this.start.parent.nextSibling) {\n            nodeAfterStart = this.start.parent.nextSibling;\n        }\n        if (this.end.parent.is('$text') && this.end.isAtStart && this.end.parent.previousSibling) {\n            nodeBeforeEnd = this.end.parent.previousSibling;\n        }\n        if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n            return nodeAfterStart;\n        }\n        return null;\n    }\n    /**\n     * Clones this range.\n     *\n     * @returns {module:engine/view/range~Range}\n     */\n    clone() {\n        return new Range(this.start, this.end);\n    }\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n     * them.\n     *\n     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n     * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n     * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/view/item~Item>}\n     */\n    *getItems(options = {}) {\n        options.boundaries = this;\n        options.ignoreElementEnd = true;\n        const treeWalker = new TreeWalker(options);\n        for (const value of treeWalker) {\n            yield value.item;\n        }\n    }\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n     * contained in this range.\n     *\n     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n     * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/view/position~Position>}\n     */\n    *getPositions(options = {}) {\n        options.boundaries = this;\n        const treeWalker = new TreeWalker(options);\n        yield treeWalker.position;\n        for (const value of treeWalker) {\n            yield value.nextPosition;\n        }\n    }\n    /**\n     * Checks and returns whether this range intersects with the given range.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} True if ranges intersect.\n     */\n    isIntersecting(otherRange) {\n        return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n    }\n    /**\n     * Creates a range from the given parents and offsets.\n     *\n     * @protected\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n     * parent element.\n     * @param {Number} startOffset Start position offset.\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n     * parent element.\n     * @param {Number} endOffset End position offset.\n     * @returns {module:engine/view/range~Range} Created range.\n     */\n    static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {\n        return new this(new Position(startElement, startOffset), new Position(endElement, endOffset));\n    }\n    /**\n     * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n     *\n     * @protected\n     * @param {module:engine/view/position~Position} position Beginning of the range.\n     * @param {Number} shift How long the range should be.\n     * @returns {module:engine/view/range~Range}\n     */\n    static _createFromPositionAndShift(position, shift) {\n        const start = position;\n        const end = position.getShiftedBy(shift);\n        return shift > 0 ? new this(start, end) : new this(end, start);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @protected\n     * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/view/range~Range}\n     */\n    static _createIn(element) {\n        return this._createFromParentsAndOffsets(element, 0, element, element.childCount);\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n     *\n     * @protected\n     * @param {module:engine/view/item~Item} item\n     * @returns {module:engine/view/range~Range}\n     */\n    static _createOn(item) {\n        const size = item.is('$textProxy') ? item.offsetSize : 1;\n        return this._createFromPositionAndShift(Position._createBefore(item), size);\n    }\n}\n/**\n * Checks whether this object is of the given type.\n *\n *\t\trange.is( 'range' ); // -> true\n *\t\trange.is( 'view:range' ); // -> true\n *\n *\t\trange.is( 'model:range' ); // -> false\n *\t\trange.is( 'element' ); // -> false\n *\t\trange.is( 'selection' ); // -> false\n *\n * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n *\n * @param {String} type\n * @returns {Boolean}\n */\nRange.prototype.is = function (type) {\n    return type === 'range' || type === 'view:range';\n};\n// Function used by getEnlarged and getTrimmed methods.\nfunction enlargeTrimSkip(value) {\n    if (value.item.is('attributeElement') || value.item.is('uiElement')) {\n        return true;\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}